function HE(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var K_ = { exports: {} }, Qy = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BT;
function kE() {
  if (BT) return Qy;
  BT = 1;
  var s = Symbol.for("react.transitional.element"), i = Symbol.for("react.fragment");
  function l(u, h, g) {
    var _ = null;
    if (g !== void 0 && (_ = "" + g), h.key !== void 0 && (_ = "" + h.key), "key" in h) {
      g = {};
      for (var S in h)
        S !== "key" && (g[S] = h[S]);
    } else g = h;
    return h = g.ref, {
      $$typeof: s,
      type: u,
      key: _,
      ref: h !== void 0 ? h : null,
      props: g
    };
  }
  return Qy.Fragment = i, Qy.jsx = l, Qy.jsxs = l, Qy;
}
var Ky = {}, W_ = { exports: {} }, Re = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var YT;
function NE() {
  if (YT) return Re;
  YT = 1;
  var s = Symbol.for("react.transitional.element"), i = Symbol.for("react.portal"), l = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), h = Symbol.for("react.profiler"), g = Symbol.for("react.consumer"), _ = Symbol.for("react.context"), S = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), E = Symbol.for("react.memo"), A = Symbol.for("react.lazy"), C = Symbol.iterator;
  function z(k) {
    return k === null || typeof k != "object" ? null : (k = C && k[C] || k["@@iterator"], typeof k == "function" ? k : null);
  }
  var j = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, J = Object.assign, Q = {};
  function X(k, F, ct) {
    this.props = k, this.context = F, this.refs = Q, this.updater = ct || j;
  }
  X.prototype.isReactComponent = {}, X.prototype.setState = function(k, F) {
    if (typeof k != "object" && typeof k != "function" && k != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, k, F, "setState");
  }, X.prototype.forceUpdate = function(k) {
    this.updater.enqueueForceUpdate(this, k, "forceUpdate");
  };
  function et() {
  }
  et.prototype = X.prototype;
  function wt(k, F, ct) {
    this.props = k, this.context = F, this.refs = Q, this.updater = ct || j;
  }
  var At = wt.prototype = new et();
  At.constructor = wt, J(At, X.prototype), At.isPureReactComponent = !0;
  var Lt = Array.isArray, yt = { H: null, A: null, T: null, S: null, V: null }, Bt = Object.prototype.hasOwnProperty;
  function Ct(k, F, ct, bt, Et, zt) {
    return ct = zt.ref, {
      $$typeof: s,
      type: k,
      key: F,
      ref: ct !== void 0 ? ct : null,
      props: zt
    };
  }
  function Yt(k, F) {
    return Ct(
      k.type,
      F,
      void 0,
      void 0,
      void 0,
      k.props
    );
  }
  function Mt(k) {
    return typeof k == "object" && k !== null && k.$$typeof === s;
  }
  function ne(k) {
    var F = { "=": "=0", ":": "=2" };
    return "$" + k.replace(/[=:]/g, function(ct) {
      return F[ct];
    });
  }
  var Rt = /\/+/g;
  function kt(k, F) {
    return typeof k == "object" && k !== null && k.key != null ? ne("" + k.key) : F.toString(36);
  }
  function Ee() {
  }
  function ge(k) {
    switch (k.status) {
      case "fulfilled":
        return k.value;
      case "rejected":
        throw k.reason;
      default:
        switch (typeof k.status == "string" ? k.then(Ee, Ee) : (k.status = "pending", k.then(
          function(F) {
            k.status === "pending" && (k.status = "fulfilled", k.value = F);
          },
          function(F) {
            k.status === "pending" && (k.status = "rejected", k.reason = F);
          }
        )), k.status) {
          case "fulfilled":
            return k.value;
          case "rejected":
            throw k.reason;
        }
    }
    throw k;
  }
  function It(k, F, ct, bt, Et) {
    var zt = typeof k;
    (zt === "undefined" || zt === "boolean") && (k = null);
    var Tt = !1;
    if (k === null) Tt = !0;
    else
      switch (zt) {
        case "bigint":
        case "string":
        case "number":
          Tt = !0;
          break;
        case "object":
          switch (k.$$typeof) {
            case s:
            case i:
              Tt = !0;
              break;
            case A:
              return Tt = k._init, It(
                Tt(k._payload),
                F,
                ct,
                bt,
                Et
              );
          }
      }
    if (Tt)
      return Et = Et(k), Tt = bt === "" ? "." + kt(k, 0) : bt, Lt(Et) ? (ct = "", Tt != null && (ct = Tt.replace(Rt, "$&/") + "/"), It(Et, F, ct, "", function(on) {
        return on;
      })) : Et != null && (Mt(Et) && (Et = Yt(
        Et,
        ct + (Et.key == null || k && k.key === Et.key ? "" : ("" + Et.key).replace(
          Rt,
          "$&/"
        ) + "/") + Tt
      )), F.push(Et)), 1;
    Tt = 0;
    var We = bt === "" ? "." : bt + ":";
    if (Lt(k))
      for (var $t = 0; $t < k.length; $t++)
        bt = k[$t], zt = We + kt(bt, $t), Tt += It(
          bt,
          F,
          ct,
          zt,
          Et
        );
    else if ($t = z(k), typeof $t == "function")
      for (k = $t.call(k), $t = 0; !(bt = k.next()).done; )
        bt = bt.value, zt = We + kt(bt, $t++), Tt += It(
          bt,
          F,
          ct,
          zt,
          Et
        );
    else if (zt === "object") {
      if (typeof k.then == "function")
        return It(
          ge(k),
          F,
          ct,
          bt,
          Et
        );
      throw F = String(k), Error(
        "Objects are not valid as a React child (found: " + (F === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : F) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return Tt;
  }
  function P(k, F, ct) {
    if (k == null) return k;
    var bt = [], Et = 0;
    return It(k, bt, "", "", function(zt) {
      return F.call(ct, zt, Et++);
    }), bt;
  }
  function dt(k) {
    if (k._status === -1) {
      var F = k._result;
      F = F(), F.then(
        function(ct) {
          (k._status === 0 || k._status === -1) && (k._status = 1, k._result = ct);
        },
        function(ct) {
          (k._status === 0 || k._status === -1) && (k._status = 2, k._result = ct);
        }
      ), k._status === -1 && (k._status = 0, k._result = F);
    }
    if (k._status === 1) return k._result.default;
    throw k._result;
  }
  var ut = typeof reportError == "function" ? reportError : function(k) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var F = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof k == "object" && k !== null && typeof k.message == "string" ? String(k.message) : String(k),
        error: k
      });
      if (!window.dispatchEvent(F)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", k);
      return;
    }
    console.error(k);
  };
  function Gt() {
  }
  return Re.Children = {
    map: P,
    forEach: function(k, F, ct) {
      P(
        k,
        function() {
          F.apply(this, arguments);
        },
        ct
      );
    },
    count: function(k) {
      var F = 0;
      return P(k, function() {
        F++;
      }), F;
    },
    toArray: function(k) {
      return P(k, function(F) {
        return F;
      }) || [];
    },
    only: function(k) {
      if (!Mt(k))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return k;
    }
  }, Re.Component = X, Re.Fragment = l, Re.Profiler = h, Re.PureComponent = wt, Re.StrictMode = u, Re.Suspense = T, Re.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = yt, Re.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(k) {
      return yt.H.useMemoCache(k);
    }
  }, Re.cache = function(k) {
    return function() {
      return k.apply(null, arguments);
    };
  }, Re.cloneElement = function(k, F, ct) {
    if (k == null)
      throw Error(
        "The argument must be a React element, but you passed " + k + "."
      );
    var bt = J({}, k.props), Et = k.key, zt = void 0;
    if (F != null)
      for (Tt in F.ref !== void 0 && (zt = void 0), F.key !== void 0 && (Et = "" + F.key), F)
        !Bt.call(F, Tt) || Tt === "key" || Tt === "__self" || Tt === "__source" || Tt === "ref" && F.ref === void 0 || (bt[Tt] = F[Tt]);
    var Tt = arguments.length - 2;
    if (Tt === 1) bt.children = ct;
    else if (1 < Tt) {
      for (var We = Array(Tt), $t = 0; $t < Tt; $t++)
        We[$t] = arguments[$t + 2];
      bt.children = We;
    }
    return Ct(k.type, Et, void 0, void 0, zt, bt);
  }, Re.createContext = function(k) {
    return k = {
      $$typeof: _,
      _currentValue: k,
      _currentValue2: k,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, k.Provider = k, k.Consumer = {
      $$typeof: g,
      _context: k
    }, k;
  }, Re.createElement = function(k, F, ct) {
    var bt, Et = {}, zt = null;
    if (F != null)
      for (bt in F.key !== void 0 && (zt = "" + F.key), F)
        Bt.call(F, bt) && bt !== "key" && bt !== "__self" && bt !== "__source" && (Et[bt] = F[bt]);
    var Tt = arguments.length - 2;
    if (Tt === 1) Et.children = ct;
    else if (1 < Tt) {
      for (var We = Array(Tt), $t = 0; $t < Tt; $t++)
        We[$t] = arguments[$t + 2];
      Et.children = We;
    }
    if (k && k.defaultProps)
      for (bt in Tt = k.defaultProps, Tt)
        Et[bt] === void 0 && (Et[bt] = Tt[bt]);
    return Ct(k, zt, void 0, void 0, null, Et);
  }, Re.createRef = function() {
    return { current: null };
  }, Re.forwardRef = function(k) {
    return { $$typeof: S, render: k };
  }, Re.isValidElement = Mt, Re.lazy = function(k) {
    return {
      $$typeof: A,
      _payload: { _status: -1, _result: k },
      _init: dt
    };
  }, Re.memo = function(k, F) {
    return {
      $$typeof: E,
      type: k,
      compare: F === void 0 ? null : F
    };
  }, Re.startTransition = function(k) {
    var F = yt.T, ct = {};
    yt.T = ct;
    try {
      var bt = k(), Et = yt.S;
      Et !== null && Et(ct, bt), typeof bt == "object" && bt !== null && typeof bt.then == "function" && bt.then(Gt, ut);
    } catch (zt) {
      ut(zt);
    } finally {
      yt.T = F;
    }
  }, Re.unstable_useCacheRefresh = function() {
    return yt.H.useCacheRefresh();
  }, Re.use = function(k) {
    return yt.H.use(k);
  }, Re.useActionState = function(k, F, ct) {
    return yt.H.useActionState(k, F, ct);
  }, Re.useCallback = function(k, F) {
    return yt.H.useCallback(k, F);
  }, Re.useContext = function(k) {
    return yt.H.useContext(k);
  }, Re.useDebugValue = function() {
  }, Re.useDeferredValue = function(k, F) {
    return yt.H.useDeferredValue(k, F);
  }, Re.useEffect = function(k, F, ct) {
    var bt = yt.H;
    if (typeof ct == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return bt.useEffect(k, F);
  }, Re.useId = function() {
    return yt.H.useId();
  }, Re.useImperativeHandle = function(k, F, ct) {
    return yt.H.useImperativeHandle(k, F, ct);
  }, Re.useInsertionEffect = function(k, F) {
    return yt.H.useInsertionEffect(k, F);
  }, Re.useLayoutEffect = function(k, F) {
    return yt.H.useLayoutEffect(k, F);
  }, Re.useMemo = function(k, F) {
    return yt.H.useMemo(k, F);
  }, Re.useOptimistic = function(k, F) {
    return yt.H.useOptimistic(k, F);
  }, Re.useReducer = function(k, F, ct) {
    return yt.H.useReducer(k, F, ct);
  }, Re.useRef = function(k) {
    return yt.H.useRef(k);
  }, Re.useState = function(k) {
    return yt.H.useState(k);
  }, Re.useSyncExternalStore = function(k, F, ct) {
    return yt.H.useSyncExternalStore(
      k,
      F,
      ct
    );
  }, Re.useTransition = function() {
    return yt.H.useTransition();
  }, Re.version = "19.1.1", Re;
}
var ov = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
ov.exports;
var jT;
function UE() {
  return jT || (jT = 1, function(s, i) {
    process.env.NODE_ENV !== "production" && function() {
      function l(N, $) {
        Object.defineProperty(g.prototype, N, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              $[0],
              $[1]
            );
          }
        });
      }
      function u(N) {
        return N === null || typeof N != "object" ? null : (N = da && N[da] || N["@@iterator"], typeof N == "function" ? N : null);
      }
      function h(N, $) {
        N = (N = N.constructor) && (N.displayName || N.name) || "ReactClass";
        var Dt = N + "." + $;
        Za[Dt] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          $,
          N
        ), Za[Dt] = !0);
      }
      function g(N, $, Dt) {
        this.props = N, this.context = $, this.refs = cr, this.updater = Dt || ma;
      }
      function _() {
      }
      function S(N, $, Dt) {
        this.props = N, this.context = $, this.refs = cr, this.updater = Dt || ma;
      }
      function T(N) {
        return "" + N;
      }
      function E(N) {
        try {
          T(N);
          var $ = !1;
        } catch {
          $ = !0;
        }
        if ($) {
          $ = console;
          var Dt = $.error, Ht = typeof Symbol == "function" && Symbol.toStringTag && N[Symbol.toStringTag] || N.constructor.name || "Object";
          return Dt.call(
            $,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            Ht
          ), T(N);
        }
      }
      function A(N) {
        if (N == null) return null;
        if (typeof N == "function")
          return N.$$typeof === dc ? null : N.displayName || N.name || null;
        if (typeof N == "string") return N;
        switch (N) {
          case k:
            return "Fragment";
          case ct:
            return "Profiler";
          case F:
            return "StrictMode";
          case Tt:
            return "Suspense";
          case We:
            return "SuspenseList";
          case ci:
            return "Activity";
        }
        if (typeof N == "object")
          switch (typeof N.tag == "number" && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), N.$$typeof) {
            case Gt:
              return "Portal";
            case Et:
              return (N.displayName || "Context") + ".Provider";
            case bt:
              return (N._context.displayName || "Context") + ".Consumer";
            case zt:
              var $ = N.render;
              return N = N.displayName, N || (N = $.displayName || $.name || "", N = N !== "" ? "ForwardRef(" + N + ")" : "ForwardRef"), N;
            case $t:
              return $ = N.displayName || null, $ !== null ? $ : A(N.type) || "Memo";
            case on:
              $ = N._payload, N = N._init;
              try {
                return A(N($));
              } catch {
              }
          }
        return null;
      }
      function C(N) {
        if (N === k) return "<>";
        if (typeof N == "object" && N !== null && N.$$typeof === on)
          return "<...>";
        try {
          var $ = A(N);
          return $ ? "<" + $ + ">" : "<...>";
        } catch {
          return "<...>";
        }
      }
      function z() {
        var N = pe.A;
        return N === null ? null : N.getOwner();
      }
      function j() {
        return Error("react-stack-top-frame");
      }
      function J(N) {
        if (pa.call(N, "key")) {
          var $ = Object.getOwnPropertyDescriptor(N, "key").get;
          if ($ && $.isReactWarning) return !1;
        }
        return N.key !== void 0;
      }
      function Q(N, $) {
        function Dt() {
          po || (po = !0, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            $
          ));
        }
        Dt.isReactWarning = !0, Object.defineProperty(N, "key", {
          get: Dt,
          configurable: !0
        });
      }
      function X() {
        var N = A(this.type);
        return hu[N] || (hu[N] = !0, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        )), N = this.props.ref, N !== void 0 ? N : null;
      }
      function et(N, $, Dt, Ht, Xt, se, he, ze) {
        return Dt = se.ref, N = {
          $$typeof: ut,
          type: N,
          key: $,
          props: se,
          _owner: Xt
        }, (Dt !== void 0 ? Dt : null) !== null ? Object.defineProperty(N, "ref", {
          enumerable: !1,
          get: X
        }) : Object.defineProperty(N, "ref", { enumerable: !1, value: null }), N._store = {}, Object.defineProperty(N._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: 0
        }), Object.defineProperty(N, "_debugInfo", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: null
        }), Object.defineProperty(N, "_debugStack", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: he
        }), Object.defineProperty(N, "_debugTask", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: ze
        }), Object.freeze && (Object.freeze(N.props), Object.freeze(N)), N;
      }
      function wt(N, $) {
        return $ = et(
          N.type,
          $,
          void 0,
          void 0,
          N._owner,
          N.props,
          N._debugStack,
          N._debugTask
        ), N._store && ($._store.validated = N._store.validated), $;
      }
      function At(N) {
        return typeof N == "object" && N !== null && N.$$typeof === ut;
      }
      function Lt(N) {
        var $ = { "=": "=0", ":": "=2" };
        return "$" + N.replace(/[=:]/g, function(Dt) {
          return $[Dt];
        });
      }
      function yt(N, $) {
        return typeof N == "object" && N !== null && N.key != null ? (E(N.key), Lt("" + N.key)) : $.toString(36);
      }
      function Bt() {
      }
      function Ct(N) {
        switch (N.status) {
          case "fulfilled":
            return N.value;
          case "rejected":
            throw N.reason;
          default:
            switch (typeof N.status == "string" ? N.then(Bt, Bt) : (N.status = "pending", N.then(
              function($) {
                N.status === "pending" && (N.status = "fulfilled", N.value = $);
              },
              function($) {
                N.status === "pending" && (N.status = "rejected", N.reason = $);
              }
            )), N.status) {
              case "fulfilled":
                return N.value;
              case "rejected":
                throw N.reason;
            }
        }
        throw N;
      }
      function Yt(N, $, Dt, Ht, Xt) {
        var se = typeof N;
        (se === "undefined" || se === "boolean") && (N = null);
        var he = !1;
        if (N === null) he = !0;
        else
          switch (se) {
            case "bigint":
            case "string":
            case "number":
              he = !0;
              break;
            case "object":
              switch (N.$$typeof) {
                case ut:
                case Gt:
                  he = !0;
                  break;
                case on:
                  return he = N._init, Yt(
                    he(N._payload),
                    $,
                    Dt,
                    Ht,
                    Xt
                  );
              }
          }
        if (he) {
          he = N, Xt = Xt(he);
          var ze = Ht === "" ? "." + yt(he, 0) : Ht;
          return Va(Xt) ? (Dt = "", ze != null && (Dt = ze.replace(In, "$&/") + "/"), Yt(Xt, $, Dt, "", function(On) {
            return On;
          })) : Xt != null && (At(Xt) && (Xt.key != null && (he && he.key === Xt.key || E(Xt.key)), Dt = wt(
            Xt,
            Dt + (Xt.key == null || he && he.key === Xt.key ? "" : ("" + Xt.key).replace(
              In,
              "$&/"
            ) + "/") + ze
          ), Ht !== "" && he != null && At(he) && he.key == null && he._store && !he._store.validated && (Dt._store.validated = 2), Xt = Dt), $.push(Xt)), 1;
        }
        if (he = 0, ze = Ht === "" ? "." : Ht + ":", Va(N))
          for (var fe = 0; fe < N.length; fe++)
            Ht = N[fe], se = ze + yt(Ht, fe), he += Yt(
              Ht,
              $,
              Dt,
              se,
              Xt
            );
        else if (fe = u(N), typeof fe == "function")
          for (fe === N.entries && (ta || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), ta = !0), N = fe.call(N), fe = 0; !(Ht = N.next()).done; )
            Ht = Ht.value, se = ze + yt(Ht, fe++), he += Yt(
              Ht,
              $,
              Dt,
              se,
              Xt
            );
        else if (se === "object") {
          if (typeof N.then == "function")
            return Yt(
              Ct(N),
              $,
              Dt,
              Ht,
              Xt
            );
          throw $ = String(N), Error(
            "Objects are not valid as a React child (found: " + ($ === "[object Object]" ? "object with keys {" + Object.keys(N).join(", ") + "}" : $) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return he;
      }
      function Mt(N, $, Dt) {
        if (N == null) return N;
        var Ht = [], Xt = 0;
        return Yt(N, Ht, "", "", function(se) {
          return $.call(Dt, se, Xt++);
        }), Ht;
      }
      function ne(N) {
        if (N._status === -1) {
          var $ = N._result;
          $ = $(), $.then(
            function(Dt) {
              (N._status === 0 || N._status === -1) && (N._status = 1, N._result = Dt);
            },
            function(Dt) {
              (N._status === 0 || N._status === -1) && (N._status = 2, N._result = Dt);
            }
          ), N._status === -1 && (N._status = 0, N._result = $);
        }
        if (N._status === 1)
          return $ = N._result, $ === void 0 && console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,
            $
          ), "default" in $ || console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,
            $
          ), $.default;
        throw N._result;
      }
      function Rt() {
        var N = pe.H;
        return N === null && console.error(
          `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
        ), N;
      }
      function kt() {
      }
      function Ee(N) {
        if (hr === null)
          try {
            var $ = ("require" + Math.random()).slice(0, 7);
            hr = (s && s[$]).call(
              s,
              "timers"
            ).setImmediate;
          } catch {
            hr = function(Ht) {
              fr === !1 && (fr = !0, typeof MessageChannel > "u" && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var Xt = new MessageChannel();
              Xt.port1.onmessage = Ht, Xt.port2.postMessage(void 0);
            };
          }
        return hr(N);
      }
      function ge(N) {
        return 1 < N.length && typeof AggregateError == "function" ? new AggregateError(N) : N[0];
      }
      function It(N, $) {
        $ !== ga - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        ), ga = $;
      }
      function P(N, $, Dt) {
        var Ht = pe.actQueue;
        if (Ht !== null)
          if (Ht.length !== 0)
            try {
              dt(Ht), Ee(function() {
                return P(N, $, Dt);
              });
              return;
            } catch (Xt) {
              pe.thrownErrors.push(Xt);
            }
          else pe.actQueue = null;
        0 < pe.thrownErrors.length ? (Ht = ge(pe.thrownErrors), pe.thrownErrors.length = 0, Dt(Ht)) : $(N);
      }
      function dt(N) {
        if (!Vn) {
          Vn = !0;
          var $ = 0;
          try {
            for (; $ < N.length; $++) {
              var Dt = N[$];
              do {
                pe.didUsePromise = !1;
                var Ht = Dt(!1);
                if (Ht !== null) {
                  if (pe.didUsePromise) {
                    N[$] = Dt, N.splice(0, $);
                    return;
                  }
                  Dt = Ht;
                } else break;
              } while (!0);
            }
            N.length = 0;
          } catch (Xt) {
            N.splice(0, $ + 1), pe.thrownErrors.push(Xt);
          } finally {
            Vn = !1;
          }
        }
      }
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var ut = Symbol.for("react.transitional.element"), Gt = Symbol.for("react.portal"), k = Symbol.for("react.fragment"), F = Symbol.for("react.strict_mode"), ct = Symbol.for("react.profiler"), bt = Symbol.for("react.consumer"), Et = Symbol.for("react.context"), zt = Symbol.for("react.forward_ref"), Tt = Symbol.for("react.suspense"), We = Symbol.for("react.suspense_list"), $t = Symbol.for("react.memo"), on = Symbol.for("react.lazy"), ci = Symbol.for("react.activity"), da = Symbol.iterator, Za = {}, ma = {
        isMounted: function() {
          return !1;
        },
        enqueueForceUpdate: function(N) {
          h(N, "forceUpdate");
        },
        enqueueReplaceState: function(N) {
          h(N, "replaceState");
        },
        enqueueSetState: function(N) {
          h(N, "setState");
        }
      }, ur = Object.assign, cr = {};
      Object.freeze(cr), g.prototype.isReactComponent = {}, g.prototype.setState = function(N, $) {
        if (typeof N != "object" && typeof N != "function" && N != null)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, N, $, "setState");
      }, g.prototype.forceUpdate = function(N) {
        this.updater.enqueueForceUpdate(this, N, "forceUpdate");
      };
      var Tn = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, En;
      for (En in Tn)
        Tn.hasOwnProperty(En) && l(En, Tn[En]);
      _.prototype = g.prototype, Tn = S.prototype = new _(), Tn.constructor = S, ur(Tn, g.prototype), Tn.isPureReactComponent = !0;
      var Va = Array.isArray, dc = Symbol.for("react.client.reference"), pe = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, pa = Object.prototype.hasOwnProperty, vs = console.createTask ? console.createTask : function() {
        return null;
      };
      Tn = {
        react_stack_bottom_frame: function(N) {
          return N();
        }
      };
      var po, mc, hu = {}, go = Tn.react_stack_bottom_frame.bind(
        Tn,
        j
      )(), Zn = vs(C(j)), ta = !1, In = /\/+/g, _s = typeof reportError == "function" ? reportError : function(N) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var $ = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof N == "object" && N !== null && typeof N.message == "string" ? String(N.message) : String(N),
            error: N
          });
          if (!window.dispatchEvent($)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", N);
          return;
        }
        console.error(N);
      }, fr = !1, hr = null, ga = 0, fi = !1, Vn = !1, Pa = typeof queueMicrotask == "function" ? function(N) {
        queueMicrotask(function() {
          return queueMicrotask(N);
        });
      } : Ee;
      Tn = Object.freeze({
        __proto__: null,
        c: function(N) {
          return Rt().useMemoCache(N);
        }
      }), i.Children = {
        map: Mt,
        forEach: function(N, $, Dt) {
          Mt(
            N,
            function() {
              $.apply(this, arguments);
            },
            Dt
          );
        },
        count: function(N) {
          var $ = 0;
          return Mt(N, function() {
            $++;
          }), $;
        },
        toArray: function(N) {
          return Mt(N, function($) {
            return $;
          }) || [];
        },
        only: function(N) {
          if (!At(N))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return N;
        }
      }, i.Component = g, i.Fragment = k, i.Profiler = ct, i.PureComponent = S, i.StrictMode = F, i.Suspense = Tt, i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = pe, i.__COMPILER_RUNTIME = Tn, i.act = function(N) {
        var $ = pe.actQueue, Dt = ga;
        ga++;
        var Ht = pe.actQueue = $ !== null ? $ : [], Xt = !1;
        try {
          var se = N();
        } catch (fe) {
          pe.thrownErrors.push(fe);
        }
        if (0 < pe.thrownErrors.length)
          throw It($, Dt), N = ge(pe.thrownErrors), pe.thrownErrors.length = 0, N;
        if (se !== null && typeof se == "object" && typeof se.then == "function") {
          var he = se;
          return Pa(function() {
            Xt || fi || (fi = !0, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          }), {
            then: function(fe, On) {
              Xt = !0, he.then(
                function(Ga) {
                  if (It($, Dt), Dt === 0) {
                    try {
                      dt(Ht), Ee(function() {
                        return P(
                          Ga,
                          fe,
                          On
                        );
                      });
                    } catch (du) {
                      pe.thrownErrors.push(du);
                    }
                    if (0 < pe.thrownErrors.length) {
                      var pc = ge(
                        pe.thrownErrors
                      );
                      pe.thrownErrors.length = 0, On(pc);
                    }
                  } else fe(Ga);
                },
                function(Ga) {
                  It($, Dt), 0 < pe.thrownErrors.length && (Ga = ge(
                    pe.thrownErrors
                  ), pe.thrownErrors.length = 0), On(Ga);
                }
              );
            }
          };
        }
        var ze = se;
        if (It($, Dt), Dt === 0 && (dt(Ht), Ht.length !== 0 && Pa(function() {
          Xt || fi || (fi = !0, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), pe.actQueue = null), 0 < pe.thrownErrors.length)
          throw N = ge(pe.thrownErrors), pe.thrownErrors.length = 0, N;
        return {
          then: function(fe, On) {
            Xt = !0, Dt === 0 ? (pe.actQueue = Ht, Ee(function() {
              return P(
                ze,
                fe,
                On
              );
            })) : fe(ze);
          }
        };
      }, i.cache = function(N) {
        return function() {
          return N.apply(null, arguments);
        };
      }, i.captureOwnerStack = function() {
        var N = pe.getCurrentStack;
        return N === null ? null : N();
      }, i.cloneElement = function(N, $, Dt) {
        if (N == null)
          throw Error(
            "The argument must be a React element, but you passed " + N + "."
          );
        var Ht = ur({}, N.props), Xt = N.key, se = N._owner;
        if ($ != null) {
          var he;
          t: {
            if (pa.call($, "ref") && (he = Object.getOwnPropertyDescriptor(
              $,
              "ref"
            ).get) && he.isReactWarning) {
              he = !1;
              break t;
            }
            he = $.ref !== void 0;
          }
          he && (se = z()), J($) && (E($.key), Xt = "" + $.key);
          for (ze in $)
            !pa.call($, ze) || ze === "key" || ze === "__self" || ze === "__source" || ze === "ref" && $.ref === void 0 || (Ht[ze] = $[ze]);
        }
        var ze = arguments.length - 2;
        if (ze === 1) Ht.children = Dt;
        else if (1 < ze) {
          he = Array(ze);
          for (var fe = 0; fe < ze; fe++)
            he[fe] = arguments[fe + 2];
          Ht.children = he;
        }
        for (Ht = et(
          N.type,
          Xt,
          void 0,
          void 0,
          se,
          Ht,
          N._debugStack,
          N._debugTask
        ), Xt = 2; Xt < arguments.length; Xt++)
          se = arguments[Xt], At(se) && se._store && (se._store.validated = 1);
        return Ht;
      }, i.createContext = function(N) {
        return N = {
          $$typeof: Et,
          _currentValue: N,
          _currentValue2: N,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }, N.Provider = N, N.Consumer = {
          $$typeof: bt,
          _context: N
        }, N._currentRenderer = null, N._currentRenderer2 = null, N;
      }, i.createElement = function(N, $, Dt) {
        for (var Ht = 2; Ht < arguments.length; Ht++) {
          var Xt = arguments[Ht];
          At(Xt) && Xt._store && (Xt._store.validated = 1);
        }
        if (Ht = {}, Xt = null, $ != null)
          for (fe in mc || !("__self" in $) || "key" in $ || (mc = !0, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), J($) && (E($.key), Xt = "" + $.key), $)
            pa.call($, fe) && fe !== "key" && fe !== "__self" && fe !== "__source" && (Ht[fe] = $[fe]);
        var se = arguments.length - 2;
        if (se === 1) Ht.children = Dt;
        else if (1 < se) {
          for (var he = Array(se), ze = 0; ze < se; ze++)
            he[ze] = arguments[ze + 2];
          Object.freeze && Object.freeze(he), Ht.children = he;
        }
        if (N && N.defaultProps)
          for (fe in se = N.defaultProps, se)
            Ht[fe] === void 0 && (Ht[fe] = se[fe]);
        Xt && Q(
          Ht,
          typeof N == "function" ? N.displayName || N.name || "Unknown" : N
        );
        var fe = 1e4 > pe.recentlyCreatedOwnerStacks++;
        return et(
          N,
          Xt,
          void 0,
          void 0,
          z(),
          Ht,
          fe ? Error("react-stack-top-frame") : go,
          fe ? vs(C(N)) : Zn
        );
      }, i.createRef = function() {
        var N = { current: null };
        return Object.seal(N), N;
      }, i.forwardRef = function(N) {
        N != null && N.$$typeof === $t ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : typeof N != "function" ? console.error(
          "forwardRef requires a render function but was given %s.",
          N === null ? "null" : typeof N
        ) : N.length !== 0 && N.length !== 2 && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          N.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        ), N != null && N.defaultProps != null && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var $ = { $$typeof: zt, render: N }, Dt;
        return Object.defineProperty($, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return Dt;
          },
          set: function(Ht) {
            Dt = Ht, N.name || N.displayName || (Object.defineProperty(N, "name", { value: Ht }), N.displayName = Ht);
          }
        }), $;
      }, i.isValidElement = At, i.lazy = function(N) {
        return {
          $$typeof: on,
          _payload: { _status: -1, _result: N },
          _init: ne
        };
      }, i.memo = function(N, $) {
        N == null && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          N === null ? "null" : typeof N
        ), $ = {
          $$typeof: $t,
          type: N,
          compare: $ === void 0 ? null : $
        };
        var Dt;
        return Object.defineProperty($, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return Dt;
          },
          set: function(Ht) {
            Dt = Ht, N.name || N.displayName || (Object.defineProperty(N, "name", { value: Ht }), N.displayName = Ht);
          }
        }), $;
      }, i.startTransition = function(N) {
        var $ = pe.T, Dt = {};
        pe.T = Dt, Dt._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var Ht = N(), Xt = pe.S;
          Xt !== null && Xt(Dt, Ht), typeof Ht == "object" && Ht !== null && typeof Ht.then == "function" && Ht.then(kt, _s);
        } catch (se) {
          _s(se);
        } finally {
          $ === null && Dt._updatedFibers && (N = Dt._updatedFibers.size, Dt._updatedFibers.clear(), 10 < N && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), pe.T = $;
        }
      }, i.unstable_useCacheRefresh = function() {
        return Rt().useCacheRefresh();
      }, i.use = function(N) {
        return Rt().use(N);
      }, i.useActionState = function(N, $, Dt) {
        return Rt().useActionState(
          N,
          $,
          Dt
        );
      }, i.useCallback = function(N, $) {
        return Rt().useCallback(N, $);
      }, i.useContext = function(N) {
        var $ = Rt();
        return N.$$typeof === bt && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        ), $.useContext(N);
      }, i.useDebugValue = function(N, $) {
        return Rt().useDebugValue(N, $);
      }, i.useDeferredValue = function(N, $) {
        return Rt().useDeferredValue(N, $);
      }, i.useEffect = function(N, $, Dt) {
        N == null && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var Ht = Rt();
        if (typeof Dt == "function")
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return Ht.useEffect(N, $);
      }, i.useId = function() {
        return Rt().useId();
      }, i.useImperativeHandle = function(N, $, Dt) {
        return Rt().useImperativeHandle(N, $, Dt);
      }, i.useInsertionEffect = function(N, $) {
        return N == null && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        ), Rt().useInsertionEffect(N, $);
      }, i.useLayoutEffect = function(N, $) {
        return N == null && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        ), Rt().useLayoutEffect(N, $);
      }, i.useMemo = function(N, $) {
        return Rt().useMemo(N, $);
      }, i.useOptimistic = function(N, $) {
        return Rt().useOptimistic(N, $);
      }, i.useReducer = function(N, $, Dt) {
        return Rt().useReducer(N, $, Dt);
      }, i.useRef = function(N) {
        return Rt().useRef(N);
      }, i.useState = function(N) {
        return Rt().useState(N);
      }, i.useSyncExternalStore = function(N, $, Dt) {
        return Rt().useSyncExternalStore(
          N,
          $,
          Dt
        );
      }, i.useTransition = function() {
        return Rt().useTransition();
      }, i.version = "19.1.1", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(ov, ov.exports)), ov.exports;
}
var qT;
function Np() {
  return qT || (qT = 1, process.env.NODE_ENV === "production" ? W_.exports = NE() : W_.exports = UE()), W_.exports;
}
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZT;
function BE() {
  return ZT || (ZT = 1, process.env.NODE_ENV !== "production" && function() {
    function s(k) {
      if (k == null) return null;
      if (typeof k == "function")
        return k.$$typeof === ne ? null : k.displayName || k.name || null;
      if (typeof k == "string") return k;
      switch (k) {
        case Q:
          return "Fragment";
        case et:
          return "Profiler";
        case X:
          return "StrictMode";
        case yt:
          return "Suspense";
        case Bt:
          return "SuspenseList";
        case Mt:
          return "Activity";
      }
      if (typeof k == "object")
        switch (typeof k.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), k.$$typeof) {
          case J:
            return "Portal";
          case At:
            return (k.displayName || "Context") + ".Provider";
          case wt:
            return (k._context.displayName || "Context") + ".Consumer";
          case Lt:
            var F = k.render;
            return k = k.displayName, k || (k = F.displayName || F.name || "", k = k !== "" ? "ForwardRef(" + k + ")" : "ForwardRef"), k;
          case Ct:
            return F = k.displayName || null, F !== null ? F : s(k.type) || "Memo";
          case Yt:
            F = k._payload, k = k._init;
            try {
              return s(k(F));
            } catch {
            }
        }
      return null;
    }
    function i(k) {
      return "" + k;
    }
    function l(k) {
      try {
        i(k);
        var F = !1;
      } catch {
        F = !0;
      }
      if (F) {
        F = console;
        var ct = F.error, bt = typeof Symbol == "function" && Symbol.toStringTag && k[Symbol.toStringTag] || k.constructor.name || "Object";
        return ct.call(
          F,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          bt
        ), i(k);
      }
    }
    function u(k) {
      if (k === Q) return "<>";
      if (typeof k == "object" && k !== null && k.$$typeof === Yt)
        return "<...>";
      try {
        var F = s(k);
        return F ? "<" + F + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function h() {
      var k = Rt.A;
      return k === null ? null : k.getOwner();
    }
    function g() {
      return Error("react-stack-top-frame");
    }
    function _(k) {
      if (kt.call(k, "key")) {
        var F = Object.getOwnPropertyDescriptor(k, "key").get;
        if (F && F.isReactWarning) return !1;
      }
      return k.key !== void 0;
    }
    function S(k, F) {
      function ct() {
        It || (It = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          F
        ));
      }
      ct.isReactWarning = !0, Object.defineProperty(k, "key", {
        get: ct,
        configurable: !0
      });
    }
    function T() {
      var k = s(this.type);
      return P[k] || (P[k] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), k = this.props.ref, k !== void 0 ? k : null;
    }
    function E(k, F, ct, bt, Et, zt, Tt, We) {
      return ct = zt.ref, k = {
        $$typeof: j,
        type: k,
        key: F,
        props: zt,
        _owner: Et
      }, (ct !== void 0 ? ct : null) !== null ? Object.defineProperty(k, "ref", {
        enumerable: !1,
        get: T
      }) : Object.defineProperty(k, "ref", { enumerable: !1, value: null }), k._store = {}, Object.defineProperty(k._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(k, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(k, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: Tt
      }), Object.defineProperty(k, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: We
      }), Object.freeze && (Object.freeze(k.props), Object.freeze(k)), k;
    }
    function A(k, F, ct, bt, Et, zt, Tt, We) {
      var $t = F.children;
      if ($t !== void 0)
        if (bt)
          if (Ee($t)) {
            for (bt = 0; bt < $t.length; bt++)
              C($t[bt]);
            Object.freeze && Object.freeze($t);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else C($t);
      if (kt.call(F, "key")) {
        $t = s(k);
        var on = Object.keys(F).filter(function(da) {
          return da !== "key";
        });
        bt = 0 < on.length ? "{key: someKey, " + on.join(": ..., ") + ": ...}" : "{key: someKey}", Gt[$t + bt] || (on = 0 < on.length ? "{" + on.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          bt,
          $t,
          on,
          $t
        ), Gt[$t + bt] = !0);
      }
      if ($t = null, ct !== void 0 && (l(ct), $t = "" + ct), _(F) && (l(F.key), $t = "" + F.key), "key" in F) {
        ct = {};
        for (var ci in F)
          ci !== "key" && (ct[ci] = F[ci]);
      } else ct = F;
      return $t && S(
        ct,
        typeof k == "function" ? k.displayName || k.name || "Unknown" : k
      ), E(
        k,
        $t,
        zt,
        Et,
        h(),
        ct,
        Tt,
        We
      );
    }
    function C(k) {
      typeof k == "object" && k !== null && k.$$typeof === j && k._store && (k._store.validated = 1);
    }
    var z = Np(), j = Symbol.for("react.transitional.element"), J = Symbol.for("react.portal"), Q = Symbol.for("react.fragment"), X = Symbol.for("react.strict_mode"), et = Symbol.for("react.profiler"), wt = Symbol.for("react.consumer"), At = Symbol.for("react.context"), Lt = Symbol.for("react.forward_ref"), yt = Symbol.for("react.suspense"), Bt = Symbol.for("react.suspense_list"), Ct = Symbol.for("react.memo"), Yt = Symbol.for("react.lazy"), Mt = Symbol.for("react.activity"), ne = Symbol.for("react.client.reference"), Rt = z.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, kt = Object.prototype.hasOwnProperty, Ee = Array.isArray, ge = console.createTask ? console.createTask : function() {
      return null;
    };
    z = {
      react_stack_bottom_frame: function(k) {
        return k();
      }
    };
    var It, P = {}, dt = z.react_stack_bottom_frame.bind(
      z,
      g
    )(), ut = ge(u(g)), Gt = {};
    Ky.Fragment = Q, Ky.jsx = function(k, F, ct, bt, Et) {
      var zt = 1e4 > Rt.recentlyCreatedOwnerStacks++;
      return A(
        k,
        F,
        ct,
        !1,
        bt,
        Et,
        zt ? Error("react-stack-top-frame") : dt,
        zt ? ge(u(k)) : ut
      );
    }, Ky.jsxs = function(k, F, ct, bt, Et) {
      var zt = 1e4 > Rt.recentlyCreatedOwnerStacks++;
      return A(
        k,
        F,
        ct,
        !0,
        bt,
        Et,
        zt ? Error("react-stack-top-frame") : dt,
        zt ? ge(u(k)) : ut
      );
    };
  }()), Ky;
}
var VT;
function YE() {
  return VT || (VT = 1, process.env.NODE_ENV === "production" ? K_.exports = kE() : K_.exports = BE()), K_.exports;
}
var ee = YE(), $i = Np(), J_ = { exports: {} }, Wy = {}, I_ = { exports: {} }, Pb = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PT;
function jE() {
  return PT || (PT = 1, function(s) {
    function i(P, dt) {
      var ut = P.length;
      P.push(dt);
      t: for (; 0 < ut; ) {
        var Gt = ut - 1 >>> 1, k = P[Gt];
        if (0 < h(k, dt))
          P[Gt] = dt, P[ut] = k, ut = Gt;
        else break t;
      }
    }
    function l(P) {
      return P.length === 0 ? null : P[0];
    }
    function u(P) {
      if (P.length === 0) return null;
      var dt = P[0], ut = P.pop();
      if (ut !== dt) {
        P[0] = ut;
        t: for (var Gt = 0, k = P.length, F = k >>> 1; Gt < F; ) {
          var ct = 2 * (Gt + 1) - 1, bt = P[ct], Et = ct + 1, zt = P[Et];
          if (0 > h(bt, ut))
            Et < k && 0 > h(zt, bt) ? (P[Gt] = zt, P[Et] = ut, Gt = Et) : (P[Gt] = bt, P[ct] = ut, Gt = ct);
          else if (Et < k && 0 > h(zt, ut))
            P[Gt] = zt, P[Et] = ut, Gt = Et;
          else break t;
        }
      }
      return dt;
    }
    function h(P, dt) {
      var ut = P.sortIndex - dt.sortIndex;
      return ut !== 0 ? ut : P.id - dt.id;
    }
    if (s.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var g = performance;
      s.unstable_now = function() {
        return g.now();
      };
    } else {
      var _ = Date, S = _.now();
      s.unstable_now = function() {
        return _.now() - S;
      };
    }
    var T = [], E = [], A = 1, C = null, z = 3, j = !1, J = !1, Q = !1, X = !1, et = typeof setTimeout == "function" ? setTimeout : null, wt = typeof clearTimeout == "function" ? clearTimeout : null, At = typeof setImmediate < "u" ? setImmediate : null;
    function Lt(P) {
      for (var dt = l(E); dt !== null; ) {
        if (dt.callback === null) u(E);
        else if (dt.startTime <= P)
          u(E), dt.sortIndex = dt.expirationTime, i(T, dt);
        else break;
        dt = l(E);
      }
    }
    function yt(P) {
      if (Q = !1, Lt(P), !J)
        if (l(T) !== null)
          J = !0, Bt || (Bt = !0, kt());
        else {
          var dt = l(E);
          dt !== null && It(yt, dt.startTime - P);
        }
    }
    var Bt = !1, Ct = -1, Yt = 5, Mt = -1;
    function ne() {
      return X ? !0 : !(s.unstable_now() - Mt < Yt);
    }
    function Rt() {
      if (X = !1, Bt) {
        var P = s.unstable_now();
        Mt = P;
        var dt = !0;
        try {
          t: {
            J = !1, Q && (Q = !1, wt(Ct), Ct = -1), j = !0;
            var ut = z;
            try {
              e: {
                for (Lt(P), C = l(T); C !== null && !(C.expirationTime > P && ne()); ) {
                  var Gt = C.callback;
                  if (typeof Gt == "function") {
                    C.callback = null, z = C.priorityLevel;
                    var k = Gt(
                      C.expirationTime <= P
                    );
                    if (P = s.unstable_now(), typeof k == "function") {
                      C.callback = k, Lt(P), dt = !0;
                      break e;
                    }
                    C === l(T) && u(T), Lt(P);
                  } else u(T);
                  C = l(T);
                }
                if (C !== null) dt = !0;
                else {
                  var F = l(E);
                  F !== null && It(
                    yt,
                    F.startTime - P
                  ), dt = !1;
                }
              }
              break t;
            } finally {
              C = null, z = ut, j = !1;
            }
            dt = void 0;
          }
        } finally {
          dt ? kt() : Bt = !1;
        }
      }
    }
    var kt;
    if (typeof At == "function")
      kt = function() {
        At(Rt);
      };
    else if (typeof MessageChannel < "u") {
      var Ee = new MessageChannel(), ge = Ee.port2;
      Ee.port1.onmessage = Rt, kt = function() {
        ge.postMessage(null);
      };
    } else
      kt = function() {
        et(Rt, 0);
      };
    function It(P, dt) {
      Ct = et(function() {
        P(s.unstable_now());
      }, dt);
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(P) {
      P.callback = null;
    }, s.unstable_forceFrameRate = function(P) {
      0 > P || 125 < P ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : Yt = 0 < P ? Math.floor(1e3 / P) : 5;
    }, s.unstable_getCurrentPriorityLevel = function() {
      return z;
    }, s.unstable_next = function(P) {
      switch (z) {
        case 1:
        case 2:
        case 3:
          var dt = 3;
          break;
        default:
          dt = z;
      }
      var ut = z;
      z = dt;
      try {
        return P();
      } finally {
        z = ut;
      }
    }, s.unstable_requestPaint = function() {
      X = !0;
    }, s.unstable_runWithPriority = function(P, dt) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          P = 3;
      }
      var ut = z;
      z = P;
      try {
        return dt();
      } finally {
        z = ut;
      }
    }, s.unstable_scheduleCallback = function(P, dt, ut) {
      var Gt = s.unstable_now();
      switch (typeof ut == "object" && ut !== null ? (ut = ut.delay, ut = typeof ut == "number" && 0 < ut ? Gt + ut : Gt) : ut = Gt, P) {
        case 1:
          var k = -1;
          break;
        case 2:
          k = 250;
          break;
        case 5:
          k = 1073741823;
          break;
        case 4:
          k = 1e4;
          break;
        default:
          k = 5e3;
      }
      return k = ut + k, P = {
        id: A++,
        callback: dt,
        priorityLevel: P,
        startTime: ut,
        expirationTime: k,
        sortIndex: -1
      }, ut > Gt ? (P.sortIndex = ut, i(E, P), l(T) === null && P === l(E) && (Q ? (wt(Ct), Ct = -1) : Q = !0, It(yt, ut - Gt))) : (P.sortIndex = k, i(T, P), J || j || (J = !0, Bt || (Bt = !0, kt()))), P;
    }, s.unstable_shouldYield = ne, s.unstable_wrapCallback = function(P) {
      var dt = z;
      return function() {
        var ut = z;
        z = dt;
        try {
          return P.apply(this, arguments);
        } finally {
          z = ut;
        }
      };
    };
  }(Pb)), Pb;
}
var Gb = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var GT;
function qE() {
  return GT || (GT = 1, function(s) {
    process.env.NODE_ENV !== "production" && function() {
      function i() {
        if (yt = !1, Mt) {
          var P = s.unstable_now();
          kt = P;
          var dt = !0;
          try {
            t: {
              At = !1, Lt && (Lt = !1, Ct(ne), ne = -1), wt = !0;
              var ut = et;
              try {
                e: {
                  for (_(P), X = u(j); X !== null && !(X.expirationTime > P && T()); ) {
                    var Gt = X.callback;
                    if (typeof Gt == "function") {
                      X.callback = null, et = X.priorityLevel;
                      var k = Gt(
                        X.expirationTime <= P
                      );
                      if (P = s.unstable_now(), typeof k == "function") {
                        X.callback = k, _(P), dt = !0;
                        break e;
                      }
                      X === u(j) && h(j), _(P);
                    } else h(j);
                    X = u(j);
                  }
                  if (X !== null) dt = !0;
                  else {
                    var F = u(J);
                    F !== null && E(
                      S,
                      F.startTime - P
                    ), dt = !1;
                  }
                }
                break t;
              } finally {
                X = null, et = ut, wt = !1;
              }
              dt = void 0;
            }
          } finally {
            dt ? Ee() : Mt = !1;
          }
        }
      }
      function l(P, dt) {
        var ut = P.length;
        P.push(dt);
        t: for (; 0 < ut; ) {
          var Gt = ut - 1 >>> 1, k = P[Gt];
          if (0 < g(k, dt))
            P[Gt] = dt, P[ut] = k, ut = Gt;
          else break t;
        }
      }
      function u(P) {
        return P.length === 0 ? null : P[0];
      }
      function h(P) {
        if (P.length === 0) return null;
        var dt = P[0], ut = P.pop();
        if (ut !== dt) {
          P[0] = ut;
          t: for (var Gt = 0, k = P.length, F = k >>> 1; Gt < F; ) {
            var ct = 2 * (Gt + 1) - 1, bt = P[ct], Et = ct + 1, zt = P[Et];
            if (0 > g(bt, ut))
              Et < k && 0 > g(zt, bt) ? (P[Gt] = zt, P[Et] = ut, Gt = Et) : (P[Gt] = bt, P[ct] = ut, Gt = ct);
            else if (Et < k && 0 > g(zt, ut))
              P[Gt] = zt, P[Et] = ut, Gt = Et;
            else break t;
          }
        }
        return dt;
      }
      function g(P, dt) {
        var ut = P.sortIndex - dt.sortIndex;
        return ut !== 0 ? ut : P.id - dt.id;
      }
      function _(P) {
        for (var dt = u(J); dt !== null; ) {
          if (dt.callback === null) h(J);
          else if (dt.startTime <= P)
            h(J), dt.sortIndex = dt.expirationTime, l(j, dt);
          else break;
          dt = u(J);
        }
      }
      function S(P) {
        if (Lt = !1, _(P), !At)
          if (u(j) !== null)
            At = !0, Mt || (Mt = !0, Ee());
          else {
            var dt = u(J);
            dt !== null && E(
              S,
              dt.startTime - P
            );
          }
      }
      function T() {
        return yt ? !0 : !(s.unstable_now() - kt < Rt);
      }
      function E(P, dt) {
        ne = Bt(function() {
          P(s.unstable_now());
        }, dt);
      }
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()), s.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var A = performance;
        s.unstable_now = function() {
          return A.now();
        };
      } else {
        var C = Date, z = C.now();
        s.unstable_now = function() {
          return C.now() - z;
        };
      }
      var j = [], J = [], Q = 1, X = null, et = 3, wt = !1, At = !1, Lt = !1, yt = !1, Bt = typeof setTimeout == "function" ? setTimeout : null, Ct = typeof clearTimeout == "function" ? clearTimeout : null, Yt = typeof setImmediate < "u" ? setImmediate : null, Mt = !1, ne = -1, Rt = 5, kt = -1;
      if (typeof Yt == "function")
        var Ee = function() {
          Yt(i);
        };
      else if (typeof MessageChannel < "u") {
        var ge = new MessageChannel(), It = ge.port2;
        ge.port1.onmessage = i, Ee = function() {
          It.postMessage(null);
        };
      } else
        Ee = function() {
          Bt(i, 0);
        };
      s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(P) {
        P.callback = null;
      }, s.unstable_forceFrameRate = function(P) {
        0 > P || 125 < P ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : Rt = 0 < P ? Math.floor(1e3 / P) : 5;
      }, s.unstable_getCurrentPriorityLevel = function() {
        return et;
      }, s.unstable_next = function(P) {
        switch (et) {
          case 1:
          case 2:
          case 3:
            var dt = 3;
            break;
          default:
            dt = et;
        }
        var ut = et;
        et = dt;
        try {
          return P();
        } finally {
          et = ut;
        }
      }, s.unstable_requestPaint = function() {
        yt = !0;
      }, s.unstable_runWithPriority = function(P, dt) {
        switch (P) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            P = 3;
        }
        var ut = et;
        et = P;
        try {
          return dt();
        } finally {
          et = ut;
        }
      }, s.unstable_scheduleCallback = function(P, dt, ut) {
        var Gt = s.unstable_now();
        switch (typeof ut == "object" && ut !== null ? (ut = ut.delay, ut = typeof ut == "number" && 0 < ut ? Gt + ut : Gt) : ut = Gt, P) {
          case 1:
            var k = -1;
            break;
          case 2:
            k = 250;
            break;
          case 5:
            k = 1073741823;
            break;
          case 4:
            k = 1e4;
            break;
          default:
            k = 5e3;
        }
        return k = ut + k, P = {
          id: Q++,
          callback: dt,
          priorityLevel: P,
          startTime: ut,
          expirationTime: k,
          sortIndex: -1
        }, ut > Gt ? (P.sortIndex = ut, l(J, P), u(j) === null && P === u(J) && (Lt ? (Ct(ne), ne = -1) : Lt = !0, E(S, ut - Gt))) : (P.sortIndex = k, l(j, P), At || wt || (At = !0, Mt || (Mt = !0, Ee()))), P;
      }, s.unstable_shouldYield = T, s.unstable_wrapCallback = function(P) {
        var dt = et;
        return function() {
          var ut = et;
          et = dt;
          try {
            return P.apply(this, arguments);
          } finally {
            et = ut;
          }
        };
      }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(Gb)), Gb;
}
var XT;
function Sw() {
  return XT || (XT = 1, process.env.NODE_ENV === "production" ? I_.exports = jE() : I_.exports = qE()), I_.exports;
}
var $_ = { exports: {} }, Ba = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QT;
function ZE() {
  if (QT) return Ba;
  QT = 1;
  var s = Np();
  function i(T) {
    var E = "https://react.dev/errors/" + T;
    if (1 < arguments.length) {
      E += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var A = 2; A < arguments.length; A++)
        E += "&args[]=" + encodeURIComponent(arguments[A]);
    }
    return "Minified React error #" + T + "; visit " + E + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function l() {
  }
  var u = {
    d: {
      f: l,
      r: function() {
        throw Error(i(522));
      },
      D: l,
      C: l,
      L: l,
      m: l,
      X: l,
      S: l,
      M: l
    },
    p: 0,
    findDOMNode: null
  }, h = Symbol.for("react.portal");
  function g(T, E, A) {
    var C = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: h,
      key: C == null ? null : "" + C,
      children: T,
      containerInfo: E,
      implementation: A
    };
  }
  var _ = s.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function S(T, E) {
    if (T === "font") return "";
    if (typeof E == "string")
      return E === "use-credentials" ? E : "";
  }
  return Ba.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = u, Ba.createPortal = function(T, E) {
    var A = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!E || E.nodeType !== 1 && E.nodeType !== 9 && E.nodeType !== 11)
      throw Error(i(299));
    return g(T, E, null, A);
  }, Ba.flushSync = function(T) {
    var E = _.T, A = u.p;
    try {
      if (_.T = null, u.p = 2, T) return T();
    } finally {
      _.T = E, u.p = A, u.d.f();
    }
  }, Ba.preconnect = function(T, E) {
    typeof T == "string" && (E ? (E = E.crossOrigin, E = typeof E == "string" ? E === "use-credentials" ? E : "" : void 0) : E = null, u.d.C(T, E));
  }, Ba.prefetchDNS = function(T) {
    typeof T == "string" && u.d.D(T);
  }, Ba.preinit = function(T, E) {
    if (typeof T == "string" && E && typeof E.as == "string") {
      var A = E.as, C = S(A, E.crossOrigin), z = typeof E.integrity == "string" ? E.integrity : void 0, j = typeof E.fetchPriority == "string" ? E.fetchPriority : void 0;
      A === "style" ? u.d.S(
        T,
        typeof E.precedence == "string" ? E.precedence : void 0,
        {
          crossOrigin: C,
          integrity: z,
          fetchPriority: j
        }
      ) : A === "script" && u.d.X(T, {
        crossOrigin: C,
        integrity: z,
        fetchPriority: j,
        nonce: typeof E.nonce == "string" ? E.nonce : void 0
      });
    }
  }, Ba.preinitModule = function(T, E) {
    if (typeof T == "string")
      if (typeof E == "object" && E !== null) {
        if (E.as == null || E.as === "script") {
          var A = S(
            E.as,
            E.crossOrigin
          );
          u.d.M(T, {
            crossOrigin: A,
            integrity: typeof E.integrity == "string" ? E.integrity : void 0,
            nonce: typeof E.nonce == "string" ? E.nonce : void 0
          });
        }
      } else E == null && u.d.M(T);
  }, Ba.preload = function(T, E) {
    if (typeof T == "string" && typeof E == "object" && E !== null && typeof E.as == "string") {
      var A = E.as, C = S(A, E.crossOrigin);
      u.d.L(T, A, {
        crossOrigin: C,
        integrity: typeof E.integrity == "string" ? E.integrity : void 0,
        nonce: typeof E.nonce == "string" ? E.nonce : void 0,
        type: typeof E.type == "string" ? E.type : void 0,
        fetchPriority: typeof E.fetchPriority == "string" ? E.fetchPriority : void 0,
        referrerPolicy: typeof E.referrerPolicy == "string" ? E.referrerPolicy : void 0,
        imageSrcSet: typeof E.imageSrcSet == "string" ? E.imageSrcSet : void 0,
        imageSizes: typeof E.imageSizes == "string" ? E.imageSizes : void 0,
        media: typeof E.media == "string" ? E.media : void 0
      });
    }
  }, Ba.preloadModule = function(T, E) {
    if (typeof T == "string")
      if (E) {
        var A = S(E.as, E.crossOrigin);
        u.d.m(T, {
          as: typeof E.as == "string" && E.as !== "script" ? E.as : void 0,
          crossOrigin: A,
          integrity: typeof E.integrity == "string" ? E.integrity : void 0
        });
      } else u.d.m(T);
  }, Ba.requestFormReset = function(T) {
    u.d.r(T);
  }, Ba.unstable_batchedUpdates = function(T, E) {
    return T(E);
  }, Ba.useFormState = function(T, E, A) {
    return _.H.useFormState(T, E, A);
  }, Ba.useFormStatus = function() {
    return _.H.useHostTransitionStatus();
  }, Ba.version = "19.1.1", Ba;
}
var Ya = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KT;
function VE() {
  return KT || (KT = 1, process.env.NODE_ENV !== "production" && function() {
    function s() {
    }
    function i(C) {
      return "" + C;
    }
    function l(C, z, j) {
      var J = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      try {
        i(J);
        var Q = !1;
      } catch {
        Q = !0;
      }
      return Q && (console.error(
        "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
        typeof Symbol == "function" && Symbol.toStringTag && J[Symbol.toStringTag] || J.constructor.name || "Object"
      ), i(J)), {
        $$typeof: E,
        key: J == null ? null : "" + J,
        children: C,
        containerInfo: z,
        implementation: j
      };
    }
    function u(C, z) {
      if (C === "font") return "";
      if (typeof z == "string")
        return z === "use-credentials" ? z : "";
    }
    function h(C) {
      return C === null ? "`null`" : C === void 0 ? "`undefined`" : C === "" ? "an empty string" : 'something with type "' + typeof C + '"';
    }
    function g(C) {
      return C === null ? "`null`" : C === void 0 ? "`undefined`" : C === "" ? "an empty string" : typeof C == "string" ? JSON.stringify(C) : typeof C == "number" ? "`" + C + "`" : 'something with type "' + typeof C + '"';
    }
    function _() {
      var C = A.H;
      return C === null && console.error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      ), C;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var S = Np(), T = {
      d: {
        f: s,
        r: function() {
          throw Error(
            "Invalid form element. requestFormReset must be passed a form that was rendered by React."
          );
        },
        D: s,
        C: s,
        L: s,
        m: s,
        X: s,
        S: s,
        M: s
      },
      p: 0,
      findDOMNode: null
    }, E = Symbol.for("react.portal"), A = S.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
    ), Ya.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = T, Ya.createPortal = function(C, z) {
      var j = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!z || z.nodeType !== 1 && z.nodeType !== 9 && z.nodeType !== 11)
        throw Error("Target container is not a DOM element.");
      return l(C, z, null, j);
    }, Ya.flushSync = function(C) {
      var z = A.T, j = T.p;
      try {
        if (A.T = null, T.p = 2, C)
          return C();
      } finally {
        A.T = z, T.p = j, T.d.f() && console.error(
          "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
        );
      }
    }, Ya.preconnect = function(C, z) {
      typeof C == "string" && C ? z != null && typeof z != "object" ? console.error(
        "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
        g(z)
      ) : z != null && typeof z.crossOrigin != "string" && console.error(
        "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
        h(z.crossOrigin)
      ) : console.error(
        "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        h(C)
      ), typeof C == "string" && (z ? (z = z.crossOrigin, z = typeof z == "string" ? z === "use-credentials" ? z : "" : void 0) : z = null, T.d.C(C, z));
    }, Ya.prefetchDNS = function(C) {
      if (typeof C != "string" || !C)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          h(C)
        );
      else if (1 < arguments.length) {
        var z = arguments[1];
        typeof z == "object" && z.hasOwnProperty("crossOrigin") ? console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          g(z)
        ) : console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          g(z)
        );
      }
      typeof C == "string" && T.d.D(C);
    }, Ya.preinit = function(C, z) {
      if (typeof C == "string" && C ? z == null || typeof z != "object" ? console.error(
        "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
        g(z)
      ) : z.as !== "style" && z.as !== "script" && console.error(
        'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
        g(z.as)
      ) : console.error(
        "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        h(C)
      ), typeof C == "string" && z && typeof z.as == "string") {
        var j = z.as, J = u(j, z.crossOrigin), Q = typeof z.integrity == "string" ? z.integrity : void 0, X = typeof z.fetchPriority == "string" ? z.fetchPriority : void 0;
        j === "style" ? T.d.S(
          C,
          typeof z.precedence == "string" ? z.precedence : void 0,
          {
            crossOrigin: J,
            integrity: Q,
            fetchPriority: X
          }
        ) : j === "script" && T.d.X(C, {
          crossOrigin: J,
          integrity: Q,
          fetchPriority: X,
          nonce: typeof z.nonce == "string" ? z.nonce : void 0
        });
      }
    }, Ya.preinitModule = function(C, z) {
      var j = "";
      if (typeof C == "string" && C || (j += " The `href` argument encountered was " + h(C) + "."), z !== void 0 && typeof z != "object" ? j += " The `options` argument encountered was " + h(z) + "." : z && "as" in z && z.as !== "script" && (j += " The `as` option encountered was " + g(z.as) + "."), j)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          j
        );
      else
        switch (j = z && typeof z.as == "string" ? z.as : "script", j) {
          case "script":
            break;
          default:
            j = g(j), console.error(
              'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
              j,
              C
            );
        }
      typeof C == "string" && (typeof z == "object" && z !== null ? (z.as == null || z.as === "script") && (j = u(
        z.as,
        z.crossOrigin
      ), T.d.M(C, {
        crossOrigin: j,
        integrity: typeof z.integrity == "string" ? z.integrity : void 0,
        nonce: typeof z.nonce == "string" ? z.nonce : void 0
      })) : z == null && T.d.M(C));
    }, Ya.preload = function(C, z) {
      var j = "";
      if (typeof C == "string" && C || (j += " The `href` argument encountered was " + h(C) + "."), z == null || typeof z != "object" ? j += " The `options` argument encountered was " + h(z) + "." : typeof z.as == "string" && z.as || (j += " The `as` option encountered was " + h(z.as) + "."), j && console.error(
        'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
        j
      ), typeof C == "string" && typeof z == "object" && z !== null && typeof z.as == "string") {
        j = z.as;
        var J = u(
          j,
          z.crossOrigin
        );
        T.d.L(C, j, {
          crossOrigin: J,
          integrity: typeof z.integrity == "string" ? z.integrity : void 0,
          nonce: typeof z.nonce == "string" ? z.nonce : void 0,
          type: typeof z.type == "string" ? z.type : void 0,
          fetchPriority: typeof z.fetchPriority == "string" ? z.fetchPriority : void 0,
          referrerPolicy: typeof z.referrerPolicy == "string" ? z.referrerPolicy : void 0,
          imageSrcSet: typeof z.imageSrcSet == "string" ? z.imageSrcSet : void 0,
          imageSizes: typeof z.imageSizes == "string" ? z.imageSizes : void 0,
          media: typeof z.media == "string" ? z.media : void 0
        });
      }
    }, Ya.preloadModule = function(C, z) {
      var j = "";
      typeof C == "string" && C || (j += " The `href` argument encountered was " + h(C) + "."), z !== void 0 && typeof z != "object" ? j += " The `options` argument encountered was " + h(z) + "." : z && "as" in z && typeof z.as != "string" && (j += " The `as` option encountered was " + h(z.as) + "."), j && console.error(
        'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
        j
      ), typeof C == "string" && (z ? (j = u(
        z.as,
        z.crossOrigin
      ), T.d.m(C, {
        as: typeof z.as == "string" && z.as !== "script" ? z.as : void 0,
        crossOrigin: j,
        integrity: typeof z.integrity == "string" ? z.integrity : void 0
      })) : T.d.m(C));
    }, Ya.requestFormReset = function(C) {
      T.d.r(C);
    }, Ya.unstable_batchedUpdates = function(C, z) {
      return C(z);
    }, Ya.useFormState = function(C, z, j) {
      return _().useFormState(C, z, j);
    }, Ya.useFormStatus = function() {
      return _().useHostTransitionStatus();
    }, Ya.version = "19.1.1", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Ya;
}
var WT;
function Tw() {
  if (WT) return $_.exports;
  WT = 1;
  function s() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s);
      } catch (i) {
        console.error(i);
      }
    }
  }
  return process.env.NODE_ENV === "production" ? (s(), $_.exports = ZE()) : $_.exports = VE(), $_.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JT;
function PE() {
  if (JT) return Wy;
  JT = 1;
  var s = Sw(), i = Np(), l = Tw();
  function u(n) {
    var o = "https://react.dev/errors/" + n;
    if (1 < arguments.length) {
      o += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var c = 2; c < arguments.length; c++)
        o += "&args[]=" + encodeURIComponent(arguments[c]);
    }
    return "Minified React error #" + n + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function h(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11);
  }
  function g(n) {
    var o = n, c = n;
    if (n.alternate) for (; o.return; ) o = o.return;
    else {
      n = o;
      do
        o = n, (o.flags & 4098) !== 0 && (c = o.return), n = o.return;
      while (n);
    }
    return o.tag === 3 ? c : null;
  }
  function _(n) {
    if (n.tag === 13) {
      var o = n.memoizedState;
      if (o === null && (n = n.alternate, n !== null && (o = n.memoizedState)), o !== null) return o.dehydrated;
    }
    return null;
  }
  function S(n) {
    if (g(n) !== n)
      throw Error(u(188));
  }
  function T(n) {
    var o = n.alternate;
    if (!o) {
      if (o = g(n), o === null) throw Error(u(188));
      return o !== n ? null : n;
    }
    for (var c = n, m = o; ; ) {
      var b = c.return;
      if (b === null) break;
      var x = b.alternate;
      if (x === null) {
        if (m = b.return, m !== null) {
          c = m;
          continue;
        }
        break;
      }
      if (b.child === x.child) {
        for (x = b.child; x; ) {
          if (x === c) return S(b), n;
          if (x === m) return S(b), o;
          x = x.sibling;
        }
        throw Error(u(188));
      }
      if (c.return !== m.return) c = b, m = x;
      else {
        for (var R = !1, U = b.child; U; ) {
          if (U === c) {
            R = !0, c = b, m = x;
            break;
          }
          if (U === m) {
            R = !0, m = b, c = x;
            break;
          }
          U = U.sibling;
        }
        if (!R) {
          for (U = x.child; U; ) {
            if (U === c) {
              R = !0, c = x, m = b;
              break;
            }
            if (U === m) {
              R = !0, m = x, c = b;
              break;
            }
            U = U.sibling;
          }
          if (!R) throw Error(u(189));
        }
      }
      if (c.alternate !== m) throw Error(u(190));
    }
    if (c.tag !== 3) throw Error(u(188));
    return c.stateNode.current === c ? n : o;
  }
  function E(n) {
    var o = n.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return n;
    for (n = n.child; n !== null; ) {
      if (o = E(n), o !== null) return o;
      n = n.sibling;
    }
    return null;
  }
  var A = Object.assign, C = Symbol.for("react.element"), z = Symbol.for("react.transitional.element"), j = Symbol.for("react.portal"), J = Symbol.for("react.fragment"), Q = Symbol.for("react.strict_mode"), X = Symbol.for("react.profiler"), et = Symbol.for("react.provider"), wt = Symbol.for("react.consumer"), At = Symbol.for("react.context"), Lt = Symbol.for("react.forward_ref"), yt = Symbol.for("react.suspense"), Bt = Symbol.for("react.suspense_list"), Ct = Symbol.for("react.memo"), Yt = Symbol.for("react.lazy"), Mt = Symbol.for("react.activity"), ne = Symbol.for("react.memo_cache_sentinel"), Rt = Symbol.iterator;
  function kt(n) {
    return n === null || typeof n != "object" ? null : (n = Rt && n[Rt] || n["@@iterator"], typeof n == "function" ? n : null);
  }
  var Ee = Symbol.for("react.client.reference");
  function ge(n) {
    if (n == null) return null;
    if (typeof n == "function")
      return n.$$typeof === Ee ? null : n.displayName || n.name || null;
    if (typeof n == "string") return n;
    switch (n) {
      case J:
        return "Fragment";
      case X:
        return "Profiler";
      case Q:
        return "StrictMode";
      case yt:
        return "Suspense";
      case Bt:
        return "SuspenseList";
      case Mt:
        return "Activity";
    }
    if (typeof n == "object")
      switch (n.$$typeof) {
        case j:
          return "Portal";
        case At:
          return (n.displayName || "Context") + ".Provider";
        case wt:
          return (n._context.displayName || "Context") + ".Consumer";
        case Lt:
          var o = n.render;
          return n = n.displayName, n || (n = o.displayName || o.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n;
        case Ct:
          return o = n.displayName || null, o !== null ? o : ge(n.type) || "Memo";
        case Yt:
          o = n._payload, n = n._init;
          try {
            return ge(n(o));
          } catch {
          }
      }
    return null;
  }
  var It = Array.isArray, P = i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, dt = l.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ut = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Gt = [], k = -1;
  function F(n) {
    return { current: n };
  }
  function ct(n) {
    0 > k || (n.current = Gt[k], Gt[k] = null, k--);
  }
  function bt(n, o) {
    k++, Gt[k] = n.current, n.current = o;
  }
  var Et = F(null), zt = F(null), Tt = F(null), We = F(null);
  function $t(n, o) {
    switch (bt(Tt, o), bt(zt, n), bt(Et, null), o.nodeType) {
      case 9:
      case 11:
        n = (n = o.documentElement) && (n = n.namespaceURI) ? Js(n) : 0;
        break;
      default:
        if (n = o.tagName, o = o.namespaceURI)
          o = Js(o), n = $c(o, n);
        else
          switch (n) {
            case "svg":
              n = 1;
              break;
            case "math":
              n = 2;
              break;
            default:
              n = 0;
          }
    }
    ct(Et), bt(Et, n);
  }
  function on() {
    ct(Et), ct(zt), ct(Tt);
  }
  function ci(n) {
    n.memoizedState !== null && bt(We, n);
    var o = Et.current, c = $c(o, n.type);
    o !== c && (bt(zt, n), bt(Et, c));
  }
  function da(n) {
    zt.current === n && (ct(Et), ct(zt)), We.current === n && (ct(We), Na._currentValue = ut);
  }
  var Za = Object.prototype.hasOwnProperty, ma = s.unstable_scheduleCallback, ur = s.unstable_cancelCallback, cr = s.unstable_shouldYield, Tn = s.unstable_requestPaint, En = s.unstable_now, Va = s.unstable_getCurrentPriorityLevel, dc = s.unstable_ImmediatePriority, pe = s.unstable_UserBlockingPriority, pa = s.unstable_NormalPriority, vs = s.unstable_LowPriority, po = s.unstable_IdlePriority, mc = s.log, hu = s.unstable_setDisableYieldValue, go = null, Zn = null;
  function ta(n) {
    if (typeof mc == "function" && hu(n), Zn && typeof Zn.setStrictMode == "function")
      try {
        Zn.setStrictMode(go, n);
      } catch {
      }
  }
  var In = Math.clz32 ? Math.clz32 : hr, _s = Math.log, fr = Math.LN2;
  function hr(n) {
    return n >>>= 0, n === 0 ? 32 : 31 - (_s(n) / fr | 0) | 0;
  }
  var ga = 256, fi = 4194304;
  function Vn(n) {
    var o = n & 42;
    if (o !== 0) return o;
    switch (n & -n) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return n & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return n;
    }
  }
  function Pa(n, o, c) {
    var m = n.pendingLanes;
    if (m === 0) return 0;
    var b = 0, x = n.suspendedLanes, R = n.pingedLanes;
    n = n.warmLanes;
    var U = m & 134217727;
    return U !== 0 ? (m = U & ~x, m !== 0 ? b = Vn(m) : (R &= U, R !== 0 ? b = Vn(R) : c || (c = U & ~n, c !== 0 && (b = Vn(c))))) : (U = m & ~x, U !== 0 ? b = Vn(U) : R !== 0 ? b = Vn(R) : c || (c = m & ~n, c !== 0 && (b = Vn(c)))), b === 0 ? 0 : o !== 0 && o !== b && (o & x) === 0 && (x = b & -b, c = o & -o, x >= c || x === 32 && (c & 4194048) !== 0) ? o : b;
  }
  function N(n, o) {
    return (n.pendingLanes & ~(n.suspendedLanes & ~n.pingedLanes) & o) === 0;
  }
  function $(n, o) {
    switch (n) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return o + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Dt() {
    var n = ga;
    return ga <<= 1, (ga & 4194048) === 0 && (ga = 256), n;
  }
  function Ht() {
    var n = fi;
    return fi <<= 1, (fi & 62914560) === 0 && (fi = 4194304), n;
  }
  function Xt(n) {
    for (var o = [], c = 0; 31 > c; c++) o.push(n);
    return o;
  }
  function se(n, o) {
    n.pendingLanes |= o, o !== 268435456 && (n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0);
  }
  function he(n, o, c, m, b, x) {
    var R = n.pendingLanes;
    n.pendingLanes = c, n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0, n.expiredLanes &= c, n.entangledLanes &= c, n.errorRecoveryDisabledLanes &= c, n.shellSuspendCounter = 0;
    var U = n.entanglements, Z = n.expirationTimes, it = n.hiddenUpdates;
    for (c = R & ~c; 0 < c; ) {
      var vt = 31 - In(c), St = 1 << vt;
      U[vt] = 0, Z[vt] = -1;
      var ot = it[vt];
      if (ot !== null)
        for (it[vt] = null, vt = 0; vt < ot.length; vt++) {
          var st = ot[vt];
          st !== null && (st.lane &= -536870913);
        }
      c &= ~St;
    }
    m !== 0 && ze(n, m, 0), x !== 0 && b === 0 && n.tag !== 0 && (n.suspendedLanes |= x & ~(R & ~o));
  }
  function ze(n, o, c) {
    n.pendingLanes |= o, n.suspendedLanes &= ~o;
    var m = 31 - In(o);
    n.entangledLanes |= o, n.entanglements[m] = n.entanglements[m] | 1073741824 | c & 4194090;
  }
  function fe(n, o) {
    var c = n.entangledLanes |= o;
    for (n = n.entanglements; c; ) {
      var m = 31 - In(c), b = 1 << m;
      b & o | n[m] & o && (n[m] |= o), c &= ~b;
    }
  }
  function On(n) {
    switch (n) {
      case 2:
        n = 1;
        break;
      case 8:
        n = 4;
        break;
      case 32:
        n = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        n = 128;
        break;
      case 268435456:
        n = 134217728;
        break;
      default:
        n = 0;
    }
    return n;
  }
  function Ga(n) {
    return n &= -n, 2 < n ? 8 < n ? (n & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function pc() {
    var n = dt.p;
    return n !== 0 ? n : (n = window.event, n === void 0 ? 32 : ry(n.type));
  }
  function du(n, o) {
    var c = dt.p;
    try {
      return dt.p = n, o();
    } finally {
      dt.p = c;
    }
  }
  var Nn = Math.random().toString(36).slice(2), Pn = "__reactFiber$" + Nn, Mi = "__reactProps$" + Nn, dr = "__reactContainer$" + Nn, ea = "__reactEvents$" + Nn, Wt = "__reactListeners$" + Nn, mu = "__reactHandles$" + Nn, Af = "__reactResources$" + Nn, Vt = "__reactMarker$" + Nn;
  function mr(n) {
    delete n[Pn], delete n[Mi], delete n[ea], delete n[Wt], delete n[mu];
  }
  function Un(n) {
    var o = n[Pn];
    if (o) return o;
    for (var c = n.parentNode; c; ) {
      if (o = c[dr] || c[Pn]) {
        if (c = o.alternate, o.child !== null || c !== null && c.child !== null)
          for (n = ki(n); n !== null; ) {
            if (c = n[Pn]) return c;
            n = ki(n);
          }
        return o;
      }
      n = c, c = n.parentNode;
    }
    return null;
  }
  function bl(n) {
    if (n = n[Pn] || n[dr]) {
      var o = n.tag;
      if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3)
        return n;
    }
    return null;
  }
  function yo(n) {
    var o = n.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return n.stateNode;
    throw Error(u(33));
  }
  function vo(n) {
    var o = n[Af];
    return o || (o = n[Af] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), o;
  }
  function Bn(n) {
    n[Vt] = !0;
  }
  var pu = /* @__PURE__ */ new Set(), na = {};
  function Sl(n, o) {
    Wo(n, o), Wo(n + "Capture", o);
  }
  function Wo(n, o) {
    for (na[n] = o, n = 0; n < o.length; n++)
      pu.add(o[n]);
  }
  var bd = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), bs = {}, Df = {};
  function Sd(n) {
    return Za.call(Df, n) ? !0 : Za.call(bs, n) ? !1 : bd.test(n) ? Df[n] = !0 : (bs[n] = !0, !1);
  }
  function Jo(n, o, c) {
    if (Sd(o))
      if (c === null) n.removeAttribute(o);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
            n.removeAttribute(o);
            return;
          case "boolean":
            var m = o.toLowerCase().slice(0, 5);
            if (m !== "data-" && m !== "aria-") {
              n.removeAttribute(o);
              return;
            }
        }
        n.setAttribute(o, "" + c);
      }
  }
  function gu(n, o, c) {
    if (c === null) n.removeAttribute(o);
    else {
      switch (typeof c) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          n.removeAttribute(o);
          return;
      }
      n.setAttribute(o, "" + c);
    }
  }
  function _o(n, o, c, m) {
    if (m === null) n.removeAttribute(c);
    else {
      switch (typeof m) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          n.removeAttribute(c);
          return;
      }
      n.setAttributeNS(o, c, "" + m);
    }
  }
  var pr, Ss;
  function Tl(n) {
    if (pr === void 0)
      try {
        throw Error();
      } catch (c) {
        var o = c.stack.trim().match(/\n( *(at )?)/);
        pr = o && o[1] || "", Ss = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + pr + n + Ss;
  }
  var hi = !1;
  function ya(n, o) {
    if (!n || hi) return "";
    hi = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var m = {
        DetermineComponentFrameRoot: function() {
          try {
            if (o) {
              var St = function() {
                throw Error();
              };
              if (Object.defineProperty(St.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(St, []);
                } catch (st) {
                  var ot = st;
                }
                Reflect.construct(n, [], St);
              } else {
                try {
                  St.call();
                } catch (st) {
                  ot = st;
                }
                n.call(St.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (st) {
                ot = st;
              }
              (St = n()) && typeof St.catch == "function" && St.catch(function() {
              });
            }
          } catch (st) {
            if (st && ot && typeof st.stack == "string")
              return [st.stack, ot.stack];
          }
          return [null, null];
        }
      };
      m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var b = Object.getOwnPropertyDescriptor(
        m.DetermineComponentFrameRoot,
        "name"
      );
      b && b.configurable && Object.defineProperty(
        m.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var x = m.DetermineComponentFrameRoot(), R = x[0], U = x[1];
      if (R && U) {
        var Z = R.split(`
`), it = U.split(`
`);
        for (b = m = 0; m < Z.length && !Z[m].includes("DetermineComponentFrameRoot"); )
          m++;
        for (; b < it.length && !it[b].includes(
          "DetermineComponentFrameRoot"
        ); )
          b++;
        if (m === Z.length || b === it.length)
          for (m = Z.length - 1, b = it.length - 1; 1 <= m && 0 <= b && Z[m] !== it[b]; )
            b--;
        for (; 1 <= m && 0 <= b; m--, b--)
          if (Z[m] !== it[b]) {
            if (m !== 1 || b !== 1)
              do
                if (m--, b--, 0 > b || Z[m] !== it[b]) {
                  var vt = `
` + Z[m].replace(" at new ", " at ");
                  return n.displayName && vt.includes("<anonymous>") && (vt = vt.replace("<anonymous>", n.displayName)), vt;
                }
              while (1 <= m && 0 <= b);
            break;
          }
      }
    } finally {
      hi = !1, Error.prepareStackTrace = c;
    }
    return (c = n ? n.displayName || n.name : "") ? Tl(c) : "";
  }
  function we(n) {
    switch (n.tag) {
      case 26:
      case 27:
      case 5:
        return Tl(n.type);
      case 16:
        return Tl("Lazy");
      case 13:
        return Tl("Suspense");
      case 19:
        return Tl("SuspenseList");
      case 0:
      case 15:
        return ya(n.type, !1);
      case 11:
        return ya(n.type.render, !1);
      case 1:
        return ya(n.type, !0);
      case 31:
        return Tl("Activity");
      default:
        return "";
    }
  }
  function ln(n) {
    try {
      var o = "";
      do
        o += we(n), n = n.return;
      while (n);
      return o;
    } catch (c) {
      return `
Error generating stack: ` + c.message + `
` + c.stack;
    }
  }
  function Yn(n) {
    switch (typeof n) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return n;
      case "object":
        return n;
      default:
        return "";
    }
  }
  function bo(n) {
    var o = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
  }
  function xl(n) {
    var o = bo(n) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(
      n.constructor.prototype,
      o
    ), m = "" + n[o];
    if (!n.hasOwnProperty(o) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var b = c.get, x = c.set;
      return Object.defineProperty(n, o, {
        configurable: !0,
        get: function() {
          return b.call(this);
        },
        set: function(R) {
          m = "" + R, x.call(this, R);
        }
      }), Object.defineProperty(n, o, {
        enumerable: c.enumerable
      }), {
        getValue: function() {
          return m;
        },
        setValue: function(R) {
          m = "" + R;
        },
        stopTracking: function() {
          n._valueTracker = null, delete n[o];
        }
      };
    }
  }
  function So(n) {
    n._valueTracker || (n._valueTracker = xl(n));
  }
  function le(n) {
    if (!n) return !1;
    var o = n._valueTracker;
    if (!o) return !0;
    var c = o.getValue(), m = "";
    return n && (m = bo(n) ? n.checked ? "true" : "false" : n.value), n = m, n !== c ? (o.setValue(n), !0) : !1;
  }
  function Fe(n) {
    if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null;
    try {
      return n.activeElement || n.body;
    } catch {
      return n.body;
    }
  }
  var Rf = /[\n"\\]/g;
  function Ei(n) {
    return n.replace(
      Rf,
      function(o) {
        return "\\" + o.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Oi(n, o, c, m, b, x, R, U) {
    n.name = "", R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" ? n.type = R : n.removeAttribute("type"), o != null ? R === "number" ? (o === 0 && n.value === "" || n.value != o) && (n.value = "" + Yn(o)) : n.value !== "" + Yn(o) && (n.value = "" + Yn(o)) : R !== "submit" && R !== "reset" || n.removeAttribute("value"), o != null ? wl(n, R, Yn(o)) : c != null ? wl(n, R, Yn(c)) : m != null && n.removeAttribute("value"), b == null && x != null && (n.defaultChecked = !!x), b != null && (n.checked = b && typeof b != "function" && typeof b != "symbol"), U != null && typeof U != "function" && typeof U != "symbol" && typeof U != "boolean" ? n.name = "" + Yn(U) : n.removeAttribute("name");
  }
  function gc(n, o, c, m, b, x, R, U) {
    if (x != null && typeof x != "function" && typeof x != "symbol" && typeof x != "boolean" && (n.type = x), o != null || c != null) {
      if (!(x !== "submit" && x !== "reset" || o != null))
        return;
      c = c != null ? "" + Yn(c) : "", o = o != null ? "" + Yn(o) : c, U || o === n.value || (n.value = o), n.defaultValue = o;
    }
    m = m ?? b, m = typeof m != "function" && typeof m != "symbol" && !!m, n.checked = U ? n.checked : !!m, n.defaultChecked = !!m, R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" && (n.name = R);
  }
  function wl(n, o, c) {
    o === "number" && Fe(n.ownerDocument) === n || n.defaultValue === "" + c || (n.defaultValue = "" + c);
  }
  function ia(n, o, c, m) {
    if (n = n.options, o) {
      o = {};
      for (var b = 0; b < c.length; b++)
        o["$" + c[b]] = !0;
      for (c = 0; c < n.length; c++)
        b = o.hasOwnProperty("$" + n[c].value), n[c].selected !== b && (n[c].selected = b), b && m && (n[c].defaultSelected = !0);
    } else {
      for (c = "" + Yn(c), o = null, b = 0; b < n.length; b++) {
        if (n[b].value === c) {
          n[b].selected = !0, m && (n[b].defaultSelected = !0);
          return;
        }
        o !== null || n[b].disabled || (o = n[b]);
      }
      o !== null && (o.selected = !0);
    }
  }
  function yn(n, o, c) {
    if (o != null && (o = "" + Yn(o), o !== n.value && (n.value = o), c == null)) {
      n.defaultValue !== o && (n.defaultValue = o);
      return;
    }
    n.defaultValue = c != null ? "" + Yn(c) : "";
  }
  function Io(n, o, c, m) {
    if (o == null) {
      if (m != null) {
        if (c != null) throw Error(u(92));
        if (It(m)) {
          if (1 < m.length) throw Error(u(93));
          m = m[0];
        }
        c = m;
      }
      c == null && (c = ""), o = c;
    }
    c = Yn(o), n.defaultValue = c, m = n.textContent, m === c && m !== "" && m !== null && (n.value = m);
  }
  function To(n, o) {
    if (o) {
      var c = n.firstChild;
      if (c && c === n.lastChild && c.nodeType === 3) {
        c.nodeValue = o;
        return;
      }
    }
    n.textContent = o;
  }
  var gr = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function yr(n, o, c) {
    var m = o.indexOf("--") === 0;
    c == null || typeof c == "boolean" || c === "" ? m ? n.setProperty(o, "") : o === "float" ? n.cssFloat = "" : n[o] = "" : m ? n.setProperty(o, c) : typeof c != "number" || c === 0 || gr.has(o) ? o === "float" ? n.cssFloat = c : n[o] = ("" + c).trim() : n[o] = c + "px";
  }
  function $o(n, o, c) {
    if (o != null && typeof o != "object")
      throw Error(u(62));
    if (n = n.style, c != null) {
      for (var m in c)
        !c.hasOwnProperty(m) || o != null && o.hasOwnProperty(m) || (m.indexOf("--") === 0 ? n.setProperty(m, "") : m === "float" ? n.cssFloat = "" : n[m] = "");
      for (var b in o)
        m = o[b], o.hasOwnProperty(b) && c[b] !== m && yr(n, b, m);
    } else
      for (var x in o)
        o.hasOwnProperty(x) && yr(n, x, o[x]);
  }
  function Fo(n) {
    if (n.indexOf("-") === -1) return !1;
    switch (n) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Cf = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), yu = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Ts(n) {
    return yu.test("" + n) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : n;
  }
  var tl = null;
  function xs(n) {
    return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n;
  }
  var ws = null, Ml = null;
  function Td(n) {
    var o = bl(n);
    if (o && (n = o.stateNode)) {
      var c = n[Mi] || null;
      t: switch (n = o.stateNode, o.type) {
        case "input":
          if (Oi(
            n,
            c.value,
            c.defaultValue,
            c.defaultValue,
            c.checked,
            c.defaultChecked,
            c.type,
            c.name
          ), o = c.name, c.type === "radio" && o != null) {
            for (c = n; c.parentNode; ) c = c.parentNode;
            for (c = c.querySelectorAll(
              'input[name="' + Ei(
                "" + o
              ) + '"][type="radio"]'
            ), o = 0; o < c.length; o++) {
              var m = c[o];
              if (m !== n && m.form === n.form) {
                var b = m[Mi] || null;
                if (!b) throw Error(u(90));
                Oi(
                  m,
                  b.value,
                  b.defaultValue,
                  b.defaultValue,
                  b.checked,
                  b.defaultChecked,
                  b.type,
                  b.name
                );
              }
            }
            for (o = 0; o < c.length; o++)
              m = c[o], m.form === n.form && le(m);
          }
          break t;
        case "textarea":
          yn(n, c.value, c.defaultValue);
          break t;
        case "select":
          o = c.value, o != null && ia(n, !!c.multiple, o, !1);
      }
    }
  }
  var ce = !1;
  function Ai(n, o, c) {
    if (ce) return n(o, c);
    ce = !0;
    try {
      var m = n(o);
      return m;
    } finally {
      if (ce = !1, (ws !== null || Ml !== null) && (Zu(), ws && (o = ws, n = Ml, Ml = ws = null, Td(o), n)))
        for (o = 0; o < n.length; o++) Td(n[o]);
    }
  }
  function Ye(n, o) {
    var c = n.stateNode;
    if (c === null) return null;
    var m = c[Mi] || null;
    if (m === null) return null;
    c = m[o];
    t: switch (o) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (m = !m.disabled) || (n = n.type, m = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !m;
        break t;
      default:
        n = !1;
    }
    if (n) return null;
    if (c && typeof c != "function")
      throw Error(
        u(231, o, typeof c)
      );
    return c;
  }
  var Xa = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), vr = !1;
  if (Xa)
    try {
      var Qa = {};
      Object.defineProperty(Qa, "passive", {
        get: function() {
          vr = !0;
        }
      }), window.addEventListener("test", Qa, Qa), window.removeEventListener("test", Qa, Qa);
    } catch {
      vr = !1;
    }
  var Ka = null, va = null, el = null;
  function Ms() {
    if (el) return el;
    var n, o = va, c = o.length, m, b = "value" in Ka ? Ka.value : Ka.textContent, x = b.length;
    for (n = 0; n < c && o[n] === b[n]; n++) ;
    var R = c - n;
    for (m = 1; m <= R && o[c - m] === b[x - m]; m++) ;
    return el = b.slice(n, 1 < m ? 1 - m : void 0);
  }
  function Ue(n) {
    var o = n.keyCode;
    return "charCode" in n ? (n = n.charCode, n === 0 && o === 13 && (n = 13)) : n = o, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0;
  }
  function xo() {
    return !0;
  }
  function vu() {
    return !1;
  }
  function di(n) {
    function o(c, m, b, x, R) {
      this._reactName = c, this._targetInst = b, this.type = m, this.nativeEvent = x, this.target = R, this.currentTarget = null;
      for (var U in n)
        n.hasOwnProperty(U) && (c = n[U], this[U] = c ? c(x) : x[U]);
      return this.isDefaultPrevented = (x.defaultPrevented != null ? x.defaultPrevented : x.returnValue === !1) ? xo : vu, this.isPropagationStopped = vu, this;
    }
    return A(o.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var c = this.nativeEvent;
        c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = xo);
      },
      stopPropagation: function() {
        var c = this.nativeEvent;
        c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = xo);
      },
      persist: function() {
      },
      isPersistent: xo
    }), o;
  }
  var El = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, _u = di(El), Es = A({}, El, { view: 0, detail: 0 }), xd = di(Es), yc, Oe, bu, $n = A({}, Es, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Mo,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
      return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
    },
    movementX: function(n) {
      return "movementX" in n ? n.movementX : (n !== bu && (bu && n.type === "mousemove" ? (yc = n.screenX - bu.screenX, Oe = n.screenY - bu.screenY) : Oe = yc = 0, bu = n), yc);
    },
    movementY: function(n) {
      return "movementY" in n ? n.movementY : Oe;
    }
  }), Os = di($n), zf = A({}, $n, { dataTransfer: 0 }), wd = di(zf), Lf = A({}, Es, { relatedTarget: 0 }), Hf = di(Lf), Md = A({}, El, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Up = di(Md), Bp = A({}, El, {
    clipboardData: function(n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    }
  }), As = di(Bp), Ed = A({}, El, { data: 0 }), _a = di(Ed), Od = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, kf = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, wo = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function Nf(n) {
    var o = this.nativeEvent;
    return o.getModifierState ? o.getModifierState(n) : (n = wo[n]) ? !!o[n] : !1;
  }
  function Mo() {
    return Nf;
  }
  var nl = A({}, Es, {
    key: function(n) {
      if (n.key) {
        var o = Od[n.key] || n.key;
        if (o !== "Unidentified") return o;
      }
      return n.type === "keypress" ? (n = Ue(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? kf[n.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Mo,
    charCode: function(n) {
      return n.type === "keypress" ? Ue(n) : 0;
    },
    keyCode: function(n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function(n) {
      return n.type === "keypress" ? Ue(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    }
  }), Wa = di(nl), ji = A({}, $n, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), _r = di(ji), vc = A({}, Es, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Mo
  }), Uf = di(vc), mi = A({}, El, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Ad = di(mi), Su = A({}, $n, {
    deltaX: function(n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function(n) {
      return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Ol = di(Su), br = A({}, El, {
    newState: 0,
    oldState: 0
  }), Al = di(br), Dd = [9, 13, 27, 32], il = Xa && "CompositionEvent" in window, pi = null;
  Xa && "documentMode" in document && (pi = document.documentMode);
  var _c = Xa && "TextEvent" in window && !pi, Ja = Xa && (!il || pi && 8 < pi && 11 >= pi), Bf = " ", Sr = !1;
  function Ds(n, o) {
    switch (n) {
      case "keyup":
        return Dd.indexOf(o.keyCode) !== -1;
      case "keydown":
        return o.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Dl(n) {
    return n = n.detail, typeof n == "object" && "data" in n ? n.data : null;
  }
  var Rl = !1;
  function bc(n, o) {
    switch (n) {
      case "compositionend":
        return Dl(o);
      case "keypress":
        return o.which !== 32 ? null : (Sr = !0, Bf);
      case "textInput":
        return n = o.data, n === Bf && Sr ? null : n;
      default:
        return null;
    }
  }
  function Rs(n, o) {
    if (Rl)
      return n === "compositionend" || !il && Ds(n, o) ? (n = Ms(), el = va = Ka = null, Rl = !1, n) : null;
    switch (n) {
      case "paste":
        return null;
      case "keypress":
        if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) {
          if (o.char && 1 < o.char.length)
            return o.char;
          if (o.which) return String.fromCharCode(o.which);
        }
        return null;
      case "compositionend":
        return Ja && o.locale !== "ko" ? null : o.data;
      default:
        return null;
    }
  }
  var ba = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function al(n) {
    var o = n && n.nodeName && n.nodeName.toLowerCase();
    return o === "input" ? !!ba[n.type] : o === "textarea";
  }
  function Sc(n, o, c, m) {
    ws ? Ml ? Ml.push(m) : Ml = [m] : ws = m, o = Ic(o, "onChange"), 0 < o.length && (c = new _u(
      "onChange",
      "change",
      null,
      c,
      m
    ), n.push({ event: c, listeners: o }));
  }
  var jn = null, Ia = null;
  function Cl(n) {
    Xu(n, 0);
  }
  function Eo(n) {
    var o = yo(n);
    if (le(o)) return n;
  }
  function Cs(n, o) {
    if (n === "change") return o;
  }
  var Tc = !1;
  if (Xa) {
    var Oo;
    if (Xa) {
      var zs = "oninput" in document;
      if (!zs) {
        var Ao = document.createElement("div");
        Ao.setAttribute("oninput", "return;"), zs = typeof Ao.oninput == "function";
      }
      Oo = zs;
    } else Oo = !1;
    Tc = Oo && (!document.documentMode || 9 < document.documentMode);
  }
  function ol() {
    jn && (jn.detachEvent("onpropertychange", Yf), Ia = jn = null);
  }
  function Yf(n) {
    if (n.propertyName === "value" && Eo(Ia)) {
      var o = [];
      Sc(
        o,
        Ia,
        n,
        xs(n)
      ), Ai(Cl, o);
    }
  }
  function Tr(n, o, c) {
    n === "focusin" ? (ol(), jn = o, Ia = c, jn.attachEvent("onpropertychange", Yf)) : n === "focusout" && ol();
  }
  function zl(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
      return Eo(Ia);
  }
  function Fn(n, o) {
    if (n === "click") return Eo(o);
  }
  function jf(n, o) {
    if (n === "input" || n === "change")
      return Eo(o);
  }
  function Ll(n, o) {
    return n === o && (n !== 0 || 1 / n === 1 / o) || n !== n && o !== o;
  }
  var ti = typeof Object.is == "function" ? Object.is : Ll;
  function gi(n, o) {
    if (ti(n, o)) return !0;
    if (typeof n != "object" || n === null || typeof o != "object" || o === null)
      return !1;
    var c = Object.keys(n), m = Object.keys(o);
    if (c.length !== m.length) return !1;
    for (m = 0; m < c.length; m++) {
      var b = c[m];
      if (!Za.call(o, b) || !ti(n[b], o[b]))
        return !1;
    }
    return !0;
  }
  function $a(n) {
    for (; n && n.firstChild; ) n = n.firstChild;
    return n;
  }
  function tn(n, o) {
    var c = $a(n);
    n = 0;
    for (var m; c; ) {
      if (c.nodeType === 3) {
        if (m = n + c.textContent.length, n <= o && m >= o)
          return { node: c, offset: o - n };
        n = m;
      }
      t: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break t;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = $a(c);
    }
  }
  function Ls(n, o) {
    return n && o ? n === o ? !0 : n && n.nodeType === 3 ? !1 : o && o.nodeType === 3 ? Ls(n, o.parentNode) : "contains" in n ? n.contains(o) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(o) & 16) : !1 : !1;
  }
  function xr(n) {
    n = n != null && n.ownerDocument != null && n.ownerDocument.defaultView != null ? n.ownerDocument.defaultView : window;
    for (var o = Fe(n.document); o instanceof n.HTMLIFrameElement; ) {
      try {
        var c = typeof o.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) n = o.contentWindow;
      else break;
      o = Fe(n.document);
    }
    return o;
  }
  function Hs(n) {
    var o = n && n.nodeName && n.nodeName.toLowerCase();
    return o && (o === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || o === "textarea" || n.contentEditable === "true");
  }
  var Do = Xa && "documentMode" in document && 11 >= document.documentMode, Di = null, qi = null, Ro = null, Hl = !1;
  function xc(n, o, c) {
    var m = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    Hl || Di == null || Di !== Fe(m) || (m = Di, "selectionStart" in m && Hs(m) ? m = { start: m.selectionStart, end: m.selectionEnd } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = {
      anchorNode: m.anchorNode,
      anchorOffset: m.anchorOffset,
      focusNode: m.focusNode,
      focusOffset: m.focusOffset
    }), Ro && gi(Ro, m) || (Ro = m, m = Ic(qi, "onSelect"), 0 < m.length && (o = new _u(
      "onSelect",
      "select",
      null,
      o,
      c
    ), n.push({ event: o, listeners: m }), o.target = Di)));
  }
  function Sa(n, o) {
    var c = {};
    return c[n.toLowerCase()] = o.toLowerCase(), c["Webkit" + n] = "webkit" + o, c["Moz" + n] = "moz" + o, c;
  }
  var ks = {
    animationend: Sa("Animation", "AnimationEnd"),
    animationiteration: Sa("Animation", "AnimationIteration"),
    animationstart: Sa("Animation", "AnimationStart"),
    transitionrun: Sa("Transition", "TransitionRun"),
    transitionstart: Sa("Transition", "TransitionStart"),
    transitioncancel: Sa("Transition", "TransitionCancel"),
    transitionend: Sa("Transition", "TransitionEnd")
  }, aa = {}, Fa = {};
  Xa && (Fa = document.createElement("div").style, "AnimationEvent" in window || (delete ks.animationend.animation, delete ks.animationiteration.animation, delete ks.animationstart.animation), "TransitionEvent" in window || delete ks.transitionend.transition);
  function to(n) {
    if (aa[n]) return aa[n];
    if (!ks[n]) return n;
    var o = ks[n], c;
    for (c in o)
      if (o.hasOwnProperty(c) && c in Fa)
        return aa[n] = o[c];
    return n;
  }
  var Rd = to("animationend"), Ta = to("animationiteration"), Tu = to("animationstart"), qf = to("transitionrun"), Ns = to("transitionstart"), Cd = to("transitioncancel"), wc = to("transitionend"), Zf = /* @__PURE__ */ new Map(), Co = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Co.push("scrollEnd");
  function xa(n, o) {
    Zf.set(n, o), Sl(o, [n]);
  }
  var kl = /* @__PURE__ */ new WeakMap();
  function Zi(n, o) {
    if (typeof n == "object" && n !== null) {
      var c = kl.get(n);
      return c !== void 0 ? c : (o = {
        value: n,
        source: o,
        stack: ln(o)
      }, kl.set(n, o), o);
    }
    return {
      value: n,
      source: o,
      stack: ln(o)
    };
  }
  var Ri = [], Nl = 0, Gn = 0;
  function wa() {
    for (var n = Nl, o = Gn = Nl = 0; o < n; ) {
      var c = Ri[o];
      Ri[o++] = null;
      var m = Ri[o];
      Ri[o++] = null;
      var b = Ri[o];
      Ri[o++] = null;
      var x = Ri[o];
      if (Ri[o++] = null, m !== null && b !== null) {
        var R = m.pending;
        R === null ? b.next = b : (b.next = R.next, R.next = b), m.pending = b;
      }
      x !== 0 && sl(c, b, x);
    }
  }
  function ll(n, o, c, m) {
    Ri[Nl++] = n, Ri[Nl++] = o, Ri[Nl++] = c, Ri[Nl++] = m, Gn |= m, n.lanes |= m, n = n.alternate, n !== null && (n.lanes |= m);
  }
  function zo(n, o, c, m) {
    return ll(n, o, c, m), rl(n);
  }
  function Lo(n, o) {
    return ll(n, null, null, o), rl(n);
  }
  function sl(n, o, c) {
    n.lanes |= c;
    var m = n.alternate;
    m !== null && (m.lanes |= c);
    for (var b = !1, x = n.return; x !== null; )
      x.childLanes |= c, m = x.alternate, m !== null && (m.childLanes |= c), x.tag === 22 && (n = x.stateNode, n === null || n._visibility & 1 || (b = !0)), n = x, x = x.return;
    return n.tag === 3 ? (x = n.stateNode, b && o !== null && (b = 31 - In(c), n = x.hiddenUpdates, m = n[b], m === null ? n[b] = [o] : m.push(o), o.lane = c | 536870912), x) : null;
  }
  function rl(n) {
    if (50 < Gc)
      throw Gc = 0, kg = null, Error(u(185));
    for (var o = n.return; o !== null; )
      n = o, o = n.return;
    return n.tag === 3 ? n.stateNode : null;
  }
  var Us = {};
  function Vf(n, o, c, m) {
    this.tag = n, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = o, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Vi(n, o, c, m) {
    return new Vf(n, o, c, m);
  }
  function wr(n) {
    return n = n.prototype, !(!n || !n.isReactComponent);
  }
  function Ma(n, o) {
    var c = n.alternate;
    return c === null ? (c = Vi(
      n.tag,
      o,
      n.key,
      n.mode
    ), c.elementType = n.elementType, c.type = n.type, c.stateNode = n.stateNode, c.alternate = n, n.alternate = c) : (c.pendingProps = o, c.type = n.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = n.flags & 65011712, c.childLanes = n.childLanes, c.lanes = n.lanes, c.child = n.child, c.memoizedProps = n.memoizedProps, c.memoizedState = n.memoizedState, c.updateQueue = n.updateQueue, o = n.dependencies, c.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }, c.sibling = n.sibling, c.index = n.index, c.ref = n.ref, c.refCleanup = n.refCleanup, c;
  }
  function ye(n, o) {
    n.flags &= 65011714;
    var c = n.alternate;
    return c === null ? (n.childLanes = 0, n.lanes = o, n.child = null, n.subtreeFlags = 0, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null) : (n.childLanes = c.childLanes, n.lanes = c.lanes, n.child = c.child, n.subtreeFlags = 0, n.deletions = null, n.memoizedProps = c.memoizedProps, n.memoizedState = c.memoizedState, n.updateQueue = c.updateQueue, n.type = c.type, o = c.dependencies, n.dependencies = o === null ? null : {
      lanes: o.lanes,
      firstContext: o.firstContext
    }), n;
  }
  function Ot(n, o, c, m, b, x) {
    var R = 0;
    if (m = n, typeof n == "function") wr(n) && (R = 1);
    else if (typeof n == "string")
      R = o_(
        n,
        c,
        Et.current
      ) ? 26 : n === "html" || n === "head" || n === "body" ? 27 : 5;
    else
      t: switch (n) {
        case Mt:
          return n = Vi(31, c, o, b), n.elementType = Mt, n.lanes = x, n;
        case J:
          return oa(c.children, b, x, o);
        case Q:
          R = 8, b |= 24;
          break;
        case X:
          return n = Vi(12, c, o, b | 2), n.elementType = X, n.lanes = x, n;
        case yt:
          return n = Vi(13, c, o, b), n.elementType = yt, n.lanes = x, n;
        case Bt:
          return n = Vi(19, c, o, b), n.elementType = Bt, n.lanes = x, n;
        default:
          if (typeof n == "object" && n !== null)
            switch (n.$$typeof) {
              case et:
              case At:
                R = 10;
                break t;
              case wt:
                R = 9;
                break t;
              case Lt:
                R = 11;
                break t;
              case Ct:
                R = 14;
                break t;
              case Yt:
                R = 16, m = null;
                break t;
            }
          R = 29, c = Error(
            u(130, n === null ? "null" : typeof n, "")
          ), m = null;
      }
    return o = Vi(R, c, o, b), o.elementType = n, o.type = m, o.lanes = x, o;
  }
  function oa(n, o, c, m) {
    return n = Vi(7, n, m, o), n.lanes = c, n;
  }
  function Mr(n, o, c) {
    return n = Vi(6, n, null, o), n.lanes = c, n;
  }
  function cn(n, o, c) {
    return o = Vi(
      4,
      n.children !== null ? n.children : [],
      n.key,
      o
    ), o.lanes = c, o.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation
    }, o;
  }
  var ul = [], Ul = 0, r = null, d = 0, v = [], w = 0, O = null, H = 1, q = "";
  function I(n, o) {
    ul[Ul++] = d, ul[Ul++] = r, r = n, d = o;
  }
  function rt(n, o, c) {
    v[w++] = H, v[w++] = q, v[w++] = O, O = n;
    var m = H;
    n = q;
    var b = 32 - In(m) - 1;
    m &= ~(1 << b), c += 1;
    var x = 32 - In(o) + b;
    if (30 < x) {
      var R = b - b % 5;
      x = (m & (1 << R) - 1).toString(32), m >>= R, b -= R, H = 1 << 32 - In(o) + b | c << b | m, q = x + n;
    } else
      H = 1 << x | c << b | m, q = n;
  }
  function xt(n) {
    n.return !== null && (I(n, 1), rt(n, 1, 0));
  }
  function Nt(n) {
    for (; n === r; )
      r = ul[--Ul], ul[Ul] = null, d = ul[--Ul], ul[Ul] = null;
    for (; n === O; )
      O = v[--w], v[w] = null, q = v[--w], v[w] = null, H = v[--w], v[w] = null;
  }
  var qt = null, Zt = null, oe = !1, Ge = null, dn = !1, An = Error(u(519));
  function Pi(n) {
    var o = Error(u(418, ""));
    throw Ys(Zi(o, n)), An;
  }
  function xu(n) {
    var o = n.stateNode, c = n.type, m = n.memoizedProps;
    switch (o[Pn] = n, o[Mi] = m, c) {
      case "dialog":
        _e("cancel", o), _e("close", o);
        break;
      case "iframe":
      case "object":
      case "embed":
        _e("load", o);
        break;
      case "video":
      case "audio":
        for (c = 0; c < Dh.length; c++)
          _e(Dh[c], o);
        break;
      case "source":
        _e("error", o);
        break;
      case "img":
      case "image":
      case "link":
        _e("error", o), _e("load", o);
        break;
      case "details":
        _e("toggle", o);
        break;
      case "input":
        _e("invalid", o), gc(
          o,
          m.value,
          m.defaultValue,
          m.checked,
          m.defaultChecked,
          m.type,
          m.name,
          !0
        ), So(o);
        break;
      case "select":
        _e("invalid", o);
        break;
      case "textarea":
        _e("invalid", o), Io(o, m.value, m.defaultValue, m.children), So(o);
    }
    c = m.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || o.textContent === "" + c || m.suppressHydrationWarning === !0 || Wg(o.textContent, c) ? (m.popover != null && (_e("beforetoggle", o), _e("toggle", o)), m.onScroll != null && _e("scroll", o), m.onScrollEnd != null && _e("scrollend", o), m.onClick != null && (o.onclick = jm), o = !0) : o = !1, o || Pi(n);
  }
  function Pf(n) {
    for (qt = n.return; qt; )
      switch (qt.tag) {
        case 5:
        case 13:
          dn = !1;
          return;
        case 27:
        case 3:
          dn = !0;
          return;
        default:
          qt = qt.return;
      }
  }
  function Er(n) {
    if (n !== qt) return !1;
    if (!oe) return Pf(n), oe = !0, !1;
    var o = n.tag, c;
    if ((c = o !== 3 && o !== 27) && ((c = o === 5) && (c = n.type, c = !(c !== "form" && c !== "button") || ns(n.type, n.memoizedProps)), c = !c), c && Zt && Pi(n), Pf(n), o === 13) {
      if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(u(317));
      t: {
        for (n = n.nextSibling, o = 0; n; ) {
          if (n.nodeType === 8)
            if (c = n.data, c === "/$") {
              if (o === 0) {
                Zt = pl(n.nextSibling);
                break t;
              }
              o--;
            } else
              c !== "$" && c !== "$!" && c !== "$?" || o++;
          n = n.nextSibling;
        }
        Zt = null;
      }
    } else
      o === 27 ? (o = Zt, Xr(n.type) ? (n = Qr, Qr = null, Zt = n) : Zt = o) : Zt = qt ? pl(n.stateNode.nextSibling) : null;
    return !0;
  }
  function Bs() {
    Zt = qt = null, oe = !1;
  }
  function Gf() {
    var n = Ge;
    return n !== null && (za === null ? za = n : za.push.apply(
      za,
      n
    ), Ge = null), n;
  }
  function Ys(n) {
    Ge === null ? Ge = [n] : Ge.push(n);
  }
  var fn = F(null), Ea = null, eo = null;
  function cl(n, o, c) {
    bt(fn, o._currentValue), o._currentValue = c;
  }
  function Ho(n) {
    n._currentValue = fn.current, ct(fn);
  }
  function Or(n, o, c) {
    for (; n !== null; ) {
      var m = n.alternate;
      if ((n.childLanes & o) !== o ? (n.childLanes |= o, m !== null && (m.childLanes |= o)) : m !== null && (m.childLanes & o) !== o && (m.childLanes |= o), n === c) break;
      n = n.return;
    }
  }
  function Mc(n, o, c, m) {
    var b = n.child;
    for (b !== null && (b.return = n); b !== null; ) {
      var x = b.dependencies;
      if (x !== null) {
        var R = b.child;
        x = x.firstContext;
        t: for (; x !== null; ) {
          var U = x;
          x = b;
          for (var Z = 0; Z < o.length; Z++)
            if (U.context === o[Z]) {
              x.lanes |= c, U = x.alternate, U !== null && (U.lanes |= c), Or(
                x.return,
                c,
                n
              ), m || (R = null);
              break t;
            }
          x = U.next;
        }
      } else if (b.tag === 18) {
        if (R = b.return, R === null) throw Error(u(341));
        R.lanes |= c, x = R.alternate, x !== null && (x.lanes |= c), Or(R, c, n), R = null;
      } else R = b.child;
      if (R !== null) R.return = b;
      else
        for (R = b; R !== null; ) {
          if (R === n) {
            R = null;
            break;
          }
          if (b = R.sibling, b !== null) {
            b.return = R.return, R = b;
            break;
          }
          R = R.return;
        }
      b = R;
    }
  }
  function Ar(n, o, c, m) {
    n = null;
    for (var b = o, x = !1; b !== null; ) {
      if (!x) {
        if ((b.flags & 524288) !== 0) x = !0;
        else if ((b.flags & 262144) !== 0) break;
      }
      if (b.tag === 10) {
        var R = b.alternate;
        if (R === null) throw Error(u(387));
        if (R = R.memoizedProps, R !== null) {
          var U = b.type;
          ti(b.pendingProps.value, R.value) || (n !== null ? n.push(U) : n = [U]);
        }
      } else if (b === We.current) {
        if (R = b.alternate, R === null) throw Error(u(387));
        R.memoizedState.memoizedState !== b.memoizedState.memoizedState && (n !== null ? n.push(Na) : n = [Na]);
      }
      b = b.return;
    }
    n !== null && Mc(
      o,
      n,
      c,
      m
    ), o.flags |= 262144;
  }
  function Xf(n) {
    for (n = n.firstContext; n !== null; ) {
      if (!ti(
        n.context._currentValue,
        n.memoizedValue
      ))
        return !0;
      n = n.next;
    }
    return !1;
  }
  function Dr(n) {
    Ea = n, eo = null, n = n.dependencies, n !== null && (n.firstContext = null);
  }
  function yi(n) {
    return Yp(Ea, n);
  }
  function Qf(n, o) {
    return Ea === null && Dr(n), Yp(n, o);
  }
  function Yp(n, o) {
    var c = o._currentValue;
    if (o = { context: o, memoizedValue: c, next: null }, eo === null) {
      if (n === null) throw Error(u(308));
      eo = o, n.dependencies = { lanes: 0, firstContext: o }, n.flags |= 524288;
    } else eo = eo.next = o;
    return c;
  }
  var Ec = typeof AbortController < "u" ? AbortController : function() {
    var n = [], o = this.signal = {
      aborted: !1,
      addEventListener: function(c, m) {
        n.push(m);
      }
    };
    this.abort = function() {
      o.aborted = !0, n.forEach(function(c) {
        return c();
      });
    };
  }, zd = s.unstable_scheduleCallback, Ev = s.unstable_NormalPriority, ei = {
    $$typeof: At,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Oc() {
    return {
      controller: new Ec(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Bl(n) {
    n.refCount--, n.refCount === 0 && zd(Ev, function() {
      n.controller.abort();
    });
  }
  var Rr = null, Kf = 0, ko = 0, ni = null;
  function Ld(n, o) {
    if (Rr === null) {
      var c = Rr = [];
      Kf = 0, ko = Gu(), ni = {
        status: "pending",
        value: void 0,
        then: function(m) {
          c.push(m);
        }
      };
    }
    return Kf++, o.then(Hd, Hd), o;
  }
  function Hd() {
    if (--Kf === 0 && Rr !== null) {
      ni !== null && (ni.status = "fulfilled");
      var n = Rr;
      Rr = null, ko = 0, ni = null;
      for (var o = 0; o < n.length; o++) (0, n[o])();
    }
  }
  function Ov(n, o) {
    var c = [], m = {
      status: "pending",
      value: null,
      reason: null,
      then: function(b) {
        c.push(b);
      }
    };
    return n.then(
      function() {
        m.status = "fulfilled", m.value = o;
        for (var b = 0; b < c.length; b++) (0, c[b])(o);
      },
      function(b) {
        for (m.status = "rejected", m.reason = b, b = 0; b < c.length; b++)
          (0, c[b])(void 0);
      }
    ), m;
  }
  var kd = P.S;
  P.S = function(n, o) {
    typeof o == "object" && o !== null && typeof o.then == "function" && Ld(n, o), kd !== null && kd(n, o);
  };
  var Yl = F(null);
  function Wf() {
    var n = Yl.current;
    return n !== null ? n : sn.pooledCache;
  }
  function wu(n, o) {
    o === null ? bt(Yl, Yl.current) : bt(Yl, o.pool);
  }
  function Nd() {
    var n = Wf();
    return n === null ? null : { parent: ei._currentValue, pool: n };
  }
  var Cr = Error(u(460)), Ud = Error(u(474)), Jf = Error(u(542)), Bd = { then: function() {
  } };
  function Yd(n) {
    return n = n.status, n === "fulfilled" || n === "rejected";
  }
  function If() {
  }
  function jp(n, o, c) {
    switch (c = n[c], c === void 0 ? n.push(o) : c !== o && (o.then(If, If), o = c), o.status) {
      case "fulfilled":
        return o.value;
      case "rejected":
        throw n = o.reason, Zp(n), n;
      default:
        if (typeof o.status == "string") o.then(If, If);
        else {
          if (n = sn, n !== null && 100 < n.shellSuspendCounter)
            throw Error(u(482));
          n = o, n.status = "pending", n.then(
            function(m) {
              if (o.status === "pending") {
                var b = o;
                b.status = "fulfilled", b.value = m;
              }
            },
            function(m) {
              if (o.status === "pending") {
                var b = o;
                b.status = "rejected", b.reason = m;
              }
            }
          );
        }
        switch (o.status) {
          case "fulfilled":
            return o.value;
          case "rejected":
            throw n = o.reason, Zp(n), n;
        }
        throw Mu = o, Cr;
    }
  }
  var Mu = null;
  function qp() {
    if (Mu === null) throw Error(u(459));
    var n = Mu;
    return Mu = null, n;
  }
  function Zp(n) {
    if (n === Cr || n === Jf)
      throw Error(u(483));
  }
  var jl = !1;
  function jd(n) {
    n.updateQueue = {
      baseState: n.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function qd(n, o) {
    n = n.updateQueue, o.updateQueue === n && (o.updateQueue = {
      baseState: n.baseState,
      firstBaseUpdate: n.firstBaseUpdate,
      lastBaseUpdate: n.lastBaseUpdate,
      shared: n.shared,
      callbacks: null
    });
  }
  function Oa(n) {
    return { lane: n, tag: 0, payload: null, callback: null, next: null };
  }
  function ql(n, o, c) {
    var m = n.updateQueue;
    if (m === null) return null;
    if (m = m.shared, (Qe & 2) !== 0) {
      var b = m.pending;
      return b === null ? o.next = o : (o.next = b.next, b.next = o), m.pending = o, o = rl(n), sl(n, null, c), o;
    }
    return ll(n, m, o, c), rl(n);
  }
  function Eu(n, o, c) {
    if (o = o.updateQueue, o !== null && (o = o.shared, (c & 4194048) !== 0)) {
      var m = o.lanes;
      m &= n.pendingLanes, c |= m, o.lanes = c, fe(n, c);
    }
  }
  function Vp(n, o) {
    var c = n.updateQueue, m = n.alternate;
    if (m !== null && (m = m.updateQueue, c === m)) {
      var b = null, x = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var R = {
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: null,
            next: null
          };
          x === null ? b = x = R : x = x.next = R, c = c.next;
        } while (c !== null);
        x === null ? b = x = o : x = x.next = o;
      } else b = x = o;
      c = {
        baseState: m.baseState,
        firstBaseUpdate: b,
        lastBaseUpdate: x,
        shared: m.shared,
        callbacks: m.callbacks
      }, n.updateQueue = c;
      return;
    }
    n = c.lastBaseUpdate, n === null ? c.firstBaseUpdate = o : n.next = o, c.lastBaseUpdate = o;
  }
  var Pp = !1;
  function Ac() {
    if (Pp) {
      var n = ni;
      if (n !== null) throw n;
    }
  }
  function js(n, o, c, m) {
    Pp = !1;
    var b = n.updateQueue;
    jl = !1;
    var x = b.firstBaseUpdate, R = b.lastBaseUpdate, U = b.shared.pending;
    if (U !== null) {
      b.shared.pending = null;
      var Z = U, it = Z.next;
      Z.next = null, R === null ? x = it : R.next = it, R = Z;
      var vt = n.alternate;
      vt !== null && (vt = vt.updateQueue, U = vt.lastBaseUpdate, U !== R && (U === null ? vt.firstBaseUpdate = it : U.next = it, vt.lastBaseUpdate = Z));
    }
    if (x !== null) {
      var St = b.baseState;
      R = 0, vt = it = Z = null, U = x;
      do {
        var ot = U.lane & -536870913, st = ot !== U.lane;
        if (st ? (He & ot) === ot : (m & ot) === ot) {
          ot !== 0 && ot === ko && (Pp = !0), vt !== null && (vt = vt.next = {
            lane: 0,
            tag: U.tag,
            payload: U.payload,
            callback: null,
            next: null
          });
          t: {
            var Ft = n, te = U;
            ot = o;
            var Ze = c;
            switch (te.tag) {
              case 1:
                if (Ft = te.payload, typeof Ft == "function") {
                  St = Ft.call(Ze, St, ot);
                  break t;
                }
                St = Ft;
                break t;
              case 3:
                Ft.flags = Ft.flags & -65537 | 128;
              case 0:
                if (Ft = te.payload, ot = typeof Ft == "function" ? Ft.call(Ze, St, ot) : Ft, ot == null) break t;
                St = A({}, St, ot);
                break t;
              case 2:
                jl = !0;
            }
          }
          ot = U.callback, ot !== null && (n.flags |= 64, st && (n.flags |= 8192), st = b.callbacks, st === null ? b.callbacks = [ot] : st.push(ot));
        } else
          st = {
            lane: ot,
            tag: U.tag,
            payload: U.payload,
            callback: U.callback,
            next: null
          }, vt === null ? (it = vt = st, Z = St) : vt = vt.next = st, R |= ot;
        if (U = U.next, U === null) {
          if (U = b.shared.pending, U === null)
            break;
          st = U, U = st.next, st.next = null, b.lastBaseUpdate = st, b.shared.pending = null;
        }
      } while (!0);
      vt === null && (Z = St), b.baseState = Z, b.firstBaseUpdate = it, b.lastBaseUpdate = vt, x === null && (b.shared.lanes = 0), Qs |= R, n.lanes = R, n.memoizedState = St;
    }
  }
  function Zd(n, o) {
    if (typeof n != "function")
      throw Error(u(191, n));
    n.call(o);
  }
  function $f(n, o) {
    var c = n.callbacks;
    if (c !== null)
      for (n.callbacks = null, n = 0; n < c.length; n++)
        Zd(c[n], o);
  }
  var Ou = F(null), Ff = F(0);
  function vi(n, o) {
    n = Xs, bt(Ff, n), bt(Ou, o), Xs = n | o.baseLanes;
  }
  function Dc() {
    bt(Ff, Xs), bt(Ou, Ou.current);
  }
  function Rc() {
    Xs = Ff.current, ct(Ou), ct(Ff);
  }
  var No = 0, ve = null, Xe = null, xn = null, th = !1, no = !1, zr = !1, fl = 0, io = 0, qs = null, Gp = 0;
  function wn() {
    throw Error(u(321));
  }
  function Vd(n, o) {
    if (o === null) return !1;
    for (var c = 0; c < o.length && c < n.length; c++)
      if (!ti(n[c], o[c])) return !1;
    return !0;
  }
  function Pd(n, o, c, m, b, x) {
    return No = x, ve = o, o.memoizedState = null, o.updateQueue = null, o.lanes = 0, P.H = n === null || n.memoizedState === null ? lg : sg, zr = !1, x = c(m, b), zr = !1, no && (x = Xp(
      o,
      c,
      m,
      b
    )), Lr(n), x;
  }
  function Lr(n) {
    P.H = sm;
    var o = Xe !== null && Xe.next !== null;
    if (No = 0, xn = Xe = ve = null, th = !1, io = 0, qs = null, o) throw Error(u(300));
    n === null || ii || (n = n.dependencies, n !== null && Xf(n) && (ii = !0));
  }
  function Xp(n, o, c, m) {
    ve = n;
    var b = 0;
    do {
      if (no && (qs = null), io = 0, no = !1, 25 <= b) throw Error(u(301));
      if (b += 1, xn = Xe = null, n.updateQueue != null) {
        var x = n.updateQueue;
        x.lastEffect = null, x.events = null, x.stores = null, x.memoCache != null && (x.memoCache.index = 0);
      }
      P.H = Zs, x = o(c, m);
    } while (no);
    return x;
  }
  function Av() {
    var n = P.H, o = n.useState()[0];
    return o = typeof o.then == "function" ? nh(o) : o, n = n.useState()[0], (Xe !== null ? Xe.memoizedState : null) !== n && (ve.flags |= 1024), o;
  }
  function Gd() {
    var n = fl !== 0;
    return fl = 0, n;
  }
  function Cc(n, o, c) {
    o.updateQueue = n.updateQueue, o.flags &= -2053, n.lanes &= ~c;
  }
  function Xd(n) {
    if (th) {
      for (n = n.memoizedState; n !== null; ) {
        var o = n.queue;
        o !== null && (o.pending = null), n = n.next;
      }
      th = !1;
    }
    No = 0, xn = Xe = ve = null, no = !1, io = fl = 0, qs = null;
  }
  function Gi() {
    var n = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return xn === null ? ve.memoizedState = xn = n : xn = xn.next = n, xn;
  }
  function Dn() {
    if (Xe === null) {
      var n = ve.alternate;
      n = n !== null ? n.memoizedState : null;
    } else n = Xe.next;
    var o = xn === null ? ve.memoizedState : xn.next;
    if (o !== null)
      xn = o, Xe = n;
    else {
      if (n === null)
        throw ve.alternate === null ? Error(u(467)) : Error(u(310));
      Xe = n, n = {
        memoizedState: Xe.memoizedState,
        baseState: Xe.baseState,
        baseQueue: Xe.baseQueue,
        queue: Xe.queue,
        next: null
      }, xn === null ? ve.memoizedState = xn = n : xn = xn.next = n;
    }
    return xn;
  }
  function eh() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function nh(n) {
    var o = io;
    return io += 1, qs === null && (qs = []), n = jp(qs, n, o), o = ve, (xn === null ? o.memoizedState : xn.next) === null && (o = o.alternate, P.H = o === null || o.memoizedState === null ? lg : sg), n;
  }
  function Xn(n) {
    if (n !== null && typeof n == "object") {
      if (typeof n.then == "function") return nh(n);
      if (n.$$typeof === At) return yi(n);
    }
    throw Error(u(438, String(n)));
  }
  function Qd(n) {
    var o = null, c = ve.updateQueue;
    if (c !== null && (o = c.memoCache), o == null) {
      var m = ve.alternate;
      m !== null && (m = m.updateQueue, m !== null && (m = m.memoCache, m != null && (o = {
        data: m.data.map(function(b) {
          return b.slice();
        }),
        index: 0
      })));
    }
    if (o == null && (o = { data: [], index: 0 }), c === null && (c = eh(), ve.updateQueue = c), c.memoCache = o, c = o.data[o.index], c === void 0)
      for (c = o.data[o.index] = Array(n), m = 0; m < n; m++)
        c[m] = ne;
    return o.index++, c;
  }
  function Zl(n, o) {
    return typeof o == "function" ? o(n) : o;
  }
  function ih(n) {
    var o = Dn();
    return Kd(o, Xe, n);
  }
  function Kd(n, o, c) {
    var m = n.queue;
    if (m === null) throw Error(u(311));
    m.lastRenderedReducer = c;
    var b = n.baseQueue, x = m.pending;
    if (x !== null) {
      if (b !== null) {
        var R = b.next;
        b.next = x.next, x.next = R;
      }
      o.baseQueue = b = x, m.pending = null;
    }
    if (x = n.baseState, b === null) n.memoizedState = x;
    else {
      o = b.next;
      var U = R = null, Z = null, it = o, vt = !1;
      do {
        var St = it.lane & -536870913;
        if (St !== it.lane ? (He & St) === St : (No & St) === St) {
          var ot = it.revertLane;
          if (ot === 0)
            Z !== null && (Z = Z.next = {
              lane: 0,
              revertLane: 0,
              action: it.action,
              hasEagerState: it.hasEagerState,
              eagerState: it.eagerState,
              next: null
            }), St === ko && (vt = !0);
          else if ((No & ot) === ot) {
            it = it.next, ot === ko && (vt = !0);
            continue;
          } else
            St = {
              lane: 0,
              revertLane: it.revertLane,
              action: it.action,
              hasEagerState: it.hasEagerState,
              eagerState: it.eagerState,
              next: null
            }, Z === null ? (U = Z = St, R = x) : Z = Z.next = St, ve.lanes |= ot, Qs |= ot;
          St = it.action, zr && c(x, St), x = it.hasEagerState ? it.eagerState : c(x, St);
        } else
          ot = {
            lane: St,
            revertLane: it.revertLane,
            action: it.action,
            hasEagerState: it.hasEagerState,
            eagerState: it.eagerState,
            next: null
          }, Z === null ? (U = Z = ot, R = x) : Z = Z.next = ot, ve.lanes |= St, Qs |= St;
        it = it.next;
      } while (it !== null && it !== o);
      if (Z === null ? R = x : Z.next = U, !ti(x, n.memoizedState) && (ii = !0, vt && (c = ni, c !== null)))
        throw c;
      n.memoizedState = x, n.baseState = R, n.baseQueue = Z, m.lastRenderedState = x;
    }
    return b === null && (m.lanes = 0), [n.memoizedState, m.dispatch];
  }
  function Wd(n) {
    var o = Dn(), c = o.queue;
    if (c === null) throw Error(u(311));
    c.lastRenderedReducer = n;
    var m = c.dispatch, b = c.pending, x = o.memoizedState;
    if (b !== null) {
      c.pending = null;
      var R = b = b.next;
      do
        x = n(x, R.action), R = R.next;
      while (R !== b);
      ti(x, o.memoizedState) || (ii = !0), o.memoizedState = x, o.baseQueue === null && (o.baseState = x), c.lastRenderedState = x;
    }
    return [x, m];
  }
  function ah(n, o, c) {
    var m = ve, b = Dn(), x = oe;
    if (x) {
      if (c === void 0) throw Error(u(407));
      c = c();
    } else c = o();
    var R = !ti(
      (Xe || b).memoizedState,
      c
    );
    R && (b.memoizedState = c, ii = !0), b = b.queue;
    var U = Kp.bind(null, m, b, n);
    if (en(2048, 8, U, [n]), b.getSnapshot !== o || R || xn !== null && xn.memoizedState.tag & 1) {
      if (m.flags |= 2048, Aa(
        9,
        sh(),
        Qp.bind(
          null,
          m,
          b,
          c,
          o
        ),
        null
      ), sn === null) throw Error(u(349));
      x || (No & 124) !== 0 || Jd(m, o, c);
    }
    return c;
  }
  function Jd(n, o, c) {
    n.flags |= 16384, n = { getSnapshot: o, value: c }, o = ve.updateQueue, o === null ? (o = eh(), ve.updateQueue = o, o.stores = [n]) : (c = o.stores, c === null ? o.stores = [n] : c.push(n));
  }
  function Qp(n, o, c, m) {
    o.value = c, o.getSnapshot = m, Wp(o) && Id(n);
  }
  function Kp(n, o, c) {
    return c(function() {
      Wp(o) && Id(n);
    });
  }
  function Wp(n) {
    var o = n.getSnapshot;
    n = n.value;
    try {
      var c = o();
      return !ti(n, c);
    } catch {
      return !0;
    }
  }
  function Id(n) {
    var o = Lo(n, 2);
    o !== null && lo(o, n, 2);
  }
  function oh(n) {
    var o = Gi();
    if (typeof n == "function") {
      var c = n;
      if (n = c(), zr) {
        ta(!0);
        try {
          c();
        } finally {
          ta(!1);
        }
      }
    }
    return o.memoizedState = o.baseState = n, o.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Zl,
      lastRenderedState: n
    }, o;
  }
  function $d(n, o, c, m) {
    return n.baseState = c, Kd(
      n,
      Xe,
      typeof m == "function" ? m : Zl
    );
  }
  function Dv(n, o, c, m, b) {
    if (Cu(n)) throw Error(u(485));
    if (n = o.action, n !== null) {
      var x = {
        payload: b,
        action: n,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(R) {
          x.listeners.push(R);
        }
      };
      P.T !== null ? c(!0) : x.isTransition = !1, m(x), c = o.pending, c === null ? (x.next = o.pending = x, Fd(o, x)) : (x.next = c.next, o.pending = c.next = x);
    }
  }
  function Fd(n, o) {
    var c = o.action, m = o.payload, b = n.state;
    if (o.isTransition) {
      var x = P.T, R = {};
      P.T = R;
      try {
        var U = c(b, m), Z = P.S;
        Z !== null && Z(R, U), lh(n, o, U);
      } catch (it) {
        em(n, o, it);
      } finally {
        P.T = x;
      }
    } else
      try {
        x = c(b, m), lh(n, o, x);
      } catch (it) {
        em(n, o, it);
      }
  }
  function lh(n, o, c) {
    c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(
      function(m) {
        tm(n, o, m);
      },
      function(m) {
        return em(n, o, m);
      }
    ) : tm(n, o, c);
  }
  function tm(n, o, c) {
    o.status = "fulfilled", o.value = c, Jp(o), n.state = c, o = n.pending, o !== null && (c = o.next, c === o ? n.pending = null : (c = c.next, o.next = c, Fd(n, c)));
  }
  function em(n, o, c) {
    var m = n.pending;
    if (n.pending = null, m !== null) {
      m = m.next;
      do
        o.status = "rejected", o.reason = c, Jp(o), o = o.next;
      while (o !== m);
    }
    n.action = null;
  }
  function Jp(n) {
    n = n.listeners;
    for (var o = 0; o < n.length; o++) (0, n[o])();
  }
  function nm(n, o) {
    return o;
  }
  function Ip(n, o) {
    if (oe) {
      var c = sn.formState;
      if (c !== null) {
        t: {
          var m = ve;
          if (oe) {
            if (Zt) {
              e: {
                for (var b = Zt, x = dn; b.nodeType !== 8; ) {
                  if (!x) {
                    b = null;
                    break e;
                  }
                  if (b = pl(
                    b.nextSibling
                  ), b === null) {
                    b = null;
                    break e;
                  }
                }
                x = b.data, b = x === "F!" || x === "F" ? b : null;
              }
              if (b) {
                Zt = pl(
                  b.nextSibling
                ), m = b.data === "F!";
                break t;
              }
            }
            Pi(m);
          }
          m = !1;
        }
        m && (o = c[0]);
      }
    }
    return c = Gi(), c.memoizedState = c.baseState = o, m = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: nm,
      lastRenderedState: o
    }, c.queue = m, c = ag.bind(
      null,
      ve,
      m
    ), m.dispatch = c, m = oh(!1), x = ch.bind(
      null,
      ve,
      !1,
      m.queue
    ), m = Gi(), b = {
      state: o,
      dispatch: null,
      action: n,
      pending: null
    }, m.queue = b, c = Dv.bind(
      null,
      ve,
      b,
      x,
      c
    ), b.dispatch = c, m.memoizedState = n, [o, c, !1];
  }
  function Vl(n) {
    var o = Dn();
    return im(o, Xe, n);
  }
  function im(n, o, c) {
    if (o = Kd(
      n,
      o,
      nm
    )[0], n = ih(Zl)[0], typeof o == "object" && o !== null && typeof o.then == "function")
      try {
        var m = nh(o);
      } catch (R) {
        throw R === Cr ? Jf : R;
      }
    else m = o;
    o = Dn();
    var b = o.queue, x = b.dispatch;
    return c !== o.memoizedState && (ve.flags |= 2048, Aa(
      9,
      sh(),
      L0.bind(null, b, c),
      null
    )), [m, x, n];
  }
  function L0(n, o) {
    n.action = o;
  }
  function am(n) {
    var o = Dn(), c = Xe;
    if (c !== null)
      return im(o, c, n);
    Dn(), o = o.memoizedState, c = Dn();
    var m = c.queue.dispatch;
    return c.memoizedState = n, [o, m, !1];
  }
  function Aa(n, o, c, m) {
    return n = { tag: n, create: c, deps: m, inst: o, next: null }, o = ve.updateQueue, o === null && (o = eh(), ve.updateQueue = o), c = o.lastEffect, c === null ? o.lastEffect = n.next = n : (m = c.next, c.next = n, n.next = m, o.lastEffect = n), n;
  }
  function sh() {
    return { destroy: void 0, resource: void 0 };
  }
  function rh() {
    return Dn().memoizedState;
  }
  function Hr(n, o, c, m) {
    var b = Gi();
    m = m === void 0 ? null : m, ve.flags |= n, b.memoizedState = Aa(
      1 | o,
      sh(),
      c,
      m
    );
  }
  function en(n, o, c, m) {
    var b = Dn();
    m = m === void 0 ? null : m;
    var x = b.memoizedState.inst;
    Xe !== null && m !== null && Vd(m, Xe.memoizedState.deps) ? b.memoizedState = Aa(o, x, c, m) : (ve.flags |= n, b.memoizedState = Aa(
      1 | o,
      x,
      c,
      m
    ));
  }
  function Rv(n, o) {
    Hr(8390656, 8, n, o);
  }
  function Cv(n, o) {
    en(2048, 8, n, o);
  }
  function $p(n, o) {
    return en(4, 2, n, o);
  }
  function hl(n, o) {
    return en(4, 4, n, o);
  }
  function Fp(n, o) {
    if (typeof o == "function") {
      n = n();
      var c = o(n);
      return function() {
        typeof c == "function" ? c() : o(null);
      };
    }
    if (o != null)
      return n = n(), o.current = n, function() {
        o.current = null;
      };
  }
  function om(n, o, c) {
    c = c != null ? c.concat([n]) : null, en(4, 4, Fp.bind(null, o, n), c);
  }
  function Au() {
  }
  function Du(n, o) {
    var c = Dn();
    o = o === void 0 ? null : o;
    var m = c.memoizedState;
    return o !== null && Vd(o, m[1]) ? m[0] : (c.memoizedState = [n, o], n);
  }
  function tg(n, o) {
    var c = Dn();
    o = o === void 0 ? null : o;
    var m = c.memoizedState;
    if (o !== null && Vd(o, m[1]))
      return m[0];
    if (m = n(), zr) {
      ta(!0);
      try {
        n();
      } finally {
        ta(!1);
      }
    }
    return c.memoizedState = [m, o], m;
  }
  function uh(n, o, c) {
    return c === void 0 || (No & 1073741824) !== 0 ? n.memoizedState = o : (n.memoizedState = c, n = Ng(), ve.lanes |= n, Qs |= n, c);
  }
  function eg(n, o, c, m) {
    return ti(c, o) ? c : Ou.current !== null ? (n = uh(n, c, m), ti(n, o) || (ii = !0), n) : (No & 42) === 0 ? (ii = !0, n.memoizedState = c) : (n = Ng(), ve.lanes |= n, Qs |= n, o);
  }
  function zv(n, o, c, m, b) {
    var x = dt.p;
    dt.p = x !== 0 && 8 > x ? x : 8;
    var R = P.T, U = {};
    P.T = U, ch(n, !1, o, c);
    try {
      var Z = b(), it = P.S;
      if (it !== null && it(U, Z), Z !== null && typeof Z == "object" && typeof Z.then == "function") {
        var vt = Ov(
          Z,
          m
        );
        Ru(
          n,
          o,
          vt,
          oo(n)
        );
      } else
        Ru(
          n,
          o,
          m,
          oo(n)
        );
    } catch (St) {
      Ru(
        n,
        o,
        { then: function() {
        }, status: "rejected", reason: St },
        oo()
      );
    } finally {
      dt.p = x, P.T = R;
    }
  }
  function H0() {
  }
  function lm(n, o, c, m) {
    if (n.tag !== 5) throw Error(u(476));
    var b = Lv(n).queue;
    zv(
      n,
      b,
      o,
      ut,
      c === null ? H0 : function() {
        return zc(n), c(m);
      }
    );
  }
  function Lv(n) {
    var o = n.memoizedState;
    if (o !== null) return o;
    o = {
      memoizedState: ut,
      baseState: ut,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Zl,
        lastRenderedState: ut
      },
      next: null
    };
    var c = {};
    return o.next = {
      memoizedState: c,
      baseState: c,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Zl,
        lastRenderedState: c
      },
      next: null
    }, n.memoizedState = o, n = n.alternate, n !== null && (n.memoizedState = o), o;
  }
  function zc(n) {
    var o = Lv(n).next.queue;
    Ru(n, o, {}, oo());
  }
  function Uo() {
    return yi(Na);
  }
  function ng() {
    return Dn().memoizedState;
  }
  function Hv() {
    return Dn().memoizedState;
  }
  function kv(n) {
    for (var o = n.return; o !== null; ) {
      switch (o.tag) {
        case 24:
        case 3:
          var c = oo();
          n = Oa(c);
          var m = ql(o, n, c);
          m !== null && (lo(m, o, c), Eu(m, o, c)), o = { cache: Oc() }, n.payload = o;
          return;
      }
      o = o.return;
    }
  }
  function ig(n, o, c) {
    var m = oo();
    c = {
      lane: m,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Cu(n) ? Nv(o, c) : (c = zo(n, o, c, m), c !== null && (lo(c, n, m), og(c, o, m)));
  }
  function ag(n, o, c) {
    var m = oo();
    Ru(n, o, c, m);
  }
  function Ru(n, o, c, m) {
    var b = {
      lane: m,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Cu(n)) Nv(o, b);
    else {
      var x = n.alternate;
      if (n.lanes === 0 && (x === null || x.lanes === 0) && (x = o.lastRenderedReducer, x !== null))
        try {
          var R = o.lastRenderedState, U = x(R, c);
          if (b.hasEagerState = !0, b.eagerState = U, ti(U, R))
            return ll(n, o, b, 0), sn === null && wa(), !1;
        } catch {
        } finally {
        }
      if (c = zo(n, o, b, m), c !== null)
        return lo(c, n, m), og(c, o, m), !0;
    }
    return !1;
  }
  function ch(n, o, c, m) {
    if (m = {
      lane: 2,
      revertLane: Gu(),
      action: m,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Cu(n)) {
      if (o) throw Error(u(479));
    } else
      o = zo(
        n,
        c,
        m,
        2
      ), o !== null && lo(o, n, 2);
  }
  function Cu(n) {
    var o = n.alternate;
    return n === ve || o !== null && o === ve;
  }
  function Nv(n, o) {
    no = th = !0;
    var c = n.pending;
    c === null ? o.next = o : (o.next = c.next, c.next = o), n.pending = o;
  }
  function og(n, o, c) {
    if ((c & 4194048) !== 0) {
      var m = o.lanes;
      m &= n.pendingLanes, c |= m, o.lanes = c, fe(n, c);
    }
  }
  var sm = {
    readContext: yi,
    use: Xn,
    useCallback: wn,
    useContext: wn,
    useEffect: wn,
    useImperativeHandle: wn,
    useLayoutEffect: wn,
    useInsertionEffect: wn,
    useMemo: wn,
    useReducer: wn,
    useRef: wn,
    useState: wn,
    useDebugValue: wn,
    useDeferredValue: wn,
    useTransition: wn,
    useSyncExternalStore: wn,
    useId: wn,
    useHostTransitionStatus: wn,
    useFormState: wn,
    useActionState: wn,
    useOptimistic: wn,
    useMemoCache: wn,
    useCacheRefresh: wn
  }, lg = {
    readContext: yi,
    use: Xn,
    useCallback: function(n, o) {
      return Gi().memoizedState = [
        n,
        o === void 0 ? null : o
      ], n;
    },
    useContext: yi,
    useEffect: Rv,
    useImperativeHandle: function(n, o, c) {
      c = c != null ? c.concat([n]) : null, Hr(
        4194308,
        4,
        Fp.bind(null, o, n),
        c
      );
    },
    useLayoutEffect: function(n, o) {
      return Hr(4194308, 4, n, o);
    },
    useInsertionEffect: function(n, o) {
      Hr(4, 2, n, o);
    },
    useMemo: function(n, o) {
      var c = Gi();
      o = o === void 0 ? null : o;
      var m = n();
      if (zr) {
        ta(!0);
        try {
          n();
        } finally {
          ta(!1);
        }
      }
      return c.memoizedState = [m, o], m;
    },
    useReducer: function(n, o, c) {
      var m = Gi();
      if (c !== void 0) {
        var b = c(o);
        if (zr) {
          ta(!0);
          try {
            c(o);
          } finally {
            ta(!1);
          }
        }
      } else b = o;
      return m.memoizedState = m.baseState = b, n = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: n,
        lastRenderedState: b
      }, m.queue = n, n = n.dispatch = ig.bind(
        null,
        ve,
        n
      ), [m.memoizedState, n];
    },
    useRef: function(n) {
      var o = Gi();
      return n = { current: n }, o.memoizedState = n;
    },
    useState: function(n) {
      n = oh(n);
      var o = n.queue, c = ag.bind(null, ve, o);
      return o.dispatch = c, [n.memoizedState, c];
    },
    useDebugValue: Au,
    useDeferredValue: function(n, o) {
      var c = Gi();
      return uh(c, n, o);
    },
    useTransition: function() {
      var n = oh(!1);
      return n = zv.bind(
        null,
        ve,
        n.queue,
        !0,
        !1
      ), Gi().memoizedState = n, [!1, n];
    },
    useSyncExternalStore: function(n, o, c) {
      var m = ve, b = Gi();
      if (oe) {
        if (c === void 0)
          throw Error(u(407));
        c = c();
      } else {
        if (c = o(), sn === null)
          throw Error(u(349));
        (He & 124) !== 0 || Jd(m, o, c);
      }
      b.memoizedState = c;
      var x = { value: c, getSnapshot: o };
      return b.queue = x, Rv(Kp.bind(null, m, x, n), [
        n
      ]), m.flags |= 2048, Aa(
        9,
        sh(),
        Qp.bind(
          null,
          m,
          x,
          c,
          o
        ),
        null
      ), c;
    },
    useId: function() {
      var n = Gi(), o = sn.identifierPrefix;
      if (oe) {
        var c = q, m = H;
        c = (m & ~(1 << 32 - In(m) - 1)).toString(32) + c, o = "" + o + "R" + c, c = fl++, 0 < c && (o += "H" + c.toString(32)), o += "";
      } else
        c = Gp++, o = "" + o + "r" + c.toString(32) + "";
      return n.memoizedState = o;
    },
    useHostTransitionStatus: Uo,
    useFormState: Ip,
    useActionState: Ip,
    useOptimistic: function(n) {
      var o = Gi();
      o.memoizedState = o.baseState = n;
      var c = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return o.queue = c, o = ch.bind(
        null,
        ve,
        !0,
        c
      ), c.dispatch = o, [n, o];
    },
    useMemoCache: Qd,
    useCacheRefresh: function() {
      return Gi().memoizedState = kv.bind(
        null,
        ve
      );
    }
  }, sg = {
    readContext: yi,
    use: Xn,
    useCallback: Du,
    useContext: yi,
    useEffect: Cv,
    useImperativeHandle: om,
    useInsertionEffect: $p,
    useLayoutEffect: hl,
    useMemo: tg,
    useReducer: ih,
    useRef: rh,
    useState: function() {
      return ih(Zl);
    },
    useDebugValue: Au,
    useDeferredValue: function(n, o) {
      var c = Dn();
      return eg(
        c,
        Xe.memoizedState,
        n,
        o
      );
    },
    useTransition: function() {
      var n = ih(Zl)[0], o = Dn().memoizedState;
      return [
        typeof n == "boolean" ? n : nh(n),
        o
      ];
    },
    useSyncExternalStore: ah,
    useId: ng,
    useHostTransitionStatus: Uo,
    useFormState: Vl,
    useActionState: Vl,
    useOptimistic: function(n, o) {
      var c = Dn();
      return $d(c, Xe, n, o);
    },
    useMemoCache: Qd,
    useCacheRefresh: Hv
  }, Zs = {
    readContext: yi,
    use: Xn,
    useCallback: Du,
    useContext: yi,
    useEffect: Cv,
    useImperativeHandle: om,
    useInsertionEffect: $p,
    useLayoutEffect: hl,
    useMemo: tg,
    useReducer: Wd,
    useRef: rh,
    useState: function() {
      return Wd(Zl);
    },
    useDebugValue: Au,
    useDeferredValue: function(n, o) {
      var c = Dn();
      return Xe === null ? uh(c, n, o) : eg(
        c,
        Xe.memoizedState,
        n,
        o
      );
    },
    useTransition: function() {
      var n = Wd(Zl)[0], o = Dn().memoizedState;
      return [
        typeof n == "boolean" ? n : nh(n),
        o
      ];
    },
    useSyncExternalStore: ah,
    useId: ng,
    useHostTransitionStatus: Uo,
    useFormState: am,
    useActionState: am,
    useOptimistic: function(n, o) {
      var c = Dn();
      return Xe !== null ? $d(c, Xe, n, o) : (c.baseState = n, [n, c.queue.dispatch]);
    },
    useMemoCache: Qd,
    useCacheRefresh: Hv
  }, zu = null, Lc = 0;
  function rm(n) {
    var o = Lc;
    return Lc += 1, zu === null && (zu = []), jp(zu, n, o);
  }
  function Lu(n, o) {
    o = o.props.ref, n.ref = o !== void 0 ? o : null;
  }
  function Xi(n, o) {
    throw o.$$typeof === C ? Error(u(525)) : (n = Object.prototype.toString.call(o), Error(
      u(
        31,
        n === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : n
      )
    ));
  }
  function rg(n) {
    var o = n._init;
    return o(n._payload);
  }
  function Da(n) {
    function o(tt, W) {
      if (n) {
        var nt = tt.deletions;
        nt === null ? (tt.deletions = [W], tt.flags |= 16) : nt.push(W);
      }
    }
    function c(tt, W) {
      if (!n) return null;
      for (; W !== null; )
        o(tt, W), W = W.sibling;
      return null;
    }
    function m(tt) {
      for (var W = /* @__PURE__ */ new Map(); tt !== null; )
        tt.key !== null ? W.set(tt.key, tt) : W.set(tt.index, tt), tt = tt.sibling;
      return W;
    }
    function b(tt, W) {
      return tt = Ma(tt, W), tt.index = 0, tt.sibling = null, tt;
    }
    function x(tt, W, nt) {
      return tt.index = nt, n ? (nt = tt.alternate, nt !== null ? (nt = nt.index, nt < W ? (tt.flags |= 67108866, W) : nt) : (tt.flags |= 67108866, W)) : (tt.flags |= 1048576, W);
    }
    function R(tt) {
      return n && tt.alternate === null && (tt.flags |= 67108866), tt;
    }
    function U(tt, W, nt, _t) {
      return W === null || W.tag !== 6 ? (W = Mr(nt, tt.mode, _t), W.return = tt, W) : (W = b(W, nt), W.return = tt, W);
    }
    function Z(tt, W, nt, _t) {
      var Pt = nt.type;
      return Pt === J ? vt(
        tt,
        W,
        nt.props.children,
        _t,
        nt.key
      ) : W !== null && (W.elementType === Pt || typeof Pt == "object" && Pt !== null && Pt.$$typeof === Yt && rg(Pt) === W.type) ? (W = b(W, nt.props), Lu(W, nt), W.return = tt, W) : (W = Ot(
        nt.type,
        nt.key,
        nt.props,
        null,
        tt.mode,
        _t
      ), Lu(W, nt), W.return = tt, W);
    }
    function it(tt, W, nt, _t) {
      return W === null || W.tag !== 4 || W.stateNode.containerInfo !== nt.containerInfo || W.stateNode.implementation !== nt.implementation ? (W = cn(nt, tt.mode, _t), W.return = tt, W) : (W = b(W, nt.children || []), W.return = tt, W);
    }
    function vt(tt, W, nt, _t, Pt) {
      return W === null || W.tag !== 7 ? (W = oa(
        nt,
        tt.mode,
        _t,
        Pt
      ), W.return = tt, W) : (W = b(W, nt), W.return = tt, W);
    }
    function St(tt, W, nt) {
      if (typeof W == "string" && W !== "" || typeof W == "number" || typeof W == "bigint")
        return W = Mr(
          "" + W,
          tt.mode,
          nt
        ), W.return = tt, W;
      if (typeof W == "object" && W !== null) {
        switch (W.$$typeof) {
          case z:
            return nt = Ot(
              W.type,
              W.key,
              W.props,
              null,
              tt.mode,
              nt
            ), Lu(nt, W), nt.return = tt, nt;
          case j:
            return W = cn(
              W,
              tt.mode,
              nt
            ), W.return = tt, W;
          case Yt:
            var _t = W._init;
            return W = _t(W._payload), St(tt, W, nt);
        }
        if (It(W) || kt(W))
          return W = oa(
            W,
            tt.mode,
            nt,
            null
          ), W.return = tt, W;
        if (typeof W.then == "function")
          return St(tt, rm(W), nt);
        if (W.$$typeof === At)
          return St(
            tt,
            Qf(tt, W),
            nt
          );
        Xi(tt, W);
      }
      return null;
    }
    function ot(tt, W, nt, _t) {
      var Pt = W !== null ? W.key : null;
      if (typeof nt == "string" && nt !== "" || typeof nt == "number" || typeof nt == "bigint")
        return Pt !== null ? null : U(tt, W, "" + nt, _t);
      if (typeof nt == "object" && nt !== null) {
        switch (nt.$$typeof) {
          case z:
            return nt.key === Pt ? Z(tt, W, nt, _t) : null;
          case j:
            return nt.key === Pt ? it(tt, W, nt, _t) : null;
          case Yt:
            return Pt = nt._init, nt = Pt(nt._payload), ot(tt, W, nt, _t);
        }
        if (It(nt) || kt(nt))
          return Pt !== null ? null : vt(tt, W, nt, _t, null);
        if (typeof nt.then == "function")
          return ot(
            tt,
            W,
            rm(nt),
            _t
          );
        if (nt.$$typeof === At)
          return ot(
            tt,
            W,
            Qf(tt, nt),
            _t
          );
        Xi(tt, nt);
      }
      return null;
    }
    function st(tt, W, nt, _t, Pt) {
      if (typeof _t == "string" && _t !== "" || typeof _t == "number" || typeof _t == "bigint")
        return tt = tt.get(nt) || null, U(W, tt, "" + _t, Pt);
      if (typeof _t == "object" && _t !== null) {
        switch (_t.$$typeof) {
          case z:
            return tt = tt.get(
              _t.key === null ? nt : _t.key
            ) || null, Z(W, tt, _t, Pt);
          case j:
            return tt = tt.get(
              _t.key === null ? nt : _t.key
            ) || null, it(W, tt, _t, Pt);
          case Yt:
            var Ae = _t._init;
            return _t = Ae(_t._payload), st(
              tt,
              W,
              nt,
              _t,
              Pt
            );
        }
        if (It(_t) || kt(_t))
          return tt = tt.get(nt) || null, vt(W, tt, _t, Pt, null);
        if (typeof _t.then == "function")
          return st(
            tt,
            W,
            nt,
            rm(_t),
            Pt
          );
        if (_t.$$typeof === At)
          return st(
            tt,
            W,
            nt,
            Qf(W, _t),
            Pt
          );
        Xi(W, _t);
      }
      return null;
    }
    function Ft(tt, W, nt, _t) {
      for (var Pt = null, Ae = null, Jt = W, ae = W = 0, Si = null; Jt !== null && ae < nt.length; ae++) {
        Jt.index > ae ? (Si = Jt, Jt = null) : Si = Jt.sibling;
        var je = ot(
          tt,
          Jt,
          nt[ae],
          _t
        );
        if (je === null) {
          Jt === null && (Jt = Si);
          break;
        }
        n && Jt && je.alternate === null && o(tt, Jt), W = x(je, W, ae), Ae === null ? Pt = je : Ae.sibling = je, Ae = je, Jt = Si;
      }
      if (ae === nt.length)
        return c(tt, Jt), oe && I(tt, ae), Pt;
      if (Jt === null) {
        for (; ae < nt.length; ae++)
          Jt = St(tt, nt[ae], _t), Jt !== null && (W = x(
            Jt,
            W,
            ae
          ), Ae === null ? Pt = Jt : Ae.sibling = Jt, Ae = Jt);
        return oe && I(tt, ae), Pt;
      }
      for (Jt = m(Jt); ae < nt.length; ae++)
        Si = st(
          Jt,
          tt,
          ae,
          nt[ae],
          _t
        ), Si !== null && (n && Si.alternate !== null && Jt.delete(
          Si.key === null ? ae : Si.key
        ), W = x(
          Si,
          W,
          ae
        ), Ae === null ? Pt = Si : Ae.sibling = Si, Ae = Si);
      return n && Jt.forEach(function($r) {
        return o(tt, $r);
      }), oe && I(tt, ae), Pt;
    }
    function te(tt, W, nt, _t) {
      if (nt == null) throw Error(u(151));
      for (var Pt = null, Ae = null, Jt = W, ae = W = 0, Si = null, je = nt.next(); Jt !== null && !je.done; ae++, je = nt.next()) {
        Jt.index > ae ? (Si = Jt, Jt = null) : Si = Jt.sibling;
        var $r = ot(tt, Jt, je.value, _t);
        if ($r === null) {
          Jt === null && (Jt = Si);
          break;
        }
        n && Jt && $r.alternate === null && o(tt, Jt), W = x($r, W, ae), Ae === null ? Pt = $r : Ae.sibling = $r, Ae = $r, Jt = Si;
      }
      if (je.done)
        return c(tt, Jt), oe && I(tt, ae), Pt;
      if (Jt === null) {
        for (; !je.done; ae++, je = nt.next())
          je = St(tt, je.value, _t), je !== null && (W = x(je, W, ae), Ae === null ? Pt = je : Ae.sibling = je, Ae = je);
        return oe && I(tt, ae), Pt;
      }
      for (Jt = m(Jt); !je.done; ae++, je = nt.next())
        je = st(Jt, tt, ae, je.value, _t), je !== null && (n && je.alternate !== null && Jt.delete(je.key === null ? ae : je.key), W = x(je, W, ae), Ae === null ? Pt = je : Ae.sibling = je, Ae = je);
      return n && Jt.forEach(function(X0) {
        return o(tt, X0);
      }), oe && I(tt, ae), Pt;
    }
    function Ze(tt, W, nt, _t) {
      if (typeof nt == "object" && nt !== null && nt.type === J && nt.key === null && (nt = nt.props.children), typeof nt == "object" && nt !== null) {
        switch (nt.$$typeof) {
          case z:
            t: {
              for (var Pt = nt.key; W !== null; ) {
                if (W.key === Pt) {
                  if (Pt = nt.type, Pt === J) {
                    if (W.tag === 7) {
                      c(
                        tt,
                        W.sibling
                      ), _t = b(
                        W,
                        nt.props.children
                      ), _t.return = tt, tt = _t;
                      break t;
                    }
                  } else if (W.elementType === Pt || typeof Pt == "object" && Pt !== null && Pt.$$typeof === Yt && rg(Pt) === W.type) {
                    c(
                      tt,
                      W.sibling
                    ), _t = b(W, nt.props), Lu(_t, nt), _t.return = tt, tt = _t;
                    break t;
                  }
                  c(tt, W);
                  break;
                } else o(tt, W);
                W = W.sibling;
              }
              nt.type === J ? (_t = oa(
                nt.props.children,
                tt.mode,
                _t,
                nt.key
              ), _t.return = tt, tt = _t) : (_t = Ot(
                nt.type,
                nt.key,
                nt.props,
                null,
                tt.mode,
                _t
              ), Lu(_t, nt), _t.return = tt, tt = _t);
            }
            return R(tt);
          case j:
            t: {
              for (Pt = nt.key; W !== null; ) {
                if (W.key === Pt)
                  if (W.tag === 4 && W.stateNode.containerInfo === nt.containerInfo && W.stateNode.implementation === nt.implementation) {
                    c(
                      tt,
                      W.sibling
                    ), _t = b(W, nt.children || []), _t.return = tt, tt = _t;
                    break t;
                  } else {
                    c(tt, W);
                    break;
                  }
                else o(tt, W);
                W = W.sibling;
              }
              _t = cn(nt, tt.mode, _t), _t.return = tt, tt = _t;
            }
            return R(tt);
          case Yt:
            return Pt = nt._init, nt = Pt(nt._payload), Ze(
              tt,
              W,
              nt,
              _t
            );
        }
        if (It(nt))
          return Ft(
            tt,
            W,
            nt,
            _t
          );
        if (kt(nt)) {
          if (Pt = kt(nt), typeof Pt != "function") throw Error(u(150));
          return nt = Pt.call(nt), te(
            tt,
            W,
            nt,
            _t
          );
        }
        if (typeof nt.then == "function")
          return Ze(
            tt,
            W,
            rm(nt),
            _t
          );
        if (nt.$$typeof === At)
          return Ze(
            tt,
            W,
            Qf(tt, nt),
            _t
          );
        Xi(tt, nt);
      }
      return typeof nt == "string" && nt !== "" || typeof nt == "number" || typeof nt == "bigint" ? (nt = "" + nt, W !== null && W.tag === 6 ? (c(tt, W.sibling), _t = b(W, nt), _t.return = tt, tt = _t) : (c(tt, W), _t = Mr(nt, tt.mode, _t), _t.return = tt, tt = _t), R(tt)) : c(tt, W);
    }
    return function(tt, W, nt, _t) {
      try {
        Lc = 0;
        var Pt = Ze(
          tt,
          W,
          nt,
          _t
        );
        return zu = null, Pt;
      } catch (Jt) {
        if (Jt === Cr || Jt === Jf) throw Jt;
        var Ae = Vi(29, Jt, null, tt.mode);
        return Ae.lanes = _t, Ae.return = tt, Ae;
      } finally {
      }
    };
  }
  var Hu = Da(!0), Pl = Da(!1), ao = F(null), Qi = null;
  function Vs(n) {
    var o = n.alternate;
    bt(nn, nn.current & 1), bt(ao, n), Qi === null && (o === null || Ou.current !== null || o.memoizedState !== null) && (Qi = n);
  }
  function Gl(n) {
    if (n.tag === 22) {
      if (bt(nn, nn.current), bt(ao, n), Qi === null) {
        var o = n.alternate;
        o !== null && o.memoizedState !== null && (Qi = n);
      }
    } else Xl();
  }
  function Xl() {
    bt(nn, nn.current), bt(ao, ao.current);
  }
  function dl(n) {
    ct(ao), Qi === n && (Qi = null), ct(nn);
  }
  var nn = F(0);
  function fh(n) {
    for (var o = n; o !== null; ) {
      if (o.tag === 13) {
        var c = o.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || Hh(c)))
          return o;
      } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
        if ((o.flags & 128) !== 0) return o;
      } else if (o.child !== null) {
        o.child.return = o, o = o.child;
        continue;
      }
      if (o === n) break;
      for (; o.sibling === null; ) {
        if (o.return === null || o.return === n) return null;
        o = o.return;
      }
      o.sibling.return = o.return, o = o.sibling;
    }
    return null;
  }
  function kr(n, o, c, m) {
    o = n.memoizedState, c = c(m, o), c = c == null ? o : A({}, o, c), n.memoizedState = c, n.lanes === 0 && (n.updateQueue.baseState = c);
  }
  var um = {
    enqueueSetState: function(n, o, c) {
      n = n._reactInternals;
      var m = oo(), b = Oa(m);
      b.payload = o, c != null && (b.callback = c), o = ql(n, b, m), o !== null && (lo(o, n, m), Eu(o, n, m));
    },
    enqueueReplaceState: function(n, o, c) {
      n = n._reactInternals;
      var m = oo(), b = Oa(m);
      b.tag = 1, b.payload = o, c != null && (b.callback = c), o = ql(n, b, m), o !== null && (lo(o, n, m), Eu(o, n, m));
    },
    enqueueForceUpdate: function(n, o) {
      n = n._reactInternals;
      var c = oo(), m = Oa(c);
      m.tag = 2, o != null && (m.callback = o), o = ql(n, m, c), o !== null && (lo(o, n, c), Eu(o, n, c));
    }
  };
  function Hc(n, o, c, m, b, x, R) {
    return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(m, x, R) : o.prototype && o.prototype.isPureReactComponent ? !gi(c, m) || !gi(b, x) : !0;
  }
  function ku(n, o, c, m) {
    n = o.state, typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(c, m), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(c, m), o.state !== n && um.enqueueReplaceState(o, o.state, null);
  }
  function Nr(n, o) {
    var c = o;
    if ("ref" in o) {
      c = {};
      for (var m in o)
        m !== "ref" && (c[m] = o[m]);
    }
    if (n = n.defaultProps) {
      c === o && (c = A({}, c));
      for (var b in n)
        c[b] === void 0 && (c[b] = n[b]);
    }
    return c;
  }
  var hh = typeof reportError == "function" ? reportError : function(n) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var o = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof n == "object" && n !== null && typeof n.message == "string" ? String(n.message) : String(n),
        error: n
      });
      if (!window.dispatchEvent(o)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", n);
      return;
    }
    console.error(n);
  };
  function kc(n) {
    hh(n);
  }
  function ug(n) {
    console.error(n);
  }
  function dh(n) {
    hh(n);
  }
  function mh(n, o) {
    try {
      var c = n.onUncaughtError;
      c(o.value, { componentStack: o.stack });
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  function cg(n, o, c) {
    try {
      var m = n.onCaughtError;
      m(c.value, {
        componentStack: c.stack,
        errorBoundary: o.tag === 1 ? o.stateNode : null
      });
    } catch (b) {
      setTimeout(function() {
        throw b;
      });
    }
  }
  function fg(n, o, c) {
    return c = Oa(c), c.tag = 3, c.payload = { element: null }, c.callback = function() {
      mh(n, o);
    }, c;
  }
  function hg(n) {
    return n = Oa(n), n.tag = 3, n;
  }
  function Ra(n, o, c, m) {
    var b = c.type.getDerivedStateFromError;
    if (typeof b == "function") {
      var x = m.value;
      n.payload = function() {
        return b(x);
      }, n.callback = function() {
        cg(o, c, m);
      };
    }
    var R = c.stateNode;
    R !== null && typeof R.componentDidCatch == "function" && (n.callback = function() {
      cg(o, c, m), typeof b != "function" && (jr === null ? jr = /* @__PURE__ */ new Set([this]) : jr.add(this));
      var U = m.stack;
      this.componentDidCatch(m.value, {
        componentStack: U !== null ? U : ""
      });
    });
  }
  function Uv(n, o, c, m, b) {
    if (c.flags |= 32768, m !== null && typeof m == "object" && typeof m.then == "function") {
      if (o = c.alternate, o !== null && Ar(
        o,
        c,
        b,
        !0
      ), c = ao.current, c !== null) {
        switch (c.tag) {
          case 13:
            return Qi === null ? Pu() : c.alternate === null && Ln === 0 && (Ln = 3), c.flags &= -257, c.flags |= 65536, c.lanes = b, m === Bd ? c.flags |= 16384 : (o = c.updateQueue, o === null ? c.updateQueue = /* @__PURE__ */ new Set([m]) : o.add(m), km(n, m, b)), !1;
          case 22:
            return c.flags |= 65536, m === Bd ? c.flags |= 16384 : (o = c.updateQueue, o === null ? (o = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([m])
            }, c.updateQueue = o) : (c = o.retryQueue, c === null ? o.retryQueue = /* @__PURE__ */ new Set([m]) : c.add(m)), km(n, m, b)), !1;
        }
        throw Error(u(435, c.tag));
      }
      return km(n, m, b), Pu(), !1;
    }
    if (oe)
      return o = ao.current, o !== null ? ((o.flags & 65536) === 0 && (o.flags |= 256), o.flags |= 65536, o.lanes = b, m !== An && (n = Error(u(422), { cause: m }), Ys(Zi(n, c)))) : (m !== An && (o = Error(u(423), {
        cause: m
      }), Ys(
        Zi(o, c)
      )), n = n.current.alternate, n.flags |= 65536, b &= -b, n.lanes |= b, m = Zi(m, c), b = fg(
        n.stateNode,
        m,
        b
      ), Vp(n, b), Ln !== 4 && (Ln = 2)), !1;
    var x = Error(u(520), { cause: m });
    if (x = Zi(x, c), Zc === null ? Zc = [x] : Zc.push(x), Ln !== 4 && (Ln = 2), o === null) return !0;
    m = Zi(m, c), c = o;
    do {
      switch (c.tag) {
        case 3:
          return c.flags |= 65536, n = b & -b, c.lanes |= n, n = fg(c.stateNode, m, n), Vp(c, n), !1;
        case 1:
          if (o = c.type, x = c.stateNode, (c.flags & 128) === 0 && (typeof o.getDerivedStateFromError == "function" || x !== null && typeof x.componentDidCatch == "function" && (jr === null || !jr.has(x))))
            return c.flags |= 65536, b &= -b, c.lanes |= b, b = hg(b), Ra(
              b,
              n,
              c,
              m
            ), Vp(c, b), !1;
      }
      c = c.return;
    } while (c !== null);
    return !1;
  }
  var Rn = Error(u(461)), ii = !1;
  function _i(n, o, c, m) {
    o.child = n === null ? Pl(o, null, c, m) : Hu(
      o,
      n.child,
      c,
      m
    );
  }
  function Bv(n, o, c, m, b) {
    c = c.render;
    var x = o.ref;
    if ("ref" in m) {
      var R = {};
      for (var U in m)
        U !== "ref" && (R[U] = m[U]);
    } else R = m;
    return Dr(o), m = Pd(
      n,
      o,
      c,
      R,
      x,
      b
    ), U = Gd(), n !== null && !ii ? (Cc(n, o, b), Ql(n, o, b)) : (oe && U && xt(o), o.flags |= 1, _i(n, o, m, b), o.child);
  }
  function Ps(n, o, c, m, b) {
    if (n === null) {
      var x = c.type;
      return typeof x == "function" && !wr(x) && x.defaultProps === void 0 && c.compare === null ? (o.tag = 15, o.type = x, Nu(
        n,
        o,
        x,
        m,
        b
      )) : (n = Ot(
        c.type,
        null,
        m,
        o,
        o.mode,
        b
      ), n.ref = o.ref, n.return = o, o.child = n);
    }
    if (x = n.child, !_m(n, b)) {
      var R = x.memoizedProps;
      if (c = c.compare, c = c !== null ? c : gi, c(R, m) && n.ref === o.ref)
        return Ql(n, o, b);
    }
    return o.flags |= 1, n = Ma(x, m), n.ref = o.ref, n.return = o, o.child = n;
  }
  function Nu(n, o, c, m, b) {
    if (n !== null) {
      var x = n.memoizedProps;
      if (gi(x, m) && n.ref === o.ref)
        if (ii = !1, o.pendingProps = m = x, _m(n, b))
          (n.flags & 131072) !== 0 && (ii = !0);
        else
          return o.lanes = n.lanes, Ql(n, o, b);
    }
    return fm(
      n,
      o,
      c,
      m,
      b
    );
  }
  function cm(n, o, c) {
    var m = o.pendingProps, b = m.children, x = n !== null ? n.memoizedState : null;
    if (m.mode === "hidden") {
      if ((o.flags & 128) !== 0) {
        if (m = x !== null ? x.baseLanes | c : c, n !== null) {
          for (b = o.child = n.child, x = 0; b !== null; )
            x = x | b.lanes | b.childLanes, b = b.sibling;
          o.childLanes = x & ~m;
        } else o.childLanes = 0, o.child = null;
        return Uu(
          n,
          o,
          m,
          c
        );
      }
      if ((c & 536870912) !== 0)
        o.memoizedState = { baseLanes: 0, cachePool: null }, n !== null && wu(
          o,
          x !== null ? x.cachePool : null
        ), x !== null ? vi(o, x) : Dc(), Gl(o);
      else
        return o.lanes = o.childLanes = 536870912, Uu(
          n,
          o,
          x !== null ? x.baseLanes | c : c,
          c
        );
    } else
      x !== null ? (wu(o, x.cachePool), vi(o, x), Xl(), o.memoizedState = null) : (n !== null && wu(o, null), Dc(), Xl());
    return _i(n, o, b, c), o.child;
  }
  function Uu(n, o, c, m) {
    var b = Wf();
    return b = b === null ? null : { parent: ei._currentValue, pool: b }, o.memoizedState = {
      baseLanes: c,
      cachePool: b
    }, n !== null && wu(o, null), Dc(), Gl(o), n !== null && Ar(n, o, m, !0), null;
  }
  function ph(n, o) {
    var c = o.ref;
    if (c === null)
      n !== null && n.ref !== null && (o.flags |= 4194816);
    else {
      if (typeof c != "function" && typeof c != "object")
        throw Error(u(284));
      (n === null || n.ref !== c) && (o.flags |= 4194816);
    }
  }
  function fm(n, o, c, m, b) {
    return Dr(o), c = Pd(
      n,
      o,
      c,
      m,
      void 0,
      b
    ), m = Gd(), n !== null && !ii ? (Cc(n, o, b), Ql(n, o, b)) : (oe && m && xt(o), o.flags |= 1, _i(n, o, c, b), o.child);
  }
  function dg(n, o, c, m, b, x) {
    return Dr(o), o.updateQueue = null, c = Xp(
      o,
      m,
      c,
      b
    ), Lr(n), m = Gd(), n !== null && !ii ? (Cc(n, o, x), Ql(n, o, x)) : (oe && m && xt(o), o.flags |= 1, _i(n, o, c, x), o.child);
  }
  function hm(n, o, c, m, b) {
    if (Dr(o), o.stateNode === null) {
      var x = Us, R = c.contextType;
      typeof R == "object" && R !== null && (x = yi(R)), x = new c(m, x), o.memoizedState = x.state !== null && x.state !== void 0 ? x.state : null, x.updater = um, o.stateNode = x, x._reactInternals = o, x = o.stateNode, x.props = m, x.state = o.memoizedState, x.refs = {}, jd(o), R = c.contextType, x.context = typeof R == "object" && R !== null ? yi(R) : Us, x.state = o.memoizedState, R = c.getDerivedStateFromProps, typeof R == "function" && (kr(
        o,
        c,
        R,
        m
      ), x.state = o.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof x.getSnapshotBeforeUpdate == "function" || typeof x.UNSAFE_componentWillMount != "function" && typeof x.componentWillMount != "function" || (R = x.state, typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount(), R !== x.state && um.enqueueReplaceState(x, x.state, null), js(o, m, x, b), Ac(), x.state = o.memoizedState), typeof x.componentDidMount == "function" && (o.flags |= 4194308), m = !0;
    } else if (n === null) {
      x = o.stateNode;
      var U = o.memoizedProps, Z = Nr(c, U);
      x.props = Z;
      var it = x.context, vt = c.contextType;
      R = Us, typeof vt == "object" && vt !== null && (R = yi(vt));
      var St = c.getDerivedStateFromProps;
      vt = typeof St == "function" || typeof x.getSnapshotBeforeUpdate == "function", U = o.pendingProps !== U, vt || typeof x.UNSAFE_componentWillReceiveProps != "function" && typeof x.componentWillReceiveProps != "function" || (U || it !== R) && ku(
        o,
        x,
        m,
        R
      ), jl = !1;
      var ot = o.memoizedState;
      x.state = ot, js(o, m, x, b), Ac(), it = o.memoizedState, U || ot !== it || jl ? (typeof St == "function" && (kr(
        o,
        c,
        St,
        m
      ), it = o.memoizedState), (Z = jl || Hc(
        o,
        c,
        Z,
        m,
        ot,
        it,
        R
      )) ? (vt || typeof x.UNSAFE_componentWillMount != "function" && typeof x.componentWillMount != "function" || (typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount()), typeof x.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof x.componentDidMount == "function" && (o.flags |= 4194308), o.memoizedProps = m, o.memoizedState = it), x.props = m, x.state = it, x.context = R, m = Z) : (typeof x.componentDidMount == "function" && (o.flags |= 4194308), m = !1);
    } else {
      x = o.stateNode, qd(n, o), R = o.memoizedProps, vt = Nr(c, R), x.props = vt, St = o.pendingProps, ot = x.context, it = c.contextType, Z = Us, typeof it == "object" && it !== null && (Z = yi(it)), U = c.getDerivedStateFromProps, (it = typeof U == "function" || typeof x.getSnapshotBeforeUpdate == "function") || typeof x.UNSAFE_componentWillReceiveProps != "function" && typeof x.componentWillReceiveProps != "function" || (R !== St || ot !== Z) && ku(
        o,
        x,
        m,
        Z
      ), jl = !1, ot = o.memoizedState, x.state = ot, js(o, m, x, b), Ac();
      var st = o.memoizedState;
      R !== St || ot !== st || jl || n !== null && n.dependencies !== null && Xf(n.dependencies) ? (typeof U == "function" && (kr(
        o,
        c,
        U,
        m
      ), st = o.memoizedState), (vt = jl || Hc(
        o,
        c,
        vt,
        m,
        ot,
        st,
        Z
      ) || n !== null && n.dependencies !== null && Xf(n.dependencies)) ? (it || typeof x.UNSAFE_componentWillUpdate != "function" && typeof x.componentWillUpdate != "function" || (typeof x.componentWillUpdate == "function" && x.componentWillUpdate(m, st, Z), typeof x.UNSAFE_componentWillUpdate == "function" && x.UNSAFE_componentWillUpdate(
        m,
        st,
        Z
      )), typeof x.componentDidUpdate == "function" && (o.flags |= 4), typeof x.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof x.componentDidUpdate != "function" || R === n.memoizedProps && ot === n.memoizedState || (o.flags |= 4), typeof x.getSnapshotBeforeUpdate != "function" || R === n.memoizedProps && ot === n.memoizedState || (o.flags |= 1024), o.memoizedProps = m, o.memoizedState = st), x.props = m, x.state = st, x.context = Z, m = vt) : (typeof x.componentDidUpdate != "function" || R === n.memoizedProps && ot === n.memoizedState || (o.flags |= 4), typeof x.getSnapshotBeforeUpdate != "function" || R === n.memoizedProps && ot === n.memoizedState || (o.flags |= 1024), m = !1);
    }
    return x = m, ph(n, o), m = (o.flags & 128) !== 0, x || m ? (x = o.stateNode, c = m && typeof c.getDerivedStateFromError != "function" ? null : x.render(), o.flags |= 1, n !== null && m ? (o.child = Hu(
      o,
      n.child,
      null,
      b
    ), o.child = Hu(
      o,
      null,
      c,
      b
    )) : _i(n, o, c, b), o.memoizedState = x.state, n = o.child) : n = Ql(
      n,
      o,
      b
    ), n;
  }
  function dm(n, o, c, m) {
    return Bs(), o.flags |= 256, _i(n, o, c, m), o.child;
  }
  var mm = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function mg(n) {
    return { baseLanes: n, cachePool: Nd() };
  }
  function pg(n, o, c) {
    return n = n !== null ? n.childLanes & ~c : 0, o && (n |= jo), n;
  }
  function gg(n, o, c) {
    var m = o.pendingProps, b = !1, x = (o.flags & 128) !== 0, R;
    if ((R = x) || (R = n !== null && n.memoizedState === null ? !1 : (nn.current & 2) !== 0), R && (b = !0, o.flags &= -129), R = (o.flags & 32) !== 0, o.flags &= -33, n === null) {
      if (oe) {
        if (b ? Vs(o) : Xl(), oe) {
          var U = Zt, Z;
          if (Z = U) {
            t: {
              for (Z = U, U = dn; Z.nodeType !== 8; ) {
                if (!U) {
                  U = null;
                  break t;
                }
                if (Z = pl(
                  Z.nextSibling
                ), Z === null) {
                  U = null;
                  break t;
                }
              }
              U = Z;
            }
            U !== null ? (o.memoizedState = {
              dehydrated: U,
              treeContext: O !== null ? { id: H, overflow: q } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, Z = Vi(
              18,
              null,
              null,
              0
            ), Z.stateNode = U, Z.return = o, o.child = Z, qt = o, Zt = null, Z = !0) : Z = !1;
          }
          Z || Pi(o);
        }
        if (U = o.memoizedState, U !== null && (U = U.dehydrated, U !== null))
          return Hh(U) ? o.lanes = 32 : o.lanes = 536870912, null;
        dl(o);
      }
      return U = m.children, m = m.fallback, b ? (Xl(), b = o.mode, U = gm(
        { mode: "hidden", children: U },
        b
      ), m = oa(
        m,
        b,
        c,
        null
      ), U.return = o, m.return = o, U.sibling = m, o.child = U, b = o.child, b.memoizedState = mg(c), b.childLanes = pg(
        n,
        R,
        c
      ), o.memoizedState = mm, m) : (Vs(o), pm(o, U));
    }
    if (Z = n.memoizedState, Z !== null && (U = Z.dehydrated, U !== null)) {
      if (x)
        o.flags & 256 ? (Vs(o), o.flags &= -257, o = Ur(
          n,
          o,
          c
        )) : o.memoizedState !== null ? (Xl(), o.child = n.child, o.flags |= 128, o = null) : (Xl(), b = m.fallback, U = o.mode, m = gm(
          { mode: "visible", children: m.children },
          U
        ), b = oa(
          b,
          U,
          c,
          null
        ), b.flags |= 2, m.return = o, b.return = o, m.sibling = b, o.child = m, Hu(
          o,
          n.child,
          null,
          c
        ), m = o.child, m.memoizedState = mg(c), m.childLanes = pg(
          n,
          R,
          c
        ), o.memoizedState = mm, o = b);
      else if (Vs(o), Hh(U)) {
        if (R = U.nextSibling && U.nextSibling.dataset, R) var it = R.dgst;
        R = it, m = Error(u(419)), m.stack = "", m.digest = R, Ys({ value: m, source: null, stack: null }), o = Ur(
          n,
          o,
          c
        );
      } else if (ii || Ar(n, o, c, !1), R = (c & n.childLanes) !== 0, ii || R) {
        if (R = sn, R !== null && (m = c & -c, m = (m & 42) !== 0 ? 1 : On(m), m = (m & (R.suspendedLanes | c)) !== 0 ? 0 : m, m !== 0 && m !== Z.retryLane))
          throw Z.retryLane = m, Lo(n, m), lo(R, n, m), Rn;
        U.data === "$?" || Pu(), o = Ur(
          n,
          o,
          c
        );
      } else
        U.data === "$?" ? (o.flags |= 192, o.child = n.child, o = null) : (n = Z.treeContext, Zt = pl(
          U.nextSibling
        ), qt = o, oe = !0, Ge = null, dn = !1, n !== null && (v[w++] = H, v[w++] = q, v[w++] = O, H = n.id, q = n.overflow, O = o), o = pm(
          o,
          m.children
        ), o.flags |= 4096);
      return o;
    }
    return b ? (Xl(), b = m.fallback, U = o.mode, Z = n.child, it = Z.sibling, m = Ma(Z, {
      mode: "hidden",
      children: m.children
    }), m.subtreeFlags = Z.subtreeFlags & 65011712, it !== null ? b = Ma(it, b) : (b = oa(
      b,
      U,
      c,
      null
    ), b.flags |= 2), b.return = o, m.return = o, m.sibling = b, o.child = m, m = b, b = o.child, U = n.child.memoizedState, U === null ? U = mg(c) : (Z = U.cachePool, Z !== null ? (it = ei._currentValue, Z = Z.parent !== it ? { parent: it, pool: it } : Z) : Z = Nd(), U = {
      baseLanes: U.baseLanes | c,
      cachePool: Z
    }), b.memoizedState = U, b.childLanes = pg(
      n,
      R,
      c
    ), o.memoizedState = mm, m) : (Vs(o), c = n.child, n = c.sibling, c = Ma(c, {
      mode: "visible",
      children: m.children
    }), c.return = o, c.sibling = null, n !== null && (R = o.deletions, R === null ? (o.deletions = [n], o.flags |= 16) : R.push(n)), o.child = c, o.memoizedState = null, c);
  }
  function pm(n, o) {
    return o = gm(
      { mode: "visible", children: o },
      n.mode
    ), o.return = n, n.child = o;
  }
  function gm(n, o) {
    return n = Vi(22, n, null, o), n.lanes = 0, n.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, n;
  }
  function Ur(n, o, c) {
    return Hu(o, n.child, null, c), n = pm(
      o,
      o.pendingProps.children
    ), n.flags |= 2, o.memoizedState = null, n;
  }
  function gh(n, o, c) {
    n.lanes |= o;
    var m = n.alternate;
    m !== null && (m.lanes |= o), Or(n.return, o, c);
  }
  function ym(n, o, c, m, b) {
    var x = n.memoizedState;
    x === null ? n.memoizedState = {
      isBackwards: o,
      rendering: null,
      renderingStartTime: 0,
      last: m,
      tail: c,
      tailMode: b
    } : (x.isBackwards = o, x.rendering = null, x.renderingStartTime = 0, x.last = m, x.tail = c, x.tailMode = b);
  }
  function vm(n, o, c) {
    var m = o.pendingProps, b = m.revealOrder, x = m.tail;
    if (_i(n, o, m.children, c), m = nn.current, (m & 2) !== 0)
      m = m & 1 | 2, o.flags |= 128;
    else {
      if (n !== null && (n.flags & 128) !== 0)
        t: for (n = o.child; n !== null; ) {
          if (n.tag === 13)
            n.memoizedState !== null && gh(n, c, o);
          else if (n.tag === 19)
            gh(n, c, o);
          else if (n.child !== null) {
            n.child.return = n, n = n.child;
            continue;
          }
          if (n === o) break t;
          for (; n.sibling === null; ) {
            if (n.return === null || n.return === o)
              break t;
            n = n.return;
          }
          n.sibling.return = n.return, n = n.sibling;
        }
      m &= 1;
    }
    switch (bt(nn, m), b) {
      case "forwards":
        for (c = o.child, b = null; c !== null; )
          n = c.alternate, n !== null && fh(n) === null && (b = c), c = c.sibling;
        c = b, c === null ? (b = o.child, o.child = null) : (b = c.sibling, c.sibling = null), ym(
          o,
          !1,
          b,
          c,
          x
        );
        break;
      case "backwards":
        for (c = null, b = o.child, o.child = null; b !== null; ) {
          if (n = b.alternate, n !== null && fh(n) === null) {
            o.child = b;
            break;
          }
          n = b.sibling, b.sibling = c, c = b, b = n;
        }
        ym(
          o,
          !0,
          c,
          null,
          x
        );
        break;
      case "together":
        ym(o, !1, null, null, void 0);
        break;
      default:
        o.memoizedState = null;
    }
    return o.child;
  }
  function Ql(n, o, c) {
    if (n !== null && (o.dependencies = n.dependencies), Qs |= o.lanes, (c & o.childLanes) === 0)
      if (n !== null) {
        if (Ar(
          n,
          o,
          c,
          !1
        ), (c & o.childLanes) === 0)
          return null;
      } else return null;
    if (n !== null && o.child !== n.child)
      throw Error(u(153));
    if (o.child !== null) {
      for (n = o.child, c = Ma(n, n.pendingProps), o.child = c, c.return = o; n.sibling !== null; )
        n = n.sibling, c = c.sibling = Ma(n, n.pendingProps), c.return = o;
      c.sibling = null;
    }
    return o.child;
  }
  function _m(n, o) {
    return (n.lanes & o) !== 0 ? !0 : (n = n.dependencies, !!(n !== null && Xf(n)));
  }
  function Yv(n, o, c) {
    switch (o.tag) {
      case 3:
        $t(o, o.stateNode.containerInfo), cl(o, ei, n.memoizedState.cache), Bs();
        break;
      case 27:
      case 5:
        ci(o);
        break;
      case 4:
        $t(o, o.stateNode.containerInfo);
        break;
      case 10:
        cl(
          o,
          o.type,
          o.memoizedProps.value
        );
        break;
      case 13:
        var m = o.memoizedState;
        if (m !== null)
          return m.dehydrated !== null ? (Vs(o), o.flags |= 128, null) : (c & o.child.childLanes) !== 0 ? gg(n, o, c) : (Vs(o), n = Ql(
            n,
            o,
            c
          ), n !== null ? n.sibling : null);
        Vs(o);
        break;
      case 19:
        var b = (n.flags & 128) !== 0;
        if (m = (c & o.childLanes) !== 0, m || (Ar(
          n,
          o,
          c,
          !1
        ), m = (c & o.childLanes) !== 0), b) {
          if (m)
            return vm(
              n,
              o,
              c
            );
          o.flags |= 128;
        }
        if (b = o.memoizedState, b !== null && (b.rendering = null, b.tail = null, b.lastEffect = null), bt(nn, nn.current), m) break;
        return null;
      case 22:
      case 23:
        return o.lanes = 0, cm(n, o, c);
      case 24:
        cl(o, ei, n.memoizedState.cache);
    }
    return Ql(n, o, c);
  }
  function jv(n, o, c) {
    if (n !== null)
      if (n.memoizedProps !== o.pendingProps)
        ii = !0;
      else {
        if (!_m(n, c) && (o.flags & 128) === 0)
          return ii = !1, Yv(
            n,
            o,
            c
          );
        ii = (n.flags & 131072) !== 0;
      }
    else
      ii = !1, oe && (o.flags & 1048576) !== 0 && rt(o, d, o.index);
    switch (o.lanes = 0, o.tag) {
      case 16:
        t: {
          n = o.pendingProps;
          var m = o.elementType, b = m._init;
          if (m = b(m._payload), o.type = m, typeof m == "function")
            wr(m) ? (n = Nr(m, n), o.tag = 1, o = hm(
              null,
              o,
              m,
              n,
              c
            )) : (o.tag = 0, o = fm(
              null,
              o,
              m,
              n,
              c
            ));
          else {
            if (m != null) {
              if (b = m.$$typeof, b === Lt) {
                o.tag = 11, o = Bv(
                  null,
                  o,
                  m,
                  n,
                  c
                );
                break t;
              } else if (b === Ct) {
                o.tag = 14, o = Ps(
                  null,
                  o,
                  m,
                  n,
                  c
                );
                break t;
              }
            }
            throw o = ge(m) || m, Error(u(306, o, ""));
          }
        }
        return o;
      case 0:
        return fm(
          n,
          o,
          o.type,
          o.pendingProps,
          c
        );
      case 1:
        return m = o.type, b = Nr(
          m,
          o.pendingProps
        ), hm(
          n,
          o,
          m,
          b,
          c
        );
      case 3:
        t: {
          if ($t(
            o,
            o.stateNode.containerInfo
          ), n === null) throw Error(u(387));
          m = o.pendingProps;
          var x = o.memoizedState;
          b = x.element, qd(n, o), js(o, m, null, c);
          var R = o.memoizedState;
          if (m = R.cache, cl(o, ei, m), m !== x.cache && Mc(
            o,
            [ei],
            c,
            !0
          ), Ac(), m = R.element, x.isDehydrated)
            if (x = {
              element: m,
              isDehydrated: !1,
              cache: R.cache
            }, o.updateQueue.baseState = x, o.memoizedState = x, o.flags & 256) {
              o = dm(
                n,
                o,
                m,
                c
              );
              break t;
            } else if (m !== b) {
              b = Zi(
                Error(u(424)),
                o
              ), Ys(b), o = dm(
                n,
                o,
                m,
                c
              );
              break t;
            } else {
              switch (n = o.stateNode.containerInfo, n.nodeType) {
                case 9:
                  n = n.body;
                  break;
                default:
                  n = n.nodeName === "HTML" ? n.ownerDocument.body : n;
              }
              for (Zt = pl(n.firstChild), qt = o, oe = !0, Ge = null, dn = !0, c = Pl(
                o,
                null,
                m,
                c
              ), o.child = c; c; )
                c.flags = c.flags & -3 | 4096, c = c.sibling;
            }
          else {
            if (Bs(), m === b) {
              o = Ql(
                n,
                o,
                c
              );
              break t;
            }
            _i(
              n,
              o,
              m,
              c
            );
          }
          o = o.child;
        }
        return o;
      case 26:
        return ph(n, o), n === null ? (c = n_(
          o.type,
          null,
          o.pendingProps,
          null
        )) ? o.memoizedState = c : oe || (c = o.type, n = o.pendingProps, m = Zo(
          Tt.current
        ).createElement(c), m[Pn] = o, m[Mi] = n, re(m, c, n), Bn(m), o.stateNode = m) : o.memoizedState = n_(
          o.type,
          n.memoizedProps,
          o.pendingProps,
          n.memoizedState
        ), null;
      case 27:
        return ci(o), n === null && oe && (m = o.stateNode = jt(
          o.type,
          o.pendingProps,
          Tt.current
        ), qt = o, dn = !0, b = Zt, Xr(o.type) ? (Qr = b, Zt = pl(
          m.firstChild
        )) : Zt = b), _i(
          n,
          o,
          o.pendingProps.children,
          c
        ), ph(n, o), n === null && (o.flags |= 4194304), o.child;
      case 5:
        return n === null && oe && ((b = m = Zt) && (m = tf(
          m,
          o.type,
          o.pendingProps,
          dn
        ), m !== null ? (o.stateNode = m, qt = o, Zt = pl(
          m.firstChild
        ), dn = !1, b = !0) : b = !1), b || Pi(o)), ci(o), b = o.type, x = o.pendingProps, R = n !== null ? n.memoizedProps : null, m = x.children, ns(b, x) ? m = null : R !== null && ns(b, R) && (o.flags |= 32), o.memoizedState !== null && (b = Pd(
          n,
          o,
          Av,
          null,
          null,
          c
        ), Na._currentValue = b), ph(n, o), _i(n, o, m, c), o.child;
      case 6:
        return n === null && oe && ((n = c = Zt) && (c = V0(
          c,
          o.pendingProps,
          dn
        ), c !== null ? (o.stateNode = c, qt = o, Zt = null, n = !0) : n = !1), n || Pi(o)), null;
      case 13:
        return gg(n, o, c);
      case 4:
        return $t(
          o,
          o.stateNode.containerInfo
        ), m = o.pendingProps, n === null ? o.child = Hu(
          o,
          null,
          m,
          c
        ) : _i(
          n,
          o,
          m,
          c
        ), o.child;
      case 11:
        return Bv(
          n,
          o,
          o.type,
          o.pendingProps,
          c
        );
      case 7:
        return _i(
          n,
          o,
          o.pendingProps,
          c
        ), o.child;
      case 8:
        return _i(
          n,
          o,
          o.pendingProps.children,
          c
        ), o.child;
      case 12:
        return _i(
          n,
          o,
          o.pendingProps.children,
          c
        ), o.child;
      case 10:
        return m = o.pendingProps, cl(o, o.type, m.value), _i(
          n,
          o,
          m.children,
          c
        ), o.child;
      case 9:
        return b = o.type._context, m = o.pendingProps.children, Dr(o), b = yi(b), m = m(b), o.flags |= 1, _i(n, o, m, c), o.child;
      case 14:
        return Ps(
          n,
          o,
          o.type,
          o.pendingProps,
          c
        );
      case 15:
        return Nu(
          n,
          o,
          o.type,
          o.pendingProps,
          c
        );
      case 19:
        return vm(n, o, c);
      case 31:
        return m = o.pendingProps, c = o.mode, m = {
          mode: m.mode,
          children: m.children
        }, n === null ? (c = gm(
          m,
          c
        ), c.ref = o.ref, o.child = c, c.return = o, o = c) : (c = Ma(n.child, m), c.ref = o.ref, o.child = c, c.return = o, o = c), o;
      case 22:
        return cm(n, o, c);
      case 24:
        return Dr(o), m = yi(ei), n === null ? (b = Wf(), b === null && (b = sn, x = Oc(), b.pooledCache = x, x.refCount++, x !== null && (b.pooledCacheLanes |= c), b = x), o.memoizedState = {
          parent: m,
          cache: b
        }, jd(o), cl(o, ei, b)) : ((n.lanes & c) !== 0 && (qd(n, o), js(o, null, null, c), Ac()), b = n.memoizedState, x = o.memoizedState, b.parent !== m ? (b = { parent: m, cache: m }, o.memoizedState = b, o.lanes === 0 && (o.memoizedState = o.updateQueue.baseState = b), cl(o, ei, m)) : (m = x.cache, cl(o, ei, m), m !== b.cache && Mc(
          o,
          [ei],
          c,
          !0
        ))), _i(
          n,
          o,
          o.pendingProps.children,
          c
        ), o.child;
      case 29:
        throw o.pendingProps;
    }
    throw Error(u(156, o.tag));
  }
  function Kl(n) {
    n.flags |= 4;
  }
  function Nc(n, o) {
    if (o.type !== "stylesheet" || (o.state.loading & 4) !== 0)
      n.flags &= -16777217;
    else if (n.flags |= 16777216, !Fg(o)) {
      if (o = ao.current, o !== null && ((He & 4194048) === He ? Qi !== null : (He & 62914560) !== He && (He & 536870912) === 0 || o !== Qi))
        throw Mu = Bd, Ud;
      n.flags |= 8192;
    }
  }
  function yh(n, o) {
    o !== null && (n.flags |= 4), n.flags & 16384 && (o = n.tag !== 22 ? Ht() : 536870912, n.lanes |= o, qc |= o);
  }
  function Uc(n, o) {
    if (!oe)
      switch (n.tailMode) {
        case "hidden":
          o = n.tail;
          for (var c = null; o !== null; )
            o.alternate !== null && (c = o), o = o.sibling;
          c === null ? n.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = n.tail;
          for (var m = null; c !== null; )
            c.alternate !== null && (m = c), c = c.sibling;
          m === null ? o || n.tail === null ? n.tail = null : n.tail.sibling = null : m.sibling = null;
      }
  }
  function ie(n) {
    var o = n.alternate !== null && n.alternate.child === n.child, c = 0, m = 0;
    if (o)
      for (var b = n.child; b !== null; )
        c |= b.lanes | b.childLanes, m |= b.subtreeFlags & 65011712, m |= b.flags & 65011712, b.return = n, b = b.sibling;
    else
      for (b = n.child; b !== null; )
        c |= b.lanes | b.childLanes, m |= b.subtreeFlags, m |= b.flags, b.return = n, b = b.sibling;
    return n.subtreeFlags |= m, n.childLanes = c, o;
  }
  function yg(n, o, c) {
    var m = o.pendingProps;
    switch (Nt(o), o.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ie(o), null;
      case 1:
        return ie(o), null;
      case 3:
        return c = o.stateNode, m = null, n !== null && (m = n.memoizedState.cache), o.memoizedState.cache !== m && (o.flags |= 2048), Ho(ei), on(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (n === null || n.child === null) && (Er(o) ? Kl(o) : n === null || n.memoizedState.isDehydrated && (o.flags & 256) === 0 || (o.flags |= 1024, Gf())), ie(o), null;
      case 26:
        return c = o.memoizedState, n === null ? (Kl(o), c !== null ? (ie(o), Nc(o, c)) : (ie(o), o.flags &= -16777217)) : c ? c !== n.memoizedState ? (Kl(o), ie(o), Nc(o, c)) : (ie(o), o.flags &= -16777217) : (n.memoizedProps !== m && Kl(o), ie(o), o.flags &= -16777217), null;
      case 27:
        da(o), c = Tt.current;
        var b = o.type;
        if (n !== null && o.stateNode != null)
          n.memoizedProps !== m && Kl(o);
        else {
          if (!m) {
            if (o.stateNode === null)
              throw Error(u(166));
            return ie(o), null;
          }
          n = Et.current, Er(o) ? xu(o) : (n = jt(b, m, c), o.stateNode = n, Kl(o));
        }
        return ie(o), null;
      case 5:
        if (da(o), c = o.type, n !== null && o.stateNode != null)
          n.memoizedProps !== m && Kl(o);
        else {
          if (!m) {
            if (o.stateNode === null)
              throw Error(u(166));
            return ie(o), null;
          }
          if (n = Et.current, Er(o))
            xu(o);
          else {
            switch (b = Zo(
              Tt.current
            ), n) {
              case 1:
                n = b.createElementNS(
                  "http://www.w3.org/2000/svg",
                  c
                );
                break;
              case 2:
                n = b.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  c
                );
                break;
              default:
                switch (c) {
                  case "svg":
                    n = b.createElementNS(
                      "http://www.w3.org/2000/svg",
                      c
                    );
                    break;
                  case "math":
                    n = b.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      c
                    );
                    break;
                  case "script":
                    n = b.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild);
                    break;
                  case "select":
                    n = typeof m.is == "string" ? b.createElement("select", { is: m.is }) : b.createElement("select"), m.multiple ? n.multiple = !0 : m.size && (n.size = m.size);
                    break;
                  default:
                    n = typeof m.is == "string" ? b.createElement(c, { is: m.is }) : b.createElement(c);
                }
            }
            n[Pn] = o, n[Mi] = m;
            t: for (b = o.child; b !== null; ) {
              if (b.tag === 5 || b.tag === 6)
                n.appendChild(b.stateNode);
              else if (b.tag !== 4 && b.tag !== 27 && b.child !== null) {
                b.child.return = b, b = b.child;
                continue;
              }
              if (b === o) break t;
              for (; b.sibling === null; ) {
                if (b.return === null || b.return === o)
                  break t;
                b = b.return;
              }
              b.sibling.return = b.return, b = b.sibling;
            }
            o.stateNode = n;
            t: switch (re(n, c, m), c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                n = !!m.autoFocus;
                break t;
              case "img":
                n = !0;
                break t;
              default:
                n = !1;
            }
            n && Kl(o);
          }
        }
        return ie(o), o.flags &= -16777217, null;
      case 6:
        if (n && o.stateNode != null)
          n.memoizedProps !== m && Kl(o);
        else {
          if (typeof m != "string" && o.stateNode === null)
            throw Error(u(166));
          if (n = Tt.current, Er(o)) {
            if (n = o.stateNode, c = o.memoizedProps, m = null, b = qt, b !== null)
              switch (b.tag) {
                case 27:
                case 5:
                  m = b.memoizedProps;
              }
            n[Pn] = o, n = !!(n.nodeValue === c || m !== null && m.suppressHydrationWarning === !0 || Wg(n.nodeValue, c)), n || Pi(o);
          } else
            n = Zo(n).createTextNode(
              m
            ), n[Pn] = o, o.stateNode = n;
        }
        return ie(o), null;
      case 13:
        if (m = o.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
          if (b = Er(o), m !== null && m.dehydrated !== null) {
            if (n === null) {
              if (!b) throw Error(u(318));
              if (b = o.memoizedState, b = b !== null ? b.dehydrated : null, !b) throw Error(u(317));
              b[Pn] = o;
            } else
              Bs(), (o.flags & 128) === 0 && (o.memoizedState = null), o.flags |= 4;
            ie(o), b = !1;
          } else
            b = Gf(), n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = b), b = !0;
          if (!b)
            return o.flags & 256 ? (dl(o), o) : (dl(o), null);
        }
        if (dl(o), (o.flags & 128) !== 0)
          return o.lanes = c, o;
        if (c = m !== null, n = n !== null && n.memoizedState !== null, c) {
          m = o.child, b = null, m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (b = m.alternate.memoizedState.cachePool.pool);
          var x = null;
          m.memoizedState !== null && m.memoizedState.cachePool !== null && (x = m.memoizedState.cachePool.pool), x !== b && (m.flags |= 2048);
        }
        return c !== n && c && (o.child.flags |= 8192), yh(o, o.updateQueue), ie(o), null;
      case 4:
        return on(), n === null && Qg(o.stateNode.containerInfo), ie(o), null;
      case 10:
        return Ho(o.type), ie(o), null;
      case 19:
        if (ct(nn), b = o.memoizedState, b === null) return ie(o), null;
        if (m = (o.flags & 128) !== 0, x = b.rendering, x === null)
          if (m) Uc(b, !1);
          else {
            if (Ln !== 0 || n !== null && (n.flags & 128) !== 0)
              for (n = o.child; n !== null; ) {
                if (x = fh(n), x !== null) {
                  for (o.flags |= 128, Uc(b, !1), n = x.updateQueue, o.updateQueue = n, yh(o, n), o.subtreeFlags = 0, n = c, c = o.child; c !== null; )
                    ye(c, n), c = c.sibling;
                  return bt(
                    nn,
                    nn.current & 1 | 2
                  ), o.child;
                }
                n = n.sibling;
              }
            b.tail !== null && En() > Am && (o.flags |= 128, m = !0, Uc(b, !1), o.lanes = 4194304);
          }
        else {
          if (!m)
            if (n = fh(x), n !== null) {
              if (o.flags |= 128, m = !0, n = n.updateQueue, o.updateQueue = n, yh(o, n), Uc(b, !0), b.tail === null && b.tailMode === "hidden" && !x.alternate && !oe)
                return ie(o), null;
            } else
              2 * En() - b.renderingStartTime > Am && c !== 536870912 && (o.flags |= 128, m = !0, Uc(b, !1), o.lanes = 4194304);
          b.isBackwards ? (x.sibling = o.child, o.child = x) : (n = b.last, n !== null ? n.sibling = x : o.child = x, b.last = x);
        }
        return b.tail !== null ? (o = b.tail, b.rendering = o, b.tail = o.sibling, b.renderingStartTime = En(), o.sibling = null, n = nn.current, bt(nn, m ? n & 1 | 2 : n & 1), o) : (ie(o), null);
      case 22:
      case 23:
        return dl(o), Rc(), m = o.memoizedState !== null, n !== null ? n.memoizedState !== null !== m && (o.flags |= 8192) : m && (o.flags |= 8192), m ? (c & 536870912) !== 0 && (o.flags & 128) === 0 && (ie(o), o.subtreeFlags & 6 && (o.flags |= 8192)) : ie(o), c = o.updateQueue, c !== null && yh(o, c.retryQueue), c = null, n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (c = n.memoizedState.cachePool.pool), m = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (m = o.memoizedState.cachePool.pool), m !== c && (o.flags |= 2048), n !== null && ct(Yl), null;
      case 24:
        return c = null, n !== null && (c = n.memoizedState.cache), o.memoizedState.cache !== c && (o.flags |= 2048), Ho(ei), ie(o), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(u(156, o.tag));
  }
  function k0(n, o) {
    switch (Nt(o), o.tag) {
      case 1:
        return n = o.flags, n & 65536 ? (o.flags = n & -65537 | 128, o) : null;
      case 3:
        return Ho(ei), on(), n = o.flags, (n & 65536) !== 0 && (n & 128) === 0 ? (o.flags = n & -65537 | 128, o) : null;
      case 26:
      case 27:
      case 5:
        return da(o), null;
      case 13:
        if (dl(o), n = o.memoizedState, n !== null && n.dehydrated !== null) {
          if (o.alternate === null)
            throw Error(u(340));
          Bs();
        }
        return n = o.flags, n & 65536 ? (o.flags = n & -65537 | 128, o) : null;
      case 19:
        return ct(nn), null;
      case 4:
        return on(), null;
      case 10:
        return Ho(o.type), null;
      case 22:
      case 23:
        return dl(o), Rc(), n !== null && ct(Yl), n = o.flags, n & 65536 ? (o.flags = n & -65537 | 128, o) : null;
      case 24:
        return Ho(ei), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function vg(n, o) {
    switch (Nt(o), o.tag) {
      case 3:
        Ho(ei), on();
        break;
      case 26:
      case 27:
      case 5:
        da(o);
        break;
      case 4:
        on();
        break;
      case 13:
        dl(o);
        break;
      case 19:
        ct(nn);
        break;
      case 10:
        Ho(o.type);
        break;
      case 22:
      case 23:
        dl(o), Rc(), n !== null && ct(Yl);
        break;
      case 24:
        Ho(ei);
    }
  }
  function vh(n, o) {
    try {
      var c = o.updateQueue, m = c !== null ? c.lastEffect : null;
      if (m !== null) {
        var b = m.next;
        c = b;
        do {
          if ((c.tag & n) === n) {
            m = void 0;
            var x = c.create, R = c.inst;
            m = x(), R.destroy = m;
          }
          c = c.next;
        } while (c !== b);
      }
    } catch (U) {
      Je(o, o.return, U);
    }
  }
  function Br(n, o, c) {
    try {
      var m = o.updateQueue, b = m !== null ? m.lastEffect : null;
      if (b !== null) {
        var x = b.next;
        m = x;
        do {
          if ((m.tag & n) === n) {
            var R = m.inst, U = R.destroy;
            if (U !== void 0) {
              R.destroy = void 0, b = o;
              var Z = c, it = U;
              try {
                it();
              } catch (vt) {
                Je(
                  b,
                  Z,
                  vt
                );
              }
            }
          }
          m = m.next;
        } while (m !== x);
      }
    } catch (vt) {
      Je(o, o.return, vt);
    }
  }
  function bm(n) {
    var o = n.updateQueue;
    if (o !== null) {
      var c = n.stateNode;
      try {
        $f(o, c);
      } catch (m) {
        Je(n, n.return, m);
      }
    }
  }
  function _g(n, o, c) {
    c.props = Nr(
      n.type,
      n.memoizedProps
    ), c.state = n.memoizedState;
    try {
      c.componentWillUnmount();
    } catch (m) {
      Je(n, o, m);
    }
  }
  function Bc(n, o) {
    try {
      var c = n.ref;
      if (c !== null) {
        switch (n.tag) {
          case 26:
          case 27:
          case 5:
            var m = n.stateNode;
            break;
          case 30:
            m = n.stateNode;
            break;
          default:
            m = n.stateNode;
        }
        typeof c == "function" ? n.refCleanup = c(m) : c.current = m;
      }
    } catch (b) {
      Je(n, o, b);
    }
  }
  function ml(n, o) {
    var c = n.ref, m = n.refCleanup;
    if (c !== null)
      if (typeof m == "function")
        try {
          m();
        } catch (b) {
          Je(n, o, b);
        } finally {
          n.refCleanup = null, n = n.alternate, n != null && (n.refCleanup = null);
        }
      else if (typeof c == "function")
        try {
          c(null);
        } catch (b) {
          Je(n, o, b);
        }
      else c.current = null;
  }
  function Yc(n) {
    var o = n.type, c = n.memoizedProps, m = n.stateNode;
    try {
      t: switch (o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && m.focus();
          break t;
        case "img":
          c.src ? m.src = c.src : c.srcSet && (m.srcset = c.srcSet);
      }
    } catch (b) {
      Je(n, n.return, b);
    }
  }
  function bg(n, o, c) {
    try {
      var m = n.stateNode;
      j0(m, n.type, c, o), m[Mi] = o;
    } catch (b) {
      Je(n, n.return, b);
    }
  }
  function qv(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 26 || n.tag === 27 && Xr(n.type) || n.tag === 4;
  }
  function Bo(n) {
    t: for (; ; ) {
      for (; n.sibling === null; ) {
        if (n.return === null || qv(n.return)) return null;
        n = n.return;
      }
      for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
        if (n.tag === 27 && Xr(n.type) || n.flags & 2 || n.child === null || n.tag === 4) continue t;
        n.child.return = n, n = n.child;
      }
      if (!(n.flags & 2)) return n.stateNode;
    }
  }
  function Bu(n, o, c) {
    var m = n.tag;
    if (m === 5 || m === 6)
      n = n.stateNode, o ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(n, o) : (o = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, o.appendChild(n), c = c._reactRootContainer, c != null || o.onclick !== null || (o.onclick = jm));
    else if (m !== 4 && (m === 27 && Xr(n.type) && (c = n.stateNode, o = null), n = n.child, n !== null))
      for (Bu(n, o, c), n = n.sibling; n !== null; )
        Bu(n, o, c), n = n.sibling;
  }
  function Sm(n, o, c) {
    var m = n.tag;
    if (m === 5 || m === 6)
      n = n.stateNode, o ? c.insertBefore(n, o) : c.appendChild(n);
    else if (m !== 4 && (m === 27 && Xr(n.type) && (c = n.stateNode), n = n.child, n !== null))
      for (Sm(n, o, c), n = n.sibling; n !== null; )
        Sm(n, o, c), n = n.sibling;
  }
  function Tm(n) {
    var o = n.stateNode, c = n.memoizedProps;
    try {
      for (var m = n.type, b = o.attributes; b.length; )
        o.removeAttributeNode(b[0]);
      re(o, m, c), o[Pn] = n, o[Mi] = c;
    } catch (x) {
      Je(n, n.return, x);
    }
  }
  var Wl = !1, Cn = !1, xm = !1, wm = typeof WeakSet == "function" ? WeakSet : Set, ai = null;
  function Sg(n, o) {
    if (n = n.containerInfo, Ch = Uh, n = xr(n), Hs(n)) {
      if ("selectionStart" in n)
        var c = {
          start: n.selectionStart,
          end: n.selectionEnd
        };
      else
        t: {
          c = (c = n.ownerDocument) && c.defaultView || window;
          var m = c.getSelection && c.getSelection();
          if (m && m.rangeCount !== 0) {
            c = m.anchorNode;
            var b = m.anchorOffset, x = m.focusNode;
            m = m.focusOffset;
            try {
              c.nodeType, x.nodeType;
            } catch {
              c = null;
              break t;
            }
            var R = 0, U = -1, Z = -1, it = 0, vt = 0, St = n, ot = null;
            e: for (; ; ) {
              for (var st; St !== c || b !== 0 && St.nodeType !== 3 || (U = R + b), St !== x || m !== 0 && St.nodeType !== 3 || (Z = R + m), St.nodeType === 3 && (R += St.nodeValue.length), (st = St.firstChild) !== null; )
                ot = St, St = st;
              for (; ; ) {
                if (St === n) break e;
                if (ot === c && ++it === b && (U = R), ot === x && ++vt === m && (Z = R), (st = St.nextSibling) !== null) break;
                St = ot, ot = St.parentNode;
              }
              St = st;
            }
            c = U === -1 || Z === -1 ? null : { start: U, end: Z };
          } else c = null;
        }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (zh = { focusedElem: n, selectionRange: c }, Uh = !1, ai = o; ai !== null; )
      if (o = ai, n = o.child, (o.subtreeFlags & 1024) !== 0 && n !== null)
        n.return = o, ai = n;
      else
        for (; ai !== null; ) {
          switch (o = ai, x = o.alternate, n = o.flags, o.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((n & 1024) !== 0 && x !== null) {
                n = void 0, c = o, b = x.memoizedProps, x = x.memoizedState, m = c.stateNode;
                try {
                  var Ft = Nr(
                    c.type,
                    b,
                    c.elementType === c.type
                  );
                  n = m.getSnapshotBeforeUpdate(
                    Ft,
                    x
                  ), m.__reactInternalSnapshotBeforeUpdate = n;
                } catch (te) {
                  Je(
                    c,
                    c.return,
                    te
                  );
                }
              }
              break;
            case 3:
              if ((n & 1024) !== 0) {
                if (n = o.stateNode.containerInfo, c = n.nodeType, c === 9)
                  Lh(n);
                else if (c === 1)
                  switch (n.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Lh(n);
                      break;
                    default:
                      n.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((n & 1024) !== 0) throw Error(u(163));
          }
          if (n = o.sibling, n !== null) {
            n.return = o.return, ai = n;
            break;
          }
          ai = o.return;
        }
  }
  function Tg(n, o, c) {
    var m = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 15:
        Il(n, c), m & 4 && vh(5, c);
        break;
      case 1:
        if (Il(n, c), m & 4)
          if (n = c.stateNode, o === null)
            try {
              n.componentDidMount();
            } catch (R) {
              Je(c, c.return, R);
            }
          else {
            var b = Nr(
              c.type,
              o.memoizedProps
            );
            o = o.memoizedState;
            try {
              n.componentDidUpdate(
                b,
                o,
                n.__reactInternalSnapshotBeforeUpdate
              );
            } catch (R) {
              Je(
                c,
                c.return,
                R
              );
            }
          }
        m & 64 && bm(c), m & 512 && Bc(c, c.return);
        break;
      case 3:
        if (Il(n, c), m & 64 && (n = c.updateQueue, n !== null)) {
          if (o = null, c.child !== null)
            switch (c.child.tag) {
              case 27:
              case 5:
                o = c.child.stateNode;
                break;
              case 1:
                o = c.child.stateNode;
            }
          try {
            $f(n, o);
          } catch (R) {
            Je(c, c.return, R);
          }
        }
        break;
      case 27:
        o === null && m & 4 && Tm(c);
      case 26:
      case 5:
        Il(n, c), o === null && m & 4 && Yc(c), m & 512 && Bc(c, c.return);
        break;
      case 12:
        Il(n, c);
        break;
      case 13:
        Il(n, c), m & 4 && Mm(n, c), m & 64 && (n = c.memoizedState, n !== null && (n = n.dehydrated, n !== null && (c = N0.bind(
          null,
          c
        ), P0(n, c))));
        break;
      case 22:
        if (m = c.memoizedState !== null || Wl, !m) {
          o = o !== null && o.memoizedState !== null || Cn, b = Wl;
          var x = Cn;
          Wl = m, (Cn = o) && !x ? Yr(
            n,
            c,
            (c.subtreeFlags & 8772) !== 0
          ) : Il(n, c), Wl = b, Cn = x;
        }
        break;
      case 30:
        break;
      default:
        Il(n, c);
    }
  }
  function xg(n) {
    var o = n.alternate;
    o !== null && (n.alternate = null, xg(o)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (o = n.stateNode, o !== null && mr(o)), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
  }
  var vn = null, Ci = !1;
  function Jl(n, o, c) {
    for (c = c.child; c !== null; )
      Ce(n, o, c), c = c.sibling;
  }
  function Ce(n, o, c) {
    if (Zn && typeof Zn.onCommitFiberUnmount == "function")
      try {
        Zn.onCommitFiberUnmount(go, c);
      } catch {
      }
    switch (c.tag) {
      case 26:
        Cn || ml(c, o), Jl(
          n,
          o,
          c
        ), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
        break;
      case 27:
        Cn || ml(c, o);
        var m = vn, b = Ci;
        Xr(c.type) && (vn = c.stateNode, Ci = !1), Jl(
          n,
          o,
          c
        ), Ha(c.stateNode), vn = m, Ci = b;
        break;
      case 5:
        Cn || ml(c, o);
      case 6:
        if (m = vn, b = Ci, vn = null, Jl(
          n,
          o,
          c
        ), vn = m, Ci = b, vn !== null)
          if (Ci)
            try {
              (vn.nodeType === 9 ? vn.body : vn.nodeName === "HTML" ? vn.ownerDocument.body : vn).removeChild(c.stateNode);
            } catch (x) {
              Je(
                c,
                o,
                x
              );
            }
          else
            try {
              vn.removeChild(c.stateNode);
            } catch (x) {
              Je(
                c,
                o,
                x
              );
            }
        break;
      case 18:
        vn !== null && (Ci ? (n = vn, Zm(
          n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n,
          c.stateNode
        ), os(n)) : Zm(vn, c.stateNode));
        break;
      case 4:
        m = vn, b = Ci, vn = c.stateNode.containerInfo, Ci = !0, Jl(
          n,
          o,
          c
        ), vn = m, Ci = b;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Cn || Br(2, c, o), Cn || Br(4, c, o), Jl(
          n,
          o,
          c
        );
        break;
      case 1:
        Cn || (ml(c, o), m = c.stateNode, typeof m.componentWillUnmount == "function" && _g(
          c,
          o,
          m
        )), Jl(
          n,
          o,
          c
        );
        break;
      case 21:
        Jl(
          n,
          o,
          c
        );
        break;
      case 22:
        Cn = (m = Cn) || c.memoizedState !== null, Jl(
          n,
          o,
          c
        ), Cn = m;
        break;
      default:
        Jl(
          n,
          o,
          c
        );
    }
  }
  function Mm(n, o) {
    if (o.memoizedState === null && (n = o.alternate, n !== null && (n = n.memoizedState, n !== null && (n = n.dehydrated, n !== null))))
      try {
        os(n);
      } catch (c) {
        Je(o, o.return, c);
      }
  }
  function wg(n) {
    switch (n.tag) {
      case 13:
      case 19:
        var o = n.stateNode;
        return o === null && (o = n.stateNode = new wm()), o;
      case 22:
        return n = n.stateNode, o = n._retryCache, o === null && (o = n._retryCache = new wm()), o;
      default:
        throw Error(u(435, n.tag));
    }
  }
  function Em(n, o) {
    var c = wg(n);
    o.forEach(function(m) {
      var b = U0.bind(null, n, m);
      c.has(m) || (c.add(m), m.then(b, b));
    });
  }
  function la(n, o) {
    var c = o.deletions;
    if (c !== null)
      for (var m = 0; m < c.length; m++) {
        var b = c[m], x = n, R = o, U = R;
        t: for (; U !== null; ) {
          switch (U.tag) {
            case 27:
              if (Xr(U.type)) {
                vn = U.stateNode, Ci = !1;
                break t;
              }
              break;
            case 5:
              vn = U.stateNode, Ci = !1;
              break t;
            case 3:
            case 4:
              vn = U.stateNode.containerInfo, Ci = !0;
              break t;
          }
          U = U.return;
        }
        if (vn === null) throw Error(u(160));
        Ce(x, R, b), vn = null, Ci = !1, x = b.alternate, x !== null && (x.return = null), b.return = null;
      }
    if (o.subtreeFlags & 13878)
      for (o = o.child; o !== null; )
        _h(o, n), o = o.sibling;
  }
  var sa = null;
  function _h(n, o) {
    var c = n.alternate, m = n.flags;
    switch (n.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        la(o, n), bi(n), m & 4 && (Br(3, n, n.return), vh(3, n), Br(5, n, n.return));
        break;
      case 1:
        la(o, n), bi(n), m & 512 && (Cn || c === null || ml(c, c.return)), m & 64 && Wl && (n = n.updateQueue, n !== null && (m = n.callbacks, m !== null && (c = n.shared.hiddenCallbacks, n.shared.hiddenCallbacks = c === null ? m : c.concat(m))));
        break;
      case 26:
        var b = sa;
        if (la(o, n), bi(n), m & 512 && (Cn || c === null || ml(c, c.return)), m & 4) {
          var x = c !== null ? c.memoizedState : null;
          if (m = n.memoizedState, c === null)
            if (m === null)
              if (n.stateNode === null) {
                t: {
                  m = n.type, c = n.memoizedProps, b = b.ownerDocument || b;
                  e: switch (m) {
                    case "title":
                      x = b.getElementsByTagName("title")[0], (!x || x[Vt] || x[Pn] || x.namespaceURI === "http://www.w3.org/2000/svg" || x.hasAttribute("itemprop")) && (x = b.createElement(m), b.head.insertBefore(
                        x,
                        b.querySelector("head > title")
                      )), re(x, m, c), x[Pn] = n, Bn(x), m = x;
                      break t;
                    case "link":
                      var R = Ig(
                        "link",
                        "href",
                        b
                      ).get(m + (c.href || ""));
                      if (R) {
                        for (var U = 0; U < R.length; U++)
                          if (x = R[U], x.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && x.getAttribute("rel") === (c.rel == null ? null : c.rel) && x.getAttribute("title") === (c.title == null ? null : c.title) && x.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                            R.splice(U, 1);
                            break e;
                          }
                      }
                      x = b.createElement(m), re(x, m, c), b.head.appendChild(x);
                      break;
                    case "meta":
                      if (R = Ig(
                        "meta",
                        "content",
                        b
                      ).get(m + (c.content || ""))) {
                        for (U = 0; U < R.length; U++)
                          if (x = R[U], x.getAttribute("content") === (c.content == null ? null : "" + c.content) && x.getAttribute("name") === (c.name == null ? null : c.name) && x.getAttribute("property") === (c.property == null ? null : c.property) && x.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && x.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                            R.splice(U, 1);
                            break e;
                          }
                      }
                      x = b.createElement(m), re(x, m, c), b.head.appendChild(x);
                      break;
                    default:
                      throw Error(u(468, m));
                  }
                  x[Pn] = n, Bn(x), m = x;
                }
                n.stateNode = m;
              } else
                $g(
                  b,
                  n.type,
                  n.stateNode
                );
            else
              n.stateNode = a_(
                b,
                m,
                n.memoizedProps
              );
          else
            x !== m ? (x === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : x.count--, m === null ? $g(
              b,
              n.type,
              n.stateNode
            ) : a_(
              b,
              m,
              n.memoizedProps
            )) : m === null && n.stateNode !== null && bg(
              n,
              n.memoizedProps,
              c.memoizedProps
            );
        }
        break;
      case 27:
        la(o, n), bi(n), m & 512 && (Cn || c === null || ml(c, c.return)), c !== null && m & 4 && bg(
          n,
          n.memoizedProps,
          c.memoizedProps
        );
        break;
      case 5:
        if (la(o, n), bi(n), m & 512 && (Cn || c === null || ml(c, c.return)), n.flags & 32) {
          b = n.stateNode;
          try {
            To(b, "");
          } catch (st) {
            Je(n, n.return, st);
          }
        }
        m & 4 && n.stateNode != null && (b = n.memoizedProps, bg(
          n,
          b,
          c !== null ? c.memoizedProps : b
        )), m & 1024 && (xm = !0);
        break;
      case 6:
        if (la(o, n), bi(n), m & 4) {
          if (n.stateNode === null)
            throw Error(u(162));
          m = n.memoizedProps, c = n.stateNode;
          try {
            c.nodeValue = m;
          } catch (st) {
            Je(n, n.return, st);
          }
        }
        break;
      case 3:
        if (Jr = null, b = sa, sa = Vm(o.containerInfo), la(o, n), sa = b, bi(n), m & 4 && c !== null && c.memoizedState.isDehydrated)
          try {
            os(o.containerInfo);
          } catch (st) {
            Je(n, n.return, st);
          }
        xm && (xm = !1, Mg(n));
        break;
      case 4:
        m = sa, sa = Vm(
          n.stateNode.containerInfo
        ), la(o, n), bi(n), sa = m;
        break;
      case 12:
        la(o, n), bi(n);
        break;
      case 13:
        la(o, n), bi(n), n.child.flags & 8192 && n.memoizedState !== null != (c !== null && c.memoizedState !== null) && (Lg = En()), m & 4 && (m = n.updateQueue, m !== null && (n.updateQueue = null, Em(n, m)));
        break;
      case 22:
        b = n.memoizedState !== null;
        var Z = c !== null && c.memoizedState !== null, it = Wl, vt = Cn;
        if (Wl = it || b, Cn = vt || Z, la(o, n), Cn = vt, Wl = it, bi(n), m & 8192)
          t: for (o = n.stateNode, o._visibility = b ? o._visibility & -2 : o._visibility | 1, b && (c === null || Z || Wl || Cn || _n(n)), c = null, o = n; ; ) {
            if (o.tag === 5 || o.tag === 26) {
              if (c === null) {
                Z = c = o;
                try {
                  if (x = Z.stateNode, b)
                    R = x.style, typeof R.setProperty == "function" ? R.setProperty("display", "none", "important") : R.display = "none";
                  else {
                    U = Z.stateNode;
                    var St = Z.memoizedProps.style, ot = St != null && St.hasOwnProperty("display") ? St.display : null;
                    U.style.display = ot == null || typeof ot == "boolean" ? "" : ("" + ot).trim();
                  }
                } catch (st) {
                  Je(Z, Z.return, st);
                }
              }
            } else if (o.tag === 6) {
              if (c === null) {
                Z = o;
                try {
                  Z.stateNode.nodeValue = b ? "" : Z.memoizedProps;
                } catch (st) {
                  Je(Z, Z.return, st);
                }
              }
            } else if ((o.tag !== 22 && o.tag !== 23 || o.memoizedState === null || o === n) && o.child !== null) {
              o.child.return = o, o = o.child;
              continue;
            }
            if (o === n) break t;
            for (; o.sibling === null; ) {
              if (o.return === null || o.return === n) break t;
              c === o && (c = null), o = o.return;
            }
            c === o && (c = null), o.sibling.return = o.return, o = o.sibling;
          }
        m & 4 && (m = n.updateQueue, m !== null && (c = m.retryQueue, c !== null && (m.retryQueue = null, Em(n, c))));
        break;
      case 19:
        la(o, n), bi(n), m & 4 && (m = n.updateQueue, m !== null && (n.updateQueue = null, Em(n, m)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        la(o, n), bi(n);
    }
  }
  function bi(n) {
    var o = n.flags;
    if (o & 2) {
      try {
        for (var c, m = n.return; m !== null; ) {
          if (qv(m)) {
            c = m;
            break;
          }
          m = m.return;
        }
        if (c == null) throw Error(u(160));
        switch (c.tag) {
          case 27:
            var b = c.stateNode, x = Bo(n);
            Sm(n, x, b);
            break;
          case 5:
            var R = c.stateNode;
            c.flags & 32 && (To(R, ""), c.flags &= -33);
            var U = Bo(n);
            Sm(n, U, R);
            break;
          case 3:
          case 4:
            var Z = c.stateNode.containerInfo, it = Bo(n);
            Bu(
              n,
              it,
              Z
            );
            break;
          default:
            throw Error(u(161));
        }
      } catch (vt) {
        Je(n, n.return, vt);
      }
      n.flags &= -3;
    }
    o & 4096 && (n.flags &= -4097);
  }
  function Mg(n) {
    if (n.subtreeFlags & 1024)
      for (n = n.child; n !== null; ) {
        var o = n;
        Mg(o), o.tag === 5 && o.flags & 1024 && o.stateNode.reset(), n = n.sibling;
      }
  }
  function Il(n, o) {
    if (o.subtreeFlags & 8772)
      for (o = o.child; o !== null; )
        Tg(n, o.alternate, o), o = o.sibling;
  }
  function _n(n) {
    for (n = n.child; n !== null; ) {
      var o = n;
      switch (o.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Br(4, o, o.return), _n(o);
          break;
        case 1:
          ml(o, o.return);
          var c = o.stateNode;
          typeof c.componentWillUnmount == "function" && _g(
            o,
            o.return,
            c
          ), _n(o);
          break;
        case 27:
          Ha(o.stateNode);
        case 26:
        case 5:
          ml(o, o.return), _n(o);
          break;
        case 22:
          o.memoizedState === null && _n(o);
          break;
        case 30:
          _n(o);
          break;
        default:
          _n(o);
      }
      n = n.sibling;
    }
  }
  function Yr(n, o, c) {
    for (c = c && (o.subtreeFlags & 8772) !== 0, o = o.child; o !== null; ) {
      var m = o.alternate, b = n, x = o, R = x.flags;
      switch (x.tag) {
        case 0:
        case 11:
        case 15:
          Yr(
            b,
            x,
            c
          ), vh(4, x);
          break;
        case 1:
          if (Yr(
            b,
            x,
            c
          ), m = x, b = m.stateNode, typeof b.componentDidMount == "function")
            try {
              b.componentDidMount();
            } catch (it) {
              Je(m, m.return, it);
            }
          if (m = x, b = m.updateQueue, b !== null) {
            var U = m.stateNode;
            try {
              var Z = b.shared.hiddenCallbacks;
              if (Z !== null)
                for (b.shared.hiddenCallbacks = null, b = 0; b < Z.length; b++)
                  Zd(Z[b], U);
            } catch (it) {
              Je(m, m.return, it);
            }
          }
          c && R & 64 && bm(x), Bc(x, x.return);
          break;
        case 27:
          Tm(x);
        case 26:
        case 5:
          Yr(
            b,
            x,
            c
          ), c && m === null && R & 4 && Yc(x), Bc(x, x.return);
          break;
        case 12:
          Yr(
            b,
            x,
            c
          );
          break;
        case 13:
          Yr(
            b,
            x,
            c
          ), c && R & 4 && Mm(b, x);
          break;
        case 22:
          x.memoizedState === null && Yr(
            b,
            x,
            c
          ), Bc(x, x.return);
          break;
        case 30:
          break;
        default:
          Yr(
            b,
            x,
            c
          );
      }
      o = o.sibling;
    }
  }
  function Yo(n, o) {
    var c = null;
    n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (c = n.memoizedState.cachePool.pool), n = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (n = o.memoizedState.cachePool.pool), n !== c && (n != null && n.refCount++, c != null && Bl(c));
  }
  function Om(n, o) {
    n = null, o.alternate !== null && (n = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== n && (o.refCount++, n != null && Bl(n));
  }
  function zi(n, o, c, m) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; )
        Eg(
          n,
          o,
          c,
          m
        ), o = o.sibling;
  }
  function Eg(n, o, c, m) {
    var b = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        zi(
          n,
          o,
          c,
          m
        ), b & 2048 && vh(9, o);
        break;
      case 1:
        zi(
          n,
          o,
          c,
          m
        );
        break;
      case 3:
        zi(
          n,
          o,
          c,
          m
        ), b & 2048 && (n = null, o.alternate !== null && (n = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== n && (o.refCount++, n != null && Bl(n)));
        break;
      case 12:
        if (b & 2048) {
          zi(
            n,
            o,
            c,
            m
          ), n = o.stateNode;
          try {
            var x = o.memoizedProps, R = x.id, U = x.onPostCommit;
            typeof U == "function" && U(
              R,
              o.alternate === null ? "mount" : "update",
              n.passiveEffectDuration,
              -0
            );
          } catch (Z) {
            Je(o, o.return, Z);
          }
        } else
          zi(
            n,
            o,
            c,
            m
          );
        break;
      case 13:
        zi(
          n,
          o,
          c,
          m
        );
        break;
      case 23:
        break;
      case 22:
        x = o.stateNode, R = o.alternate, o.memoizedState !== null ? x._visibility & 2 ? zi(
          n,
          o,
          c,
          m
        ) : qe(n, o) : x._visibility & 2 ? zi(
          n,
          o,
          c,
          m
        ) : (x._visibility |= 2, Gs(
          n,
          o,
          c,
          m,
          (o.subtreeFlags & 10256) !== 0
        )), b & 2048 && Yo(R, o);
        break;
      case 24:
        zi(
          n,
          o,
          c,
          m
        ), b & 2048 && Om(o.alternate, o);
        break;
      default:
        zi(
          n,
          o,
          c,
          m
        );
    }
  }
  function Gs(n, o, c, m, b) {
    for (b = b && (o.subtreeFlags & 10256) !== 0, o = o.child; o !== null; ) {
      var x = n, R = o, U = c, Z = m, it = R.flags;
      switch (R.tag) {
        case 0:
        case 11:
        case 15:
          Gs(
            x,
            R,
            U,
            Z,
            b
          ), vh(8, R);
          break;
        case 23:
          break;
        case 22:
          var vt = R.stateNode;
          R.memoizedState !== null ? vt._visibility & 2 ? Gs(
            x,
            R,
            U,
            Z,
            b
          ) : qe(
            x,
            R
          ) : (vt._visibility |= 2, Gs(
            x,
            R,
            U,
            Z,
            b
          )), b && it & 2048 && Yo(
            R.alternate,
            R
          );
          break;
        case 24:
          Gs(
            x,
            R,
            U,
            Z,
            b
          ), b && it & 2048 && Om(R.alternate, R);
          break;
        default:
          Gs(
            x,
            R,
            U,
            Z,
            b
          );
      }
      o = o.sibling;
    }
  }
  function qe(n, o) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; ) {
        var c = n, m = o, b = m.flags;
        switch (m.tag) {
          case 22:
            qe(c, m), b & 2048 && Yo(
              m.alternate,
              m
            );
            break;
          case 24:
            qe(c, m), b & 2048 && Om(m.alternate, m);
            break;
          default:
            qe(c, m);
        }
        o = o.sibling;
      }
  }
  var Yu = 8192;
  function zn(n) {
    if (n.subtreeFlags & Yu)
      for (n = n.child; n !== null; )
        Zv(n), n = n.sibling;
  }
  function Zv(n) {
    switch (n.tag) {
      case 26:
        zn(n), n.flags & Yu && n.memoizedState !== null && s_(
          sa,
          n.memoizedState,
          n.memoizedProps
        );
        break;
      case 5:
        zn(n);
        break;
      case 3:
      case 4:
        var o = sa;
        sa = Vm(n.stateNode.containerInfo), zn(n), sa = o;
        break;
      case 22:
        n.memoizedState === null && (o = n.alternate, o !== null && o.memoizedState !== null ? (o = Yu, Yu = 16777216, zn(n), Yu = o) : zn(n));
        break;
      default:
        zn(n);
    }
  }
  function Og(n) {
    var o = n.alternate;
    if (o !== null && (n = o.child, n !== null)) {
      o.child = null;
      do
        o = n.sibling, n.sibling = null, n = o;
      while (n !== null);
    }
  }
  function ju(n) {
    var o = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (o !== null)
        for (var c = 0; c < o.length; c++) {
          var m = o[c];
          ai = m, Dg(
            m,
            n
          );
        }
      Og(n);
    }
    if (n.subtreeFlags & 10256)
      for (n = n.child; n !== null; )
        Ag(n), n = n.sibling;
  }
  function Ag(n) {
    switch (n.tag) {
      case 0:
      case 11:
      case 15:
        ju(n), n.flags & 2048 && Br(9, n, n.return);
        break;
      case 3:
        ju(n);
        break;
      case 12:
        ju(n);
        break;
      case 22:
        var o = n.stateNode;
        n.memoizedState !== null && o._visibility & 2 && (n.return === null || n.return.tag !== 13) ? (o._visibility &= -3, ra(n)) : ju(n);
        break;
      default:
        ju(n);
    }
  }
  function ra(n) {
    var o = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (o !== null)
        for (var c = 0; c < o.length; c++) {
          var m = o[c];
          ai = m, Dg(
            m,
            n
          );
        }
      Og(n);
    }
    for (n = n.child; n !== null; ) {
      switch (o = n, o.tag) {
        case 0:
        case 11:
        case 15:
          Br(8, o, o.return), ra(o);
          break;
        case 22:
          c = o.stateNode, c._visibility & 2 && (c._visibility &= -3, ra(o));
          break;
        default:
          ra(o);
      }
      n = n.sibling;
    }
  }
  function Dg(n, o) {
    for (; ai !== null; ) {
      var c = ai;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          Br(8, c, o);
          break;
        case 23:
        case 22:
          if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
            var m = c.memoizedState.cachePool.pool;
            m != null && m.refCount++;
          }
          break;
        case 24:
          Bl(c.memoizedState.cache);
      }
      if (m = c.child, m !== null) m.return = c, ai = m;
      else
        t: for (c = n; ai !== null; ) {
          m = ai;
          var b = m.sibling, x = m.return;
          if (xg(m), m === c) {
            ai = null;
            break t;
          }
          if (b !== null) {
            b.return = x, ai = b;
            break t;
          }
          ai = x;
        }
    }
  }
  var Rg = {
    getCacheForType: function(n) {
      var o = yi(ei), c = o.data.get(n);
      return c === void 0 && (c = n(), o.data.set(n, c)), c;
    }
  }, Vv = typeof WeakMap == "function" ? WeakMap : Map, Qe = 0, sn = null, Le = null, He = 0, Ke = 0, Ca = null, $l = !1, jc = !1, Cg = !1, Xs = 0, Ln = 0, Qs = 0, qu = 0, Fl = 0, jo = 0, qc = 0, Zc = null, za = null, zg = !1, Lg = 0, Am = 1 / 0, Vc = null, jr = null, Li = 0, ts = null, Pc = null, Hi = 0, Dm = 0, Rm = null, Hg = null, Gc = 0, kg = null;
  function oo() {
    if ((Qe & 2) !== 0 && He !== 0)
      return He & -He;
    if (P.T !== null) {
      var n = ko;
      return n !== 0 ? n : Gu();
    }
    return pc();
  }
  function Ng() {
    jo === 0 && (jo = (He & 536870912) === 0 || oe ? Dt() : 536870912);
    var n = ao.current;
    return n !== null && (n.flags |= 32), jo;
  }
  function lo(n, o, c) {
    (n === sn && (Ke === 2 || Ke === 9) || n.cancelPendingCommit !== null) && (es(n, 0), Ks(
      n,
      He,
      jo,
      !1
    )), se(n, c), ((Qe & 2) === 0 || n !== sn) && (n === sn && ((Qe & 2) === 0 && (qu |= c), Ln === 4 && Ks(
      n,
      He,
      jo,
      !1
    )), La(n));
  }
  function Xc(n, o, c) {
    if ((Qe & 6) !== 0) throw Error(u(327));
    var m = !c && (o & 124) === 0 && (o & n.expiredLanes) === 0 || N(n, o), b = m ? Bg(n, o) : Cm(n, o, !0), x = m;
    do {
      if (b === 0) {
        jc && !m && Ks(n, o, 0, !1);
        break;
      } else {
        if (c = n.current.alternate, x && !Pv(c)) {
          b = Cm(n, o, !1), x = !1;
          continue;
        }
        if (b === 2) {
          if (x = o, n.errorRecoveryDisabledLanes & x)
            var R = 0;
          else
            R = n.pendingLanes & -536870913, R = R !== 0 ? R : R & 536870912 ? 536870912 : 0;
          if (R !== 0) {
            o = R;
            t: {
              var U = n;
              b = Zc;
              var Z = U.current.memoizedState.isDehydrated;
              if (Z && (es(U, R).flags |= 256), R = Cm(
                U,
                R,
                !1
              ), R !== 2) {
                if (Cg && !Z) {
                  U.errorRecoveryDisabledLanes |= x, qu |= x, b = 4;
                  break t;
                }
                x = za, za = b, x !== null && (za === null ? za = x : za.push.apply(
                  za,
                  x
                ));
              }
              b = R;
            }
            if (x = !1, b !== 2) continue;
          }
        }
        if (b === 1) {
          es(n, 0), Ks(n, o, 0, !0);
          break;
        }
        t: {
          switch (m = n, x = b, x) {
            case 0:
            case 1:
              throw Error(u(345));
            case 4:
              if ((o & 4194048) !== o) break;
            case 6:
              Ks(
                m,
                o,
                jo,
                !$l
              );
              break t;
            case 2:
              za = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(u(329));
          }
          if ((o & 62914560) === o && (b = Lg + 300 - En(), 10 < b)) {
            if (Ks(
              m,
              o,
              jo,
              !$l
            ), Pa(m, 0, !0) !== 0) break t;
            m.timeoutHandle = qm(
              bh.bind(
                null,
                m,
                c,
                za,
                Vc,
                zg,
                o,
                jo,
                qu,
                qc,
                $l,
                x,
                2,
                -0,
                0
              ),
              b
            );
            break t;
          }
          bh(
            m,
            c,
            za,
            Vc,
            zg,
            o,
            jo,
            qu,
            qc,
            $l,
            x,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    La(n);
  }
  function bh(n, o, c, m, b, x, R, U, Z, it, vt, St, ot, st) {
    if (n.timeoutHandle = -1, St = o.subtreeFlags, (St & 8192 || (St & 16785408) === 16785408) && (of = { stylesheets: null, count: 0, unsuspend: l_ }, Zv(o), St = ty(), St !== null)) {
      n.cancelPendingCommit = St(
        Qv.bind(
          null,
          n,
          o,
          x,
          c,
          m,
          b,
          R,
          U,
          Z,
          vt,
          1,
          ot,
          st
        )
      ), Ks(n, x, R, !it);
      return;
    }
    Qv(
      n,
      o,
      x,
      c,
      m,
      b,
      R,
      U,
      Z
    );
  }
  function Pv(n) {
    for (var o = n; ; ) {
      var c = o.tag;
      if ((c === 0 || c === 11 || c === 15) && o.flags & 16384 && (c = o.updateQueue, c !== null && (c = c.stores, c !== null)))
        for (var m = 0; m < c.length; m++) {
          var b = c[m], x = b.getSnapshot;
          b = b.value;
          try {
            if (!ti(x(), b)) return !1;
          } catch {
            return !1;
          }
        }
      if (c = o.child, o.subtreeFlags & 16384 && c !== null)
        c.return = o, o = c;
      else {
        if (o === n) break;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === n) return !0;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
    }
    return !0;
  }
  function Ks(n, o, c, m) {
    o &= ~Fl, o &= ~qu, n.suspendedLanes |= o, n.pingedLanes &= ~o, m && (n.warmLanes |= o), m = n.expirationTimes;
    for (var b = o; 0 < b; ) {
      var x = 31 - In(b), R = 1 << x;
      m[x] = -1, b &= ~R;
    }
    c !== 0 && ze(n, c, o);
  }
  function Zu() {
    return (Qe & 6) === 0 ? (wh(0), !1) : !0;
  }
  function qr() {
    if (Le !== null) {
      if (Ke === 0)
        var n = Le.return;
      else
        n = Le, eo = Ea = null, Xd(n), zu = null, Lc = 0, n = Le;
      for (; n !== null; )
        vg(n.alternate, n), n = n.return;
      Le = null;
    }
  }
  function es(n, o) {
    var c = n.timeoutHandle;
    c !== -1 && (n.timeoutHandle = -1, q0(c)), c = n.cancelPendingCommit, c !== null && (n.cancelPendingCommit = null, c()), qr(), sn = n, Le = c = Ma(n.current, null), He = o, Ke = 0, Ca = null, $l = !1, jc = N(n, o), Cg = !1, qc = jo = Fl = qu = Qs = Ln = 0, za = Zc = null, zg = !1, (o & 8) !== 0 && (o |= o & 32);
    var m = n.entangledLanes;
    if (m !== 0)
      for (n = n.entanglements, m &= o; 0 < m; ) {
        var b = 31 - In(m), x = 1 << b;
        o |= n[b], m &= ~x;
      }
    return Xs = o, wa(), c;
  }
  function Ug(n, o) {
    ve = null, P.H = sm, o === Cr || o === Jf ? (o = qp(), Ke = 3) : o === Ud ? (o = qp(), Ke = 4) : Ke = o === Rn ? 8 : o !== null && typeof o == "object" && typeof o.then == "function" ? 6 : 1, Ca = o, Le === null && (Ln = 1, mh(
      n,
      Zi(o, n.current)
    ));
  }
  function Gv() {
    var n = P.H;
    return P.H = sm, n === null ? sm : n;
  }
  function Vu() {
    var n = P.A;
    return P.A = Rg, n;
  }
  function Pu() {
    Ln = 4, $l || (He & 4194048) !== He && ao.current !== null || (jc = !0), (Qs & 134217727) === 0 && (qu & 134217727) === 0 || sn === null || Ks(
      sn,
      He,
      jo,
      !1
    );
  }
  function Cm(n, o, c) {
    var m = Qe;
    Qe |= 2;
    var b = Gv(), x = Vu();
    (sn !== n || He !== o) && (Vc = null, es(n, o)), o = !1;
    var R = Ln;
    t: do
      try {
        if (Ke !== 0 && Le !== null) {
          var U = Le, Z = Ca;
          switch (Ke) {
            case 8:
              qr(), R = 6;
              break t;
            case 3:
            case 2:
            case 9:
            case 6:
              ao.current === null && (o = !0);
              var it = Ke;
              if (Ke = 0, Ca = null, Qc(n, U, Z, it), c && jc) {
                R = 0;
                break t;
              }
              break;
            default:
              it = Ke, Ke = 0, Ca = null, Qc(n, U, Z, it);
          }
        }
        zm(), R = Ln;
        break;
      } catch (vt) {
        Ug(n, vt);
      }
    while (!0);
    return o && n.shellSuspendCounter++, eo = Ea = null, Qe = m, P.H = b, P.A = x, Le === null && (sn = null, He = 0, wa()), R;
  }
  function zm() {
    for (; Le !== null; ) jg(Le);
  }
  function Bg(n, o) {
    var c = Qe;
    Qe |= 2;
    var m = Gv(), b = Vu();
    sn !== n || He !== o ? (Vc = null, Am = En() + 500, es(n, o)) : jc = N(
      n,
      o
    );
    t: do
      try {
        if (Ke !== 0 && Le !== null) {
          o = Le;
          var x = Ca;
          e: switch (Ke) {
            case 1:
              Ke = 0, Ca = null, Qc(n, o, x, 1);
              break;
            case 2:
            case 9:
              if (Yd(x)) {
                Ke = 0, Ca = null, qg(o);
                break;
              }
              o = function() {
                Ke !== 2 && Ke !== 9 || sn !== n || (Ke = 7), La(n);
              }, x.then(o, o);
              break t;
            case 3:
              Ke = 7;
              break t;
            case 4:
              Ke = 5;
              break t;
            case 7:
              Yd(x) ? (Ke = 0, Ca = null, qg(o)) : (Ke = 0, Ca = null, Qc(n, o, x, 7));
              break;
            case 5:
              var R = null;
              switch (Le.tag) {
                case 26:
                  R = Le.memoizedState;
                case 5:
                case 27:
                  var U = Le;
                  if (!R || Fg(R)) {
                    Ke = 0, Ca = null;
                    var Z = U.sibling;
                    if (Z !== null) Le = Z;
                    else {
                      var it = U.return;
                      it !== null ? (Le = it, Sh(it)) : Le = null;
                    }
                    break e;
                  }
              }
              Ke = 0, Ca = null, Qc(n, o, x, 5);
              break;
            case 6:
              Ke = 0, Ca = null, Qc(n, o, x, 6);
              break;
            case 8:
              qr(), Ln = 6;
              break t;
            default:
              throw Error(u(462));
          }
        }
        Yg();
        break;
      } catch (vt) {
        Ug(n, vt);
      }
    while (!0);
    return eo = Ea = null, P.H = m, P.A = b, Qe = c, Le !== null ? 0 : (sn = null, He = 0, wa(), Ln);
  }
  function Yg() {
    for (; Le !== null && !cr(); )
      jg(Le);
  }
  function jg(n) {
    var o = jv(n.alternate, n, Xs);
    n.memoizedProps = n.pendingProps, o === null ? Sh(n) : Le = o;
  }
  function qg(n) {
    var o = n, c = o.alternate;
    switch (o.tag) {
      case 15:
      case 0:
        o = dg(
          c,
          o,
          o.pendingProps,
          o.type,
          void 0,
          He
        );
        break;
      case 11:
        o = dg(
          c,
          o,
          o.pendingProps,
          o.type.render,
          o.ref,
          He
        );
        break;
      case 5:
        Xd(o);
      default:
        vg(c, o), o = Le = ye(o, Xs), o = jv(c, o, Xs);
    }
    n.memoizedProps = n.pendingProps, o === null ? Sh(n) : Le = o;
  }
  function Qc(n, o, c, m) {
    eo = Ea = null, Xd(o), zu = null, Lc = 0;
    var b = o.return;
    try {
      if (Uv(
        n,
        b,
        o,
        c,
        He
      )) {
        Ln = 1, mh(
          n,
          Zi(c, n.current)
        ), Le = null;
        return;
      }
    } catch (x) {
      if (b !== null) throw Le = b, x;
      Ln = 1, mh(
        n,
        Zi(c, n.current)
      ), Le = null;
      return;
    }
    o.flags & 32768 ? (oe || m === 1 ? n = !0 : jc || (He & 536870912) !== 0 ? n = !1 : ($l = n = !0, (m === 2 || m === 9 || m === 3 || m === 6) && (m = ao.current, m !== null && m.tag === 13 && (m.flags |= 16384))), Xv(o, n)) : Sh(o);
  }
  function Sh(n) {
    var o = n;
    do {
      if ((o.flags & 32768) !== 0) {
        Xv(
          o,
          $l
        );
        return;
      }
      n = o.return;
      var c = yg(
        o.alternate,
        o,
        Xs
      );
      if (c !== null) {
        Le = c;
        return;
      }
      if (o = o.sibling, o !== null) {
        Le = o;
        return;
      }
      Le = o = n;
    } while (o !== null);
    Ln === 0 && (Ln = 5);
  }
  function Xv(n, o) {
    do {
      var c = k0(n.alternate, n);
      if (c !== null) {
        c.flags &= 32767, Le = c;
        return;
      }
      if (c = n.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !o && (n = n.sibling, n !== null)) {
        Le = n;
        return;
      }
      Le = n = c;
    } while (n !== null);
    Ln = 6, Le = null;
  }
  function Qv(n, o, c, m, b, x, R, U, Z) {
    n.cancelPendingCommit = null;
    do
      Hm();
    while (Li !== 0);
    if ((Qe & 6) !== 0) throw Error(u(327));
    if (o !== null) {
      if (o === n.current) throw Error(u(177));
      if (x = o.lanes | o.childLanes, x |= Gn, he(
        n,
        c,
        x,
        R,
        U,
        Z
      ), n === sn && (Le = sn = null, He = 0), Pc = o, ts = n, Hi = c, Dm = x, Rm = b, Hg = m, (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? (n.callbackNode = null, n.callbackPriority = 0, B0(pa, function() {
        return Zg(), null;
      })) : (n.callbackNode = null, n.callbackPriority = 0), m = (o.flags & 13878) !== 0, (o.subtreeFlags & 13878) !== 0 || m) {
        m = P.T, P.T = null, b = dt.p, dt.p = 2, R = Qe, Qe |= 4;
        try {
          Sg(n, o, c);
        } finally {
          Qe = R, dt.p = b, P.T = m;
        }
      }
      Li = 1, Kv(), Th(), Lm();
    }
  }
  function Kv() {
    if (Li === 1) {
      Li = 0;
      var n = ts, o = Pc, c = (o.flags & 13878) !== 0;
      if ((o.subtreeFlags & 13878) !== 0 || c) {
        c = P.T, P.T = null;
        var m = dt.p;
        dt.p = 2;
        var b = Qe;
        Qe |= 4;
        try {
          _h(o, n);
          var x = zh, R = xr(n.containerInfo), U = x.focusedElem, Z = x.selectionRange;
          if (R !== U && U && U.ownerDocument && Ls(
            U.ownerDocument.documentElement,
            U
          )) {
            if (Z !== null && Hs(U)) {
              var it = Z.start, vt = Z.end;
              if (vt === void 0 && (vt = it), "selectionStart" in U)
                U.selectionStart = it, U.selectionEnd = Math.min(
                  vt,
                  U.value.length
                );
              else {
                var St = U.ownerDocument || document, ot = St && St.defaultView || window;
                if (ot.getSelection) {
                  var st = ot.getSelection(), Ft = U.textContent.length, te = Math.min(Z.start, Ft), Ze = Z.end === void 0 ? te : Math.min(Z.end, Ft);
                  !st.extend && te > Ze && (R = Ze, Ze = te, te = R);
                  var tt = tn(
                    U,
                    te
                  ), W = tn(
                    U,
                    Ze
                  );
                  if (tt && W && (st.rangeCount !== 1 || st.anchorNode !== tt.node || st.anchorOffset !== tt.offset || st.focusNode !== W.node || st.focusOffset !== W.offset)) {
                    var nt = St.createRange();
                    nt.setStart(tt.node, tt.offset), st.removeAllRanges(), te > Ze ? (st.addRange(nt), st.extend(W.node, W.offset)) : (nt.setEnd(W.node, W.offset), st.addRange(nt));
                  }
                }
              }
            }
            for (St = [], st = U; st = st.parentNode; )
              st.nodeType === 1 && St.push({
                element: st,
                left: st.scrollLeft,
                top: st.scrollTop
              });
            for (typeof U.focus == "function" && U.focus(), U = 0; U < St.length; U++) {
              var _t = St[U];
              _t.element.scrollLeft = _t.left, _t.element.scrollTop = _t.top;
            }
          }
          Uh = !!Ch, zh = Ch = null;
        } finally {
          Qe = b, dt.p = m, P.T = c;
        }
      }
      n.current = o, Li = 2;
    }
  }
  function Th() {
    if (Li === 2) {
      Li = 0;
      var n = ts, o = Pc, c = (o.flags & 8772) !== 0;
      if ((o.subtreeFlags & 8772) !== 0 || c) {
        c = P.T, P.T = null;
        var m = dt.p;
        dt.p = 2;
        var b = Qe;
        Qe |= 4;
        try {
          Tg(n, o.alternate, o);
        } finally {
          Qe = b, dt.p = m, P.T = c;
        }
      }
      Li = 3;
    }
  }
  function Lm() {
    if (Li === 4 || Li === 3) {
      Li = 0, Tn();
      var n = ts, o = Pc, c = Hi, m = Hg;
      (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? Li = 5 : (Li = 0, Pc = ts = null, Wv(n, n.pendingLanes));
      var b = n.pendingLanes;
      if (b === 0 && (jr = null), Ga(c), o = o.stateNode, Zn && typeof Zn.onCommitFiberRoot == "function")
        try {
          Zn.onCommitFiberRoot(
            go,
            o,
            void 0,
            (o.current.flags & 128) === 128
          );
        } catch {
        }
      if (m !== null) {
        o = P.T, b = dt.p, dt.p = 2, P.T = null;
        try {
          for (var x = n.onRecoverableError, R = 0; R < m.length; R++) {
            var U = m[R];
            x(U.value, {
              componentStack: U.stack
            });
          }
        } finally {
          P.T = o, dt.p = b;
        }
      }
      (Hi & 3) !== 0 && Hm(), La(n), b = n.pendingLanes, (c & 4194090) !== 0 && (b & 42) !== 0 ? n === kg ? Gc++ : (Gc = 0, kg = n) : Gc = 0, wh(0);
    }
  }
  function Wv(n, o) {
    (n.pooledCacheLanes &= o) === 0 && (o = n.pooledCache, o != null && (n.pooledCache = null, Bl(o)));
  }
  function Hm(n) {
    return Kv(), Th(), Lm(), Zg();
  }
  function Zg() {
    if (Li !== 5) return !1;
    var n = ts, o = Dm;
    Dm = 0;
    var c = Ga(Hi), m = P.T, b = dt.p;
    try {
      dt.p = 32 > c ? 32 : c, P.T = null, c = Rm, Rm = null;
      var x = ts, R = Hi;
      if (Li = 0, Pc = ts = null, Hi = 0, (Qe & 6) !== 0) throw Error(u(331));
      var U = Qe;
      if (Qe |= 4, Ag(x.current), Eg(
        x,
        x.current,
        R,
        c
      ), Qe = U, wh(0, !1), Zn && typeof Zn.onPostCommitFiberRoot == "function")
        try {
          Zn.onPostCommitFiberRoot(go, x);
        } catch {
        }
      return !0;
    } finally {
      dt.p = b, P.T = m, Wv(n, o);
    }
  }
  function Vg(n, o, c) {
    o = Zi(c, o), o = fg(n.stateNode, o, 2), n = ql(n, o, 2), n !== null && (se(n, 2), La(n));
  }
  function Je(n, o, c) {
    if (n.tag === 3)
      Vg(n, n, c);
    else
      for (; o !== null; ) {
        if (o.tag === 3) {
          Vg(
            o,
            n,
            c
          );
          break;
        } else if (o.tag === 1) {
          var m = o.stateNode;
          if (typeof o.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (jr === null || !jr.has(m))) {
            n = Zi(c, n), c = hg(2), m = ql(o, c, 2), m !== null && (Ra(
              c,
              m,
              o,
              n
            ), se(m, 2), La(m));
            break;
          }
        }
        o = o.return;
      }
  }
  function km(n, o, c) {
    var m = n.pingCache;
    if (m === null) {
      m = n.pingCache = new Vv();
      var b = /* @__PURE__ */ new Set();
      m.set(o, b);
    } else
      b = m.get(o), b === void 0 && (b = /* @__PURE__ */ new Set(), m.set(o, b));
    b.has(c) || (Cg = !0, b.add(c), n = Pg.bind(null, n, o, c), o.then(n, n));
  }
  function Pg(n, o, c) {
    var m = n.pingCache;
    m !== null && m.delete(o), n.pingedLanes |= n.suspendedLanes & c, n.warmLanes &= ~c, sn === n && (He & c) === c && (Ln === 4 || Ln === 3 && (He & 62914560) === He && 300 > En() - Lg ? (Qe & 2) === 0 && es(n, 0) : Fl |= c, qc === He && (qc = 0)), La(n);
  }
  function Gg(n, o) {
    o === 0 && (o = Ht()), n = Lo(n, o), n !== null && (se(n, o), La(n));
  }
  function N0(n) {
    var o = n.memoizedState, c = 0;
    o !== null && (c = o.retryLane), Gg(n, c);
  }
  function U0(n, o) {
    var c = 0;
    switch (n.tag) {
      case 13:
        var m = n.stateNode, b = n.memoizedState;
        b !== null && (c = b.retryLane);
        break;
      case 19:
        m = n.stateNode;
        break;
      case 22:
        m = n.stateNode._retryCache;
        break;
      default:
        throw Error(u(314));
    }
    m !== null && m.delete(o), Gg(n, c);
  }
  function B0(n, o) {
    return ma(n, o);
  }
  var Nm = null, Zr = null, xh = !1, Kc = !1, Um = !1, Vr = 0;
  function La(n) {
    n !== Zr && n.next === null && (Zr === null ? Nm = Zr = n : Zr = Zr.next = n), Kc = !0, xh || (xh = !0, $v());
  }
  function wh(n, o) {
    if (!Um && Kc) {
      Um = !0;
      do
        for (var c = !1, m = Nm; m !== null; ) {
          if (n !== 0) {
            var b = m.pendingLanes;
            if (b === 0) var x = 0;
            else {
              var R = m.suspendedLanes, U = m.pingedLanes;
              x = (1 << 31 - In(42 | n) + 1) - 1, x &= b & ~(R & ~U), x = x & 201326741 ? x & 201326741 | 1 : x ? x | 2 : 0;
            }
            x !== 0 && (c = !0, Eh(m, x));
          } else
            x = He, x = Pa(
              m,
              m === sn ? x : 0,
              m.cancelPendingCommit !== null || m.timeoutHandle !== -1
            ), (x & 3) === 0 || N(m, x) || (c = !0, Eh(m, x));
          m = m.next;
        }
      while (c);
      Um = !1;
    }
  }
  function Jv() {
    Mh();
  }
  function Mh() {
    Kc = xh = !1;
    var n = 0;
    Vr !== 0 && (Is() && (n = Vr), Vr = 0);
    for (var o = En(), c = null, m = Nm; m !== null; ) {
      var b = m.next, x = Xg(m, o);
      x === 0 ? (m.next = null, c === null ? Nm = b : c.next = b, b === null && (Zr = c)) : (c = m, (n !== 0 || (x & 3) !== 0) && (Kc = !0)), m = b;
    }
    wh(n);
  }
  function Xg(n, o) {
    for (var c = n.suspendedLanes, m = n.pingedLanes, b = n.expirationTimes, x = n.pendingLanes & -62914561; 0 < x; ) {
      var R = 31 - In(x), U = 1 << R, Z = b[R];
      Z === -1 ? ((U & c) === 0 || (U & m) !== 0) && (b[R] = $(U, o)) : Z <= o && (n.expiredLanes |= U), x &= ~U;
    }
    if (o = sn, c = He, c = Pa(
      n,
      n === o ? c : 0,
      n.cancelPendingCommit !== null || n.timeoutHandle !== -1
    ), m = n.callbackNode, c === 0 || n === o && (Ke === 2 || Ke === 9) || n.cancelPendingCommit !== null)
      return m !== null && m !== null && ur(m), n.callbackNode = null, n.callbackPriority = 0;
    if ((c & 3) === 0 || N(n, c)) {
      if (o = c & -c, o === n.callbackPriority) return o;
      switch (m !== null && ur(m), Ga(c)) {
        case 2:
        case 8:
          c = pe;
          break;
        case 32:
          c = pa;
          break;
        case 268435456:
          c = po;
          break;
        default:
          c = pa;
      }
      return m = Iv.bind(null, n), c = ma(c, m), n.callbackPriority = o, n.callbackNode = c, o;
    }
    return m !== null && m !== null && ur(m), n.callbackPriority = 2, n.callbackNode = null, 2;
  }
  function Iv(n, o) {
    if (Li !== 0 && Li !== 5)
      return n.callbackNode = null, n.callbackPriority = 0, null;
    var c = n.callbackNode;
    if (Hm() && n.callbackNode !== c)
      return null;
    var m = He;
    return m = Pa(
      n,
      n === sn ? m : 0,
      n.cancelPendingCommit !== null || n.timeoutHandle !== -1
    ), m === 0 ? null : (Xc(n, m, o), Xg(n, En()), n.callbackNode != null && n.callbackNode === c ? Iv.bind(null, n) : null);
  }
  function Eh(n, o) {
    if (Hm()) return null;
    Xc(n, o, !0);
  }
  function $v() {
    Z0(function() {
      (Qe & 6) !== 0 ? ma(
        dc,
        Jv
      ) : Mh();
    });
  }
  function Gu() {
    return Vr === 0 && (Vr = Dt()), Vr;
  }
  function Bm(n) {
    return n == null || typeof n == "symbol" || typeof n == "boolean" ? null : typeof n == "function" ? n : Ts("" + n);
  }
  function Oh(n, o) {
    var c = o.ownerDocument.createElement("input");
    return c.name = o.name, c.value = o.value, n.id && c.setAttribute("form", n.id), o.parentNode.insertBefore(c, o), n = new FormData(n), c.parentNode.removeChild(c), n;
  }
  function Fv(n, o, c, m, b) {
    if (o === "submit" && c && c.stateNode === b) {
      var x = Bm(
        (b[Mi] || null).action
      ), R = m.submitter;
      R && (o = (o = R[Mi] || null) ? Bm(o.formAction) : R.getAttribute("formAction"), o !== null && (x = o, R = null));
      var U = new _u(
        "action",
        "action",
        null,
        m,
        b
      );
      n.push({
        event: U,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (m.defaultPrevented) {
                if (Vr !== 0) {
                  var Z = R ? Oh(b, R) : new FormData(b);
                  lm(
                    c,
                    {
                      pending: !0,
                      data: Z,
                      method: b.method,
                      action: x
                    },
                    null,
                    Z
                  );
                }
              } else
                typeof x == "function" && (U.preventDefault(), Z = R ? Oh(b, R) : new FormData(b), lm(
                  c,
                  {
                    pending: !0,
                    data: Z,
                    method: b.method,
                    action: x
                  },
                  x,
                  Z
                ));
            },
            currentTarget: b
          }
        ]
      });
    }
  }
  for (var Hn = 0; Hn < Co.length; Hn++) {
    var Ah = Co[Hn], Y0 = Ah.toLowerCase(), Me = Ah[0].toUpperCase() + Ah.slice(1);
    xa(
      Y0,
      "on" + Me
    );
  }
  xa(Rd, "onAnimationEnd"), xa(Ta, "onAnimationIteration"), xa(Tu, "onAnimationStart"), xa("dblclick", "onDoubleClick"), xa("focusin", "onFocus"), xa("focusout", "onBlur"), xa(qf, "onTransitionRun"), xa(Ns, "onTransitionStart"), xa(Cd, "onTransitionCancel"), xa(wc, "onTransitionEnd"), Wo("onMouseEnter", ["mouseout", "mouseover"]), Wo("onMouseLeave", ["mouseout", "mouseover"]), Wo("onPointerEnter", ["pointerout", "pointerover"]), Wo("onPointerLeave", ["pointerout", "pointerover"]), Sl(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Sl(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Sl("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Sl(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Sl(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Sl(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Dh = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), Pr = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Dh)
  );
  function Xu(n, o) {
    o = (o & 4) !== 0;
    for (var c = 0; c < n.length; c++) {
      var m = n[c], b = m.event;
      m = m.listeners;
      t: {
        var x = void 0;
        if (o)
          for (var R = m.length - 1; 0 <= R; R--) {
            var U = m[R], Z = U.instance, it = U.currentTarget;
            if (U = U.listener, Z !== x && b.isPropagationStopped())
              break t;
            x = U, b.currentTarget = it;
            try {
              x(b);
            } catch (vt) {
              hh(vt);
            }
            b.currentTarget = null, x = Z;
          }
        else
          for (R = 0; R < m.length; R++) {
            if (U = m[R], Z = U.instance, it = U.currentTarget, U = U.listener, Z !== x && b.isPropagationStopped())
              break t;
            x = U, b.currentTarget = it;
            try {
              x(b);
            } catch (vt) {
              hh(vt);
            }
            b.currentTarget = null, x = Z;
          }
      }
    }
  }
  function _e(n, o) {
    var c = o[ea];
    c === void 0 && (c = o[ea] = /* @__PURE__ */ new Set());
    var m = n + "__bubble";
    c.has(m) || (Ym(o, n, 2, !1), c.add(m));
  }
  function Wc(n, o, c) {
    var m = 0;
    o && (m |= 4), Ym(
      c,
      n,
      m,
      o
    );
  }
  var Jc = "_reactListening" + Math.random().toString(36).slice(2);
  function Qg(n) {
    if (!n[Jc]) {
      n[Jc] = !0, pu.forEach(function(c) {
        c !== "selectionchange" && (Pr.has(c) || Wc(c, !1, n), Wc(c, !0, n));
      });
      var o = n.nodeType === 9 ? n : n.ownerDocument;
      o === null || o[Jc] || (o[Jc] = !0, Wc("selectionchange", !1, o));
    }
  }
  function Ym(n, o, c, m) {
    switch (ry(o)) {
      case 2:
        var b = r_;
        break;
      case 8:
        b = u_;
        break;
      default:
        b = ly;
    }
    c = b.bind(
      null,
      o,
      c,
      n
    ), b = void 0, !vr || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (b = !0), m ? b !== void 0 ? n.addEventListener(o, c, {
      capture: !0,
      passive: b
    }) : n.addEventListener(o, c, !0) : b !== void 0 ? n.addEventListener(o, c, {
      passive: b
    }) : n.addEventListener(o, c, !1);
  }
  function qo(n, o, c, m, b) {
    var x = m;
    if ((o & 1) === 0 && (o & 2) === 0 && m !== null)
      t: for (; ; ) {
        if (m === null) return;
        var R = m.tag;
        if (R === 3 || R === 4) {
          var U = m.stateNode.containerInfo;
          if (U === b) break;
          if (R === 4)
            for (R = m.return; R !== null; ) {
              var Z = R.tag;
              if ((Z === 3 || Z === 4) && R.stateNode.containerInfo === b)
                return;
              R = R.return;
            }
          for (; U !== null; ) {
            if (R = Un(U), R === null) return;
            if (Z = R.tag, Z === 5 || Z === 6 || Z === 26 || Z === 27) {
              m = x = R;
              continue t;
            }
            U = U.parentNode;
          }
        }
        m = m.return;
      }
    Ai(function() {
      var it = x, vt = xs(c), St = [];
      t: {
        var ot = Zf.get(n);
        if (ot !== void 0) {
          var st = _u, Ft = n;
          switch (n) {
            case "keypress":
              if (Ue(c) === 0) break t;
            case "keydown":
            case "keyup":
              st = Wa;
              break;
            case "focusin":
              Ft = "focus", st = Hf;
              break;
            case "focusout":
              Ft = "blur", st = Hf;
              break;
            case "beforeblur":
            case "afterblur":
              st = Hf;
              break;
            case "click":
              if (c.button === 2) break t;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              st = Os;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              st = wd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              st = Uf;
              break;
            case Rd:
            case Ta:
            case Tu:
              st = Up;
              break;
            case wc:
              st = Ad;
              break;
            case "scroll":
            case "scrollend":
              st = xd;
              break;
            case "wheel":
              st = Ol;
              break;
            case "copy":
            case "cut":
            case "paste":
              st = As;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              st = _r;
              break;
            case "toggle":
            case "beforetoggle":
              st = Al;
          }
          var te = (o & 4) !== 0, Ze = !te && (n === "scroll" || n === "scrollend"), tt = te ? ot !== null ? ot + "Capture" : null : ot;
          te = [];
          for (var W = it, nt; W !== null; ) {
            var _t = W;
            if (nt = _t.stateNode, _t = _t.tag, _t !== 5 && _t !== 26 && _t !== 27 || nt === null || tt === null || (_t = Ye(W, tt), _t != null && te.push(
              Ws(W, _t, nt)
            )), Ze) break;
            W = W.return;
          }
          0 < te.length && (ot = new st(
            ot,
            Ft,
            null,
            c,
            vt
          ), St.push({ event: ot, listeners: te }));
        }
      }
      if ((o & 7) === 0) {
        t: {
          if (ot = n === "mouseover" || n === "pointerover", st = n === "mouseout" || n === "pointerout", ot && c !== tl && (Ft = c.relatedTarget || c.fromElement) && (Un(Ft) || Ft[dr]))
            break t;
          if ((st || ot) && (ot = vt.window === vt ? vt : (ot = vt.ownerDocument) ? ot.defaultView || ot.parentWindow : window, st ? (Ft = c.relatedTarget || c.toElement, st = it, Ft = Ft ? Un(Ft) : null, Ft !== null && (Ze = g(Ft), te = Ft.tag, Ft !== Ze || te !== 5 && te !== 27 && te !== 6) && (Ft = null)) : (st = null, Ft = it), st !== Ft)) {
            if (te = Os, _t = "onMouseLeave", tt = "onMouseEnter", W = "mouse", (n === "pointerout" || n === "pointerover") && (te = _r, _t = "onPointerLeave", tt = "onPointerEnter", W = "pointer"), Ze = st == null ? ot : yo(st), nt = Ft == null ? ot : yo(Ft), ot = new te(
              _t,
              W + "leave",
              st,
              c,
              vt
            ), ot.target = Ze, ot.relatedTarget = nt, _t = null, Un(vt) === it && (te = new te(
              tt,
              W + "enter",
              Ft,
              c,
              vt
            ), te.target = nt, te.relatedTarget = Ze, _t = te), Ze = _t, st && Ft)
              e: {
                for (te = st, tt = Ft, W = 0, nt = te; nt; nt = Gr(nt))
                  W++;
                for (nt = 0, _t = tt; _t; _t = Gr(_t))
                  nt++;
                for (; 0 < W - nt; )
                  te = Gr(te), W--;
                for (; 0 < nt - W; )
                  tt = Gr(tt), nt--;
                for (; W--; ) {
                  if (te === tt || tt !== null && te === tt.alternate)
                    break e;
                  te = Gr(te), tt = Gr(tt);
                }
                te = null;
              }
            else te = null;
            st !== null && Rh(
              St,
              ot,
              st,
              te,
              !1
            ), Ft !== null && Ze !== null && Rh(
              St,
              Ze,
              Ft,
              te,
              !0
            );
          }
        }
        t: {
          if (ot = it ? yo(it) : window, st = ot.nodeName && ot.nodeName.toLowerCase(), st === "select" || st === "input" && ot.type === "file")
            var Pt = Cs;
          else if (al(ot))
            if (Tc)
              Pt = jf;
            else {
              Pt = zl;
              var Ae = Tr;
            }
          else
            st = ot.nodeName, !st || st.toLowerCase() !== "input" || ot.type !== "checkbox" && ot.type !== "radio" ? it && Fo(it.elementType) && (Pt = Cs) : Pt = Fn;
          if (Pt && (Pt = Pt(n, it))) {
            Sc(
              St,
              Pt,
              c,
              vt
            );
            break t;
          }
          Ae && Ae(n, ot, it), n === "focusout" && it && ot.type === "number" && it.memoizedProps.value != null && wl(ot, "number", ot.value);
        }
        switch (Ae = it ? yo(it) : window, n) {
          case "focusin":
            (al(Ae) || Ae.contentEditable === "true") && (Di = Ae, qi = it, Ro = null);
            break;
          case "focusout":
            Ro = qi = Di = null;
            break;
          case "mousedown":
            Hl = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Hl = !1, xc(St, c, vt);
            break;
          case "selectionchange":
            if (Do) break;
          case "keydown":
          case "keyup":
            xc(St, c, vt);
        }
        var Jt;
        if (il)
          t: {
            switch (n) {
              case "compositionstart":
                var ae = "onCompositionStart";
                break t;
              case "compositionend":
                ae = "onCompositionEnd";
                break t;
              case "compositionupdate":
                ae = "onCompositionUpdate";
                break t;
            }
            ae = void 0;
          }
        else
          Rl ? Ds(n, c) && (ae = "onCompositionEnd") : n === "keydown" && c.keyCode === 229 && (ae = "onCompositionStart");
        ae && (Ja && c.locale !== "ko" && (Rl || ae !== "onCompositionStart" ? ae === "onCompositionEnd" && Rl && (Jt = Ms()) : (Ka = vt, va = "value" in Ka ? Ka.value : Ka.textContent, Rl = !0)), Ae = Ic(it, ae), 0 < Ae.length && (ae = new _a(
          ae,
          n,
          null,
          c,
          vt
        ), St.push({ event: ae, listeners: Ae }), Jt ? ae.data = Jt : (Jt = Dl(c), Jt !== null && (ae.data = Jt)))), (Jt = _c ? bc(n, c) : Rs(n, c)) && (ae = Ic(it, "onBeforeInput"), 0 < ae.length && (Ae = new _a(
          "onBeforeInput",
          "beforeinput",
          null,
          c,
          vt
        ), St.push({
          event: Ae,
          listeners: ae
        }), Ae.data = Jt)), Fv(
          St,
          n,
          it,
          c,
          vt
        );
      }
      Xu(St, o);
    });
  }
  function Ws(n, o, c) {
    return {
      instance: n,
      listener: o,
      currentTarget: c
    };
  }
  function Ic(n, o) {
    for (var c = o + "Capture", m = []; n !== null; ) {
      var b = n, x = b.stateNode;
      if (b = b.tag, b !== 5 && b !== 26 && b !== 27 || x === null || (b = Ye(n, c), b != null && m.unshift(
        Ws(n, b, x)
      ), b = Ye(n, o), b != null && m.push(
        Ws(n, b, x)
      )), n.tag === 3) return m;
      n = n.return;
    }
    return [];
  }
  function Gr(n) {
    if (n === null) return null;
    do
      n = n.return;
    while (n && n.tag !== 5 && n.tag !== 27);
    return n || null;
  }
  function Rh(n, o, c, m, b) {
    for (var x = o._reactName, R = []; c !== null && c !== m; ) {
      var U = c, Z = U.alternate, it = U.stateNode;
      if (U = U.tag, Z !== null && Z === m) break;
      U !== 5 && U !== 26 && U !== 27 || it === null || (Z = it, b ? (it = Ye(c, x), it != null && R.unshift(
        Ws(c, it, Z)
      )) : b || (it = Ye(c, x), it != null && R.push(
        Ws(c, it, Z)
      ))), c = c.return;
    }
    R.length !== 0 && n.push({ event: o, listeners: R });
  }
  var so = /\r\n?/g, Kg = /\u0000|\uFFFD/g;
  function t_(n) {
    return (typeof n == "string" ? n : "" + n).replace(so, `
`).replace(Kg, "");
  }
  function Wg(n, o) {
    return o = t_(o), t_(n) === o;
  }
  function jm() {
  }
  function de(n, o, c, m, b, x) {
    switch (c) {
      case "children":
        typeof m == "string" ? o === "body" || o === "textarea" && m === "" || To(n, m) : (typeof m == "number" || typeof m == "bigint") && o !== "body" && To(n, "" + m);
        break;
      case "className":
        gu(n, "class", m);
        break;
      case "tabIndex":
        gu(n, "tabindex", m);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        gu(n, c, m);
        break;
      case "style":
        $o(n, m, x);
        break;
      case "data":
        if (o !== "object") {
          gu(n, "data", m);
          break;
        }
      case "src":
      case "href":
        if (m === "" && (o !== "a" || c !== "href")) {
          n.removeAttribute(c);
          break;
        }
        if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") {
          n.removeAttribute(c);
          break;
        }
        m = Ts("" + m), n.setAttribute(c, m);
        break;
      case "action":
      case "formAction":
        if (typeof m == "function") {
          n.setAttribute(
            c,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof x == "function" && (c === "formAction" ? (o !== "input" && de(n, o, "name", b.name, b, null), de(
            n,
            o,
            "formEncType",
            b.formEncType,
            b,
            null
          ), de(
            n,
            o,
            "formMethod",
            b.formMethod,
            b,
            null
          ), de(
            n,
            o,
            "formTarget",
            b.formTarget,
            b,
            null
          )) : (de(n, o, "encType", b.encType, b, null), de(n, o, "method", b.method, b, null), de(n, o, "target", b.target, b, null)));
        if (m == null || typeof m == "symbol" || typeof m == "boolean") {
          n.removeAttribute(c);
          break;
        }
        m = Ts("" + m), n.setAttribute(c, m);
        break;
      case "onClick":
        m != null && (n.onclick = jm);
        break;
      case "onScroll":
        m != null && _e("scroll", n);
        break;
      case "onScrollEnd":
        m != null && _e("scrollend", n);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(u(61));
          if (c = m.__html, c != null) {
            if (b.children != null) throw Error(u(60));
            n.innerHTML = c;
          }
        }
        break;
      case "multiple":
        n.multiple = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "muted":
        n.muted = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") {
          n.removeAttribute("xlink:href");
          break;
        }
        c = Ts("" + m), n.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          c
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        m != null && typeof m != "function" && typeof m != "symbol" ? n.setAttribute(c, "" + m) : n.removeAttribute(c);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        m && typeof m != "function" && typeof m != "symbol" ? n.setAttribute(c, "") : n.removeAttribute(c);
        break;
      case "capture":
      case "download":
        m === !0 ? n.setAttribute(c, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? n.setAttribute(c, m) : n.removeAttribute(c);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? n.setAttribute(c, m) : n.removeAttribute(c);
        break;
      case "rowSpan":
      case "start":
        m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? n.removeAttribute(c) : n.setAttribute(c, m);
        break;
      case "popover":
        _e("beforetoggle", n), _e("toggle", n), Jo(n, "popover", m);
        break;
      case "xlinkActuate":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          m
        );
        break;
      case "xlinkArcrole":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          m
        );
        break;
      case "xlinkRole":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          m
        );
        break;
      case "xlinkShow":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          m
        );
        break;
      case "xlinkTitle":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          m
        );
        break;
      case "xlinkType":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          m
        );
        break;
      case "xmlBase":
        _o(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          m
        );
        break;
      case "xmlLang":
        _o(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          m
        );
        break;
      case "xmlSpace":
        _o(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          m
        );
        break;
      case "is":
        Jo(n, "is", m);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = Cf.get(c) || c, Jo(n, c, m));
    }
  }
  function ft(n, o, c, m, b, x) {
    switch (c) {
      case "style":
        $o(n, m, x);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(u(61));
          if (c = m.__html, c != null) {
            if (b.children != null) throw Error(u(60));
            n.innerHTML = c;
          }
        }
        break;
      case "children":
        typeof m == "string" ? To(n, m) : (typeof m == "number" || typeof m == "bigint") && To(n, "" + m);
        break;
      case "onScroll":
        m != null && _e("scroll", n);
        break;
      case "onScrollEnd":
        m != null && _e("scrollend", n);
        break;
      case "onClick":
        m != null && (n.onclick = jm);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!na.hasOwnProperty(c))
          t: {
            if (c[0] === "o" && c[1] === "n" && (b = c.endsWith("Capture"), o = c.slice(2, b ? c.length - 7 : void 0), x = n[Mi] || null, x = x != null ? x[c] : null, typeof x == "function" && n.removeEventListener(o, x, b), typeof m == "function")) {
              typeof x != "function" && x !== null && (c in n ? n[c] = null : n.hasAttribute(c) && n.removeAttribute(c)), n.addEventListener(o, m, b);
              break t;
            }
            c in n ? n[c] = m : m === !0 ? n.setAttribute(c, "") : Jo(n, c, m);
          }
    }
  }
  function re(n, o, c) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        _e("error", n), _e("load", n);
        var m = !1, b = !1, x;
        for (x in c)
          if (c.hasOwnProperty(x)) {
            var R = c[x];
            if (R != null)
              switch (x) {
                case "src":
                  m = !0;
                  break;
                case "srcSet":
                  b = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(u(137, o));
                default:
                  de(n, o, x, R, c, null);
              }
          }
        b && de(n, o, "srcSet", c.srcSet, c, null), m && de(n, o, "src", c.src, c, null);
        return;
      case "input":
        _e("invalid", n);
        var U = x = R = b = null, Z = null, it = null;
        for (m in c)
          if (c.hasOwnProperty(m)) {
            var vt = c[m];
            if (vt != null)
              switch (m) {
                case "name":
                  b = vt;
                  break;
                case "type":
                  R = vt;
                  break;
                case "checked":
                  Z = vt;
                  break;
                case "defaultChecked":
                  it = vt;
                  break;
                case "value":
                  x = vt;
                  break;
                case "defaultValue":
                  U = vt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (vt != null)
                    throw Error(u(137, o));
                  break;
                default:
                  de(n, o, m, vt, c, null);
              }
          }
        gc(
          n,
          x,
          U,
          Z,
          it,
          R,
          b,
          !1
        ), So(n);
        return;
      case "select":
        _e("invalid", n), m = R = x = null;
        for (b in c)
          if (c.hasOwnProperty(b) && (U = c[b], U != null))
            switch (b) {
              case "value":
                x = U;
                break;
              case "defaultValue":
                R = U;
                break;
              case "multiple":
                m = U;
              default:
                de(n, o, b, U, c, null);
            }
        o = x, c = R, n.multiple = !!m, o != null ? ia(n, !!m, o, !1) : c != null && ia(n, !!m, c, !0);
        return;
      case "textarea":
        _e("invalid", n), x = b = m = null;
        for (R in c)
          if (c.hasOwnProperty(R) && (U = c[R], U != null))
            switch (R) {
              case "value":
                m = U;
                break;
              case "defaultValue":
                b = U;
                break;
              case "children":
                x = U;
                break;
              case "dangerouslySetInnerHTML":
                if (U != null) throw Error(u(91));
                break;
              default:
                de(n, o, R, U, c, null);
            }
        Io(n, m, b, x), So(n);
        return;
      case "option":
        for (Z in c)
          if (c.hasOwnProperty(Z) && (m = c[Z], m != null))
            switch (Z) {
              case "selected":
                n.selected = m && typeof m != "function" && typeof m != "symbol";
                break;
              default:
                de(n, o, Z, m, c, null);
            }
        return;
      case "dialog":
        _e("beforetoggle", n), _e("toggle", n), _e("cancel", n), _e("close", n);
        break;
      case "iframe":
      case "object":
        _e("load", n);
        break;
      case "video":
      case "audio":
        for (m = 0; m < Dh.length; m++)
          _e(Dh[m], n);
        break;
      case "image":
        _e("error", n), _e("load", n);
        break;
      case "details":
        _e("toggle", n);
        break;
      case "embed":
      case "source":
      case "link":
        _e("error", n), _e("load", n);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (it in c)
          if (c.hasOwnProperty(it) && (m = c[it], m != null))
            switch (it) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(u(137, o));
              default:
                de(n, o, it, m, c, null);
            }
        return;
      default:
        if (Fo(o)) {
          for (vt in c)
            c.hasOwnProperty(vt) && (m = c[vt], m !== void 0 && ft(
              n,
              o,
              vt,
              m,
              c,
              void 0
            ));
          return;
        }
    }
    for (U in c)
      c.hasOwnProperty(U) && (m = c[U], m != null && de(n, o, U, m, c, null));
  }
  function j0(n, o, c, m) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var b = null, x = null, R = null, U = null, Z = null, it = null, vt = null;
        for (st in c) {
          var St = c[st];
          if (c.hasOwnProperty(st) && St != null)
            switch (st) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                Z = St;
              default:
                m.hasOwnProperty(st) || de(n, o, st, null, m, St);
            }
        }
        for (var ot in m) {
          var st = m[ot];
          if (St = c[ot], m.hasOwnProperty(ot) && (st != null || St != null))
            switch (ot) {
              case "type":
                x = st;
                break;
              case "name":
                b = st;
                break;
              case "checked":
                it = st;
                break;
              case "defaultChecked":
                vt = st;
                break;
              case "value":
                R = st;
                break;
              case "defaultValue":
                U = st;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (st != null)
                  throw Error(u(137, o));
                break;
              default:
                st !== St && de(
                  n,
                  o,
                  ot,
                  st,
                  m,
                  St
                );
            }
        }
        Oi(
          n,
          R,
          U,
          Z,
          it,
          vt,
          x,
          b
        );
        return;
      case "select":
        st = R = U = ot = null;
        for (x in c)
          if (Z = c[x], c.hasOwnProperty(x) && Z != null)
            switch (x) {
              case "value":
                break;
              case "multiple":
                st = Z;
              default:
                m.hasOwnProperty(x) || de(
                  n,
                  o,
                  x,
                  null,
                  m,
                  Z
                );
            }
        for (b in m)
          if (x = m[b], Z = c[b], m.hasOwnProperty(b) && (x != null || Z != null))
            switch (b) {
              case "value":
                ot = x;
                break;
              case "defaultValue":
                U = x;
                break;
              case "multiple":
                R = x;
              default:
                x !== Z && de(
                  n,
                  o,
                  b,
                  x,
                  m,
                  Z
                );
            }
        o = U, c = R, m = st, ot != null ? ia(n, !!c, ot, !1) : !!m != !!c && (o != null ? ia(n, !!c, o, !0) : ia(n, !!c, c ? [] : "", !1));
        return;
      case "textarea":
        st = ot = null;
        for (U in c)
          if (b = c[U], c.hasOwnProperty(U) && b != null && !m.hasOwnProperty(U))
            switch (U) {
              case "value":
                break;
              case "children":
                break;
              default:
                de(n, o, U, null, m, b);
            }
        for (R in m)
          if (b = m[R], x = c[R], m.hasOwnProperty(R) && (b != null || x != null))
            switch (R) {
              case "value":
                ot = b;
                break;
              case "defaultValue":
                st = b;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (b != null) throw Error(u(91));
                break;
              default:
                b !== x && de(n, o, R, b, m, x);
            }
        yn(n, ot, st);
        return;
      case "option":
        for (var Ft in c)
          if (ot = c[Ft], c.hasOwnProperty(Ft) && ot != null && !m.hasOwnProperty(Ft))
            switch (Ft) {
              case "selected":
                n.selected = !1;
                break;
              default:
                de(
                  n,
                  o,
                  Ft,
                  null,
                  m,
                  ot
                );
            }
        for (Z in m)
          if (ot = m[Z], st = c[Z], m.hasOwnProperty(Z) && ot !== st && (ot != null || st != null))
            switch (Z) {
              case "selected":
                n.selected = ot && typeof ot != "function" && typeof ot != "symbol";
                break;
              default:
                de(
                  n,
                  o,
                  Z,
                  ot,
                  m,
                  st
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var te in c)
          ot = c[te], c.hasOwnProperty(te) && ot != null && !m.hasOwnProperty(te) && de(n, o, te, null, m, ot);
        for (it in m)
          if (ot = m[it], st = c[it], m.hasOwnProperty(it) && ot !== st && (ot != null || st != null))
            switch (it) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (ot != null)
                  throw Error(u(137, o));
                break;
              default:
                de(
                  n,
                  o,
                  it,
                  ot,
                  m,
                  st
                );
            }
        return;
      default:
        if (Fo(o)) {
          for (var Ze in c)
            ot = c[Ze], c.hasOwnProperty(Ze) && ot !== void 0 && !m.hasOwnProperty(Ze) && ft(
              n,
              o,
              Ze,
              void 0,
              m,
              ot
            );
          for (vt in m)
            ot = m[vt], st = c[vt], !m.hasOwnProperty(vt) || ot === st || ot === void 0 && st === void 0 || ft(
              n,
              o,
              vt,
              ot,
              m,
              st
            );
          return;
        }
    }
    for (var tt in c)
      ot = c[tt], c.hasOwnProperty(tt) && ot != null && !m.hasOwnProperty(tt) && de(n, o, tt, null, m, ot);
    for (St in m)
      ot = m[St], st = c[St], !m.hasOwnProperty(St) || ot === st || ot == null && st == null || de(n, o, St, ot, m, st);
  }
  var Ch = null, zh = null;
  function Zo(n) {
    return n.nodeType === 9 ? n : n.ownerDocument;
  }
  function Js(n) {
    switch (n) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function $c(n, o) {
    if (n === 0)
      switch (o) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return n === 1 && o === "foreignObject" ? 0 : n;
  }
  function ns(n, o) {
    return n === "textarea" || n === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.children == "bigint" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
  }
  var Fc = null;
  function Is() {
    var n = window.event;
    return n && n.type === "popstate" ? n === Fc ? !1 : (Fc = n, !0) : (Fc = null, !1);
  }
  var qm = typeof setTimeout == "function" ? setTimeout : void 0, q0 = typeof clearTimeout == "function" ? clearTimeout : void 0, e_ = typeof Promise == "function" ? Promise : void 0, Z0 = typeof queueMicrotask == "function" ? queueMicrotask : typeof e_ < "u" ? function(n) {
    return e_.resolve(null).then(n).catch(is);
  } : qm;
  function is(n) {
    setTimeout(function() {
      throw n;
    });
  }
  function Xr(n) {
    return n === "head";
  }
  function Zm(n, o) {
    var c = o, m = 0, b = 0;
    do {
      var x = c.nextSibling;
      if (n.removeChild(c), x && x.nodeType === 8)
        if (c = x.data, c === "/$") {
          if (0 < m && 8 > m) {
            c = m;
            var R = n.ownerDocument;
            if (c & 1 && Ha(R.documentElement), c & 2 && Ha(R.body), c & 4)
              for (c = R.head, Ha(c), R = c.firstChild; R; ) {
                var U = R.nextSibling, Z = R.nodeName;
                R[Vt] || Z === "SCRIPT" || Z === "STYLE" || Z === "LINK" && R.rel.toLowerCase() === "stylesheet" || c.removeChild(R), R = U;
              }
          }
          if (b === 0) {
            n.removeChild(x), os(o);
            return;
          }
          b--;
        } else
          c === "$" || c === "$?" || c === "$!" ? b++ : m = c.charCodeAt(0) - 48;
      else m = 0;
      c = x;
    } while (c);
    os(o);
  }
  function Lh(n) {
    var o = n.firstChild;
    for (o && o.nodeType === 10 && (o = o.nextSibling); o; ) {
      var c = o;
      switch (o = o.nextSibling, c.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Lh(c), mr(c);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (c.rel.toLowerCase() === "stylesheet") continue;
      }
      n.removeChild(c);
    }
  }
  function tf(n, o, c, m) {
    for (; n.nodeType === 1; ) {
      var b = c;
      if (n.nodeName.toLowerCase() !== o.toLowerCase()) {
        if (!m && (n.nodeName !== "INPUT" || n.type !== "hidden"))
          break;
      } else if (m) {
        if (!n[Vt])
          switch (o) {
            case "meta":
              if (!n.hasAttribute("itemprop")) break;
              return n;
            case "link":
              if (x = n.getAttribute("rel"), x === "stylesheet" && n.hasAttribute("data-precedence"))
                break;
              if (x !== b.rel || n.getAttribute("href") !== (b.href == null || b.href === "" ? null : b.href) || n.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin) || n.getAttribute("title") !== (b.title == null ? null : b.title))
                break;
              return n;
            case "style":
              if (n.hasAttribute("data-precedence")) break;
              return n;
            case "script":
              if (x = n.getAttribute("src"), (x !== (b.src == null ? null : b.src) || n.getAttribute("type") !== (b.type == null ? null : b.type) || n.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin)) && x && n.hasAttribute("async") && !n.hasAttribute("itemprop"))
                break;
              return n;
            default:
              return n;
          }
      } else if (o === "input" && n.type === "hidden") {
        var x = b.name == null ? null : "" + b.name;
        if (b.type === "hidden" && n.getAttribute("name") === x)
          return n;
      } else return n;
      if (n = pl(n.nextSibling), n === null) break;
    }
    return null;
  }
  function V0(n, o, c) {
    if (o === "") return null;
    for (; n.nodeType !== 3; )
      if ((n.nodeType !== 1 || n.nodeName !== "INPUT" || n.type !== "hidden") && !c || (n = pl(n.nextSibling), n === null)) return null;
    return n;
  }
  function Hh(n) {
    return n.data === "$!" || n.data === "$?" && n.ownerDocument.readyState === "complete";
  }
  function P0(n, o) {
    var c = n.ownerDocument;
    if (n.data !== "$?" || c.readyState === "complete")
      o();
    else {
      var m = function() {
        o(), c.removeEventListener("DOMContentLoaded", m);
      };
      c.addEventListener("DOMContentLoaded", m), n._reactRetry = m;
    }
  }
  function pl(n) {
    for (; n != null; n = n.nextSibling) {
      var o = n.nodeType;
      if (o === 1 || o === 3) break;
      if (o === 8) {
        if (o = n.data, o === "$" || o === "$!" || o === "$?" || o === "F!" || o === "F")
          break;
        if (o === "/$") return null;
      }
    }
    return n;
  }
  var Qr = null;
  function ki(n) {
    n = n.previousSibling;
    for (var o = 0; n; ) {
      if (n.nodeType === 8) {
        var c = n.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (o === 0) return n;
          o--;
        } else c === "/$" && o++;
      }
      n = n.previousSibling;
    }
    return null;
  }
  function jt(n, o, c) {
    switch (o = Zo(c), n) {
      case "html":
        if (n = o.documentElement, !n) throw Error(u(452));
        return n;
      case "head":
        if (n = o.head, !n) throw Error(u(453));
        return n;
      case "body":
        if (n = o.body, !n) throw Error(u(454));
        return n;
      default:
        throw Error(u(451));
    }
  }
  function Ha(n) {
    for (var o = n.attributes; o.length; )
      n.removeAttributeNode(o[0]);
    mr(n);
  }
  var kn = /* @__PURE__ */ new Map(), Ki = /* @__PURE__ */ new Set();
  function Vm(n) {
    return typeof n.getRootNode == "function" ? n.getRootNode() : n.nodeType === 9 ? n : n.ownerDocument;
  }
  var $s = dt.d;
  dt.d = {
    f: Pm,
    r: Gm,
    D: Fs,
    C: Xm,
    L: Kr,
    m: Wi,
    X: Wr,
    S: ka,
    M: Jg
  };
  function Pm() {
    var n = $s.f(), o = Zu();
    return n || o;
  }
  function Gm(n) {
    var o = bl(n);
    o !== null && o.tag === 5 && o.type === "form" ? zc(o) : $s.r(n);
  }
  var Ni = typeof document > "u" ? null : document;
  function gl(n, o, c) {
    var m = Ni;
    if (m && typeof o == "string" && o) {
      var b = Ei(o);
      b = 'link[rel="' + n + '"][href="' + b + '"]', typeof c == "string" && (b += '[crossorigin="' + c + '"]'), Ki.has(b) || (Ki.add(b), n = { rel: n, crossOrigin: c, href: o }, m.querySelector(b) === null && (o = m.createElement("link"), re(o, "link", n), Bn(o), m.head.appendChild(o)));
    }
  }
  function Fs(n) {
    $s.D(n), gl("dns-prefetch", n, null);
  }
  function Xm(n, o) {
    $s.C(n, o), gl("preconnect", n, o);
  }
  function Kr(n, o, c) {
    $s.L(n, o, c);
    var m = Ni;
    if (m && n && o) {
      var b = 'link[rel="preload"][as="' + Ei(o) + '"]';
      o === "image" && c && c.imageSrcSet ? (b += '[imagesrcset="' + Ei(
        c.imageSrcSet
      ) + '"]', typeof c.imageSizes == "string" && (b += '[imagesizes="' + Ei(
        c.imageSizes
      ) + '"]')) : b += '[href="' + Ei(n) + '"]';
      var x = b;
      switch (o) {
        case "style":
          x = ef(n);
          break;
        case "script":
          x = Vo(n);
      }
      kn.has(x) || (n = A(
        {
          rel: "preload",
          href: o === "image" && c && c.imageSrcSet ? void 0 : n,
          as: o
        },
        c
      ), kn.set(x, n), m.querySelector(b) !== null || o === "style" && m.querySelector(nf(x)) || o === "script" && m.querySelector(Qu(x)) || (o = m.createElement("link"), re(o, "link", n), Bn(o), m.head.appendChild(o)));
    }
  }
  function Wi(n, o) {
    $s.m(n, o);
    var c = Ni;
    if (c && n) {
      var m = o && typeof o.as == "string" ? o.as : "script", b = 'link[rel="modulepreload"][as="' + Ei(m) + '"][href="' + Ei(n) + '"]', x = b;
      switch (m) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          x = Vo(n);
      }
      if (!kn.has(x) && (n = A({ rel: "modulepreload", href: n }, o), kn.set(x, n), c.querySelector(b) === null)) {
        switch (m) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (c.querySelector(Qu(x)))
              return;
        }
        m = c.createElement("link"), re(m, "link", n), Bn(m), c.head.appendChild(m);
      }
    }
  }
  function ka(n, o, c) {
    $s.S(n, o, c);
    var m = Ni;
    if (m && n) {
      var b = vo(m).hoistableStyles, x = ef(n);
      o = o || "default";
      var R = b.get(x);
      if (!R) {
        var U = { loading: 0, preload: null };
        if (R = m.querySelector(
          nf(x)
        ))
          U.loading = 5;
        else {
          n = A(
            { rel: "stylesheet", href: n, "data-precedence": o },
            c
          ), (c = kn.get(x)) && Km(n, c);
          var Z = R = m.createElement("link");
          Bn(Z), re(Z, "link", n), Z._p = new Promise(function(it, vt) {
            Z.onload = it, Z.onerror = vt;
          }), Z.addEventListener("load", function() {
            U.loading |= 1;
          }), Z.addEventListener("error", function() {
            U.loading |= 2;
          }), U.loading |= 4, Qm(R, o, m);
        }
        R = {
          type: "stylesheet",
          instance: R,
          count: 1,
          state: U
        }, b.set(x, R);
      }
    }
  }
  function Wr(n, o) {
    $s.X(n, o);
    var c = Ni;
    if (c && n) {
      var m = vo(c).hoistableScripts, b = Vo(n), x = m.get(b);
      x || (x = c.querySelector(Qu(b)), x || (n = A({ src: n, async: !0 }, o), (o = kn.get(b)) && Wm(n, o), x = c.createElement("script"), Bn(x), re(x, "link", n), c.head.appendChild(x)), x = {
        type: "script",
        instance: x,
        count: 1,
        state: null
      }, m.set(b, x));
    }
  }
  function Jg(n, o) {
    $s.M(n, o);
    var c = Ni;
    if (c && n) {
      var m = vo(c).hoistableScripts, b = Vo(n), x = m.get(b);
      x || (x = c.querySelector(Qu(b)), x || (n = A({ src: n, async: !0, type: "module" }, o), (o = kn.get(b)) && Wm(n, o), x = c.createElement("script"), Bn(x), re(x, "link", n), c.head.appendChild(x)), x = {
        type: "script",
        instance: x,
        count: 1,
        state: null
      }, m.set(b, x));
    }
  }
  function n_(n, o, c, m) {
    var b = (b = Tt.current) ? Vm(b) : null;
    if (!b) throw Error(u(446));
    switch (n) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof c.precedence == "string" && typeof c.href == "string" ? (o = ef(c.href), c = vo(
          b
        ).hoistableStyles, m = c.get(o), m || (m = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, c.set(o, m)), m) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
          n = ef(c.href);
          var x = vo(
            b
          ).hoistableStyles, R = x.get(n);
          if (R || (b = b.ownerDocument || b, R = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, x.set(n, R), (x = b.querySelector(
            nf(n)
          )) && !x._p && (R.instance = x, R.state.loading = 5), kn.has(n) || (c = {
            rel: "preload",
            as: "style",
            href: c.href,
            crossOrigin: c.crossOrigin,
            integrity: c.integrity,
            media: c.media,
            hrefLang: c.hrefLang,
            referrerPolicy: c.referrerPolicy
          }, kn.set(n, c), x || i_(
            b,
            n,
            c,
            R.state
          ))), o && m === null)
            throw Error(u(528, ""));
          return R;
        }
        if (o && m !== null)
          throw Error(u(529, ""));
        return null;
      case "script":
        return o = c.async, c = c.src, typeof c == "string" && o && typeof o != "function" && typeof o != "symbol" ? (o = Vo(c), c = vo(
          b
        ).hoistableScripts, m = c.get(o), m || (m = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, c.set(o, m)), m) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(u(444, n));
    }
  }
  function ef(n) {
    return 'href="' + Ei(n) + '"';
  }
  function nf(n) {
    return 'link[rel="stylesheet"][' + n + "]";
  }
  function af(n) {
    return A({}, n, {
      "data-precedence": n.precedence,
      precedence: null
    });
  }
  function i_(n, o, c, m) {
    n.querySelector('link[rel="preload"][as="style"][' + o + "]") ? m.loading = 1 : (o = n.createElement("link"), m.preload = o, o.addEventListener("load", function() {
      return m.loading |= 1;
    }), o.addEventListener("error", function() {
      return m.loading |= 2;
    }), re(o, "link", c), Bn(o), n.head.appendChild(o));
  }
  function Vo(n) {
    return '[src="' + Ei(n) + '"]';
  }
  function Qu(n) {
    return "script[async]" + n;
  }
  function a_(n, o, c) {
    if (o.count++, o.instance === null)
      switch (o.type) {
        case "style":
          var m = n.querySelector(
            'style[data-href~="' + Ei(c.href) + '"]'
          );
          if (m)
            return o.instance = m, Bn(m), m;
          var b = A({}, c, {
            "data-href": c.href,
            "data-precedence": c.precedence,
            href: null,
            precedence: null
          });
          return m = (n.ownerDocument || n).createElement(
            "style"
          ), Bn(m), re(m, "style", b), Qm(m, c.precedence, n), o.instance = m;
        case "stylesheet":
          b = ef(c.href);
          var x = n.querySelector(
            nf(b)
          );
          if (x)
            return o.state.loading |= 4, o.instance = x, Bn(x), x;
          m = af(c), (b = kn.get(b)) && Km(m, b), x = (n.ownerDocument || n).createElement("link"), Bn(x);
          var R = x;
          return R._p = new Promise(function(U, Z) {
            R.onload = U, R.onerror = Z;
          }), re(x, "link", m), o.state.loading |= 4, Qm(x, c.precedence, n), o.instance = x;
        case "script":
          return x = Vo(c.src), (b = n.querySelector(
            Qu(x)
          )) ? (o.instance = b, Bn(b), b) : (m = c, (b = kn.get(x)) && (m = A({}, c), Wm(m, b)), n = n.ownerDocument || n, b = n.createElement("script"), Bn(b), re(b, "link", m), n.head.appendChild(b), o.instance = b);
        case "void":
          return null;
        default:
          throw Error(u(443, o.type));
      }
    else
      o.type === "stylesheet" && (o.state.loading & 4) === 0 && (m = o.instance, o.state.loading |= 4, Qm(m, c.precedence, n));
    return o.instance;
  }
  function Qm(n, o, c) {
    for (var m = c.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), b = m.length ? m[m.length - 1] : null, x = b, R = 0; R < m.length; R++) {
      var U = m[R];
      if (U.dataset.precedence === o) x = U;
      else if (x !== b) break;
    }
    x ? x.parentNode.insertBefore(n, x.nextSibling) : (o = c.nodeType === 9 ? c.head : c, o.insertBefore(n, o.firstChild));
  }
  function Km(n, o) {
    n.crossOrigin == null && (n.crossOrigin = o.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = o.referrerPolicy), n.title == null && (n.title = o.title);
  }
  function Wm(n, o) {
    n.crossOrigin == null && (n.crossOrigin = o.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = o.referrerPolicy), n.integrity == null && (n.integrity = o.integrity);
  }
  var Jr = null;
  function Ig(n, o, c) {
    if (Jr === null) {
      var m = /* @__PURE__ */ new Map(), b = Jr = /* @__PURE__ */ new Map();
      b.set(c, m);
    } else
      b = Jr, m = b.get(c), m || (m = /* @__PURE__ */ new Map(), b.set(c, m));
    if (m.has(n)) return m;
    for (m.set(n, null), c = c.getElementsByTagName(n), b = 0; b < c.length; b++) {
      var x = c[b];
      if (!(x[Vt] || x[Pn] || n === "link" && x.getAttribute("rel") === "stylesheet") && x.namespaceURI !== "http://www.w3.org/2000/svg") {
        var R = x.getAttribute(o) || "";
        R = n + R;
        var U = m.get(R);
        U ? U.push(x) : m.set(R, [x]);
      }
    }
    return m;
  }
  function $g(n, o, c) {
    n = n.ownerDocument || n, n.head.insertBefore(
      c,
      o === "title" ? n.querySelector("head > title") : null
    );
  }
  function o_(n, o, c) {
    if (c === 1 || o.itemProp != null) return !1;
    switch (n) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof o.precedence != "string" || typeof o.href != "string" || o.href === "")
          break;
        return !0;
      case "link":
        if (typeof o.rel != "string" || typeof o.href != "string" || o.href === "" || o.onLoad || o.onError)
          break;
        switch (o.rel) {
          case "stylesheet":
            return n = o.disabled, typeof o.precedence == "string" && n == null;
          default:
            return !0;
        }
      case "script":
        if (o.async && typeof o.async != "function" && typeof o.async != "symbol" && !o.onLoad && !o.onError && o.src && typeof o.src == "string")
          return !0;
    }
    return !1;
  }
  function Fg(n) {
    return !(n.type === "stylesheet" && (n.state.loading & 3) === 0);
  }
  var of = null;
  function l_() {
  }
  function s_(n, o, c) {
    if (of === null) throw Error(u(475));
    var m = of;
    if (o.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && (o.state.loading & 4) === 0) {
      if (o.instance === null) {
        var b = ef(c.href), x = n.querySelector(
          nf(b)
        );
        if (x) {
          n = x._p, n !== null && typeof n == "object" && typeof n.then == "function" && (m.count++, m = kh.bind(m), n.then(m, m)), o.state.loading |= 4, o.instance = x, Bn(x);
          return;
        }
        x = n.ownerDocument || n, c = af(c), (b = kn.get(b)) && Km(c, b), x = x.createElement("link"), Bn(x);
        var R = x;
        R._p = new Promise(function(U, Z) {
          R.onload = U, R.onerror = Z;
        }), re(x, "link", c), o.instance = x;
      }
      m.stylesheets === null && (m.stylesheets = /* @__PURE__ */ new Map()), m.stylesheets.set(o, n), (n = o.state.preload) && (o.state.loading & 3) === 0 && (m.count++, o = kh.bind(m), n.addEventListener("load", o), n.addEventListener("error", o));
    }
  }
  function ty() {
    if (of === null) throw Error(u(475));
    var n = of;
    return n.stylesheets && n.count === 0 && Nh(n, n.stylesheets), 0 < n.count ? function(o) {
      var c = setTimeout(function() {
        if (n.stylesheets && Nh(n, n.stylesheets), n.unsuspend) {
          var m = n.unsuspend;
          n.unsuspend = null, m();
        }
      }, 6e4);
      return n.unsuspend = o, function() {
        n.unsuspend = null, clearTimeout(c);
      };
    } : null;
  }
  function kh() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) Nh(this, this.stylesheets);
      else if (this.unsuspend) {
        var n = this.unsuspend;
        this.unsuspend = null, n();
      }
    }
  }
  var lf = null;
  function Nh(n, o) {
    n.stylesheets = null, n.unsuspend !== null && (n.count++, lf = /* @__PURE__ */ new Map(), o.forEach(ro, n), lf = null, kh.call(n));
  }
  function ro(n, o) {
    if (!(o.state.loading & 4)) {
      var c = lf.get(n);
      if (c) var m = c.get(null);
      else {
        c = /* @__PURE__ */ new Map(), lf.set(n, c);
        for (var b = n.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), x = 0; x < b.length; x++) {
          var R = b[x];
          (R.nodeName === "LINK" || R.getAttribute("media") !== "not all") && (c.set(R.dataset.precedence, R), m = R);
        }
        m && c.set(null, m);
      }
      b = o.instance, R = b.getAttribute("data-precedence"), x = c.get(R) || m, x === m && c.set(null, b), c.set(R, b), this.count++, m = kh.bind(this), b.addEventListener("load", m), b.addEventListener("error", m), x ? x.parentNode.insertBefore(b, x.nextSibling) : (n = n.nodeType === 9 ? n.head : n, n.insertBefore(b, n.firstChild)), o.state.loading |= 4;
    }
  }
  var Na = {
    $$typeof: At,
    Provider: null,
    Consumer: null,
    _currentValue: ut,
    _currentValue2: ut,
    _threadCount: 0
  };
  function G0(n, o, c, m, b, x, R, U) {
    this.tag = 1, this.containerInfo = n, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Xt(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Xt(0), this.hiddenUpdates = Xt(null), this.identifierPrefix = m, this.onUncaughtError = b, this.onCaughtError = x, this.onRecoverableError = R, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = U, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function ey(n, o, c, m, b, x, R, U, Z, it, vt, St) {
    return n = new G0(
      n,
      o,
      c,
      R,
      U,
      Z,
      it,
      St
    ), o = 1, x === !0 && (o |= 24), x = Vi(3, null, null, o), n.current = x, x.stateNode = n, o = Oc(), o.refCount++, n.pooledCache = o, o.refCount++, x.memoizedState = {
      element: m,
      isDehydrated: c,
      cache: o
    }, jd(x), n;
  }
  function ny(n) {
    return n ? (n = Us, n) : Us;
  }
  function iy(n, o, c, m, b, x) {
    b = ny(b), m.context === null ? m.context = b : m.pendingContext = b, m = Oa(o), m.payload = { element: c }, x = x === void 0 ? null : x, x !== null && (m.callback = x), c = ql(n, m, o), c !== null && (lo(c, n, o), Eu(c, n, o));
  }
  function ay(n, o) {
    if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
      var c = n.retryLane;
      n.retryLane = c !== 0 && c < o ? c : o;
    }
  }
  function Jm(n, o) {
    ay(n, o), (n = n.alternate) && ay(n, o);
  }
  function oy(n) {
    if (n.tag === 13) {
      var o = Lo(n, 67108864);
      o !== null && lo(o, n, 67108864), Jm(n, 67108864);
    }
  }
  var Uh = !0;
  function r_(n, o, c, m) {
    var b = P.T;
    P.T = null;
    var x = dt.p;
    try {
      dt.p = 2, ly(n, o, c, m);
    } finally {
      dt.p = x, P.T = b;
    }
  }
  function u_(n, o, c, m) {
    var b = P.T;
    P.T = null;
    var x = dt.p;
    try {
      dt.p = 8, ly(n, o, c, m);
    } finally {
      dt.p = x, P.T = b;
    }
  }
  function ly(n, o, c, m) {
    if (Uh) {
      var b = Im(m);
      if (b === null)
        qo(
          n,
          o,
          m,
          $m,
          c
        ), Ku(n, m);
      else if (f_(
        b,
        n,
        o,
        c,
        m
      ))
        m.stopPropagation();
      else if (Ku(n, m), o & 4 && -1 < c_.indexOf(n)) {
        for (; b !== null; ) {
          var x = bl(b);
          if (x !== null)
            switch (x.tag) {
              case 3:
                if (x = x.stateNode, x.current.memoizedState.isDehydrated) {
                  var R = Vn(x.pendingLanes);
                  if (R !== 0) {
                    var U = x;
                    for (U.pendingLanes |= 2, U.entangledLanes |= 2; R; ) {
                      var Z = 1 << 31 - In(R);
                      U.entanglements[1] |= Z, R &= ~Z;
                    }
                    La(x), (Qe & 6) === 0 && (Am = En() + 500, wh(0));
                  }
                }
                break;
              case 13:
                U = Lo(x, 2), U !== null && lo(U, x, 2), Zu(), Jm(x, 2);
            }
          if (x = Im(m), x === null && qo(
            n,
            o,
            m,
            $m,
            c
          ), x === b) break;
          b = x;
        }
        b !== null && m.stopPropagation();
      } else
        qo(
          n,
          o,
          m,
          null,
          c
        );
    }
  }
  function Im(n) {
    return n = xs(n), sy(n);
  }
  var $m = null;
  function sy(n) {
    if ($m = null, n = Un(n), n !== null) {
      var o = g(n);
      if (o === null) n = null;
      else {
        var c = o.tag;
        if (c === 13) {
          if (n = _(o), n !== null) return n;
          n = null;
        } else if (c === 3) {
          if (o.stateNode.current.memoizedState.isDehydrated)
            return o.tag === 3 ? o.stateNode.containerInfo : null;
          n = null;
        } else o !== n && (n = null);
      }
    }
    return $m = n, null;
  }
  function ry(n) {
    switch (n) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Va()) {
          case dc:
            return 2;
          case pe:
            return 8;
          case pa:
          case vs:
            return 32;
          case po:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var sf = !1, as = null, tr = null, er = null, Bh = /* @__PURE__ */ new Map(), Yh = /* @__PURE__ */ new Map(), Ir = [], c_ = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Ku(n, o) {
    switch (n) {
      case "focusin":
      case "focusout":
        as = null;
        break;
      case "dragenter":
      case "dragleave":
        tr = null;
        break;
      case "mouseover":
      case "mouseout":
        er = null;
        break;
      case "pointerover":
      case "pointerout":
        Bh.delete(o.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Yh.delete(o.pointerId);
    }
  }
  function Wu(n, o, c, m, b, x) {
    return n === null || n.nativeEvent !== x ? (n = {
      blockedOn: o,
      domEventName: c,
      eventSystemFlags: m,
      nativeEvent: x,
      targetContainers: [b]
    }, o !== null && (o = bl(o), o !== null && oy(o)), n) : (n.eventSystemFlags |= m, o = n.targetContainers, b !== null && o.indexOf(b) === -1 && o.push(b), n);
  }
  function f_(n, o, c, m, b) {
    switch (o) {
      case "focusin":
        return as = Wu(
          as,
          n,
          o,
          c,
          m,
          b
        ), !0;
      case "dragenter":
        return tr = Wu(
          tr,
          n,
          o,
          c,
          m,
          b
        ), !0;
      case "mouseover":
        return er = Wu(
          er,
          n,
          o,
          c,
          m,
          b
        ), !0;
      case "pointerover":
        var x = b.pointerId;
        return Bh.set(
          x,
          Wu(
            Bh.get(x) || null,
            n,
            o,
            c,
            m,
            b
          )
        ), !0;
      case "gotpointercapture":
        return x = b.pointerId, Yh.set(
          x,
          Wu(
            Yh.get(x) || null,
            n,
            o,
            c,
            m,
            b
          )
        ), !0;
    }
    return !1;
  }
  function uy(n) {
    var o = Un(n.target);
    if (o !== null) {
      var c = g(o);
      if (c !== null) {
        if (o = c.tag, o === 13) {
          if (o = _(c), o !== null) {
            n.blockedOn = o, du(n.priority, function() {
              if (c.tag === 13) {
                var m = oo();
                m = On(m);
                var b = Lo(c, m);
                b !== null && lo(b, c, m), Jm(c, m);
              }
            });
            return;
          }
        } else if (o === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          n.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    n.blockedOn = null;
  }
  function jh(n) {
    if (n.blockedOn !== null) return !1;
    for (var o = n.targetContainers; 0 < o.length; ) {
      var c = Im(n.nativeEvent);
      if (c === null) {
        c = n.nativeEvent;
        var m = new c.constructor(
          c.type,
          c
        );
        tl = m, c.target.dispatchEvent(m), tl = null;
      } else
        return o = bl(c), o !== null && oy(o), n.blockedOn = c, !1;
      o.shift();
    }
    return !0;
  }
  function qh(n, o, c) {
    jh(n) && c.delete(o);
  }
  function rf() {
    sf = !1, as !== null && jh(as) && (as = null), tr !== null && jh(tr) && (tr = null), er !== null && jh(er) && (er = null), Bh.forEach(qh), Yh.forEach(qh);
  }
  function Fm(n, o) {
    n.blockedOn === o && (n.blockedOn = null, sf || (sf = !0, s.unstable_scheduleCallback(
      s.unstable_NormalPriority,
      rf
    )));
  }
  var Ju = null;
  function cy(n) {
    Ju !== n && (Ju = n, s.unstable_scheduleCallback(
      s.unstable_NormalPriority,
      function() {
        Ju === n && (Ju = null);
        for (var o = 0; o < n.length; o += 3) {
          var c = n[o], m = n[o + 1], b = n[o + 2];
          if (typeof m != "function") {
            if (sy(m || c) === null)
              continue;
            break;
          }
          var x = bl(c);
          x !== null && (n.splice(o, 3), o -= 3, lm(
            x,
            {
              pending: !0,
              data: b,
              method: c.method,
              action: m
            },
            m,
            b
          ));
        }
      }
    ));
  }
  function os(n) {
    function o(Z) {
      return Fm(Z, n);
    }
    as !== null && Fm(as, n), tr !== null && Fm(tr, n), er !== null && Fm(er, n), Bh.forEach(o), Yh.forEach(o);
    for (var c = 0; c < Ir.length; c++) {
      var m = Ir[c];
      m.blockedOn === n && (m.blockedOn = null);
    }
    for (; 0 < Ir.length && (c = Ir[0], c.blockedOn === null); )
      uy(c), c.blockedOn === null && Ir.shift();
    if (c = (n.ownerDocument || n).$$reactFormReplay, c != null)
      for (m = 0; m < c.length; m += 3) {
        var b = c[m], x = c[m + 1], R = b[Mi] || null;
        if (typeof x == "function")
          R || cy(c);
        else if (R) {
          var U = null;
          if (x && x.hasAttribute("formAction")) {
            if (b = x, R = x[Mi] || null)
              U = R.formAction;
            else if (sy(b) !== null) continue;
          } else U = R.action;
          typeof U == "function" ? c[m + 1] = U : (c.splice(m, 3), m -= 3), cy(c);
        }
      }
  }
  function fy(n) {
    this._internalRoot = n;
  }
  tp.prototype.render = fy.prototype.render = function(n) {
    var o = this._internalRoot;
    if (o === null) throw Error(u(409));
    var c = o.current, m = oo();
    iy(c, m, n, o, null, null);
  }, tp.prototype.unmount = fy.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
      this._internalRoot = null;
      var o = n.containerInfo;
      iy(n.current, 2, null, n, null, null), Zu(), o[dr] = null;
    }
  };
  function tp(n) {
    this._internalRoot = n;
  }
  tp.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
      var o = pc();
      n = { blockedOn: null, target: n, priority: o };
      for (var c = 0; c < Ir.length && o !== 0 && o < Ir[c].priority; c++) ;
      Ir.splice(c, 0, n), c === 0 && uy(n);
    }
  };
  var hy = i.version;
  if (hy !== "19.1.1")
    throw Error(
      u(
        527,
        hy,
        "19.1.1"
      )
    );
  dt.findDOMNode = function(n) {
    var o = n._reactInternals;
    if (o === void 0)
      throw typeof n.render == "function" ? Error(u(188)) : (n = Object.keys(n).join(","), Error(u(268, n)));
    return n = T(o), n = n !== null ? E(n) : null, n = n === null ? null : n.stateNode, n;
  };
  var ua = {
    bundleType: 0,
    version: "19.1.1",
    rendererPackageName: "react-dom",
    currentDispatcherRef: P,
    reconcilerVersion: "19.1.1"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Zh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Zh.isDisabled && Zh.supportsFiber)
      try {
        go = Zh.inject(
          ua
        ), Zn = Zh;
      } catch {
      }
  }
  return Wy.createRoot = function(n, o) {
    if (!h(n)) throw Error(u(299));
    var c = !1, m = "", b = kc, x = ug, R = dh, U = null;
    return o != null && (o.unstable_strictMode === !0 && (c = !0), o.identifierPrefix !== void 0 && (m = o.identifierPrefix), o.onUncaughtError !== void 0 && (b = o.onUncaughtError), o.onCaughtError !== void 0 && (x = o.onCaughtError), o.onRecoverableError !== void 0 && (R = o.onRecoverableError), o.unstable_transitionCallbacks !== void 0 && (U = o.unstable_transitionCallbacks)), o = ey(
      n,
      1,
      !1,
      null,
      null,
      c,
      m,
      b,
      x,
      R,
      U,
      null
    ), n[dr] = o.current, Qg(n), new fy(o);
  }, Wy.hydrateRoot = function(n, o, c) {
    if (!h(n)) throw Error(u(299));
    var m = !1, b = "", x = kc, R = ug, U = dh, Z = null, it = null;
    return c != null && (c.unstable_strictMode === !0 && (m = !0), c.identifierPrefix !== void 0 && (b = c.identifierPrefix), c.onUncaughtError !== void 0 && (x = c.onUncaughtError), c.onCaughtError !== void 0 && (R = c.onCaughtError), c.onRecoverableError !== void 0 && (U = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (Z = c.unstable_transitionCallbacks), c.formState !== void 0 && (it = c.formState)), o = ey(
      n,
      1,
      !0,
      o,
      c ?? null,
      m,
      b,
      x,
      R,
      U,
      Z,
      it
    ), o.context = ny(null), c = o.current, m = oo(), m = On(m), b = Oa(m), b.callback = null, ql(c, b, m), c = m, o.current.lanes = c, se(o, c), La(o), n[dr] = o.current, Qg(n), new tp(o);
  }, Wy.version = "19.1.1", Wy;
}
var Jy = {};
/**
 * @license React
 * react-dom-client.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var IT;
function GE() {
  return IT || (IT = 1, process.env.NODE_ENV !== "production" && function() {
    function s(t, e) {
      for (t = t.memoizedState; t !== null && 0 < e; )
        t = t.next, e--;
      return t;
    }
    function i(t, e, a, f) {
      if (a >= e.length) return f;
      var p = e[a], y = de(t) ? t.slice() : Me({}, t);
      return y[p] = i(t[p], e, a + 1, f), y;
    }
    function l(t, e, a) {
      if (e.length !== a.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var f = 0; f < a.length - 1; f++)
          if (e[f] !== a[f]) {
            console.warn(
              "copyWithRename() expects paths to be the same except for the deepest key"
            );
            return;
          }
        return u(t, e, a, 0);
      }
    }
    function u(t, e, a, f) {
      var p = e[f], y = de(t) ? t.slice() : Me({}, t);
      return f + 1 === e.length ? (y[a[f]] = y[p], de(y) ? y.splice(p, 1) : delete y[p]) : y[p] = u(
        t[p],
        e,
        a,
        f + 1
      ), y;
    }
    function h(t, e, a) {
      var f = e[a], p = de(t) ? t.slice() : Me({}, t);
      return a + 1 === e.length ? (de(p) ? p.splice(f, 1) : delete p[f], p) : (p[f] = h(t[f], e, a + 1), p);
    }
    function g() {
      return !1;
    }
    function _() {
      return null;
    }
    function S() {
    }
    function T() {
      console.error(
        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
      );
    }
    function E() {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    function A() {
    }
    function C(t) {
      var e = [];
      return t.forEach(function(a) {
        e.push(a);
      }), e.sort().join(", ");
    }
    function z(t, e, a, f) {
      return new pi(t, e, a, f);
    }
    function j(t, e) {
      t.context === uf && (Je(t.current, 2, e, t, null, null), Nu());
    }
    function J(t, e) {
      if (ss !== null) {
        var a = e.staleFamilies;
        e = e.updatedFamilies, Nc(), il(
          t.current,
          e,
          a
        ), Nu();
      }
    }
    function Q(t) {
      ss = t;
    }
    function X(t) {
      return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
    }
    function et(t) {
      var e = t, a = t;
      if (t.alternate) for (; e.return; ) e = e.return;
      else {
        t = e;
        do
          e = t, (e.flags & 4098) !== 0 && (a = e.return), t = e.return;
        while (t);
      }
      return e.tag === 3 ? a : null;
    }
    function wt(t) {
      if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated;
      }
      return null;
    }
    function At(t) {
      if (et(t) !== t)
        throw Error("Unable to find node on an unmounted component.");
    }
    function Lt(t) {
      var e = t.alternate;
      if (!e) {
        if (e = et(t), e === null)
          throw Error("Unable to find node on an unmounted component.");
        return e !== t ? null : t;
      }
      for (var a = t, f = e; ; ) {
        var p = a.return;
        if (p === null) break;
        var y = p.alternate;
        if (y === null) {
          if (f = p.return, f !== null) {
            a = f;
            continue;
          }
          break;
        }
        if (p.child === y.child) {
          for (y = p.child; y; ) {
            if (y === a) return At(p), t;
            if (y === f) return At(p), e;
            y = y.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== f.return) a = p, f = y;
        else {
          for (var M = !1, D = p.child; D; ) {
            if (D === a) {
              M = !0, a = p, f = y;
              break;
            }
            if (D === f) {
              M = !0, f = p, a = y;
              break;
            }
            D = D.sibling;
          }
          if (!M) {
            for (D = y.child; D; ) {
              if (D === a) {
                M = !0, a = y, f = p;
                break;
              }
              if (D === f) {
                M = !0, f = y, a = p;
                break;
              }
              D = D.sibling;
            }
            if (!M)
              throw Error(
                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
              );
          }
        }
        if (a.alternate !== f)
          throw Error(
            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
          );
      }
      if (a.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? t : e;
    }
    function yt(t) {
      var e = t.tag;
      if (e === 5 || e === 26 || e === 27 || e === 6) return t;
      for (t = t.child; t !== null; ) {
        if (e = yt(t), e !== null) return e;
        t = t.sibling;
      }
      return null;
    }
    function Bt(t) {
      return t === null || typeof t != "object" ? null : (t = Wg && t[Wg] || t["@@iterator"], typeof t == "function" ? t : null);
    }
    function Ct(t) {
      if (t == null) return null;
      if (typeof t == "function")
        return t.$$typeof === jm ? null : t.displayName || t.name || null;
      if (typeof t == "string") return t;
      switch (t) {
        case _e:
          return "Fragment";
        case Jc:
          return "Profiler";
        case Wc:
          return "StrictMode";
        case Ic:
          return "Suspense";
        case Gr:
          return "SuspenseList";
        case Kg:
          return "Activity";
      }
      if (typeof t == "object")
        switch (typeof t.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), t.$$typeof) {
          case Xu:
            return "Portal";
          case qo:
            return (t.displayName || "Context") + ".Provider";
          case Ym:
            return (t._context.displayName || "Context") + ".Consumer";
          case Ws:
            var e = t.render;
            return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
          case Rh:
            return e = t.displayName || null, e !== null ? e : Ct(t.type) || "Memo";
          case so:
            e = t._payload, t = t._init;
            try {
              return Ct(t(e));
            } catch {
            }
        }
      return null;
    }
    function Yt(t) {
      return typeof t.tag == "number" ? Mt(t) : typeof t.name == "string" ? t.name : null;
    }
    function Mt(t) {
      var e = t.type;
      switch (t.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (e._context.displayName || "Context") + ".Consumer";
        case 10:
          return (e.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return e;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Ct(e);
        case 8:
          return e === Wc ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if (typeof e == "function")
            return e.displayName || e.name || null;
          if (typeof e == "string") return e;
          break;
        case 29:
          if (e = t._debugInfo, e != null) {
            for (var a = e.length - 1; 0 <= a; a--)
              if (typeof e[a].name == "string") return e[a].name;
          }
          if (t.return !== null)
            return Mt(t.return);
      }
      return null;
    }
    function ne(t) {
      return { current: t };
    }
    function Rt(t, e) {
      0 > Zo ? console.error("Unexpected pop.") : (e !== zh[Zo] && console.error("Unexpected Fiber popped."), t.current = Ch[Zo], Ch[Zo] = null, zh[Zo] = null, Zo--);
    }
    function kt(t, e, a) {
      Zo++, Ch[Zo] = t.current, zh[Zo] = a, t.current = e;
    }
    function Ee(t) {
      return t === null && console.error(
        "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
      ), t;
    }
    function ge(t, e) {
      kt(ns, e, t), kt($c, t, t), kt(Js, null, t);
      var a = e.nodeType;
      switch (a) {
        case 9:
        case 11:
          a = a === 9 ? "#document" : "#fragment", e = (e = e.documentElement) && (e = e.namespaceURI) ? Ke(e) : lc;
          break;
        default:
          if (a = e.tagName, e = e.namespaceURI)
            e = Ke(e), e = Ca(
              e,
              a
            );
          else
            switch (a) {
              case "svg":
                e = Ap;
                break;
              case "math":
                e = q_;
                break;
              default:
                e = lc;
            }
      }
      a = a.toLowerCase(), a = yn(null, a), a = {
        context: e,
        ancestorInfo: a
      }, Rt(Js, t), kt(Js, a, t);
    }
    function It(t) {
      Rt(Js, t), Rt($c, t), Rt(ns, t);
    }
    function P() {
      return Ee(Js.current);
    }
    function dt(t) {
      t.memoizedState !== null && kt(Fc, t, t);
      var e = Ee(Js.current), a = t.type, f = Ca(e.context, a);
      a = yn(e.ancestorInfo, a), f = { context: f, ancestorInfo: a }, e !== f && (kt($c, t, t), kt(Js, f, t));
    }
    function ut(t) {
      $c.current === t && (Rt(Js, t), Rt($c, t)), Fc.current === t && (Rt(Fc, t), Py._currentValue = ld);
    }
    function Gt(t) {
      return typeof Symbol == "function" && Symbol.toStringTag && t[Symbol.toStringTag] || t.constructor.name || "Object";
    }
    function k(t) {
      try {
        return F(t), !1;
      } catch {
        return !0;
      }
    }
    function F(t) {
      return "" + t;
    }
    function ct(t, e) {
      if (k(t))
        return console.error(
          "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
          e,
          Gt(t)
        ), F(t);
    }
    function bt(t, e) {
      if (k(t))
        return console.error(
          "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
          e,
          Gt(t)
        ), F(t);
    }
    function Et(t) {
      if (k(t))
        return console.error(
          "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
          Gt(t)
        ), F(t);
    }
    function zt(t) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") return !1;
      var e = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (e.isDisabled) return !0;
      if (!e.supportsFiber)
        return console.error(
          "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
        ), !0;
      try {
        Qr = e.inject(t), ki = e;
      } catch (a) {
        console.error("React instrumentation encountered an error: %s.", a);
      }
      return !!e.checkDCE;
    }
    function Tt(t) {
      if (typeof P0 == "function" && pl(t), ki && typeof ki.setStrictMode == "function")
        try {
          ki.setStrictMode(Qr, t);
        } catch (e) {
          Ha || (Ha = !0, console.error(
            "React instrumentation encountered an error: %s",
            e
          ));
        }
    }
    function We(t) {
      jt = t;
    }
    function $t() {
      jt !== null && typeof jt.markCommitStopped == "function" && jt.markCommitStopped();
    }
    function on(t) {
      jt !== null && typeof jt.markComponentRenderStarted == "function" && jt.markComponentRenderStarted(t);
    }
    function ci() {
      jt !== null && typeof jt.markComponentRenderStopped == "function" && jt.markComponentRenderStopped();
    }
    function da(t) {
      jt !== null && typeof jt.markRenderStarted == "function" && jt.markRenderStarted(t);
    }
    function Za() {
      jt !== null && typeof jt.markRenderStopped == "function" && jt.markRenderStopped();
    }
    function ma(t, e) {
      jt !== null && typeof jt.markStateUpdateScheduled == "function" && jt.markStateUpdateScheduled(t, e);
    }
    function ur(t) {
      return t >>>= 0, t === 0 ? 32 : 31 - (Vm(t) / $s | 0) | 0;
    }
    function cr(t) {
      if (t & 1) return "SyncHydrationLane";
      if (t & 2) return "Sync";
      if (t & 4) return "InputContinuousHydration";
      if (t & 8) return "InputContinuous";
      if (t & 16) return "DefaultHydration";
      if (t & 32) return "Default";
      if (t & 128) return "TransitionHydration";
      if (t & 4194048) return "Transition";
      if (t & 62914560) return "Retry";
      if (t & 67108864) return "SelectiveHydration";
      if (t & 134217728) return "IdleHydration";
      if (t & 268435456) return "Idle";
      if (t & 536870912) return "Offscreen";
      if (t & 1073741824) return "Deferred";
    }
    function Tn(t) {
      var e = t & 42;
      if (e !== 0) return e;
      switch (t & -t) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return t & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return t & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), t;
      }
    }
    function En(t, e, a) {
      var f = t.pendingLanes;
      if (f === 0) return 0;
      var p = 0, y = t.suspendedLanes, M = t.pingedLanes;
      t = t.warmLanes;
      var D = f & 134217727;
      return D !== 0 ? (f = D & ~y, f !== 0 ? p = Tn(f) : (M &= D, M !== 0 ? p = Tn(M) : a || (a = D & ~t, a !== 0 && (p = Tn(a))))) : (D = f & ~y, D !== 0 ? p = Tn(D) : M !== 0 ? p = Tn(M) : a || (a = f & ~t, a !== 0 && (p = Tn(a)))), p === 0 ? 0 : e !== 0 && e !== p && (e & y) === 0 && (y = p & -p, a = e & -e, y >= a || y === 32 && (a & 4194048) !== 0) ? e : p;
    }
    function Va(t, e) {
      return (t.pendingLanes & ~(t.suspendedLanes & ~t.pingedLanes) & e) === 0;
    }
    function dc(t, e) {
      switch (t) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return e + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return e + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), -1;
      }
    }
    function pe() {
      var t = Pm;
      return Pm <<= 1, (Pm & 4194048) === 0 && (Pm = 256), t;
    }
    function pa() {
      var t = Gm;
      return Gm <<= 1, (Gm & 62914560) === 0 && (Gm = 4194304), t;
    }
    function vs(t) {
      for (var e = [], a = 0; 31 > a; a++) e.push(t);
      return e;
    }
    function po(t, e) {
      t.pendingLanes |= e, e !== 268435456 && (t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0);
    }
    function mc(t, e, a, f, p, y) {
      var M = t.pendingLanes;
      t.pendingLanes = a, t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0, t.expiredLanes &= a, t.entangledLanes &= a, t.errorRecoveryDisabledLanes &= a, t.shellSuspendCounter = 0;
      var D = t.entanglements, B = t.expirationTimes, Y = t.hiddenUpdates;
      for (a = M & ~a; 0 < a; ) {
        var lt = 31 - Ki(a), mt = 1 << lt;
        D[lt] = 0, B[lt] = -1;
        var at = Y[lt];
        if (at !== null)
          for (Y[lt] = null, lt = 0; lt < at.length; lt++) {
            var pt = at[lt];
            pt !== null && (pt.lane &= -536870913);
          }
        a &= ~mt;
      }
      f !== 0 && hu(t, f, 0), y !== 0 && p === 0 && t.tag !== 0 && (t.suspendedLanes |= y & ~(M & ~e));
    }
    function hu(t, e, a) {
      t.pendingLanes |= e, t.suspendedLanes &= ~e;
      var f = 31 - Ki(e);
      t.entangledLanes |= e, t.entanglements[f] = t.entanglements[f] | 1073741824 | a & 4194090;
    }
    function go(t, e) {
      var a = t.entangledLanes |= e;
      for (t = t.entanglements; a; ) {
        var f = 31 - Ki(a), p = 1 << f;
        p & e | t[f] & e && (t[f] |= e), a &= ~p;
      }
    }
    function Zn(t) {
      switch (t) {
        case 2:
          t = 1;
          break;
        case 8:
          t = 4;
          break;
        case 32:
          t = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          t = 128;
          break;
        case 268435456:
          t = 134217728;
          break;
        default:
          t = 0;
      }
      return t;
    }
    function ta(t, e, a) {
      if (kn)
        for (t = t.pendingUpdatersLaneMap; 0 < a; ) {
          var f = 31 - Ki(a), p = 1 << f;
          t[f].add(e), a &= ~p;
        }
    }
    function In(t, e) {
      if (kn)
        for (var a = t.pendingUpdatersLaneMap, f = t.memoizedUpdaters; 0 < e; ) {
          var p = 31 - Ki(e);
          t = 1 << p, p = a[p], 0 < p.size && (p.forEach(function(y) {
            var M = y.alternate;
            M !== null && f.has(M) || f.add(y);
          }), p.clear()), e &= ~t;
        }
    }
    function _s(t) {
      return t &= -t, Ni < t ? gl < t ? (t & 134217727) !== 0 ? Fs : Xm : gl : Ni;
    }
    function fr() {
      var t = re.p;
      return t !== 0 ? t : (t = window.event, t === void 0 ? Fs : Um(t.type));
    }
    function hr(t, e) {
      var a = re.p;
      try {
        return re.p = t, e();
      } finally {
        re.p = a;
      }
    }
    function ga(t) {
      delete t[Wi], delete t[ka], delete t[Jg], delete t[n_], delete t[ef];
    }
    function fi(t) {
      var e = t[Wi];
      if (e) return e;
      for (var a = t.parentNode; a; ) {
        if (e = a[Wr] || a[Wi]) {
          if (a = e.alternate, e.child !== null || a !== null && a.child !== null)
            for (t = Gc(t); t !== null; ) {
              if (a = t[Wi])
                return a;
              t = Gc(t);
            }
          return e;
        }
        t = a, a = t.parentNode;
      }
      return null;
    }
    function Vn(t) {
      if (t = t[Wi] || t[Wr]) {
        var e = t.tag;
        if (e === 5 || e === 6 || e === 13 || e === 26 || e === 27 || e === 3)
          return t;
      }
      return null;
    }
    function Pa(t) {
      var e = t.tag;
      if (e === 5 || e === 26 || e === 27 || e === 6)
        return t.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function N(t) {
      var e = t[nf];
      return e || (e = t[nf] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), e;
    }
    function $(t) {
      t[af] = !0;
    }
    function Dt(t, e) {
      Ht(t, e), Ht(t + "Capture", e);
    }
    function Ht(t, e) {
      Vo[t] && console.error(
        "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
        t
      ), Vo[t] = e;
      var a = t.toLowerCase();
      for (Qu[a] = t, t === "onDoubleClick" && (Qu.ondblclick = t), t = 0; t < e.length; t++)
        i_.add(e[t]);
    }
    function Xt(t, e) {
      a_[e.type] || e.onChange || e.onInput || e.readOnly || e.disabled || e.value == null || console.error(
        t === "select" ? "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`." : "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
      ), e.onChange || e.readOnly || e.disabled || e.checked == null || console.error(
        "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
      );
    }
    function se(t) {
      return Is.call(Wm, t) ? !0 : Is.call(Km, t) ? !1 : Qm.test(t) ? Wm[t] = !0 : (Km[t] = !0, console.error("Invalid attribute name: `%s`", t), !1);
    }
    function he(t, e, a) {
      if (se(e)) {
        if (!t.hasAttribute(e)) {
          switch (typeof a) {
            case "symbol":
            case "object":
              return a;
            case "function":
              return a;
            case "boolean":
              if (a === !1) return a;
          }
          return a === void 0 ? void 0 : null;
        }
        return t = t.getAttribute(e), t === "" && a === !0 ? !0 : (ct(a, e), t === "" + a ? a : t);
      }
    }
    function ze(t, e, a) {
      if (se(e))
        if (a === null) t.removeAttribute(e);
        else {
          switch (typeof a) {
            case "undefined":
            case "function":
            case "symbol":
              t.removeAttribute(e);
              return;
            case "boolean":
              var f = e.toLowerCase().slice(0, 5);
              if (f !== "data-" && f !== "aria-") {
                t.removeAttribute(e);
                return;
              }
          }
          ct(a, e), t.setAttribute(e, "" + a);
        }
    }
    function fe(t, e, a) {
      if (a === null) t.removeAttribute(e);
      else {
        switch (typeof a) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            t.removeAttribute(e);
            return;
        }
        ct(a, e), t.setAttribute(e, "" + a);
      }
    }
    function On(t, e, a, f) {
      if (f === null) t.removeAttribute(a);
      else {
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            t.removeAttribute(a);
            return;
        }
        ct(f, a), t.setAttributeNS(e, a, "" + f);
      }
    }
    function Ga() {
    }
    function pc() {
      if (Jr === 0) {
        Ig = console.log, $g = console.info, o_ = console.warn, Fg = console.error, of = console.group, l_ = console.groupCollapsed, s_ = console.groupEnd;
        var t = {
          configurable: !0,
          enumerable: !0,
          value: Ga,
          writable: !0
        };
        Object.defineProperties(console, {
          info: t,
          log: t,
          warn: t,
          error: t,
          group: t,
          groupCollapsed: t,
          groupEnd: t
        });
      }
      Jr++;
    }
    function du() {
      if (Jr--, Jr === 0) {
        var t = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: Me({}, t, { value: Ig }),
          info: Me({}, t, { value: $g }),
          warn: Me({}, t, { value: o_ }),
          error: Me({}, t, { value: Fg }),
          group: Me({}, t, { value: of }),
          groupCollapsed: Me({}, t, { value: l_ }),
          groupEnd: Me({}, t, { value: s_ })
        });
      }
      0 > Jr && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function Nn(t) {
      if (ty === void 0)
        try {
          throw Error();
        } catch (a) {
          var e = a.stack.trim().match(/\n( *(at )?)/);
          ty = e && e[1] || "", kh = -1 < a.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < a.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + ty + t + kh;
    }
    function Pn(t, e) {
      if (!t || lf) return "";
      var a = Nh.get(t);
      if (a !== void 0) return a;
      lf = !0, a = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var f = null;
      f = ft.H, ft.H = null, pc();
      try {
        var p = {
          DetermineComponentFrameRoot: function() {
            try {
              if (e) {
                var at = function() {
                  throw Error();
                };
                if (Object.defineProperty(at.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(at, []);
                  } catch (Qt) {
                    var pt = Qt;
                  }
                  Reflect.construct(t, [], at);
                } else {
                  try {
                    at.call();
                  } catch (Qt) {
                    pt = Qt;
                  }
                  t.call(at.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (Qt) {
                  pt = Qt;
                }
                (at = t()) && typeof at.catch == "function" && at.catch(function() {
                });
              }
            } catch (Qt) {
              if (Qt && pt && typeof Qt.stack == "string")
                return [Qt.stack, pt.stack];
            }
            return [null, null];
          }
        };
        p.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var y = Object.getOwnPropertyDescriptor(
          p.DetermineComponentFrameRoot,
          "name"
        );
        y && y.configurable && Object.defineProperty(
          p.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var M = p.DetermineComponentFrameRoot(), D = M[0], B = M[1];
        if (D && B) {
          var Y = D.split(`
`), lt = B.split(`
`);
          for (M = y = 0; y < Y.length && !Y[y].includes(
            "DetermineComponentFrameRoot"
          ); )
            y++;
          for (; M < lt.length && !lt[M].includes(
            "DetermineComponentFrameRoot"
          ); )
            M++;
          if (y === Y.length || M === lt.length)
            for (y = Y.length - 1, M = lt.length - 1; 1 <= y && 0 <= M && Y[y] !== lt[M]; )
              M--;
          for (; 1 <= y && 0 <= M; y--, M--)
            if (Y[y] !== lt[M]) {
              if (y !== 1 || M !== 1)
                do
                  if (y--, M--, 0 > M || Y[y] !== lt[M]) {
                    var mt = `
` + Y[y].replace(
                      " at new ",
                      " at "
                    );
                    return t.displayName && mt.includes("<anonymous>") && (mt = mt.replace("<anonymous>", t.displayName)), typeof t == "function" && Nh.set(t, mt), mt;
                  }
                while (1 <= y && 0 <= M);
              break;
            }
        }
      } finally {
        lf = !1, ft.H = f, du(), Error.prepareStackTrace = a;
      }
      return Y = (Y = t ? t.displayName || t.name : "") ? Nn(Y) : "", typeof t == "function" && Nh.set(t, Y), Y;
    }
    function Mi(t) {
      var e = Error.prepareStackTrace;
      if (Error.prepareStackTrace = void 0, t = t.stack, Error.prepareStackTrace = e, t.startsWith(`Error: react-stack-top-frame
`) && (t = t.slice(29)), e = t.indexOf(`
`), e !== -1 && (t = t.slice(e + 1)), e = t.indexOf("react_stack_bottom_frame"), e !== -1 && (e = t.lastIndexOf(
        `
`,
        e
      )), e !== -1)
        t = t.slice(0, e);
      else return "";
      return t;
    }
    function dr(t) {
      switch (t.tag) {
        case 26:
        case 27:
        case 5:
          return Nn(t.type);
        case 16:
          return Nn("Lazy");
        case 13:
          return Nn("Suspense");
        case 19:
          return Nn("SuspenseList");
        case 0:
        case 15:
          return Pn(t.type, !1);
        case 11:
          return Pn(t.type.render, !1);
        case 1:
          return Pn(t.type, !0);
        case 31:
          return Nn("Activity");
        default:
          return "";
      }
    }
    function ea(t) {
      try {
        var e = "";
        do {
          e += dr(t);
          var a = t._debugInfo;
          if (a)
            for (var f = a.length - 1; 0 <= f; f--) {
              var p = a[f];
              if (typeof p.name == "string") {
                var y = e, M = p.env, D = Nn(
                  p.name + (M ? " [" + M + "]" : "")
                );
                e = y + D;
              }
            }
          t = t.return;
        } while (t);
        return e;
      } catch (B) {
        return `
Error generating stack: ` + B.message + `
` + B.stack;
      }
    }
    function Wt(t) {
      return (t = t ? t.displayName || t.name : "") ? Nn(t) : "";
    }
    function mu() {
      if (ro === null) return null;
      var t = ro._debugOwner;
      return t != null ? Yt(t) : null;
    }
    function Af() {
      if (ro === null) return "";
      var t = ro;
      try {
        var e = "";
        switch (t.tag === 6 && (t = t.return), t.tag) {
          case 26:
          case 27:
          case 5:
            e += Nn(t.type);
            break;
          case 13:
            e += Nn("Suspense");
            break;
          case 19:
            e += Nn("SuspenseList");
            break;
          case 31:
            e += Nn("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            t._debugOwner || e !== "" || (e += Wt(
              t.type
            ));
            break;
          case 11:
            t._debugOwner || e !== "" || (e += Wt(
              t.type.render
            ));
        }
        for (; t; )
          if (typeof t.tag == "number") {
            var a = t;
            t = a._debugOwner;
            var f = a._debugStack;
            t && f && (typeof f != "string" && (a._debugStack = f = Mi(f)), f !== "" && (e += `
` + f));
          } else if (t.debugStack != null) {
            var p = t.debugStack;
            (t = t.owner) && p && (e += `
` + Mi(p));
          } else break;
        var y = e;
      } catch (M) {
        y = `
Error generating stack: ` + M.message + `
` + M.stack;
      }
      return y;
    }
    function Vt(t, e, a, f, p, y, M) {
      var D = ro;
      mr(t);
      try {
        return t !== null && t._debugTask ? t._debugTask.run(
          e.bind(null, a, f, p, y, M)
        ) : e(a, f, p, y, M);
      } finally {
        mr(D);
      }
      throw Error(
        "runWithFiberInDEV should never be called in production. This is a bug in React."
      );
    }
    function mr(t) {
      ft.getCurrentStack = t === null ? null : Af, Na = !1, ro = t;
    }
    function Un(t) {
      switch (typeof t) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return t;
        case "object":
          return Et(t), t;
        default:
          return "";
      }
    }
    function bl(t) {
      var e = t.type;
      return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
    }
    function yo(t) {
      var e = bl(t) ? "checked" : "value", a = Object.getOwnPropertyDescriptor(
        t.constructor.prototype,
        e
      );
      Et(t[e]);
      var f = "" + t[e];
      if (!t.hasOwnProperty(e) && typeof a < "u" && typeof a.get == "function" && typeof a.set == "function") {
        var p = a.get, y = a.set;
        return Object.defineProperty(t, e, {
          configurable: !0,
          get: function() {
            return p.call(this);
          },
          set: function(M) {
            Et(M), f = "" + M, y.call(this, M);
          }
        }), Object.defineProperty(t, e, {
          enumerable: a.enumerable
        }), {
          getValue: function() {
            return f;
          },
          setValue: function(M) {
            Et(M), f = "" + M;
          },
          stopTracking: function() {
            t._valueTracker = null, delete t[e];
          }
        };
      }
    }
    function vo(t) {
      t._valueTracker || (t._valueTracker = yo(t));
    }
    function Bn(t) {
      if (!t) return !1;
      var e = t._valueTracker;
      if (!e) return !0;
      var a = e.getValue(), f = "";
      return t && (f = bl(t) ? t.checked ? "true" : "false" : t.value), t = f, t !== a ? (e.setValue(t), !0) : !1;
    }
    function pu(t) {
      if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
      try {
        return t.activeElement || t.body;
      } catch {
        return t.body;
      }
    }
    function na(t) {
      return t.replace(
        G0,
        function(e) {
          return "\\" + e.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function Sl(t, e) {
      e.checked === void 0 || e.defaultChecked === void 0 || ny || (console.error(
        "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        mu() || "A component",
        e.type
      ), ny = !0), e.value === void 0 || e.defaultValue === void 0 || ey || (console.error(
        "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        mu() || "A component",
        e.type
      ), ey = !0);
    }
    function Wo(t, e, a, f, p, y, M, D) {
      t.name = "", M != null && typeof M != "function" && typeof M != "symbol" && typeof M != "boolean" ? (ct(M, "type"), t.type = M) : t.removeAttribute("type"), e != null ? M === "number" ? (e === 0 && t.value === "" || t.value != e) && (t.value = "" + Un(e)) : t.value !== "" + Un(e) && (t.value = "" + Un(e)) : M !== "submit" && M !== "reset" || t.removeAttribute("value"), e != null ? bs(t, M, Un(e)) : a != null ? bs(t, M, Un(a)) : f != null && t.removeAttribute("value"), p == null && y != null && (t.defaultChecked = !!y), p != null && (t.checked = p && typeof p != "function" && typeof p != "symbol"), D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" ? (ct(D, "name"), t.name = "" + Un(D)) : t.removeAttribute("name");
    }
    function bd(t, e, a, f, p, y, M, D) {
      if (y != null && typeof y != "function" && typeof y != "symbol" && typeof y != "boolean" && (ct(y, "type"), t.type = y), e != null || a != null) {
        if (!(y !== "submit" && y !== "reset" || e != null))
          return;
        a = a != null ? "" + Un(a) : "", e = e != null ? "" + Un(e) : a, D || e === t.value || (t.value = e), t.defaultValue = e;
      }
      f = f ?? p, f = typeof f != "function" && typeof f != "symbol" && !!f, t.checked = D ? t.checked : !!f, t.defaultChecked = !!f, M != null && typeof M != "function" && typeof M != "symbol" && typeof M != "boolean" && (ct(M, "name"), t.name = M);
    }
    function bs(t, e, a) {
      e === "number" && pu(t.ownerDocument) === t || t.defaultValue === "" + a || (t.defaultValue = "" + a);
    }
    function Df(t, e) {
      e.value == null && (typeof e.children == "object" && e.children !== null ? Ah.Children.forEach(e.children, function(a) {
        a == null || typeof a == "string" || typeof a == "number" || typeof a == "bigint" || ay || (ay = !0, console.error(
          "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
        ));
      }) : e.dangerouslySetInnerHTML == null || Jm || (Jm = !0, console.error(
        "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
      ))), e.selected == null || iy || (console.error(
        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
      ), iy = !0);
    }
    function Sd() {
      var t = mu();
      return t ? `

Check the render method of \`` + t + "`." : "";
    }
    function Jo(t, e, a, f) {
      if (t = t.options, e) {
        e = {};
        for (var p = 0; p < a.length; p++)
          e["$" + a[p]] = !0;
        for (a = 0; a < t.length; a++)
          p = e.hasOwnProperty("$" + t[a].value), t[a].selected !== p && (t[a].selected = p), p && f && (t[a].defaultSelected = !0);
      } else {
        for (a = "" + Un(a), e = null, p = 0; p < t.length; p++) {
          if (t[p].value === a) {
            t[p].selected = !0, f && (t[p].defaultSelected = !0);
            return;
          }
          e !== null || t[p].disabled || (e = t[p]);
        }
        e !== null && (e.selected = !0);
      }
    }
    function gu(t, e) {
      for (t = 0; t < Uh.length; t++) {
        var a = Uh[t];
        if (e[a] != null) {
          var f = de(e[a]);
          e.multiple && !f ? console.error(
            "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
            a,
            Sd()
          ) : !e.multiple && f && console.error(
            "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
            a,
            Sd()
          );
        }
      }
      e.value === void 0 || e.defaultValue === void 0 || oy || (console.error(
        "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
      ), oy = !0);
    }
    function _o(t, e) {
      e.value === void 0 || e.defaultValue === void 0 || r_ || (console.error(
        "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
        mu() || "A component"
      ), r_ = !0), e.children != null && e.value == null && console.error(
        "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
      );
    }
    function pr(t, e, a) {
      if (e != null && (e = "" + Un(e), e !== t.value && (t.value = e), a == null)) {
        t.defaultValue !== e && (t.defaultValue = e);
        return;
      }
      t.defaultValue = a != null ? "" + Un(a) : "";
    }
    function Ss(t, e, a, f) {
      if (e == null) {
        if (f != null) {
          if (a != null)
            throw Error(
              "If you supply `defaultValue` on a <textarea>, do not pass children."
            );
          if (de(f)) {
            if (1 < f.length)
              throw Error("<textarea> can only have at most one child.");
            f = f[0];
          }
          a = f;
        }
        a == null && (a = ""), e = a;
      }
      a = Un(e), t.defaultValue = a, f = t.textContent, f === a && f !== "" && f !== null && (t.value = f);
    }
    function Tl(t, e) {
      return t.serverProps === void 0 && t.serverTail.length === 0 && t.children.length === 1 && 3 < t.distanceFromLeaf && t.distanceFromLeaf > 15 - e ? Tl(t.children[0], e) : t;
    }
    function hi(t) {
      return "  " + "  ".repeat(t);
    }
    function ya(t) {
      return "+ " + "  ".repeat(t);
    }
    function we(t) {
      return "- " + "  ".repeat(t);
    }
    function ln(t) {
      switch (t.tag) {
        case 26:
        case 27:
        case 5:
          return t.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return t = t.type, t.displayName || t.name || null;
        case 11:
          return t = t.type.render, t.displayName || t.name || null;
        case 1:
          return t = t.type, t.displayName || t.name || null;
        default:
          return null;
      }
    }
    function Yn(t, e) {
      return u_.test(t) ? (t = JSON.stringify(t), t.length > e - 2 ? 8 > e ? '{"..."}' : "{" + t.slice(0, e - 7) + '..."}' : "{" + t + "}") : t.length > e ? 5 > e ? '{"..."}' : t.slice(0, e - 3) + "..." : t;
    }
    function bo(t, e, a) {
      var f = 120 - 2 * a;
      if (e === null)
        return ya(a) + Yn(t, f) + `
`;
      if (typeof e == "string") {
        for (var p = 0; p < e.length && p < t.length && e.charCodeAt(p) === t.charCodeAt(p); p++) ;
        return p > f - 8 && 10 < p && (t = "..." + t.slice(p - 8), e = "..." + e.slice(p - 8)), ya(a) + Yn(t, f) + `
` + we(a) + Yn(e, f) + `
`;
      }
      return hi(a) + Yn(t, f) + `
`;
    }
    function xl(t) {
      return Object.prototype.toString.call(t).replace(/^\[object (.*)\]$/, function(e, a) {
        return a;
      });
    }
    function So(t, e) {
      switch (typeof t) {
        case "string":
          return t = JSON.stringify(t), t.length > e ? 5 > e ? '"..."' : t.slice(0, e - 4) + '..."' : t;
        case "object":
          if (t === null) return "null";
          if (de(t)) return "[...]";
          if (t.$$typeof === Pr)
            return (e = Ct(t.type)) ? "<" + e + ">" : "<...>";
          var a = xl(t);
          if (a === "Object") {
            a = "", e -= 2;
            for (var f in t)
              if (t.hasOwnProperty(f)) {
                var p = JSON.stringify(f);
                if (p !== '"' + f + '"' && (f = p), e -= f.length - 2, p = So(
                  t[f],
                  15 > e ? e : 15
                ), e -= p.length, 0 > e) {
                  a += a === "" ? "..." : ", ...";
                  break;
                }
                a += (a === "" ? "" : ",") + f + ":" + p;
              }
            return "{" + a + "}";
          }
          return a;
        case "function":
          return (e = t.displayName || t.name) ? "function " + e : "function";
        default:
          return String(t);
      }
    }
    function le(t, e) {
      return typeof t != "string" || u_.test(t) ? "{" + So(t, e - 2) + "}" : t.length > e - 2 ? 5 > e ? '"..."' : '"' + t.slice(0, e - 5) + '..."' : '"' + t + '"';
    }
    function Fe(t, e, a) {
      var f = 120 - a.length - t.length, p = [], y;
      for (y in e)
        if (e.hasOwnProperty(y) && y !== "children") {
          var M = le(
            e[y],
            120 - a.length - y.length - 1
          );
          f -= y.length + M.length + 2, p.push(y + "=" + M);
        }
      return p.length === 0 ? a + "<" + t + `>
` : 0 < f ? a + "<" + t + " " + p.join(" ") + `>
` : a + "<" + t + `
` + a + "  " + p.join(`
` + a + "  ") + `
` + a + `>
`;
    }
    function Rf(t, e, a) {
      var f = "", p = Me({}, e), y;
      for (y in t)
        if (t.hasOwnProperty(y)) {
          delete p[y];
          var M = 120 - 2 * a - y.length - 2, D = So(t[y], M);
          e.hasOwnProperty(y) ? (M = So(e[y], M), f += ya(a) + y + ": " + D + `
`, f += we(a) + y + ": " + M + `
`) : f += ya(a) + y + ": " + D + `
`;
        }
      for (var B in p)
        p.hasOwnProperty(B) && (t = So(
          p[B],
          120 - 2 * a - B.length - 2
        ), f += we(a) + B + ": " + t + `
`);
      return f;
    }
    function Ei(t, e, a, f) {
      var p = "", y = /* @__PURE__ */ new Map();
      for (Y in a)
        a.hasOwnProperty(Y) && y.set(
          Y.toLowerCase(),
          Y
        );
      if (y.size === 1 && y.has("children"))
        p += Fe(
          t,
          e,
          hi(f)
        );
      else {
        for (var M in e)
          if (e.hasOwnProperty(M) && M !== "children") {
            var D = 120 - 2 * (f + 1) - M.length - 1, B = y.get(M.toLowerCase());
            if (B !== void 0) {
              y.delete(M.toLowerCase());
              var Y = e[M];
              B = a[B];
              var lt = le(
                Y,
                D
              );
              D = le(
                B,
                D
              ), typeof Y == "object" && Y !== null && typeof B == "object" && B !== null && xl(Y) === "Object" && xl(B) === "Object" && (2 < Object.keys(Y).length || 2 < Object.keys(B).length || -1 < lt.indexOf("...") || -1 < D.indexOf("...")) ? p += hi(f + 1) + M + `={{
` + Rf(
                Y,
                B,
                f + 2
              ) + hi(f + 1) + `}}
` : (p += ya(f + 1) + M + "=" + lt + `
`, p += we(f + 1) + M + "=" + D + `
`);
            } else
              p += hi(f + 1) + M + "=" + le(e[M], D) + `
`;
          }
        y.forEach(function(mt) {
          if (mt !== "children") {
            var at = 120 - 2 * (f + 1) - mt.length - 1;
            p += we(f + 1) + mt + "=" + le(a[mt], at) + `
`;
          }
        }), p = p === "" ? hi(f) + "<" + t + `>
` : hi(f) + "<" + t + `
` + p + hi(f) + `>
`;
      }
      return t = a.children, e = e.children, typeof t == "string" || typeof t == "number" || typeof t == "bigint" ? (y = "", (typeof e == "string" || typeof e == "number" || typeof e == "bigint") && (y = "" + e), p += bo(y, "" + t, f + 1)) : (typeof e == "string" || typeof e == "number" || typeof e == "bigint") && (p = t == null ? p + bo("" + e, null, f + 1) : p + bo("" + e, void 0, f + 1)), p;
    }
    function Oi(t, e) {
      var a = ln(t);
      if (a === null) {
        for (a = "", t = t.child; t; )
          a += Oi(t, e), t = t.sibling;
        return a;
      }
      return hi(e) + "<" + a + `>
`;
    }
    function gc(t, e) {
      var a = Tl(t, e);
      if (a !== t && (t.children.length !== 1 || t.children[0] !== a))
        return hi(e) + `...
` + gc(a, e + 1);
      a = "";
      var f = t.fiber._debugInfo;
      if (f)
        for (var p = 0; p < f.length; p++) {
          var y = f[p].name;
          typeof y == "string" && (a += hi(e) + "<" + y + `>
`, e++);
        }
      if (f = "", p = t.fiber.pendingProps, t.fiber.tag === 6)
        f = bo(p, t.serverProps, e), e++;
      else if (y = ln(t.fiber), y !== null)
        if (t.serverProps === void 0) {
          f = e;
          var M = 120 - 2 * f - y.length - 2, D = "";
          for (Y in p)
            if (p.hasOwnProperty(Y) && Y !== "children") {
              var B = le(p[Y], 15);
              if (M -= Y.length + B.length + 2, 0 > M) {
                D += " ...";
                break;
              }
              D += " " + Y + "=" + B;
            }
          f = hi(f) + "<" + y + D + `>
`, e++;
        } else
          t.serverProps === null ? (f = Fe(
            y,
            p,
            ya(e)
          ), e++) : typeof t.serverProps == "string" ? console.error(
            "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
          ) : (f = Ei(
            y,
            p,
            t.serverProps,
            e
          ), e++);
      var Y = "";
      for (p = t.fiber.child, y = 0; p && y < t.children.length; )
        M = t.children[y], M.fiber === p ? (Y += gc(M, e), y++) : Y += Oi(p, e), p = p.sibling;
      for (p && 0 < t.children.length && (Y += hi(e) + `...
`), p = t.serverTail, t.serverProps === null && e--, t = 0; t < p.length; t++)
        y = p[t], Y = typeof y == "string" ? Y + (we(e) + Yn(y, 120 - 2 * e) + `
`) : Y + Fe(
          y.type,
          y.props,
          we(e)
        );
      return a + f + Y;
    }
    function wl(t) {
      try {
        return `

` + gc(t, 0);
      } catch {
        return "";
      }
    }
    function ia(t, e, a) {
      for (var f = e, p = null, y = 0; f; )
        f === t && (y = 0), p = {
          fiber: f,
          children: p !== null ? [p] : [],
          serverProps: f === e ? a : f === t ? null : void 0,
          serverTail: [],
          distanceFromLeaf: y
        }, y++, f = f.return;
      return p !== null ? wl(p).replaceAll(/^[+-]/gm, ">") : "";
    }
    function yn(t, e) {
      var a = Me({}, t || ry), f = { tag: e };
      return Im.indexOf(e) !== -1 && (a.aTagInScope = null, a.buttonTagInScope = null, a.nobrTagInScope = null), $m.indexOf(e) !== -1 && (a.pTagInButtonScope = null), ly.indexOf(e) !== -1 && e !== "address" && e !== "div" && e !== "p" && (a.listItemTagAutoclosing = null, a.dlItemTagAutoclosing = null), a.current = f, e === "form" && (a.formTag = f), e === "a" && (a.aTagInScope = f), e === "button" && (a.buttonTagInScope = f), e === "nobr" && (a.nobrTagInScope = f), e === "p" && (a.pTagInButtonScope = f), e === "li" && (a.listItemTagAutoclosing = f), (e === "dd" || e === "dt") && (a.dlItemTagAutoclosing = f), e === "#document" || e === "html" ? a.containerTagInScope = null : a.containerTagInScope || (a.containerTagInScope = f), t !== null || e !== "#document" && e !== "html" && e !== "body" ? a.implicitRootScope === !0 && (a.implicitRootScope = !1) : a.implicitRootScope = !0, a;
    }
    function Io(t, e, a) {
      switch (e) {
        case "select":
          return t === "hr" || t === "option" || t === "optgroup" || t === "script" || t === "template" || t === "#text";
        case "optgroup":
          return t === "option" || t === "#text";
        case "option":
          return t === "#text";
        case "tr":
          return t === "th" || t === "td" || t === "style" || t === "script" || t === "template";
        case "tbody":
        case "thead":
        case "tfoot":
          return t === "tr" || t === "style" || t === "script" || t === "template";
        case "colgroup":
          return t === "col" || t === "template";
        case "table":
          return t === "caption" || t === "colgroup" || t === "tbody" || t === "tfoot" || t === "thead" || t === "style" || t === "script" || t === "template";
        case "head":
          return t === "base" || t === "basefont" || t === "bgsound" || t === "link" || t === "meta" || t === "title" || t === "noscript" || t === "noframes" || t === "style" || t === "script" || t === "template";
        case "html":
          if (a) break;
          return t === "head" || t === "body" || t === "frameset";
        case "frameset":
          return t === "frame";
        case "#document":
          if (!a) return t === "html";
      }
      switch (t) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return e !== "h1" && e !== "h2" && e !== "h3" && e !== "h4" && e !== "h5" && e !== "h6";
        case "rp":
        case "rt":
          return sy.indexOf(e) === -1;
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return e == null;
        case "head":
          return a || e === null;
        case "html":
          return a && e === "#document" || e === null;
        case "body":
          return a && (e === "#document" || e === "html") || e === null;
      }
      return !0;
    }
    function To(t, e) {
      switch (t) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return e.pTagInButtonScope;
        case "form":
          return e.formTag || e.pTagInButtonScope;
        case "li":
          return e.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return e.dlItemTagAutoclosing;
        case "button":
          return e.buttonTagInScope;
        case "a":
          return e.aTagInScope;
        case "nobr":
          return e.nobrTagInScope;
      }
      return null;
    }
    function gr(t, e) {
      for (; t; ) {
        switch (t.tag) {
          case 5:
          case 26:
          case 27:
            if (t.type === e) return t;
        }
        t = t.return;
      }
      return null;
    }
    function yr(t, e) {
      e = e || ry;
      var a = e.current;
      if (e = (a = Io(
        t,
        a && a.tag,
        e.implicitRootScope
      ) ? null : a) ? null : To(t, e), e = a || e, !e) return !0;
      var f = e.tag;
      if (e = String(!!a) + "|" + t + "|" + f, sf[e]) return !1;
      sf[e] = !0;
      var p = (e = ro) ? gr(e.return, f) : null, y = e !== null && p !== null ? ia(p, e, null) : "", M = "<" + t + ">";
      return a ? (a = "", f === "table" && t === "tr" && (a += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
        `In HTML, %s cannot be a child of <%s>.%s
This will cause a hydration error.%s`,
        M,
        f,
        a,
        y
      )) : console.error(
        `In HTML, %s cannot be a descendant of <%s>.
This will cause a hydration error.%s`,
        M,
        f,
        y
      ), e && (t = e.return, p === null || t === null || p === t && t._debugOwner === e._debugOwner || Vt(p, function() {
        console.error(
          `<%s> cannot contain a nested %s.
See this log for the ancestor stack trace.`,
          f,
          M
        );
      })), !1;
    }
    function $o(t, e, a) {
      if (a || Io("#text", e, !1))
        return !0;
      if (a = "#text|" + e, sf[a]) return !1;
      sf[a] = !0;
      var f = (a = ro) ? gr(a, e) : null;
      return a = a !== null && f !== null ? ia(
        f,
        a,
        a.tag !== 6 ? { children: null } : null
      ) : "", /\S/.test(t) ? console.error(
        `In HTML, text nodes cannot be a child of <%s>.
This will cause a hydration error.%s`,
        e,
        a
      ) : console.error(
        `In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.
This will cause a hydration error.%s`,
        e,
        a
      ), !1;
    }
    function Fo(t, e) {
      if (e) {
        var a = t.firstChild;
        if (a && a === t.lastChild && a.nodeType === 3) {
          a.nodeValue = e;
          return;
        }
      }
      t.textContent = e;
    }
    function Cf(t) {
      return t.replace(Ir, function(e, a) {
        return a.toUpperCase();
      });
    }
    function yu(t, e, a) {
      var f = e.indexOf("--") === 0;
      f || (-1 < e.indexOf("-") ? Ku.hasOwnProperty(e) && Ku[e] || (Ku[e] = !0, console.error(
        "Unsupported style property %s. Did you mean %s?",
        e,
        Cf(e.replace(Yh, "ms-"))
      )) : Bh.test(e) ? Ku.hasOwnProperty(e) && Ku[e] || (Ku[e] = !0, console.error(
        "Unsupported vendor-prefixed style property %s. Did you mean %s?",
        e,
        e.charAt(0).toUpperCase() + e.slice(1)
      )) : !c_.test(a) || Wu.hasOwnProperty(a) && Wu[a] || (Wu[a] = !0, console.error(
        `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
        e,
        a.replace(c_, "")
      )), typeof a == "number" && (isNaN(a) ? f_ || (f_ = !0, console.error(
        "`NaN` is an invalid value for the `%s` css style property.",
        e
      )) : isFinite(a) || uy || (uy = !0, console.error(
        "`Infinity` is an invalid value for the `%s` css style property.",
        e
      )))), a == null || typeof a == "boolean" || a === "" ? f ? t.setProperty(e, "") : e === "float" ? t.cssFloat = "" : t[e] = "" : f ? t.setProperty(e, a) : typeof a != "number" || a === 0 || jh.has(e) ? e === "float" ? t.cssFloat = a : (bt(a, e), t[e] = ("" + a).trim()) : t[e] = a + "px";
    }
    function Ts(t, e, a) {
      if (e != null && typeof e != "object")
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      if (e && Object.freeze(e), t = t.style, a != null) {
        if (e) {
          var f = {};
          if (a) {
            for (var p in a)
              if (a.hasOwnProperty(p) && !e.hasOwnProperty(p))
                for (var y = as[p] || [p], M = 0; M < y.length; M++)
                  f[y[M]] = p;
          }
          for (var D in e)
            if (e.hasOwnProperty(D) && (!a || a[D] !== e[D]))
              for (p = as[D] || [D], y = 0; y < p.length; y++)
                f[p[y]] = D;
          D = {};
          for (var B in e)
            for (p = as[B] || [B], y = 0; y < p.length; y++)
              D[p[y]] = B;
          B = {};
          for (var Y in f)
            if (p = f[Y], (y = D[Y]) && p !== y && (M = p + "," + y, !B[M])) {
              B[M] = !0, M = console;
              var lt = e[p];
              M.error.call(
                M,
                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                lt == null || typeof lt == "boolean" || lt === "" ? "Removing" : "Updating",
                p,
                y
              );
            }
        }
        for (var mt in a)
          !a.hasOwnProperty(mt) || e != null && e.hasOwnProperty(mt) || (mt.indexOf("--") === 0 ? t.setProperty(mt, "") : mt === "float" ? t.cssFloat = "" : t[mt] = "");
        for (var at in e)
          Y = e[at], e.hasOwnProperty(at) && a[at] !== Y && yu(t, at, Y);
      } else
        for (f in e)
          e.hasOwnProperty(f) && yu(t, f, e[f]);
    }
    function tl(t) {
      if (t.indexOf("-") === -1) return !1;
      switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function xs(t) {
      return Fm.get(t) || t;
    }
    function ws(t, e) {
      if (Is.call(os, e) && os[e])
        return !0;
      if (tp.test(e)) {
        if (t = "aria-" + e.slice(4).toLowerCase(), t = cy.hasOwnProperty(t) ? t : null, t == null)
          return console.error(
            "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
            e
          ), os[e] = !0;
        if (e !== t)
          return console.error(
            "Invalid ARIA attribute `%s`. Did you mean `%s`?",
            e,
            t
          ), os[e] = !0;
      }
      if (fy.test(e)) {
        if (t = e.toLowerCase(), t = cy.hasOwnProperty(t) ? t : null, t == null) return os[e] = !0, !1;
        e !== t && (console.error(
          "Unknown ARIA attribute `%s`. Did you mean `%s`?",
          e,
          t
        ), os[e] = !0);
      }
      return !0;
    }
    function Ml(t, e) {
      var a = [], f;
      for (f in e)
        ws(t, f) || a.push(f);
      e = a.map(function(p) {
        return "`" + p + "`";
      }).join(", "), a.length === 1 ? console.error(
        "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        e,
        t
      ) : 1 < a.length && console.error(
        "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        e,
        t
      );
    }
    function Td(t, e, a, f) {
      if (Is.call(ua, e) && ua[e])
        return !0;
      var p = e.toLowerCase();
      if (p === "onfocusin" || p === "onfocusout")
        return console.error(
          "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
        ), ua[e] = !0;
      if (typeof a == "function" && (t === "form" && e === "action" || t === "input" && e === "formAction" || t === "button" && e === "formAction"))
        return !0;
      if (f != null) {
        if (t = f.possibleRegistrationNames, f.registrationNameDependencies.hasOwnProperty(e))
          return !0;
        if (f = t.hasOwnProperty(p) ? t[p] : null, f != null)
          return console.error(
            "Invalid event handler property `%s`. Did you mean `%s`?",
            e,
            f
          ), ua[e] = !0;
        if (Zh.test(e))
          return console.error(
            "Unknown event handler property `%s`. It will be ignored.",
            e
          ), ua[e] = !0;
      } else if (Zh.test(e))
        return n.test(e) && console.error(
          "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
          e
        ), ua[e] = !0;
      if (o.test(e) || c.test(e)) return !0;
      if (p === "innerhtml")
        return console.error(
          "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
        ), ua[e] = !0;
      if (p === "aria")
        return console.error(
          "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
        ), ua[e] = !0;
      if (p === "is" && a !== null && a !== void 0 && typeof a != "string")
        return console.error(
          "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
          typeof a
        ), ua[e] = !0;
      if (typeof a == "number" && isNaN(a))
        return console.error(
          "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
          e
        ), ua[e] = !0;
      if (Ju.hasOwnProperty(p)) {
        if (p = Ju[p], p !== e)
          return console.error(
            "Invalid DOM property `%s`. Did you mean `%s`?",
            e,
            p
          ), ua[e] = !0;
      } else if (e !== p)
        return console.error(
          "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
          e,
          p
        ), ua[e] = !0;
      switch (e) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof a) {
        case "boolean":
          switch (e) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              return p = e.toLowerCase().slice(0, 5), p === "data-" || p === "aria-" ? !0 : (a ? console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                a,
                e,
                e,
                a,
                e
              ) : console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                a,
                e,
                e,
                a,
                e,
                e,
                e
              ), ua[e] = !0);
          }
        case "function":
        case "symbol":
          return ua[e] = !0, !1;
        case "string":
          if (a === "false" || a === "true") {
            switch (e) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error(
              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
              a,
              e,
              a === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
              e,
              a
            ), ua[e] = !0;
          }
      }
      return !0;
    }
    function ce(t, e, a) {
      var f = [], p;
      for (p in e)
        Td(t, p, e[p], a) || f.push(p);
      e = f.map(function(y) {
        return "`" + y + "`";
      }).join(", "), f.length === 1 ? console.error(
        "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        e,
        t
      ) : 1 < f.length && console.error(
        "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        e,
        t
      );
    }
    function Ai(t) {
      return m.test("" + t) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : t;
    }
    function Ye(t) {
      return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
    }
    function Xa(t) {
      var e = Vn(t);
      if (e && (t = e.stateNode)) {
        var a = t[ka] || null;
        t: switch (t = e.stateNode, e.type) {
          case "input":
            if (Wo(
              t,
              a.value,
              a.defaultValue,
              a.defaultValue,
              a.checked,
              a.defaultChecked,
              a.type,
              a.name
            ), e = a.name, a.type === "radio" && e != null) {
              for (a = t; a.parentNode; ) a = a.parentNode;
              for (ct(e, "name"), a = a.querySelectorAll(
                'input[name="' + na(
                  "" + e
                ) + '"][type="radio"]'
              ), e = 0; e < a.length; e++) {
                var f = a[e];
                if (f !== t && f.form === t.form) {
                  var p = f[ka] || null;
                  if (!p)
                    throw Error(
                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                    );
                  Wo(
                    f,
                    p.value,
                    p.defaultValue,
                    p.defaultValue,
                    p.checked,
                    p.defaultChecked,
                    p.type,
                    p.name
                  );
                }
              }
              for (e = 0; e < a.length; e++)
                f = a[e], f.form === t.form && Bn(f);
            }
            break t;
          case "textarea":
            pr(t, a.value, a.defaultValue);
            break t;
          case "select":
            e = a.value, e != null && Jo(t, !!a.multiple, e, !1);
        }
      }
    }
    function vr(t, e, a) {
      if (U) return t(e, a);
      U = !0;
      try {
        var f = t(e);
        return f;
      } finally {
        if (U = !1, (x !== null || R !== null) && (Nu(), x && (e = x, t = R, R = x = null, Xa(e), t)))
          for (e = 0; e < t.length; e++) Xa(t[e]);
      }
    }
    function Qa(t, e) {
      var a = t.stateNode;
      if (a === null) return null;
      var f = a[ka] || null;
      if (f === null) return null;
      a = f[e];
      t: switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (f = !f.disabled) || (t = t.type, f = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !f;
          break t;
        default:
          t = !1;
      }
      if (t) return null;
      if (a && typeof a != "function")
        throw Error(
          "Expected `" + e + "` listener to be a function, instead got a value of `" + typeof a + "` type."
        );
      return a;
    }
    function Ka() {
      if (st) return st;
      var t, e = ot, a = e.length, f, p = "value" in St ? St.value : St.textContent, y = p.length;
      for (t = 0; t < a && e[t] === p[t]; t++) ;
      var M = a - t;
      for (f = 1; f <= M && e[a - f] === p[y - f]; f++) ;
      return st = p.slice(t, 1 < f ? 1 - f : void 0);
    }
    function va(t) {
      var e = t.keyCode;
      return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
    }
    function el() {
      return !0;
    }
    function Ms() {
      return !1;
    }
    function Ue(t) {
      function e(a, f, p, y, M) {
        this._reactName = a, this._targetInst = p, this.type = f, this.nativeEvent = y, this.target = M, this.currentTarget = null;
        for (var D in t)
          t.hasOwnProperty(D) && (a = t[D], this[D] = a ? a(y) : y[D]);
        return this.isDefaultPrevented = (y.defaultPrevented != null ? y.defaultPrevented : y.returnValue === !1) ? el : Ms, this.isPropagationStopped = Ms, this;
      }
      return Me(e.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var a = this.nativeEvent;
          a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1), this.isDefaultPrevented = el);
        },
        stopPropagation: function() {
          var a = this.nativeEvent;
          a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0), this.isPropagationStopped = el);
        },
        persist: function() {
        },
        isPersistent: el
      }), e;
    }
    function xo(t) {
      var e = this.nativeEvent;
      return e.getModifierState ? e.getModifierState(t) : (t = kM[t]) ? !!e[t] : !1;
    }
    function vu() {
      return xo;
    }
    function di(t, e) {
      switch (t) {
        case "keyup":
          return QM.indexOf(e.keyCode) !== -1;
        case "keydown":
          return e.keyCode !== Z1;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function El(t) {
      return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
    }
    function _u(t, e) {
      switch (t) {
        case "compositionend":
          return El(e);
        case "keypress":
          return e.which !== P1 ? null : (X1 = !0, G1);
        case "textInput":
          return t = e.data, t === G1 && X1 ? null : t;
        default:
          return null;
      }
    }
    function Es(t, e) {
      if (ep)
        return t === "compositionend" || !Q0 && di(t, e) ? (t = Ka(), st = ot = St = null, ep = !1, t) : null;
      switch (t) {
        case "paste":
          return null;
        case "keypress":
          if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
              return e.char;
            if (e.which)
              return String.fromCharCode(e.which);
          }
          return null;
        case "compositionend":
          return V1 && e.locale !== "ko" ? null : e.data;
        default:
          return null;
      }
    }
    function xd(t) {
      var e = t && t.nodeName && t.nodeName.toLowerCase();
      return e === "input" ? !!WM[t.type] : e === "textarea";
    }
    function yc(t) {
      if (!Z) return !1;
      t = "on" + t;
      var e = t in document;
      return e || (e = document.createElement("div"), e.setAttribute(t, "return;"), e = typeof e[t] == "function"), e;
    }
    function Oe(t, e, a, f) {
      x ? R ? R.push(f) : R = [f] : x = f, e = _h(e, "onChange"), 0 < e.length && (a = new te(
        "onChange",
        "change",
        null,
        a,
        f
      ), t.push({ event: a, listeners: e }));
    }
    function bu(t) {
      Jl(t, 0);
    }
    function $n(t) {
      var e = Pa(t);
      if (Bn(e)) return t;
    }
    function Os(t, e) {
      if (t === "change") return e;
    }
    function zf() {
      my && (my.detachEvent("onpropertychange", wd), py = my = null);
    }
    function wd(t) {
      if (t.propertyName === "value" && $n(py)) {
        var e = [];
        Oe(
          e,
          py,
          t,
          Ye(t)
        ), vr(bu, e);
      }
    }
    function Lf(t, e, a) {
      t === "focusin" ? (zf(), my = e, py = a, my.attachEvent("onpropertychange", wd)) : t === "focusout" && zf();
    }
    function Hf(t) {
      if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return $n(py);
    }
    function Md(t, e) {
      if (t === "click") return $n(e);
    }
    function Up(t, e) {
      if (t === "input" || t === "change")
        return $n(e);
    }
    function Bp(t, e) {
      return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e;
    }
    function As(t, e) {
      if (uo(t, e)) return !0;
      if (typeof t != "object" || t === null || typeof e != "object" || e === null)
        return !1;
      var a = Object.keys(t), f = Object.keys(e);
      if (a.length !== f.length) return !1;
      for (f = 0; f < a.length; f++) {
        var p = a[f];
        if (!Is.call(e, p) || !uo(t[p], e[p]))
          return !1;
      }
      return !0;
    }
    function Ed(t) {
      for (; t && t.firstChild; ) t = t.firstChild;
      return t;
    }
    function _a(t, e) {
      var a = Ed(t);
      t = 0;
      for (var f; a; ) {
        if (a.nodeType === 3) {
          if (f = t + a.textContent.length, t <= e && f >= e)
            return { node: a, offset: e - t };
          t = f;
        }
        t: {
          for (; a; ) {
            if (a.nextSibling) {
              a = a.nextSibling;
              break t;
            }
            a = a.parentNode;
          }
          a = void 0;
        }
        a = Ed(a);
      }
    }
    function Od(t, e) {
      return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Od(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1;
    }
    function kf(t) {
      t = t != null && t.ownerDocument != null && t.ownerDocument.defaultView != null ? t.ownerDocument.defaultView : window;
      for (var e = pu(t.document); e instanceof t.HTMLIFrameElement; ) {
        try {
          var a = typeof e.contentWindow.location.href == "string";
        } catch {
          a = !1;
        }
        if (a) t = e.contentWindow;
        else break;
        e = pu(t.document);
      }
      return e;
    }
    function wo(t) {
      var e = t && t.nodeName && t.nodeName.toLowerCase();
      return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true");
    }
    function Nf(t, e, a) {
      var f = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument;
      W0 || np == null || np !== pu(f) || (f = np, "selectionStart" in f && wo(f) ? f = { start: f.selectionStart, end: f.selectionEnd } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = {
        anchorNode: f.anchorNode,
        anchorOffset: f.anchorOffset,
        focusNode: f.focusNode,
        focusOffset: f.focusOffset
      }), gy && As(gy, f) || (gy = f, f = _h(K0, "onSelect"), 0 < f.length && (e = new te(
        "onSelect",
        "select",
        null,
        e,
        a
      ), t.push({ event: e, listeners: f }), e.target = np)));
    }
    function Mo(t, e) {
      var a = {};
      return a[t.toLowerCase()] = e.toLowerCase(), a["Webkit" + t] = "webkit" + e, a["Moz" + t] = "moz" + e, a;
    }
    function nl(t) {
      if (J0[t]) return J0[t];
      if (!ip[t]) return t;
      var e = ip[t], a;
      for (a in e)
        if (e.hasOwnProperty(a) && a in K1)
          return J0[t] = e[a];
      return t;
    }
    function Wa(t, e) {
      F1.set(t, e), Dt(e, [t]);
    }
    function ji(t, e) {
      if (typeof t == "object" && t !== null) {
        var a = $0.get(t);
        return a !== void 0 ? a : (e = {
          value: t,
          source: e,
          stack: ea(e)
        }, $0.set(t, e), e);
      }
      return {
        value: t,
        source: e,
        stack: ea(e)
      };
    }
    function _r() {
      for (var t = ap, e = F0 = ap = 0; e < t; ) {
        var a = ls[e];
        ls[e++] = null;
        var f = ls[e];
        ls[e++] = null;
        var p = ls[e];
        ls[e++] = null;
        var y = ls[e];
        if (ls[e++] = null, f !== null && p !== null) {
          var M = f.pending;
          M === null ? p.next = p : (p.next = M.next, M.next = p), f.pending = p;
        }
        y !== 0 && Ad(a, p, y);
      }
    }
    function vc(t, e, a, f) {
      ls[ap++] = t, ls[ap++] = e, ls[ap++] = a, ls[ap++] = f, F0 |= f, t.lanes |= f, t = t.alternate, t !== null && (t.lanes |= f);
    }
    function Uf(t, e, a, f) {
      return vc(t, e, a, f), Su(t);
    }
    function mi(t, e) {
      return vc(t, null, null, e), Su(t);
    }
    function Ad(t, e, a) {
      t.lanes |= a;
      var f = t.alternate;
      f !== null && (f.lanes |= a);
      for (var p = !1, y = t.return; y !== null; )
        y.childLanes |= a, f = y.alternate, f !== null && (f.childLanes |= a), y.tag === 22 && (t = y.stateNode, t === null || t._visibility & h_ || (p = !0)), t = y, y = y.return;
      return t.tag === 3 ? (y = t.stateNode, p && e !== null && (p = 31 - Ki(a), t = y.hiddenUpdates, f = t[p], f === null ? t[p] = [e] : f.push(e), e.lane = a | 536870912), y) : null;
    }
    function Su(t) {
      if (By > vE)
        throw ed = By = 0, Yy = Db = null, Error(
          "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
        );
      ed > _E && (ed = 0, Yy = null, console.error(
        "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
      )), t.alternate === null && (t.flags & 4098) !== 0 && ml(t);
      for (var e = t, a = e.return; a !== null; )
        e.alternate === null && (e.flags & 4098) !== 0 && ml(t), e = a, a = e.return;
      return e.tag === 3 ? e.stateNode : null;
    }
    function Ol(t) {
      if (ss === null) return t;
      var e = ss(t);
      return e === void 0 ? t : e.current;
    }
    function br(t) {
      if (ss === null) return t;
      var e = ss(t);
      return e === void 0 ? t != null && typeof t.render == "function" && (e = Ol(t.render), t.render !== e) ? (e = { $$typeof: Ws, render: e }, t.displayName !== void 0 && (e.displayName = t.displayName), e) : t : e.current;
    }
    function Al(t, e) {
      if (ss === null) return !1;
      var a = t.elementType;
      e = e.type;
      var f = !1, p = typeof e == "object" && e !== null ? e.$$typeof : null;
      switch (t.tag) {
        case 1:
          typeof e == "function" && (f = !0);
          break;
        case 0:
          (typeof e == "function" || p === so) && (f = !0);
          break;
        case 11:
          (p === Ws || p === so) && (f = !0);
          break;
        case 14:
        case 15:
          (p === Rh || p === so) && (f = !0);
          break;
        default:
          return !1;
      }
      return !!(f && (t = ss(a), t !== void 0 && t === ss(e)));
    }
    function Dd(t) {
      ss !== null && typeof WeakSet == "function" && (op === null && (op = /* @__PURE__ */ new WeakSet()), op.add(t));
    }
    function il(t, e, a) {
      var f = t.alternate, p = t.child, y = t.sibling, M = t.tag, D = t.type, B = null;
      switch (M) {
        case 0:
        case 15:
        case 1:
          B = D;
          break;
        case 11:
          B = D.render;
      }
      if (ss === null)
        throw Error("Expected resolveFamily to be set during hot reload.");
      var Y = !1;
      D = !1, B !== null && (B = ss(B), B !== void 0 && (a.has(B) ? D = !0 : e.has(B) && (M === 1 ? D = !0 : Y = !0))), op !== null && (op.has(t) || f !== null && op.has(f)) && (D = !0), D && (t._debugNeedsRemount = !0), (D || Y) && (f = mi(t, 2), f !== null && Rn(f, t, 2)), p === null || D || il(
        p,
        e,
        a
      ), y !== null && il(
        y,
        e,
        a
      );
    }
    function pi(t, e, a, f) {
      this.tag = t, this.key = a, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, eS || typeof Object.preventExtensions != "function" || Object.preventExtensions(this);
    }
    function _c(t) {
      return t = t.prototype, !(!t || !t.isReactComponent);
    }
    function Ja(t, e) {
      var a = t.alternate;
      switch (a === null ? (a = z(
        t.tag,
        e,
        t.key,
        t.mode
      ), a.elementType = t.elementType, a.type = t.type, a.stateNode = t.stateNode, a._debugOwner = t._debugOwner, a._debugStack = t._debugStack, a._debugTask = t._debugTask, a._debugHookTypes = t._debugHookTypes, a.alternate = t, t.alternate = a) : (a.pendingProps = e, a.type = t.type, a.flags = 0, a.subtreeFlags = 0, a.deletions = null, a.actualDuration = -0, a.actualStartTime = -1.1), a.flags = t.flags & 65011712, a.childLanes = t.childLanes, a.lanes = t.lanes, a.child = t.child, a.memoizedProps = t.memoizedProps, a.memoizedState = t.memoizedState, a.updateQueue = t.updateQueue, e = t.dependencies, a.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext,
        _debugThenableState: e._debugThenableState
      }, a.sibling = t.sibling, a.index = t.index, a.ref = t.ref, a.refCleanup = t.refCleanup, a.selfBaseDuration = t.selfBaseDuration, a.treeBaseDuration = t.treeBaseDuration, a._debugInfo = t._debugInfo, a._debugNeedsRemount = t._debugNeedsRemount, a.tag) {
        case 0:
        case 15:
          a.type = Ol(t.type);
          break;
        case 1:
          a.type = Ol(t.type);
          break;
        case 11:
          a.type = br(t.type);
      }
      return a;
    }
    function Bf(t, e) {
      t.flags &= 65011714;
      var a = t.alternate;
      return a === null ? (t.childLanes = 0, t.lanes = e, t.child = null, t.subtreeFlags = 0, t.memoizedProps = null, t.memoizedState = null, t.updateQueue = null, t.dependencies = null, t.stateNode = null, t.selfBaseDuration = 0, t.treeBaseDuration = 0) : (t.childLanes = a.childLanes, t.lanes = a.lanes, t.child = a.child, t.subtreeFlags = 0, t.deletions = null, t.memoizedProps = a.memoizedProps, t.memoizedState = a.memoizedState, t.updateQueue = a.updateQueue, t.type = a.type, e = a.dependencies, t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext,
        _debugThenableState: e._debugThenableState
      }, t.selfBaseDuration = a.selfBaseDuration, t.treeBaseDuration = a.treeBaseDuration), t;
    }
    function Sr(t, e, a, f, p, y) {
      var M = 0, D = t;
      if (typeof t == "function")
        _c(t) && (M = 1), D = Ol(D);
      else if (typeof t == "string")
        M = P(), M = Qc(t, a, M) ? 26 : t === "html" || t === "head" || t === "body" ? 27 : 5;
      else
        t: switch (t) {
          case Kg:
            return e = z(31, a, e, p), e.elementType = Kg, e.lanes = y, e;
          case _e:
            return Dl(
              a.children,
              p,
              y,
              e
            );
          case Wc:
            M = 8, p |= Ua, p |= nr;
            break;
          case Jc:
            return t = a, f = p, typeof t.id != "string" && console.error(
              'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
              typeof t.id
            ), e = z(12, t, e, f | ca), e.elementType = Jc, e.lanes = y, e.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, e;
          case Ic:
            return e = z(13, a, e, p), e.elementType = Ic, e.lanes = y, e;
          case Gr:
            return e = z(19, a, e, p), e.elementType = Gr, e.lanes = y, e;
          default:
            if (typeof t == "object" && t !== null)
              switch (t.$$typeof) {
                case Qg:
                case qo:
                  M = 10;
                  break t;
                case Ym:
                  M = 9;
                  break t;
                case Ws:
                  M = 11, D = br(D);
                  break t;
                case Rh:
                  M = 14;
                  break t;
                case so:
                  M = 16, D = null;
                  break t;
              }
            D = "", (t === void 0 || typeof t == "object" && t !== null && Object.keys(t).length === 0) && (D += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), t === null ? a = "null" : de(t) ? a = "array" : t !== void 0 && t.$$typeof === Pr ? (a = "<" + (Ct(t.type) || "Unknown") + " />", D = " Did you accidentally export a JSX literal instead of a component?") : a = typeof t, (M = f ? Yt(f) : null) && (D += `

Check the render method of \`` + M + "`."), M = 29, a = Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (a + "." + D)
            ), D = null;
        }
      return e = z(M, a, e, p), e.elementType = t, e.type = D, e.lanes = y, e._debugOwner = f, e;
    }
    function Ds(t, e, a) {
      return e = Sr(
        t.type,
        t.key,
        t.props,
        t._owner,
        e,
        a
      ), e._debugOwner = t._owner, e._debugStack = t._debugStack, e._debugTask = t._debugTask, e;
    }
    function Dl(t, e, a, f) {
      return t = z(7, t, f, e), t.lanes = a, t;
    }
    function Rl(t, e, a) {
      return t = z(6, t, null, e), t.lanes = a, t;
    }
    function bc(t, e, a) {
      return e = z(
        4,
        t.children !== null ? t.children : [],
        t.key,
        e
      ), e.lanes = a, e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
      }, e;
    }
    function Rs(t, e) {
      jn(), lp[sp++] = m_, lp[sp++] = d_, d_ = t, m_ = e;
    }
    function ba(t, e, a) {
      jn(), rs[us++] = $u, rs[us++] = Fu, rs[us++] = Vh, Vh = t;
      var f = $u;
      t = Fu;
      var p = 32 - Ki(f) - 1;
      f &= ~(1 << p), a += 1;
      var y = 32 - Ki(e) + p;
      if (30 < y) {
        var M = p - p % 5;
        y = (f & (1 << M) - 1).toString(32), f >>= M, p -= M, $u = 1 << 32 - Ki(e) + p | a << p | f, Fu = y + t;
      } else
        $u = 1 << y | a << p | f, Fu = t;
    }
    function al(t) {
      jn(), t.return !== null && (Rs(t, 1), ba(t, 1, 0));
    }
    function Sc(t) {
      for (; t === d_; )
        d_ = lp[--sp], lp[sp] = null, m_ = lp[--sp], lp[sp] = null;
      for (; t === Vh; )
        Vh = rs[--us], rs[us] = null, Fu = rs[--us], rs[us] = null, $u = rs[--us], rs[us] = null;
    }
    function jn() {
      Ve || console.error(
        "Expected to be hydrating. This is a bug in React. Please file an issue."
      );
    }
    function Ia(t, e) {
      if (t.return === null) {
        if (cs === null)
          cs = {
            fiber: t,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: e
          };
        else {
          if (cs.fiber !== t)
            throw Error(
              "Saw multiple hydration diff roots in a pass. This is a bug in React."
            );
          cs.distanceFromLeaf > e && (cs.distanceFromLeaf = e);
        }
        return cs;
      }
      var a = Ia(
        t.return,
        e + 1
      ).children;
      return 0 < a.length && a[a.length - 1].fiber === t ? (a = a[a.length - 1], a.distanceFromLeaf > e && (a.distanceFromLeaf = e), a) : (e = {
        fiber: t,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: e
      }, a.push(e), e);
    }
    function Cl(t, e) {
      tc || (t = Ia(t, 0), t.serverProps = null, e !== null && (e = Dm(e), t.serverTail.push(e)));
    }
    function Eo(t) {
      var e = "", a = cs;
      throw a !== null && (cs = null, e = wl(a)), ol(
        ji(
          Error(
            `Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + e
          ),
          t
        )
      ), tb;
    }
    function Cs(t) {
      var e = t.stateNode, a = t.type, f = t.memoizedProps;
      switch (e[Wi] = t, e[ka] = f, Il(a, f), a) {
        case "dialog":
          Ce("cancel", e), Ce("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          Ce("load", e);
          break;
        case "video":
        case "audio":
          for (a = 0; a < jy.length; a++)
            Ce(jy[a], e);
          break;
        case "source":
          Ce("error", e);
          break;
        case "img":
        case "image":
        case "link":
          Ce("error", e), Ce("load", e);
          break;
        case "details":
          Ce("toggle", e);
          break;
        case "input":
          Xt("input", f), Ce("invalid", e), Sl(e, f), bd(
            e,
            f.value,
            f.defaultValue,
            f.checked,
            f.defaultChecked,
            f.type,
            f.name,
            !0
          ), vo(e);
          break;
        case "option":
          Df(e, f);
          break;
        case "select":
          Xt("select", f), Ce("invalid", e), gu(e, f);
          break;
        case "textarea":
          Xt("textarea", f), Ce("invalid", e), _o(e, f), Ss(
            e,
            f.value,
            f.defaultValue,
            f.children
          ), vo(e);
      }
      a = f.children, typeof a != "string" && typeof a != "number" && typeof a != "bigint" || e.textContent === "" + a || f.suppressHydrationWarning === !0 || Eg(e.textContent, a) ? (f.popover != null && (Ce("beforetoggle", e), Ce("toggle", e)), f.onScroll != null && Ce("scroll", e), f.onScrollEnd != null && Ce("scrollend", e), f.onClick != null && (e.onclick = Gs), e = !0) : e = !1, e || Eo(t);
    }
    function Tc(t) {
      for (co = t.return; co; )
        switch (co.tag) {
          case 5:
          case 13:
            Fr = !1;
            return;
          case 27:
          case 3:
            Fr = !0;
            return;
          default:
            co = co.return;
        }
    }
    function Oo(t) {
      if (t !== co) return !1;
      if (!Ve)
        return Tc(t), Ve = !0, !1;
      var e = t.tag, a;
      if ((a = e !== 3 && e !== 27) && ((a = e === 5) && (a = t.type, a = !(a !== "form" && a !== "button") || $l(t.type, t.memoizedProps)), a = !a), a && Qn) {
        for (a = Qn; a; ) {
          var f = Ia(t, 0), p = Dm(a);
          f.serverTail.push(p), a = p.type === "Suspense" ? Hg(a) : Hi(a.nextSibling);
        }
        Eo(t);
      }
      if (Tc(t), e === 13) {
        if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        Qn = Hg(t);
      } else
        e === 27 ? (e = Qn, Fl(t.type) ? (t = qb, qb = null, Qn = t) : Qn = e) : Qn = co ? Hi(t.stateNode.nextSibling) : null;
      return !0;
    }
    function zs() {
      Qn = co = null, tc = Ve = !1;
    }
    function Ao() {
      var t = Ph;
      return t !== null && (mo === null ? mo = t : mo.push.apply(
        mo,
        t
      ), Ph = null), t;
    }
    function ol(t) {
      Ph === null ? Ph = [t] : Ph.push(t);
    }
    function Yf() {
      var t = cs;
      if (t !== null) {
        cs = null;
        for (var e = wl(t); 0 < t.children.length; )
          t = t.children[0];
        Vt(t.fiber, function() {
          console.error(
            `A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`,
            "https://react.dev/link/hydration-mismatch",
            e
          );
        });
      }
    }
    function Tr() {
      rp = p_ = null, up = !1;
    }
    function zl(t, e, a) {
      kt(eb, e._currentValue, t), e._currentValue = a, kt(nb, e._currentRenderer, t), e._currentRenderer !== void 0 && e._currentRenderer !== null && e._currentRenderer !== oS && console.error(
        "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
      ), e._currentRenderer = oS;
    }
    function Fn(t, e) {
      t._currentValue = eb.current;
      var a = nb.current;
      Rt(nb, e), t._currentRenderer = a, Rt(eb, e);
    }
    function jf(t, e, a) {
      for (; t !== null; ) {
        var f = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e, f !== null && (f.childLanes |= e)) : f !== null && (f.childLanes & e) !== e && (f.childLanes |= e), t === a) break;
        t = t.return;
      }
      t !== a && console.error(
        "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Ll(t, e, a, f) {
      var p = t.child;
      for (p !== null && (p.return = t); p !== null; ) {
        var y = p.dependencies;
        if (y !== null) {
          var M = p.child;
          y = y.firstContext;
          t: for (; y !== null; ) {
            var D = y;
            y = p;
            for (var B = 0; B < e.length; B++)
              if (D.context === e[B]) {
                y.lanes |= a, D = y.alternate, D !== null && (D.lanes |= a), jf(
                  y.return,
                  a,
                  t
                ), f || (M = null);
                break t;
              }
            y = D.next;
          }
        } else if (p.tag === 18) {
          if (M = p.return, M === null)
            throw Error(
              "We just came from a parent so we must have had a parent. This is a bug in React."
            );
          M.lanes |= a, y = M.alternate, y !== null && (y.lanes |= a), jf(
            M,
            a,
            t
          ), M = null;
        } else M = p.child;
        if (M !== null) M.return = p;
        else
          for (M = p; M !== null; ) {
            if (M === t) {
              M = null;
              break;
            }
            if (p = M.sibling, p !== null) {
              p.return = M.return, M = p;
              break;
            }
            M = M.return;
          }
        p = M;
      }
    }
    function ti(t, e, a, f) {
      t = null;
      for (var p = e, y = !1; p !== null; ) {
        if (!y) {
          if ((p.flags & 524288) !== 0) y = !0;
          else if ((p.flags & 262144) !== 0) break;
        }
        if (p.tag === 10) {
          var M = p.alternate;
          if (M === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          if (M = M.memoizedProps, M !== null) {
            var D = p.type;
            uo(p.pendingProps.value, M.value) || (t !== null ? t.push(D) : t = [D]);
          }
        } else if (p === Fc.current) {
          if (M = p.alternate, M === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          M.memoizedState.memoizedState !== p.memoizedState.memoizedState && (t !== null ? t.push(Py) : t = [Py]);
        }
        p = p.return;
      }
      t !== null && Ll(
        e,
        t,
        a,
        f
      ), e.flags |= 262144;
    }
    function gi(t) {
      for (t = t.firstContext; t !== null; ) {
        if (!uo(
          t.context._currentValue,
          t.memoizedValue
        ))
          return !0;
        t = t.next;
      }
      return !1;
    }
    function $a(t) {
      p_ = t, rp = null, t = t.dependencies, t !== null && (t.firstContext = null);
    }
    function tn(t) {
      return up && console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      ), xr(p_, t);
    }
    function Ls(t, e) {
      return p_ === null && $a(t), xr(t, e);
    }
    function xr(t, e) {
      var a = e._currentValue;
      if (e = { context: e, memoizedValue: a, next: null }, rp === null) {
        if (t === null)
          throw Error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        rp = e, t.dependencies = {
          lanes: 0,
          firstContext: e,
          _debugThenableState: null
        }, t.flags |= 524288;
      } else rp = rp.next = e;
      return a;
    }
    function Hs() {
      return {
        controller: new iE(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function Do(t) {
      t.controller.signal.aborted && console.warn(
        "A cache instance was retained after it was already freed. This likely indicates a bug in React."
      ), t.refCount++;
    }
    function Di(t) {
      t.refCount--, 0 > t.refCount && console.warn(
        "A cache instance was released after it was already freed. This likely indicates a bug in React."
      ), t.refCount === 0 && aE(oE, function() {
        t.controller.abort();
      });
    }
    function qi() {
      var t = Gh;
      return Gh = 0, t;
    }
    function Ro(t) {
      var e = Gh;
      return Gh = t, e;
    }
    function Hl(t) {
      var e = Gh;
      return Gh += t, e;
    }
    function xc(t) {
      Po = cp(), 0 > t.actualStartTime && (t.actualStartTime = Po);
    }
    function Sa(t) {
      if (0 <= Po) {
        var e = cp() - Po;
        t.actualDuration += e, t.selfBaseDuration = e, Po = -1;
      }
    }
    function ks(t) {
      if (0 <= Po) {
        var e = cp() - Po;
        t.actualDuration += e, Po = -1;
      }
    }
    function aa() {
      if (0 <= Po) {
        var t = cp() - Po;
        Po = -1, Gh += t;
      }
    }
    function Fa() {
      Po = cp();
    }
    function to(t) {
      for (var e = t.child; e; )
        t.actualDuration += e.actualDuration, e = e.sibling;
    }
    function Rd(t, e) {
      if (yy === null) {
        var a = yy = [];
        ib = 0, Xh = Sg(), fp = {
          status: "pending",
          value: void 0,
          then: function(f) {
            a.push(f);
          }
        };
      }
      return ib++, e.then(Ta, Ta), e;
    }
    function Ta() {
      if (--ib === 0 && yy !== null) {
        fp !== null && (fp.status = "fulfilled");
        var t = yy;
        yy = null, Xh = 0, fp = null;
        for (var e = 0; e < t.length; e++) (0, t[e])();
      }
    }
    function Tu(t, e) {
      var a = [], f = {
        status: "pending",
        value: null,
        reason: null,
        then: function(p) {
          a.push(p);
        }
      };
      return t.then(
        function() {
          f.status = "fulfilled", f.value = e;
          for (var p = 0; p < a.length; p++) (0, a[p])(e);
        },
        function(p) {
          for (f.status = "rejected", f.reason = p, p = 0; p < a.length; p++)
            (0, a[p])(void 0);
        }
      ), f;
    }
    function qf() {
      var t = Qh.current;
      return t !== null ? t : mn.pooledCache;
    }
    function Ns(t, e) {
      e === null ? kt(Qh, Qh.current, t) : kt(Qh, e.pool, t);
    }
    function Cd() {
      var t = qf();
      return t === null ? null : { parent: Ui._currentValue, pool: t };
    }
    function wc() {
      return { didWarnAboutUncachedPromise: !1, thenables: [] };
    }
    function Zf(t) {
      return t = t.status, t === "fulfilled" || t === "rejected";
    }
    function Co() {
    }
    function xa(t, e, a) {
      ft.actQueue !== null && (ft.didUsePromise = !0);
      var f = t.thenables;
      switch (a = f[a], a === void 0 ? f.push(e) : a !== e && (t.didWarnAboutUncachedPromise || (t.didWarnAboutUncachedPromise = !0, console.error(
        "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
      )), e.then(Co, Co), e = a), e.status) {
        case "fulfilled":
          return e.value;
        case "rejected":
          throw t = e.reason, Zi(t), t;
        default:
          if (typeof e.status == "string")
            e.then(Co, Co);
          else {
            if (t = mn, t !== null && 100 < t.shellSuspendCounter)
              throw Error(
                "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
            t = e, t.status = "pending", t.then(
              function(p) {
                if (e.status === "pending") {
                  var y = e;
                  y.status = "fulfilled", y.value = p;
                }
              },
              function(p) {
                if (e.status === "pending") {
                  var y = e;
                  y.status = "rejected", y.reason = p;
                }
              }
            );
          }
          switch (e.status) {
            case "fulfilled":
              return e.value;
            case "rejected":
              throw t = e.reason, Zi(t), t;
          }
          throw My = e, S_ = !0, wy;
      }
    }
    function kl() {
      if (My === null)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var t = My;
      return My = null, S_ = !1, t;
    }
    function Zi(t) {
      if (t === wy || t === b_)
        throw Error(
          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        );
    }
    function Ri(t) {
      t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function Nl(t, e) {
      t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        callbacks: null
      });
    }
    function Gn(t) {
      return {
        lane: t,
        tag: cS,
        payload: null,
        callback: null,
        next: null
      };
    }
    function wa(t, e, a) {
      var f = t.updateQueue;
      if (f === null) return null;
      if (f = f.shared, lb === f && !dS) {
        var p = Mt(t);
        console.error(
          `An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`,
          p
        ), dS = !0;
      }
      return (Ie & ho) !== yl ? (p = f.pending, p === null ? e.next = e : (e.next = p.next, p.next = e), f.pending = e, e = Su(t), Ad(t, null, a), e) : (vc(t, f, e, a), Su(t));
    }
    function ll(t, e, a) {
      if (e = e.updateQueue, e !== null && (e = e.shared, (a & 4194048) !== 0)) {
        var f = e.lanes;
        f &= t.pendingLanes, a |= f, e.lanes = a, go(t, a);
      }
    }
    function zo(t, e) {
      var a = t.updateQueue, f = t.alternate;
      if (f !== null && (f = f.updateQueue, a === f)) {
        var p = null, y = null;
        if (a = a.firstBaseUpdate, a !== null) {
          do {
            var M = {
              lane: a.lane,
              tag: a.tag,
              payload: a.payload,
              callback: null,
              next: null
            };
            y === null ? p = y = M : y = y.next = M, a = a.next;
          } while (a !== null);
          y === null ? p = y = e : y = y.next = e;
        } else p = y = e;
        a = {
          baseState: f.baseState,
          firstBaseUpdate: p,
          lastBaseUpdate: y,
          shared: f.shared,
          callbacks: f.callbacks
        }, t.updateQueue = a;
        return;
      }
      t = a.lastBaseUpdate, t === null ? a.firstBaseUpdate = e : t.next = e, a.lastBaseUpdate = e;
    }
    function Lo() {
      if (sb) {
        var t = fp;
        if (t !== null) throw t;
      }
    }
    function sl(t, e, a, f) {
      sb = !1;
      var p = t.updateQueue;
      cf = !1, lb = p.shared;
      var y = p.firstBaseUpdate, M = p.lastBaseUpdate, D = p.shared.pending;
      if (D !== null) {
        p.shared.pending = null;
        var B = D, Y = B.next;
        B.next = null, M === null ? y = Y : M.next = Y, M = B;
        var lt = t.alternate;
        lt !== null && (lt = lt.updateQueue, D = lt.lastBaseUpdate, D !== M && (D === null ? lt.firstBaseUpdate = Y : D.next = Y, lt.lastBaseUpdate = B));
      }
      if (y !== null) {
        var mt = p.baseState;
        M = 0, lt = Y = B = null, D = y;
        do {
          var at = D.lane & -536870913, pt = at !== D.lane;
          if (pt ? (Ne & at) === at : (f & at) === at) {
            at !== 0 && at === Xh && (sb = !0), lt !== null && (lt = lt.next = {
              lane: 0,
              tag: D.tag,
              payload: D.payload,
              callback: null,
              next: null
            });
            t: {
              at = t;
              var Qt = D, ue = e, pn = a;
              switch (Qt.tag) {
                case fS:
                  if (Qt = Qt.payload, typeof Qt == "function") {
                    up = !0;
                    var Be = Qt.call(
                      pn,
                      mt,
                      ue
                    );
                    if (at.mode & Ua) {
                      Tt(!0);
                      try {
                        Qt.call(pn, mt, ue);
                      } finally {
                        Tt(!1);
                      }
                    }
                    up = !1, mt = Be;
                    break t;
                  }
                  mt = Qt;
                  break t;
                case ob:
                  at.flags = at.flags & -65537 | 128;
                case cS:
                  if (Be = Qt.payload, typeof Be == "function") {
                    if (up = !0, Qt = Be.call(
                      pn,
                      mt,
                      ue
                    ), at.mode & Ua) {
                      Tt(!0);
                      try {
                        Be.call(pn, mt, ue);
                      } finally {
                        Tt(!1);
                      }
                    }
                    up = !1;
                  } else Qt = Be;
                  if (Qt == null) break t;
                  mt = Me({}, mt, Qt);
                  break t;
                case hS:
                  cf = !0;
              }
            }
            at = D.callback, at !== null && (t.flags |= 64, pt && (t.flags |= 8192), pt = p.callbacks, pt === null ? p.callbacks = [at] : pt.push(at));
          } else
            pt = {
              lane: at,
              tag: D.tag,
              payload: D.payload,
              callback: D.callback,
              next: null
            }, lt === null ? (Y = lt = pt, B = mt) : lt = lt.next = pt, M |= at;
          if (D = D.next, D === null) {
            if (D = p.shared.pending, D === null)
              break;
            pt = D, D = pt.next, pt.next = null, p.lastBaseUpdate = pt, p.shared.pending = null;
          }
        } while (!0);
        lt === null && (B = mt), p.baseState = B, p.firstBaseUpdate = Y, p.lastBaseUpdate = lt, y === null && (p.shared.lanes = 0), mf |= M, t.lanes = M, t.memoizedState = mt;
      }
      lb = null;
    }
    function rl(t, e) {
      if (typeof t != "function")
        throw Error(
          "Invalid argument passed as callback. Expected a function. Instead received: " + t
        );
      t.call(e);
    }
    function Us(t, e) {
      var a = t.shared.hiddenCallbacks;
      if (a !== null)
        for (t.shared.hiddenCallbacks = null, t = 0; t < a.length; t++)
          rl(a[t], e);
    }
    function Vf(t, e) {
      var a = t.callbacks;
      if (a !== null)
        for (t.callbacks = null, t = 0; t < a.length; t++)
          rl(a[t], e);
    }
    function Vi(t, e) {
      var a = nu;
      kt(T_, a, t), kt(hp, e, t), nu = a | e.baseLanes;
    }
    function wr(t) {
      kt(T_, nu, t), kt(
        hp,
        hp.current,
        t
      );
    }
    function Ma(t) {
      nu = T_.current, Rt(hp, t), Rt(T_, t);
    }
    function ye() {
      var t = ht;
      ds === null ? ds = [t] : ds.push(t);
    }
    function Ot() {
      var t = ht;
      if (ds !== null && (nc++, ds[nc] !== t)) {
        var e = Mt(me);
        if (!mS.has(e) && (mS.add(e), ds !== null)) {
          for (var a = "", f = 0; f <= nc; f++) {
            var p = ds[f], y = f === nc ? t : p;
            for (p = f + 1 + ". " + p; 30 > p.length; )
              p += " ";
            p += y + `
`, a += p;
          }
          console.error(
            `React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,
            e,
            a
          );
        }
      }
    }
    function oa(t) {
      t == null || de(t) || console.error(
        "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
        ht,
        typeof t
      );
    }
    function Mr() {
      var t = Mt(me);
      gS.has(t) || (gS.add(t), console.error(
        "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
        t
      ));
    }
    function cn() {
      throw Error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      );
    }
    function ul(t, e) {
      if (Oy) return !1;
      if (e === null)
        return console.error(
          "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
          ht
        ), !1;
      t.length !== e.length && console.error(
        `The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,
        ht,
        "[" + e.join(", ") + "]",
        "[" + t.join(", ") + "]"
      );
      for (var a = 0; a < e.length && a < t.length; a++)
        if (!uo(t[a], e[a])) return !1;
      return !0;
    }
    function Ul(t, e, a, f, p, y) {
      ff = y, me = e, ds = t !== null ? t._debugHookTypes : null, nc = -1, Oy = t !== null && t.type !== e.type, (Object.prototype.toString.call(a) === "[object AsyncFunction]" || Object.prototype.toString.call(a) === "[object AsyncGeneratorFunction]") && (y = Mt(me), rb.has(y) || (rb.add(y), console.error(
        "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
        y === null ? "An unknown Component" : "<" + y + ">"
      ))), e.memoizedState = null, e.updateQueue = null, e.lanes = 0, ft.H = t !== null && t.memoizedState !== null ? cb : ds !== null ? yS : ub, Wh = y = (e.mode & Ua) !== bn;
      var M = fb(a, f, p);
      if (Wh = !1, mp && (M = d(
        e,
        a,
        f,
        p
      )), y) {
        Tt(!0);
        try {
          M = d(
            e,
            a,
            f,
            p
          );
        } finally {
          Tt(!1);
        }
      }
      return r(t, e), M;
    }
    function r(t, e) {
      e._debugHookTypes = ds, e.dependencies === null ? ec !== null && (e.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: ec
      }) : e.dependencies._debugThenableState = ec, ft.H = M_;
      var a = hn !== null && hn.next !== null;
      if (ff = 0, ds = ht = Ti = hn = me = null, nc = -1, t !== null && (t.flags & 65011712) !== (e.flags & 65011712) && console.error(
        "Internal React error: Expected static flag was missing. Please notify the React team."
      ), x_ = !1, Ey = 0, ec = null, a)
        throw Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      t === null || Ji || (t = t.dependencies, t !== null && gi(t) && (Ji = !0)), S_ ? (S_ = !1, t = !0) : t = !1, t && (e = Mt(e) || "Unknown", pS.has(e) || rb.has(e) || (pS.add(e), console.error(
        "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
      )));
    }
    function d(t, e, a, f) {
      me = t;
      var p = 0;
      do {
        if (mp && (ec = null), Ey = 0, mp = !1, p >= sE)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (p += 1, Oy = !1, Ti = hn = null, t.updateQueue != null) {
          var y = t.updateQueue;
          y.lastEffect = null, y.events = null, y.stores = null, y.memoCache != null && (y.memoCache.index = 0);
        }
        nc = -1, ft.H = vS, y = fb(e, a, f);
      } while (mp);
      return y;
    }
    function v() {
      var t = ft.H, e = t.useState()[0];
      return e = typeof e.then == "function" ? xt(e) : e, t = t.useState()[0], (hn !== null ? hn.memoizedState : null) !== t && (me.flags |= 1024), e;
    }
    function w() {
      var t = w_ !== 0;
      return w_ = 0, t;
    }
    function O(t, e, a) {
      e.updateQueue = t.updateQueue, e.flags = (e.mode & nr) !== bn ? e.flags & -402655237 : e.flags & -2053, t.lanes &= ~a;
    }
    function H(t) {
      if (x_) {
        for (t = t.memoizedState; t !== null; ) {
          var e = t.queue;
          e !== null && (e.pending = null), t = t.next;
        }
        x_ = !1;
      }
      ff = 0, ds = Ti = hn = me = null, nc = -1, ht = null, mp = !1, Ey = w_ = 0, ec = null;
    }
    function q() {
      var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ti === null ? me.memoizedState = Ti = t : Ti = Ti.next = t, Ti;
    }
    function I() {
      if (hn === null) {
        var t = me.alternate;
        t = t !== null ? t.memoizedState : null;
      } else t = hn.next;
      var e = Ti === null ? me.memoizedState : Ti.next;
      if (e !== null)
        Ti = e, hn = t;
      else {
        if (t === null)
          throw me.alternate === null ? Error(
            "Update hook called on initial render. This is likely a bug in React. Please file an issue."
          ) : Error("Rendered more hooks than during the previous render.");
        hn = t, t = {
          memoizedState: hn.memoizedState,
          baseState: hn.baseState,
          baseQueue: hn.baseQueue,
          queue: hn.queue,
          next: null
        }, Ti === null ? me.memoizedState = Ti = t : Ti = Ti.next = t;
      }
      return Ti;
    }
    function rt() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function xt(t) {
      var e = Ey;
      return Ey += 1, ec === null && (ec = wc()), t = xa(ec, t, e), e = me, (Ti === null ? e.memoizedState : Ti.next) === null && (e = e.alternate, ft.H = e !== null && e.memoizedState !== null ? cb : ub), t;
    }
    function Nt(t) {
      if (t !== null && typeof t == "object") {
        if (typeof t.then == "function") return xt(t);
        if (t.$$typeof === qo) return tn(t);
      }
      throw Error("An unsupported type was passed to use(): " + String(t));
    }
    function qt(t) {
      var e = null, a = me.updateQueue;
      if (a !== null && (e = a.memoCache), e == null) {
        var f = me.alternate;
        f !== null && (f = f.updateQueue, f !== null && (f = f.memoCache, f != null && (e = {
          data: f.data.map(function(p) {
            return p.slice();
          }),
          index: 0
        })));
      }
      if (e == null && (e = { data: [], index: 0 }), a === null && (a = rt(), me.updateQueue = a), a.memoCache = e, a = e.data[e.index], a === void 0 || Oy)
        for (a = e.data[e.index] = Array(t), f = 0; f < t; f++)
          a[f] = t_;
      else
        a.length !== t && console.error(
          "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
          a.length,
          t
        );
      return e.index++, a;
    }
    function Zt(t, e) {
      return typeof e == "function" ? e(t) : e;
    }
    function oe(t, e, a) {
      var f = q();
      if (a !== void 0) {
        var p = a(e);
        if (Wh) {
          Tt(!0);
          try {
            a(e);
          } finally {
            Tt(!1);
          }
        }
      } else p = e;
      return f.memoizedState = f.baseState = p, t = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: t,
        lastRenderedState: p
      }, f.queue = t, t = t.dispatch = Pp.bind(
        null,
        me,
        t
      ), [f.memoizedState, t];
    }
    function Ge(t) {
      var e = I();
      return dn(e, hn, t);
    }
    function dn(t, e, a) {
      var f = t.queue;
      if (f === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      f.lastRenderedReducer = a;
      var p = t.baseQueue, y = f.pending;
      if (y !== null) {
        if (p !== null) {
          var M = p.next;
          p.next = y.next, y.next = M;
        }
        e.baseQueue !== p && console.error(
          "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
        ), e.baseQueue = p = y, f.pending = null;
      }
      if (y = t.baseState, p === null) t.memoizedState = y;
      else {
        e = p.next;
        var D = M = null, B = null, Y = e, lt = !1;
        do {
          var mt = Y.lane & -536870913;
          if (mt !== Y.lane ? (Ne & mt) === mt : (ff & mt) === mt) {
            var at = Y.revertLane;
            if (at === 0)
              B !== null && (B = B.next = {
                lane: 0,
                revertLane: 0,
                action: Y.action,
                hasEagerState: Y.hasEagerState,
                eagerState: Y.eagerState,
                next: null
              }), mt === Xh && (lt = !0);
            else if ((ff & at) === at) {
              Y = Y.next, at === Xh && (lt = !0);
              continue;
            } else
              mt = {
                lane: 0,
                revertLane: Y.revertLane,
                action: Y.action,
                hasEagerState: Y.hasEagerState,
                eagerState: Y.eagerState,
                next: null
              }, B === null ? (D = B = mt, M = y) : B = B.next = mt, me.lanes |= at, mf |= at;
            mt = Y.action, Wh && a(y, mt), y = Y.hasEagerState ? Y.eagerState : a(y, mt);
          } else
            at = {
              lane: mt,
              revertLane: Y.revertLane,
              action: Y.action,
              hasEagerState: Y.hasEagerState,
              eagerState: Y.eagerState,
              next: null
            }, B === null ? (D = B = at, M = y) : B = B.next = at, me.lanes |= mt, mf |= mt;
          Y = Y.next;
        } while (Y !== null && Y !== e);
        if (B === null ? M = y : B.next = D, !uo(y, t.memoizedState) && (Ji = !0, lt && (a = fp, a !== null)))
          throw a;
        t.memoizedState = y, t.baseState = M, t.baseQueue = B, f.lastRenderedState = y;
      }
      return p === null && (f.lanes = 0), [t.memoizedState, f.dispatch];
    }
    function An(t) {
      var e = I(), a = e.queue;
      if (a === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      a.lastRenderedReducer = t;
      var f = a.dispatch, p = a.pending, y = e.memoizedState;
      if (p !== null) {
        a.pending = null;
        var M = p = p.next;
        do
          y = t(y, M.action), M = M.next;
        while (M !== p);
        uo(y, e.memoizedState) || (Ji = !0), e.memoizedState = y, e.baseQueue === null && (e.baseState = y), a.lastRenderedState = y;
      }
      return [y, f];
    }
    function Pi(t, e, a) {
      var f = me, p = q();
      if (Ve) {
        if (a === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        var y = a();
        dp || y === a() || (console.error(
          "The result of getServerSnapshot should be cached to avoid an infinite loop"
        ), dp = !0);
      } else {
        if (y = e(), dp || (a = e(), uo(y, a) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), dp = !0)), mn === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        (Ne & 124) !== 0 || Pf(f, e, y);
      }
      return p.memoizedState = y, a = { value: y, getSnapshot: e }, p.queue = a, Ld(
        Bs.bind(null, f, a, t),
        [t]
      ), f.flags |= 2048, Bl(
        hs | Bi,
        Rr(),
        Er.bind(
          null,
          f,
          a,
          y,
          e
        ),
        null
      ), y;
    }
    function xu(t, e, a) {
      var f = me, p = I(), y = Ve;
      if (y) {
        if (a === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        a = a();
      } else if (a = e(), !dp) {
        var M = e();
        uo(a, M) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), dp = !0);
      }
      (M = !uo(
        (hn || p).memoizedState,
        a
      )) && (p.memoizedState = a, Ji = !0), p = p.queue;
      var D = Bs.bind(null, f, p, t);
      if (ni(2048, Bi, D, [t]), p.getSnapshot !== e || M || Ti !== null && Ti.memoizedState.tag & hs) {
        if (f.flags |= 2048, Bl(
          hs | Bi,
          Rr(),
          Er.bind(
            null,
            f,
            p,
            a,
            e
          ),
          null
        ), mn === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        y || (ff & 124) !== 0 || Pf(f, e, a);
      }
      return a;
    }
    function Pf(t, e, a) {
      t.flags |= 16384, t = { getSnapshot: e, value: a }, e = me.updateQueue, e === null ? (e = rt(), me.updateQueue = e, e.stores = [t]) : (a = e.stores, a === null ? e.stores = [t] : a.push(t));
    }
    function Er(t, e, a, f) {
      e.value = a, e.getSnapshot = f, Gf(e) && Ys(t);
    }
    function Bs(t, e, a) {
      return a(function() {
        Gf(e) && Ys(t);
      });
    }
    function Gf(t) {
      var e = t.getSnapshot;
      t = t.value;
      try {
        var a = e();
        return !uo(t, a);
      } catch {
        return !0;
      }
    }
    function Ys(t) {
      var e = mi(t, 2);
      e !== null && Rn(e, t, 2);
    }
    function fn(t) {
      var e = q();
      if (typeof t == "function") {
        var a = t;
        if (t = a(), Wh) {
          Tt(!0);
          try {
            a();
          } finally {
            Tt(!1);
          }
        }
      }
      return e.memoizedState = e.baseState = t, e.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Zt,
        lastRenderedState: t
      }, e;
    }
    function Ea(t) {
      t = fn(t);
      var e = t.queue, a = Ac.bind(null, me, e);
      return e.dispatch = a, [t.memoizedState, a];
    }
    function eo(t) {
      var e = q();
      e.memoizedState = e.baseState = t;
      var a = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return e.queue = a, e = Zd.bind(
        null,
        me,
        !0,
        a
      ), a.dispatch = e, [t, e];
    }
    function cl(t, e) {
      var a = I();
      return Ho(a, hn, t, e);
    }
    function Ho(t, e, a, f) {
      return t.baseState = a, dn(
        t,
        hn,
        typeof f == "function" ? f : Zt
      );
    }
    function Or(t, e) {
      var a = I();
      return hn !== null ? Ho(a, hn, t, e) : (a.baseState = t, [t, a.queue.dispatch]);
    }
    function Mc(t, e, a, f, p) {
      if ($f(t))
        throw Error("Cannot update form state while rendering.");
      if (t = e.action, t !== null) {
        var y = {
          payload: p,
          action: t,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(M) {
            y.listeners.push(M);
          }
        };
        ft.T !== null ? a(!0) : y.isTransition = !1, f(y), a = e.pending, a === null ? (y.next = e.pending = y, Ar(e, y)) : (y.next = a.next, e.pending = a.next = y);
      }
    }
    function Ar(t, e) {
      var a = e.action, f = e.payload, p = t.state;
      if (e.isTransition) {
        var y = ft.T, M = {};
        ft.T = M, ft.T._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var D = a(p, f), B = ft.S;
          B !== null && B(M, D), Xf(t, e, D);
        } catch (Y) {
          yi(t, e, Y);
        } finally {
          ft.T = y, y === null && M._updatedFibers && (t = M._updatedFibers.size, M._updatedFibers.clear(), 10 < t && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          ));
        }
      } else
        try {
          M = a(p, f), Xf(t, e, M);
        } catch (Y) {
          yi(t, e, Y);
        }
    }
    function Xf(t, e, a) {
      a !== null && typeof a == "object" && typeof a.then == "function" ? (a.then(
        function(f) {
          Dr(t, e, f);
        },
        function(f) {
          return yi(t, e, f);
        }
      ), e.isTransition || console.error(
        "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
      )) : Dr(t, e, a);
    }
    function Dr(t, e, a) {
      e.status = "fulfilled", e.value = a, Qf(e), t.state = a, e = t.pending, e !== null && (a = e.next, a === e ? t.pending = null : (a = a.next, e.next = a, Ar(t, a)));
    }
    function yi(t, e, a) {
      var f = t.pending;
      if (t.pending = null, f !== null) {
        f = f.next;
        do
          e.status = "rejected", e.reason = a, Qf(e), e = e.next;
        while (e !== f);
      }
      t.action = null;
    }
    function Qf(t) {
      t = t.listeners;
      for (var e = 0; e < t.length; e++) (0, t[e])();
    }
    function Yp(t, e) {
      return e;
    }
    function Ec(t, e) {
      if (Ve) {
        var a = mn.formState;
        if (a !== null) {
          t: {
            var f = me;
            if (Ve) {
              if (Qn) {
                e: {
                  for (var p = Qn, y = Fr; p.nodeType !== 8; ) {
                    if (!y) {
                      p = null;
                      break e;
                    }
                    if (p = Hi(
                      p.nextSibling
                    ), p === null) {
                      p = null;
                      break e;
                    }
                  }
                  y = p.data, p = y === Ub || y === gT ? p : null;
                }
                if (p) {
                  Qn = Hi(
                    p.nextSibling
                  ), f = p.data === Ub;
                  break t;
                }
              }
              Eo(f);
            }
            f = !1;
          }
          f && (e = a[0]);
        }
      }
      return a = q(), a.memoizedState = a.baseState = e, f = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Yp,
        lastRenderedState: e
      }, a.queue = f, a = Ac.bind(
        null,
        me,
        f
      ), f.dispatch = a, f = fn(!1), y = Zd.bind(
        null,
        me,
        !1,
        f.queue
      ), f = q(), p = {
        state: e,
        dispatch: null,
        action: t,
        pending: null
      }, f.queue = p, a = Mc.bind(
        null,
        me,
        p,
        y,
        a
      ), p.dispatch = a, f.memoizedState = t, [e, a, !1];
    }
    function zd(t) {
      var e = I();
      return Ev(e, hn, t);
    }
    function Ev(t, e, a) {
      if (e = dn(
        t,
        e,
        Yp
      )[0], t = Ge(Zt)[0], typeof e == "object" && e !== null && typeof e.then == "function")
        try {
          var f = xt(e);
        } catch (M) {
          throw M === wy ? b_ : M;
        }
      else f = e;
      e = I();
      var p = e.queue, y = p.dispatch;
      return a !== e.memoizedState && (me.flags |= 2048, Bl(
        hs | Bi,
        Rr(),
        ei.bind(null, p, a),
        null
      )), [f, y, t];
    }
    function ei(t, e) {
      t.action = e;
    }
    function Oc(t) {
      var e = I(), a = hn;
      if (a !== null)
        return Ev(e, a, t);
      I(), e = e.memoizedState, a = I();
      var f = a.queue.dispatch;
      return a.memoizedState = t, [e, f, !1];
    }
    function Bl(t, e, a, f) {
      return t = {
        tag: t,
        create: a,
        deps: f,
        inst: e,
        next: null
      }, e = me.updateQueue, e === null && (e = rt(), me.updateQueue = e), a = e.lastEffect, a === null ? e.lastEffect = t.next = t : (f = a.next, a.next = t, t.next = f, e.lastEffect = t), t;
    }
    function Rr() {
      return { destroy: void 0, resource: void 0 };
    }
    function Kf(t) {
      var e = q();
      return t = { current: t }, e.memoizedState = t;
    }
    function ko(t, e, a, f) {
      var p = q();
      f = f === void 0 ? null : f, me.flags |= t, p.memoizedState = Bl(
        hs | e,
        Rr(),
        a,
        f
      );
    }
    function ni(t, e, a, f) {
      var p = I();
      f = f === void 0 ? null : f;
      var y = p.memoizedState.inst;
      hn !== null && f !== null && ul(f, hn.memoizedState.deps) ? p.memoizedState = Bl(e, y, a, f) : (me.flags |= t, p.memoizedState = Bl(
        hs | e,
        y,
        a,
        f
      ));
    }
    function Ld(t, e) {
      (me.mode & nr) !== bn && (me.mode & tS) === bn ? ko(276826112, Bi, t, e) : ko(8390656, Bi, t, e);
    }
    function Hd(t, e) {
      var a = 4194308;
      return (me.mode & nr) !== bn && (a |= 134217728), ko(a, fa, t, e);
    }
    function Ov(t, e) {
      if (typeof e == "function") {
        t = t();
        var a = e(t);
        return function() {
          typeof a == "function" ? a() : e(null);
        };
      }
      if (e != null)
        return e.hasOwnProperty("current") || console.error(
          "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
          "an object with keys {" + Object.keys(e).join(", ") + "}"
        ), t = t(), e.current = t, function() {
          e.current = null;
        };
    }
    function kd(t, e, a) {
      typeof e != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        e !== null ? typeof e : "null"
      ), a = a != null ? a.concat([t]) : null;
      var f = 4194308;
      (me.mode & nr) !== bn && (f |= 134217728), ko(
        f,
        fa,
        Ov.bind(null, e, t),
        a
      );
    }
    function Yl(t, e, a) {
      typeof e != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        e !== null ? typeof e : "null"
      ), a = a != null ? a.concat([t]) : null, ni(
        4,
        fa,
        Ov.bind(null, e, t),
        a
      );
    }
    function Wf(t, e) {
      return q().memoizedState = [
        t,
        e === void 0 ? null : e
      ], t;
    }
    function wu(t, e) {
      var a = I();
      e = e === void 0 ? null : e;
      var f = a.memoizedState;
      return e !== null && ul(e, f[1]) ? f[0] : (a.memoizedState = [t, e], t);
    }
    function Nd(t, e) {
      var a = q();
      e = e === void 0 ? null : e;
      var f = t();
      if (Wh) {
        Tt(!0);
        try {
          t();
        } finally {
          Tt(!1);
        }
      }
      return a.memoizedState = [f, e], f;
    }
    function Cr(t, e) {
      var a = I();
      e = e === void 0 ? null : e;
      var f = a.memoizedState;
      if (e !== null && ul(e, f[1]))
        return f[0];
      if (f = t(), Wh) {
        Tt(!0);
        try {
          t();
        } finally {
          Tt(!1);
        }
      }
      return a.memoizedState = [f, e], f;
    }
    function Ud(t, e) {
      var a = q();
      return Yd(a, t, e);
    }
    function Jf(t, e) {
      var a = I();
      return If(
        a,
        hn.memoizedState,
        t,
        e
      );
    }
    function Bd(t, e) {
      var a = I();
      return hn === null ? Yd(a, t, e) : If(
        a,
        hn.memoizedState,
        t,
        e
      );
    }
    function Yd(t, e, a) {
      return a === void 0 || (ff & 1073741824) !== 0 ? t.memoizedState = e : (t.memoizedState = a, t = Uv(), me.lanes |= t, mf |= t, a);
    }
    function If(t, e, a, f) {
      return uo(a, e) ? a : hp.current !== null ? (t = Yd(t, a, f), uo(t, e) || (Ji = !0), t) : (ff & 42) === 0 ? (Ji = !0, t.memoizedState = a) : (t = Uv(), me.lanes |= t, mf |= t, e);
    }
    function jp(t, e, a, f, p) {
      var y = re.p;
      re.p = y !== 0 && y < gl ? y : gl;
      var M = ft.T, D = {};
      ft.T = D, Zd(t, !1, e, a), D._updatedFibers = /* @__PURE__ */ new Set();
      try {
        var B = p(), Y = ft.S;
        if (Y !== null && Y(D, B), B !== null && typeof B == "object" && typeof B.then == "function") {
          var lt = Tu(
            B,
            f
          );
          js(
            t,
            e,
            lt,
            Ra(t)
          );
        } else
          js(
            t,
            e,
            f,
            Ra(t)
          );
      } catch (mt) {
        js(
          t,
          e,
          { then: function() {
          }, status: "rejected", reason: mt },
          Ra(t)
        );
      } finally {
        re.p = y, ft.T = M, M === null && D._updatedFibers && (t = D._updatedFibers.size, D._updatedFibers.clear(), 10 < t && console.warn(
          "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
        ));
      }
    }
    function Mu(t, e, a, f) {
      if (t.tag !== 5)
        throw Error(
          "Expected the form instance to be a HostComponent. This is a bug in React."
        );
      var p = qp(t).queue;
      jp(
        t,
        p,
        e,
        ld,
        a === null ? A : function() {
          return Zp(t), a(f);
        }
      );
    }
    function qp(t) {
      var e = t.memoizedState;
      if (e !== null) return e;
      e = {
        memoizedState: ld,
        baseState: ld,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Zt,
          lastRenderedState: ld
        },
        next: null
      };
      var a = {};
      return e.next = {
        memoizedState: a,
        baseState: a,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Zt,
          lastRenderedState: a
        },
        next: null
      }, t.memoizedState = e, t = t.alternate, t !== null && (t.memoizedState = e), e;
    }
    function Zp(t) {
      ft.T === null && console.error(
        "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
      );
      var e = qp(t).next.queue;
      js(
        t,
        e,
        {},
        Ra(t)
      );
    }
    function jl() {
      var t = fn(!1);
      return t = jp.bind(
        null,
        me,
        t.queue,
        !0,
        !1
      ), q().memoizedState = t, [!1, t];
    }
    function jd() {
      var t = Ge(Zt)[0], e = I().memoizedState;
      return [
        typeof t == "boolean" ? t : xt(t),
        e
      ];
    }
    function qd() {
      var t = An(Zt)[0], e = I().memoizedState;
      return [
        typeof t == "boolean" ? t : xt(t),
        e
      ];
    }
    function Oa() {
      return tn(Py);
    }
    function ql() {
      var t = q(), e = mn.identifierPrefix;
      if (Ve) {
        var a = Fu, f = $u;
        a = (f & ~(1 << 32 - Ki(f) - 1)).toString(32) + a, e = "" + e + "R" + a, a = w_++, 0 < a && (e += "H" + a.toString(32)), e += "";
      } else
        a = lE++, e = "" + e + "r" + a.toString(32) + "";
      return t.memoizedState = e;
    }
    function Eu() {
      return q().memoizedState = Vp.bind(
        null,
        me
      );
    }
    function Vp(t, e) {
      for (var a = t.return; a !== null; ) {
        switch (a.tag) {
          case 24:
          case 3:
            var f = Ra(a);
            t = Gn(f);
            var p = wa(a, t, f);
            p !== null && (Rn(p, a, f), ll(p, a, f)), a = Hs(), e != null && p !== null && console.error(
              "The seed argument is not enabled outside experimental channels."
            ), t.payload = { cache: a };
            return;
        }
        a = a.return;
      }
    }
    function Pp(t, e, a) {
      var f = arguments;
      typeof f[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), f = Ra(t);
      var p = {
        lane: f,
        revertLane: 0,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      $f(t) ? Ou(e, p) : (p = Uf(t, e, p, f), p !== null && (Rn(p, t, f), Ff(p, e, f))), ma(t, f);
    }
    function Ac(t, e, a) {
      var f = arguments;
      typeof f[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), f = Ra(t), js(t, e, a, f), ma(t, f);
    }
    function js(t, e, a, f) {
      var p = {
        lane: f,
        revertLane: 0,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if ($f(t)) Ou(e, p);
      else {
        var y = t.alternate;
        if (t.lanes === 0 && (y === null || y.lanes === 0) && (y = e.lastRenderedReducer, y !== null)) {
          var M = ft.H;
          ft.H = ar;
          try {
            var D = e.lastRenderedState, B = y(D, a);
            if (p.hasEagerState = !0, p.eagerState = B, uo(B, D))
              return vc(t, e, p, 0), mn === null && _r(), !1;
          } catch {
          } finally {
            ft.H = M;
          }
        }
        if (a = Uf(t, e, p, f), a !== null)
          return Rn(a, t, f), Ff(a, e, f), !0;
      }
      return !1;
    }
    function Zd(t, e, a, f) {
      if (ft.T === null && Xh === 0 && console.error(
        "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
      ), f = {
        lane: 2,
        revertLane: Sg(),
        action: f,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, $f(t)) {
        if (e)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        e = Uf(
          t,
          a,
          f,
          2
        ), e !== null && Rn(e, t, 2);
      ma(t, 2);
    }
    function $f(t) {
      var e = t.alternate;
      return t === me || e !== null && e === me;
    }
    function Ou(t, e) {
      mp = x_ = !0;
      var a = t.pending;
      a === null ? e.next = e : (e.next = a.next, a.next = e), t.pending = e;
    }
    function Ff(t, e, a) {
      if ((a & 4194048) !== 0) {
        var f = e.lanes;
        f &= t.pendingLanes, a |= f, e.lanes = a, go(t, a);
      }
    }
    function vi(t) {
      var e = De;
      return t != null && (De = e === null ? t : e.concat(t)), e;
    }
    function Dc(t, e, a) {
      for (var f = Object.keys(t.props), p = 0; p < f.length; p++) {
        var y = f[p];
        if (y !== "children" && y !== "key") {
          e === null && (e = Ds(t, a.mode, 0), e._debugInfo = De, e.return = a), Vt(
            e,
            function(M) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                M
              );
            },
            y
          );
          break;
        }
      }
    }
    function Rc(t) {
      var e = Ay;
      return Ay += 1, pp === null && (pp = wc()), xa(pp, t, e);
    }
    function No(t, e) {
      e = e.props.ref, t.ref = e !== void 0 ? e : null;
    }
    function ve(t, e) {
      throw e.$$typeof === Dh ? Error(
        `A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`
      ) : (t = Object.prototype.toString.call(e), Error(
        "Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."
      ));
    }
    function Xe(t, e) {
      var a = Mt(t) || "Component";
      LS[a] || (LS[a] = !0, e = e.displayName || e.name || "Component", t.tag === 3 ? console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`,
        e,
        e,
        e
      ) : console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`,
        e,
        e,
        a,
        e,
        a
      ));
    }
    function xn(t, e) {
      var a = Mt(t) || "Component";
      HS[a] || (HS[a] = !0, e = String(e), t.tag === 3 ? console.error(
        `Symbols are not valid as a React child.
  root.render(%s)`,
        e
      ) : console.error(
        `Symbols are not valid as a React child.
  <%s>%s</%s>`,
        a,
        e,
        a
      ));
    }
    function th(t) {
      function e(V, G) {
        if (t) {
          var K = V.deletions;
          K === null ? (V.deletions = [G], V.flags |= 16) : K.push(G);
        }
      }
      function a(V, G) {
        if (!t) return null;
        for (; G !== null; )
          e(V, G), G = G.sibling;
        return null;
      }
      function f(V) {
        for (var G = /* @__PURE__ */ new Map(); V !== null; )
          V.key !== null ? G.set(V.key, V) : G.set(V.index, V), V = V.sibling;
        return G;
      }
      function p(V, G) {
        return V = Ja(V, G), V.index = 0, V.sibling = null, V;
      }
      function y(V, G, K) {
        return V.index = K, t ? (K = V.alternate, K !== null ? (K = K.index, K < G ? (V.flags |= 67108866, G) : K) : (V.flags |= 67108866, G)) : (V.flags |= 1048576, G);
      }
      function M(V) {
        return t && V.alternate === null && (V.flags |= 67108866), V;
      }
      function D(V, G, K, gt) {
        return G === null || G.tag !== 6 ? (G = Rl(
          K,
          V.mode,
          gt
        ), G.return = V, G._debugOwner = V, G._debugTask = V._debugTask, G._debugInfo = De, G) : (G = p(G, K), G.return = V, G._debugInfo = De, G);
      }
      function B(V, G, K, gt) {
        var Ut = K.type;
        return Ut === _e ? (G = lt(
          V,
          G,
          K.props.children,
          gt,
          K.key
        ), Dc(K, G, V), G) : G !== null && (G.elementType === Ut || Al(G, K) || typeof Ut == "object" && Ut !== null && Ut.$$typeof === so && hf(Ut) === G.type) ? (G = p(G, K.props), No(G, K), G.return = V, G._debugOwner = K._owner, G._debugInfo = De, G) : (G = Ds(K, V.mode, gt), No(G, K), G.return = V, G._debugInfo = De, G);
      }
      function Y(V, G, K, gt) {
        return G === null || G.tag !== 4 || G.stateNode.containerInfo !== K.containerInfo || G.stateNode.implementation !== K.implementation ? (G = bc(K, V.mode, gt), G.return = V, G._debugInfo = De, G) : (G = p(G, K.children || []), G.return = V, G._debugInfo = De, G);
      }
      function lt(V, G, K, gt, Ut) {
        return G === null || G.tag !== 7 ? (G = Dl(
          K,
          V.mode,
          gt,
          Ut
        ), G.return = V, G._debugOwner = V, G._debugTask = V._debugTask, G._debugInfo = De, G) : (G = p(G, K), G.return = V, G._debugInfo = De, G);
      }
      function mt(V, G, K) {
        if (typeof G == "string" && G !== "" || typeof G == "number" || typeof G == "bigint")
          return G = Rl(
            "" + G,
            V.mode,
            K
          ), G.return = V, G._debugOwner = V, G._debugTask = V._debugTask, G._debugInfo = De, G;
        if (typeof G == "object" && G !== null) {
          switch (G.$$typeof) {
            case Pr:
              return K = Ds(
                G,
                V.mode,
                K
              ), No(K, G), K.return = V, V = vi(G._debugInfo), K._debugInfo = De, De = V, K;
            case Xu:
              return G = bc(
                G,
                V.mode,
                K
              ), G.return = V, G._debugInfo = De, G;
            case so:
              var gt = vi(G._debugInfo);
              return G = hf(G), V = mt(V, G, K), De = gt, V;
          }
          if (de(G) || Bt(G))
            return K = Dl(
              G,
              V.mode,
              K,
              null
            ), K.return = V, K._debugOwner = V, K._debugTask = V._debugTask, V = vi(G._debugInfo), K._debugInfo = De, De = V, K;
          if (typeof G.then == "function")
            return gt = vi(G._debugInfo), V = mt(
              V,
              Rc(G),
              K
            ), De = gt, V;
          if (G.$$typeof === qo)
            return mt(
              V,
              Ls(V, G),
              K
            );
          ve(V, G);
        }
        return typeof G == "function" && Xe(V, G), typeof G == "symbol" && xn(V, G), null;
      }
      function at(V, G, K, gt) {
        var Ut = G !== null ? G.key : null;
        if (typeof K == "string" && K !== "" || typeof K == "number" || typeof K == "bigint")
          return Ut !== null ? null : D(V, G, "" + K, gt);
        if (typeof K == "object" && K !== null) {
          switch (K.$$typeof) {
            case Pr:
              return K.key === Ut ? (Ut = vi(K._debugInfo), V = B(
                V,
                G,
                K,
                gt
              ), De = Ut, V) : null;
            case Xu:
              return K.key === Ut ? Y(V, G, K, gt) : null;
            case so:
              return Ut = vi(K._debugInfo), K = hf(K), V = at(
                V,
                G,
                K,
                gt
              ), De = Ut, V;
          }
          if (de(K) || Bt(K))
            return Ut !== null ? null : (Ut = vi(K._debugInfo), V = lt(
              V,
              G,
              K,
              gt,
              null
            ), De = Ut, V);
          if (typeof K.then == "function")
            return Ut = vi(K._debugInfo), V = at(
              V,
              G,
              Rc(K),
              gt
            ), De = Ut, V;
          if (K.$$typeof === qo)
            return at(
              V,
              G,
              Ls(V, K),
              gt
            );
          ve(V, K);
        }
        return typeof K == "function" && Xe(V, K), typeof K == "symbol" && xn(V, K), null;
      }
      function pt(V, G, K, gt, Ut) {
        if (typeof gt == "string" && gt !== "" || typeof gt == "number" || typeof gt == "bigint")
          return V = V.get(K) || null, D(G, V, "" + gt, Ut);
        if (typeof gt == "object" && gt !== null) {
          switch (gt.$$typeof) {
            case Pr:
              return K = V.get(
                gt.key === null ? K : gt.key
              ) || null, V = vi(gt._debugInfo), G = B(
                G,
                K,
                gt,
                Ut
              ), De = V, G;
            case Xu:
              return V = V.get(
                gt.key === null ? K : gt.key
              ) || null, Y(G, V, gt, Ut);
            case so:
              var be = vi(gt._debugInfo);
              return gt = hf(gt), G = pt(
                V,
                G,
                K,
                gt,
                Ut
              ), De = be, G;
          }
          if (de(gt) || Bt(gt))
            return K = V.get(K) || null, V = vi(gt._debugInfo), G = lt(
              G,
              K,
              gt,
              Ut,
              null
            ), De = V, G;
          if (typeof gt.then == "function")
            return be = vi(gt._debugInfo), G = pt(
              V,
              G,
              K,
              Rc(gt),
              Ut
            ), De = be, G;
          if (gt.$$typeof === qo)
            return pt(
              V,
              G,
              K,
              Ls(G, gt),
              Ut
            );
          ve(G, gt);
        }
        return typeof gt == "function" && Xe(G, gt), typeof gt == "symbol" && xn(G, gt), null;
      }
      function Qt(V, G, K, gt) {
        if (typeof K != "object" || K === null) return gt;
        switch (K.$$typeof) {
          case Pr:
          case Xu:
            S(V, G, K);
            var Ut = K.key;
            if (typeof Ut != "string") break;
            if (gt === null) {
              gt = /* @__PURE__ */ new Set(), gt.add(Ut);
              break;
            }
            if (!gt.has(Ut)) {
              gt.add(Ut);
              break;
            }
            Vt(G, function() {
              console.error(
                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.",
                Ut
              );
            });
            break;
          case so:
            K = hf(K), Qt(V, G, K, gt);
        }
        return gt;
      }
      function ue(V, G, K, gt) {
        for (var Ut = null, be = null, Kt = null, Se = G, xe = G = 0, Sn = null; Se !== null && xe < K.length; xe++) {
          Se.index > xe ? (Sn = Se, Se = null) : Sn = Se.sibling;
          var li = at(
            V,
            Se,
            K[xe],
            gt
          );
          if (li === null) {
            Se === null && (Se = Sn);
            break;
          }
          Ut = Qt(
            V,
            li,
            K[xe],
            Ut
          ), t && Se && li.alternate === null && e(V, Se), G = y(li, G, xe), Kt === null ? be = li : Kt.sibling = li, Kt = li, Se = Sn;
        }
        if (xe === K.length)
          return a(V, Se), Ve && Rs(V, xe), be;
        if (Se === null) {
          for (; xe < K.length; xe++)
            Se = mt(V, K[xe], gt), Se !== null && (Ut = Qt(
              V,
              Se,
              K[xe],
              Ut
            ), G = y(
              Se,
              G,
              xe
            ), Kt === null ? be = Se : Kt.sibling = Se, Kt = Se);
          return Ve && Rs(V, xe), be;
        }
        for (Se = f(Se); xe < K.length; xe++)
          Sn = pt(
            Se,
            V,
            xe,
            K[xe],
            gt
          ), Sn !== null && (Ut = Qt(
            V,
            Sn,
            K[xe],
            Ut
          ), t && Sn.alternate !== null && Se.delete(
            Sn.key === null ? xe : Sn.key
          ), G = y(
            Sn,
            G,
            xe
          ), Kt === null ? be = Sn : Kt.sibling = Sn, Kt = Sn);
        return t && Se.forEach(function(rc) {
          return e(V, rc);
        }), Ve && Rs(V, xe), be;
      }
      function pn(V, G, K, gt) {
        if (K == null)
          throw Error("An iterable object provided no iterator.");
        for (var Ut = null, be = null, Kt = G, Se = G = 0, xe = null, Sn = null, li = K.next(); Kt !== null && !li.done; Se++, li = K.next()) {
          Kt.index > Se ? (xe = Kt, Kt = null) : xe = Kt.sibling;
          var rc = at(V, Kt, li.value, gt);
          if (rc === null) {
            Kt === null && (Kt = xe);
            break;
          }
          Sn = Qt(
            V,
            rc,
            li.value,
            Sn
          ), t && Kt && rc.alternate === null && e(V, Kt), G = y(rc, G, Se), be === null ? Ut = rc : be.sibling = rc, be = rc, Kt = xe;
        }
        if (li.done)
          return a(V, Kt), Ve && Rs(V, Se), Ut;
        if (Kt === null) {
          for (; !li.done; Se++, li = K.next())
            Kt = mt(V, li.value, gt), Kt !== null && (Sn = Qt(
              V,
              Kt,
              li.value,
              Sn
            ), G = y(
              Kt,
              G,
              Se
            ), be === null ? Ut = Kt : be.sibling = Kt, be = Kt);
          return Ve && Rs(V, Se), Ut;
        }
        for (Kt = f(Kt); !li.done; Se++, li = K.next())
          xe = pt(
            Kt,
            V,
            Se,
            li.value,
            gt
          ), xe !== null && (Sn = Qt(
            V,
            xe,
            li.value,
            Sn
          ), t && xe.alternate !== null && Kt.delete(
            xe.key === null ? Se : xe.key
          ), G = y(
            xe,
            G,
            Se
          ), be === null ? Ut = xe : be.sibling = xe, be = xe);
        return t && Kt.forEach(function(LE) {
          return e(V, LE);
        }), Ve && Rs(V, Se), Ut;
      }
      function Be(V, G, K, gt) {
        if (typeof K == "object" && K !== null && K.type === _e && K.key === null && (Dc(K, null, V), K = K.props.children), typeof K == "object" && K !== null) {
          switch (K.$$typeof) {
            case Pr:
              var Ut = vi(K._debugInfo);
              t: {
                for (var be = K.key; G !== null; ) {
                  if (G.key === be) {
                    if (be = K.type, be === _e) {
                      if (G.tag === 7) {
                        a(
                          V,
                          G.sibling
                        ), gt = p(
                          G,
                          K.props.children
                        ), gt.return = V, gt._debugOwner = K._owner, gt._debugInfo = De, Dc(K, gt, V), V = gt;
                        break t;
                      }
                    } else if (G.elementType === be || Al(
                      G,
                      K
                    ) || typeof be == "object" && be !== null && be.$$typeof === so && hf(be) === G.type) {
                      a(
                        V,
                        G.sibling
                      ), gt = p(G, K.props), No(gt, K), gt.return = V, gt._debugOwner = K._owner, gt._debugInfo = De, V = gt;
                      break t;
                    }
                    a(V, G);
                    break;
                  } else e(V, G);
                  G = G.sibling;
                }
                K.type === _e ? (gt = Dl(
                  K.props.children,
                  V.mode,
                  gt,
                  K.key
                ), gt.return = V, gt._debugOwner = V, gt._debugTask = V._debugTask, gt._debugInfo = De, Dc(K, gt, V), V = gt) : (gt = Ds(
                  K,
                  V.mode,
                  gt
                ), No(gt, K), gt.return = V, gt._debugInfo = De, V = gt);
              }
              return V = M(V), De = Ut, V;
            case Xu:
              t: {
                for (Ut = K, K = Ut.key; G !== null; ) {
                  if (G.key === K)
                    if (G.tag === 4 && G.stateNode.containerInfo === Ut.containerInfo && G.stateNode.implementation === Ut.implementation) {
                      a(
                        V,
                        G.sibling
                      ), gt = p(
                        G,
                        Ut.children || []
                      ), gt.return = V, V = gt;
                      break t;
                    } else {
                      a(V, G);
                      break;
                    }
                  else e(V, G);
                  G = G.sibling;
                }
                gt = bc(
                  Ut,
                  V.mode,
                  gt
                ), gt.return = V, V = gt;
              }
              return M(V);
            case so:
              return Ut = vi(K._debugInfo), K = hf(K), V = Be(
                V,
                G,
                K,
                gt
              ), De = Ut, V;
          }
          if (de(K))
            return Ut = vi(K._debugInfo), V = ue(
              V,
              G,
              K,
              gt
            ), De = Ut, V;
          if (Bt(K)) {
            if (Ut = vi(K._debugInfo), be = Bt(K), typeof be != "function")
              throw Error(
                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
              );
            var Kt = be.call(K);
            return Kt === K ? (V.tag !== 0 || Object.prototype.toString.call(V.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(Kt) !== "[object Generator]") && (CS || console.error(
              "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
            ), CS = !0) : K.entries !== be || db || (console.error(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), db = !0), V = pn(
              V,
              G,
              Kt,
              gt
            ), De = Ut, V;
          }
          if (typeof K.then == "function")
            return Ut = vi(K._debugInfo), V = Be(
              V,
              G,
              Rc(K),
              gt
            ), De = Ut, V;
          if (K.$$typeof === qo)
            return Be(
              V,
              G,
              Ls(V, K),
              gt
            );
          ve(V, K);
        }
        return typeof K == "string" && K !== "" || typeof K == "number" || typeof K == "bigint" ? (Ut = "" + K, G !== null && G.tag === 6 ? (a(
          V,
          G.sibling
        ), gt = p(G, Ut), gt.return = V, V = gt) : (a(V, G), gt = Rl(
          Ut,
          V.mode,
          gt
        ), gt.return = V, gt._debugOwner = V, gt._debugTask = V._debugTask, gt._debugInfo = De, V = gt), M(V)) : (typeof K == "function" && Xe(V, K), typeof K == "symbol" && xn(V, K), a(V, G));
      }
      return function(V, G, K, gt) {
        var Ut = De;
        De = null;
        try {
          Ay = 0;
          var be = Be(
            V,
            G,
            K,
            gt
          );
          return pp = null, be;
        } catch (Sn) {
          if (Sn === wy || Sn === b_) throw Sn;
          var Kt = z(29, Sn, null, V.mode);
          Kt.lanes = gt, Kt.return = V;
          var Se = Kt._debugInfo = De;
          if (Kt._debugOwner = V._debugOwner, Kt._debugTask = V._debugTask, Se != null) {
            for (var xe = Se.length - 1; 0 <= xe; xe--)
              if (typeof Se[xe].stack == "string") {
                Kt._debugOwner = Se[xe], Kt._debugTask = Se[xe].debugTask;
                break;
              }
          }
          return Kt;
        } finally {
          De = Ut;
        }
      };
    }
    function no(t) {
      var e = t.alternate;
      kt(
        Yi,
        Yi.current & yp,
        t
      ), kt(ms, t, t), eu === null && (e === null || hp.current !== null || e.memoizedState !== null) && (eu = t);
    }
    function zr(t) {
      if (t.tag === 22) {
        if (kt(Yi, Yi.current, t), kt(ms, t, t), eu === null) {
          var e = t.alternate;
          e !== null && e.memoizedState !== null && (eu = t);
        }
      } else fl(t);
    }
    function fl(t) {
      kt(Yi, Yi.current, t), kt(
        ms,
        ms.current,
        t
      );
    }
    function io(t) {
      Rt(ms, t), eu === t && (eu = null), Rt(Yi, t);
    }
    function qs(t) {
      for (var e = t; e !== null; ) {
        if (e.tag === 13) {
          var a = e.memoizedState;
          if (a !== null && (a = a.dehydrated, a === null || a.data === oc || ts(a)))
            return e;
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
          if ((e.flags & 128) !== 0) return e;
        } else if (e.child !== null) {
          e.child.return = e, e = e.child;
          continue;
        }
        if (e === t) break;
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) return null;
          e = e.return;
        }
        e.sibling.return = e.return, e = e.sibling;
      }
      return null;
    }
    function Gp(t) {
      if (t !== null && typeof t != "function") {
        var e = String(t);
        XS.has(e) || (XS.add(e), console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          t
        ));
      }
    }
    function wn(t, e, a, f) {
      var p = t.memoizedState, y = a(f, p);
      if (t.mode & Ua) {
        Tt(!0);
        try {
          y = a(f, p);
        } finally {
          Tt(!1);
        }
      }
      y === void 0 && (e = Ct(e) || "Component", ZS.has(e) || (ZS.add(e), console.error(
        "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
        e
      ))), p = y == null ? p : Me({}, p, y), t.memoizedState = p, t.lanes === 0 && (t.updateQueue.baseState = p);
    }
    function Vd(t, e, a, f, p, y, M) {
      var D = t.stateNode;
      if (typeof D.shouldComponentUpdate == "function") {
        if (a = D.shouldComponentUpdate(
          f,
          y,
          M
        ), t.mode & Ua) {
          Tt(!0);
          try {
            a = D.shouldComponentUpdate(
              f,
              y,
              M
            );
          } finally {
            Tt(!1);
          }
        }
        return a === void 0 && console.error(
          "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
          Ct(e) || "Component"
        ), a;
      }
      return e.prototype && e.prototype.isPureReactComponent ? !As(a, f) || !As(p, y) : !0;
    }
    function Pd(t, e, a, f) {
      var p = e.state;
      typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(a, f), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(a, f), e.state !== p && (t = Mt(t) || "Component", US.has(t) || (US.add(t), console.error(
        "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
        t
      )), mb.enqueueReplaceState(
        e,
        e.state,
        null
      ));
    }
    function Lr(t, e) {
      var a = e;
      if ("ref" in e) {
        a = {};
        for (var f in e)
          f !== "ref" && (a[f] = e[f]);
      }
      if (t = t.defaultProps) {
        a === e && (a = Me({}, a));
        for (var p in t)
          a[p] === void 0 && (a[p] = t[p]);
      }
      return a;
    }
    function Xp(t) {
      pb(t), console.warn(
        `%s

%s
`,
        vp ? "An error occurred in the <" + vp + "> component." : "An error occurred in one of your React components.",
        `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`
      );
    }
    function Av(t) {
      var e = vp ? "The above error occurred in the <" + vp + "> component." : "The above error occurred in one of your React components.", a = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((gb || "Anonymous") + ".");
      if (typeof t == "object" && t !== null && typeof t.environmentName == "string") {
        var f = t.environmentName;
        t = [
          `%o

%s

%s
`,
          t,
          e,
          a
        ].slice(0), typeof t[0] == "string" ? t.splice(
          0,
          1,
          wT + t[0],
          MT,
          P_ + f + P_,
          ET
        ) : t.splice(
          0,
          0,
          wT,
          MT,
          P_ + f + P_,
          ET
        ), t.unshift(console), f = CE.apply(console.error, t), f();
      } else
        console.error(
          `%o

%s

%s
`,
          t,
          e,
          a
        );
    }
    function Gd(t) {
      pb(t);
    }
    function Cc(t, e) {
      try {
        vp = e.source ? Mt(e.source) : null, gb = null;
        var a = e.value;
        if (ft.actQueue !== null)
          ft.thrownErrors.push(a);
        else {
          var f = t.onUncaughtError;
          f(a, { componentStack: e.stack });
        }
      } catch (p) {
        setTimeout(function() {
          throw p;
        });
      }
    }
    function Xd(t, e, a) {
      try {
        vp = a.source ? Mt(a.source) : null, gb = Mt(e);
        var f = t.onCaughtError;
        f(a.value, {
          componentStack: a.stack,
          errorBoundary: e.tag === 1 ? e.stateNode : null
        });
      } catch (p) {
        setTimeout(function() {
          throw p;
        });
      }
    }
    function Gi(t, e, a) {
      return a = Gn(a), a.tag = ob, a.payload = { element: null }, a.callback = function() {
        Vt(e.source, Cc, t, e);
      }, a;
    }
    function Dn(t) {
      return t = Gn(t), t.tag = ob, t;
    }
    function eh(t, e, a, f) {
      var p = a.type.getDerivedStateFromError;
      if (typeof p == "function") {
        var y = f.value;
        t.payload = function() {
          return p(y);
        }, t.callback = function() {
          Dd(a), Vt(
            f.source,
            Xd,
            e,
            a,
            f
          );
        };
      }
      var M = a.stateNode;
      M !== null && typeof M.componentDidCatch == "function" && (t.callback = function() {
        Dd(a), Vt(
          f.source,
          Xd,
          e,
          a,
          f
        ), typeof p != "function" && (gf === null ? gf = /* @__PURE__ */ new Set([this]) : gf.add(this)), rE(this, f), typeof p == "function" || (a.lanes & 2) === 0 && console.error(
          "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
          Mt(a) || "Unknown"
        );
      });
    }
    function nh(t, e, a, f, p) {
      if (a.flags |= 32768, kn && Yc(t, p), f !== null && typeof f == "object" && typeof f.then == "function") {
        if (e = a.alternate, e !== null && ti(
          e,
          a,
          p,
          !0
        ), Ve && (tc = !0), a = ms.current, a !== null) {
          switch (a.tag) {
            case 13:
              return eu === null ? hm() : a.alternate === null && Kn === ac && (Kn = bb), a.flags &= -257, a.flags |= 65536, a.lanes = p, f === ab ? a.flags |= 16384 : (e = a.updateQueue, e === null ? a.updateQueue = /* @__PURE__ */ new Set([f]) : e.add(f), yg(t, f, p)), !1;
            case 22:
              return a.flags |= 65536, f === ab ? a.flags |= 16384 : (e = a.updateQueue, e === null ? (e = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([f])
              }, a.updateQueue = e) : (a = e.retryQueue, a === null ? e.retryQueue = /* @__PURE__ */ new Set([f]) : a.add(f)), yg(t, f, p)), !1;
          }
          throw Error(
            "Unexpected Suspense handler tag (" + a.tag + "). This is a bug in React."
          );
        }
        return yg(t, f, p), hm(), !1;
      }
      if (Ve)
        return tc = !0, e = ms.current, e !== null ? ((e.flags & 65536) === 0 && (e.flags |= 256), e.flags |= 65536, e.lanes = p, f !== tb && ol(
          ji(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
              { cause: f }
            ),
            a
          )
        )) : (f !== tb && ol(
          ji(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
              { cause: f }
            ),
            a
          )
        ), t = t.current.alternate, t.flags |= 65536, p &= -p, t.lanes |= p, f = ji(f, a), p = Gi(
          t.stateNode,
          f,
          p
        ), zo(t, p), Kn !== Jh && (Kn = Tp)), !1;
      var y = ji(
        Error(
          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
          { cause: f }
        ),
        a
      );
      if (Ny === null ? Ny = [y] : Ny.push(y), Kn !== Jh && (Kn = Tp), e === null) return !0;
      f = ji(f, a), a = e;
      do {
        switch (a.tag) {
          case 3:
            return a.flags |= 65536, t = p & -p, a.lanes |= t, t = Gi(
              a.stateNode,
              f,
              t
            ), zo(a, t), !1;
          case 1:
            if (e = a.type, y = a.stateNode, (a.flags & 128) === 0 && (typeof e.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (gf === null || !gf.has(y))))
              return a.flags |= 65536, p &= -p, a.lanes |= p, p = Dn(p), eh(
                p,
                t,
                a,
                f
              ), zo(a, p), !1;
        }
        a = a.return;
      } while (a !== null);
      return !1;
    }
    function Xn(t, e, a, f) {
      e.child = t === null ? kS(e, null, a, f) : gp(
        e,
        t.child,
        a,
        f
      );
    }
    function Qd(t, e, a, f, p) {
      a = a.render;
      var y = e.ref;
      if ("ref" in f) {
        var M = {};
        for (var D in f)
          D !== "ref" && (M[D] = f[D]);
      } else M = f;
      return $a(e), on(e), f = Ul(
        t,
        e,
        a,
        M,
        y,
        p
      ), D = w(), ci(), t !== null && !Ji ? (O(t, e, p), Vl(t, e, p)) : (Ve && D && al(e), e.flags |= 1, Xn(t, e, f, p), e.child);
    }
    function Zl(t, e, a, f, p) {
      if (t === null) {
        var y = a.type;
        return typeof y == "function" && !_c(y) && y.defaultProps === void 0 && a.compare === null ? (a = Ol(y), e.tag = 15, e.type = a, Id(e, y), ih(
          t,
          e,
          a,
          f,
          p
        )) : (t = Sr(
          a.type,
          null,
          f,
          e,
          e.mode,
          p
        ), t.ref = e.ref, t.return = e, e.child = t);
      }
      if (y = t.child, !im(t, p)) {
        var M = y.memoizedProps;
        if (a = a.compare, a = a !== null ? a : As, a(M, f) && t.ref === e.ref)
          return Vl(
            t,
            e,
            p
          );
      }
      return e.flags |= 1, t = Ja(y, f), t.ref = e.ref, t.return = e, e.child = t;
    }
    function ih(t, e, a, f, p) {
      if (t !== null) {
        var y = t.memoizedProps;
        if (As(y, f) && t.ref === e.ref && e.type === t.type)
          if (Ji = !1, e.pendingProps = f = y, im(t, p))
            (t.flags & 131072) !== 0 && (Ji = !0);
          else
            return e.lanes = t.lanes, Vl(t, e, p);
      }
      return Jd(
        t,
        e,
        a,
        f,
        p
      );
    }
    function Kd(t, e, a) {
      var f = e.pendingProps, p = f.children, y = t !== null ? t.memoizedState : null;
      if (f.mode === "hidden") {
        if ((e.flags & 128) !== 0) {
          if (f = y !== null ? y.baseLanes | a : a, t !== null) {
            for (p = e.child = t.child, y = 0; p !== null; )
              y = y | p.lanes | p.childLanes, p = p.sibling;
            e.childLanes = y & ~f;
          } else e.childLanes = 0, e.child = null;
          return Wd(
            t,
            e,
            f,
            a
          );
        }
        if ((a & 536870912) !== 0)
          e.memoizedState = { baseLanes: 0, cachePool: null }, t !== null && Ns(
            e,
            y !== null ? y.cachePool : null
          ), y !== null ? Vi(e, y) : wr(e), zr(e);
        else
          return e.lanes = e.childLanes = 536870912, Wd(
            t,
            e,
            y !== null ? y.baseLanes | a : a,
            a
          );
      } else
        y !== null ? (Ns(e, y.cachePool), Vi(e, y), fl(e), e.memoizedState = null) : (t !== null && Ns(e, null), wr(e), fl(e));
      return Xn(t, e, p, a), e.child;
    }
    function Wd(t, e, a, f) {
      var p = qf();
      return p = p === null ? null : {
        parent: Ui._currentValue,
        pool: p
      }, e.memoizedState = {
        baseLanes: a,
        cachePool: p
      }, t !== null && Ns(e, null), wr(e), zr(e), t !== null && ti(t, e, f, !0), null;
    }
    function ah(t, e) {
      var a = e.ref;
      if (a === null)
        t !== null && t.ref !== null && (e.flags |= 4194816);
      else {
        if (typeof a != "function" && typeof a != "object")
          throw Error(
            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
          );
        (t === null || t.ref !== a) && (e.flags |= 4194816);
      }
    }
    function Jd(t, e, a, f, p) {
      if (a.prototype && typeof a.prototype.render == "function") {
        var y = Ct(a) || "Unknown";
        KS[y] || (console.error(
          "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
          y,
          y
        ), KS[y] = !0);
      }
      return e.mode & Ua && ir.recordLegacyContextWarning(
        e,
        null
      ), t === null && (Id(e, e.type), a.contextTypes && (y = Ct(a) || "Unknown", JS[y] || (JS[y] = !0, console.error(
        "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
        y
      )))), $a(e), on(e), a = Ul(
        t,
        e,
        a,
        f,
        void 0,
        p
      ), f = w(), ci(), t !== null && !Ji ? (O(t, e, p), Vl(t, e, p)) : (Ve && f && al(e), e.flags |= 1, Xn(t, e, a, p), e.child);
    }
    function Qp(t, e, a, f, p, y) {
      return $a(e), on(e), nc = -1, Oy = t !== null && t.type !== e.type, e.updateQueue = null, a = d(
        e,
        f,
        a,
        p
      ), r(t, e), f = w(), ci(), t !== null && !Ji ? (O(t, e, y), Vl(t, e, y)) : (Ve && f && al(e), e.flags |= 1, Xn(t, e, a, y), e.child);
    }
    function Kp(t, e, a, f, p) {
      switch (_(e)) {
        case !1:
          var y = e.stateNode, M = new e.type(
            e.memoizedProps,
            y.context
          ).state;
          y.updater.enqueueSetState(y, M, null);
          break;
        case !0:
          e.flags |= 128, e.flags |= 65536, y = Error("Simulated error coming from DevTools");
          var D = p & -p;
          if (e.lanes |= D, M = mn, M === null)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          D = Dn(D), eh(
            D,
            M,
            e,
            ji(y, e)
          ), zo(e, D);
      }
      if ($a(e), e.stateNode === null) {
        if (M = uf, y = a.contextType, "contextType" in a && y !== null && (y === void 0 || y.$$typeof !== qo) && !GS.has(a) && (GS.add(a), D = y === void 0 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof y != "object" ? " However, it is set to a " + typeof y + "." : y.$$typeof === Ym ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(y).join(", ") + "}.", console.error(
          "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
          Ct(a) || "Component",
          D
        )), typeof y == "object" && y !== null && (M = tn(y)), y = new a(f, M), e.mode & Ua) {
          Tt(!0);
          try {
            y = new a(f, M);
          } finally {
            Tt(!1);
          }
        }
        if (M = e.memoizedState = y.state !== null && y.state !== void 0 ? y.state : null, y.updater = mb, e.stateNode = y, y._reactInternals = e, y._reactInternalInstance = NS, typeof a.getDerivedStateFromProps == "function" && M === null && (M = Ct(a) || "Component", BS.has(M) || (BS.add(M), console.error(
          "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
          M,
          y.state === null ? "null" : "undefined",
          M
        ))), typeof a.getDerivedStateFromProps == "function" || typeof y.getSnapshotBeforeUpdate == "function") {
          var B = D = M = null;
          if (typeof y.componentWillMount == "function" && y.componentWillMount.__suppressDeprecationWarning !== !0 ? M = "componentWillMount" : typeof y.UNSAFE_componentWillMount == "function" && (M = "UNSAFE_componentWillMount"), typeof y.componentWillReceiveProps == "function" && y.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? D = "componentWillReceiveProps" : typeof y.UNSAFE_componentWillReceiveProps == "function" && (D = "UNSAFE_componentWillReceiveProps"), typeof y.componentWillUpdate == "function" && y.componentWillUpdate.__suppressDeprecationWarning !== !0 ? B = "componentWillUpdate" : typeof y.UNSAFE_componentWillUpdate == "function" && (B = "UNSAFE_componentWillUpdate"), M !== null || D !== null || B !== null) {
            y = Ct(a) || "Component";
            var Y = typeof a.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            jS.has(y) || (jS.add(y), console.error(
              `Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`,
              y,
              Y,
              M !== null ? `
  ` + M : "",
              D !== null ? `
  ` + D : "",
              B !== null ? `
  ` + B : ""
            ));
          }
        }
        y = e.stateNode, M = Ct(a) || "Component", y.render || (a.prototype && typeof a.prototype.render == "function" ? console.error(
          "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
          M
        ) : console.error(
          "No `render` method found on the %s instance: you may have forgotten to define `render`.",
          M
        )), !y.getInitialState || y.getInitialState.isReactClassApproved || y.state || console.error(
          "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
          M
        ), y.getDefaultProps && !y.getDefaultProps.isReactClassApproved && console.error(
          "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
          M
        ), y.contextType && console.error(
          "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
          M
        ), a.childContextTypes && !PS.has(a) && (PS.add(a), console.error(
          "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
          M
        )), a.contextTypes && !VS.has(a) && (VS.add(a), console.error(
          "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
          M
        )), typeof y.componentShouldUpdate == "function" && console.error(
          "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
          M
        ), a.prototype && a.prototype.isPureReactComponent && typeof y.shouldComponentUpdate < "u" && console.error(
          "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
          Ct(a) || "A pure component"
        ), typeof y.componentDidUnmount == "function" && console.error(
          "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
          M
        ), typeof y.componentDidReceiveProps == "function" && console.error(
          "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
          M
        ), typeof y.componentWillRecieveProps == "function" && console.error(
          "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
          M
        ), typeof y.UNSAFE_componentWillRecieveProps == "function" && console.error(
          "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
          M
        ), D = y.props !== f, y.props !== void 0 && D && console.error(
          "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
          M
        ), y.defaultProps && console.error(
          "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
          M,
          M
        ), typeof y.getSnapshotBeforeUpdate != "function" || typeof y.componentDidUpdate == "function" || YS.has(a) || (YS.add(a), console.error(
          "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
          Ct(a)
        )), typeof y.getDerivedStateFromProps == "function" && console.error(
          "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          M
        ), typeof y.getDerivedStateFromError == "function" && console.error(
          "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          M
        ), typeof a.getSnapshotBeforeUpdate == "function" && console.error(
          "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
          M
        ), (D = y.state) && (typeof D != "object" || de(D)) && console.error("%s.state: must be set to an object or null", M), typeof y.getChildContext == "function" && typeof a.childContextTypes != "object" && console.error(
          "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
          M
        ), y = e.stateNode, y.props = f, y.state = e.memoizedState, y.refs = {}, Ri(e), M = a.contextType, y.context = typeof M == "object" && M !== null ? tn(M) : uf, y.state === f && (M = Ct(a) || "Component", qS.has(M) || (qS.add(M), console.error(
          "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
          M
        ))), e.mode & Ua && ir.recordLegacyContextWarning(
          e,
          y
        ), ir.recordUnsafeLifecycleWarnings(
          e,
          y
        ), y.state = e.memoizedState, M = a.getDerivedStateFromProps, typeof M == "function" && (wn(
          e,
          a,
          M,
          f
        ), y.state = e.memoizedState), typeof a.getDerivedStateFromProps == "function" || typeof y.getSnapshotBeforeUpdate == "function" || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (M = y.state, typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount(), M !== y.state && (console.error(
          "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          Mt(e) || "Component"
        ), mb.enqueueReplaceState(
          y,
          y.state,
          null
        )), sl(e, f, y, p), Lo(), y.state = e.memoizedState), typeof y.componentDidMount == "function" && (e.flags |= 4194308), (e.mode & nr) !== bn && (e.flags |= 134217728), y = !0;
      } else if (t === null) {
        y = e.stateNode;
        var lt = e.memoizedProps;
        D = Lr(a, lt), y.props = D;
        var mt = y.context;
        B = a.contextType, M = uf, typeof B == "object" && B !== null && (M = tn(B)), Y = a.getDerivedStateFromProps, B = typeof Y == "function" || typeof y.getSnapshotBeforeUpdate == "function", lt = e.pendingProps !== lt, B || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (lt || mt !== M) && Pd(
          e,
          y,
          f,
          M
        ), cf = !1;
        var at = e.memoizedState;
        y.state = at, sl(e, f, y, p), Lo(), mt = e.memoizedState, lt || at !== mt || cf ? (typeof Y == "function" && (wn(
          e,
          a,
          Y,
          f
        ), mt = e.memoizedState), (D = cf || Vd(
          e,
          a,
          D,
          f,
          at,
          mt,
          M
        )) ? (B || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount()), typeof y.componentDidMount == "function" && (e.flags |= 4194308), (e.mode & nr) !== bn && (e.flags |= 134217728)) : (typeof y.componentDidMount == "function" && (e.flags |= 4194308), (e.mode & nr) !== bn && (e.flags |= 134217728), e.memoizedProps = f, e.memoizedState = mt), y.props = f, y.state = mt, y.context = M, y = D) : (typeof y.componentDidMount == "function" && (e.flags |= 4194308), (e.mode & nr) !== bn && (e.flags |= 134217728), y = !1);
      } else {
        y = e.stateNode, Nl(t, e), M = e.memoizedProps, B = Lr(a, M), y.props = B, Y = e.pendingProps, at = y.context, mt = a.contextType, D = uf, typeof mt == "object" && mt !== null && (D = tn(mt)), lt = a.getDerivedStateFromProps, (mt = typeof lt == "function" || typeof y.getSnapshotBeforeUpdate == "function") || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (M !== Y || at !== D) && Pd(
          e,
          y,
          f,
          D
        ), cf = !1, at = e.memoizedState, y.state = at, sl(e, f, y, p), Lo();
        var pt = e.memoizedState;
        M !== Y || at !== pt || cf || t !== null && t.dependencies !== null && gi(t.dependencies) ? (typeof lt == "function" && (wn(
          e,
          a,
          lt,
          f
        ), pt = e.memoizedState), (B = cf || Vd(
          e,
          a,
          B,
          f,
          at,
          pt,
          D
        ) || t !== null && t.dependencies !== null && gi(t.dependencies)) ? (mt || typeof y.UNSAFE_componentWillUpdate != "function" && typeof y.componentWillUpdate != "function" || (typeof y.componentWillUpdate == "function" && y.componentWillUpdate(f, pt, D), typeof y.UNSAFE_componentWillUpdate == "function" && y.UNSAFE_componentWillUpdate(
          f,
          pt,
          D
        )), typeof y.componentDidUpdate == "function" && (e.flags |= 4), typeof y.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof y.componentDidUpdate != "function" || M === t.memoizedProps && at === t.memoizedState || (e.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || M === t.memoizedProps && at === t.memoizedState || (e.flags |= 1024), e.memoizedProps = f, e.memoizedState = pt), y.props = f, y.state = pt, y.context = D, y = B) : (typeof y.componentDidUpdate != "function" || M === t.memoizedProps && at === t.memoizedState || (e.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || M === t.memoizedProps && at === t.memoizedState || (e.flags |= 1024), y = !1);
      }
      if (D = y, ah(t, e), M = (e.flags & 128) !== 0, D || M) {
        if (D = e.stateNode, mr(e), M && typeof a.getDerivedStateFromError != "function")
          a = null, Po = -1;
        else {
          if (on(e), a = SS(D), e.mode & Ua) {
            Tt(!0);
            try {
              SS(D);
            } finally {
              Tt(!1);
            }
          }
          ci();
        }
        e.flags |= 1, t !== null && M ? (e.child = gp(
          e,
          t.child,
          null,
          p
        ), e.child = gp(
          e,
          null,
          a,
          p
        )) : Xn(t, e, a, p), e.memoizedState = D.state, t = e.child;
      } else
        t = Vl(
          t,
          e,
          p
        );
      return p = e.stateNode, y && p.props !== f && (_p || console.error(
        "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
        Mt(e) || "a component"
      ), _p = !0), t;
    }
    function Wp(t, e, a, f) {
      return zs(), e.flags |= 256, Xn(t, e, a, f), e.child;
    }
    function Id(t, e) {
      e && e.childContextTypes && console.error(
        `childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`,
        e.displayName || e.name || "Component"
      ), typeof e.getDerivedStateFromProps == "function" && (t = Ct(e) || "Unknown", IS[t] || (console.error(
        "%s: Function components do not support getDerivedStateFromProps.",
        t
      ), IS[t] = !0)), typeof e.contextType == "object" && e.contextType !== null && (e = Ct(e) || "Unknown", WS[e] || (console.error(
        "%s: Function components do not support contextType.",
        e
      ), WS[e] = !0));
    }
    function oh(t) {
      return { baseLanes: t, cachePool: Cd() };
    }
    function $d(t, e, a) {
      return t = t !== null ? t.childLanes & ~a : 0, e && (t |= _l), t;
    }
    function Dv(t, e, a) {
      var f, p = e.pendingProps;
      g(e) && (e.flags |= 128);
      var y = !1, M = (e.flags & 128) !== 0;
      if ((f = M) || (f = t !== null && t.memoizedState === null ? !1 : (Yi.current & Dy) !== 0), f && (y = !0, e.flags &= -129), f = (e.flags & 32) !== 0, e.flags &= -33, t === null) {
        if (Ve) {
          if (y ? no(e) : fl(e), Ve) {
            var D = Qn, B;
            if (!(B = !D)) {
              t: {
                var Y = D;
                for (B = Fr; Y.nodeType !== 8; ) {
                  if (!B) {
                    B = null;
                    break t;
                  }
                  if (Y = Hi(Y.nextSibling), Y === null) {
                    B = null;
                    break t;
                  }
                }
                B = Y;
              }
              B !== null ? (jn(), e.memoizedState = {
                dehydrated: B,
                treeContext: Vh !== null ? { id: $u, overflow: Fu } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, Y = z(18, null, null, bn), Y.stateNode = B, Y.return = e, e.child = Y, co = e, Qn = null, B = !0) : B = !1, B = !B;
            }
            B && (Cl(
              e,
              D
            ), Eo(e));
          }
          if (D = e.memoizedState, D !== null && (D = D.dehydrated, D !== null))
            return ts(D) ? e.lanes = 32 : e.lanes = 536870912, null;
          io(e);
        }
        return D = p.children, p = p.fallback, y ? (fl(e), y = e.mode, D = lh(
          {
            mode: "hidden",
            children: D
          },
          y
        ), p = Dl(
          p,
          y,
          a,
          null
        ), D.return = e, p.return = e, D.sibling = p, e.child = D, y = e.child, y.memoizedState = oh(a), y.childLanes = $d(
          t,
          f,
          a
        ), e.memoizedState = vb, p) : (no(e), Fd(
          e,
          D
        ));
      }
      var lt = t.memoizedState;
      if (lt !== null && (D = lt.dehydrated, D !== null)) {
        if (M)
          e.flags & 256 ? (no(e), e.flags &= -257, e = tm(
            t,
            e,
            a
          )) : e.memoizedState !== null ? (fl(e), e.child = t.child, e.flags |= 128, e = null) : (fl(e), y = p.fallback, D = e.mode, p = lh(
            {
              mode: "visible",
              children: p.children
            },
            D
          ), y = Dl(
            y,
            D,
            a,
            null
          ), y.flags |= 2, p.return = e, y.return = e, p.sibling = y, e.child = p, gp(
            e,
            t.child,
            null,
            a
          ), p = e.child, p.memoizedState = oh(a), p.childLanes = $d(
            t,
            f,
            a
          ), e.memoizedState = vb, e = y);
        else if (no(e), Ve && console.error(
          "We should not be hydrating here. This is a bug in React. Please file a bug."
        ), ts(D)) {
          if (f = D.nextSibling && D.nextSibling.dataset, f) {
            B = f.dgst;
            var mt = f.msg;
            Y = f.stck;
            var at = f.cstck;
          }
          D = mt, f = B, p = Y, B = y = at, y = Error(D || "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), y.stack = p || "", y.digest = f, f = B === void 0 ? null : B, p = {
            value: y,
            source: null,
            stack: f
          }, typeof f == "string" && $0.set(
            y,
            p
          ), ol(p), e = tm(
            t,
            e,
            a
          );
        } else if (Ji || ti(
          t,
          e,
          a,
          !1
        ), f = (a & t.childLanes) !== 0, Ji || f) {
          if (f = mn, f !== null && (p = a & -a, p = (p & 42) !== 0 ? 1 : Zn(
            p
          ), p = (p & (f.suspendedLanes | a)) !== 0 ? 0 : p, p !== 0 && p !== lt.retryLane))
            throw lt.retryLane = p, mi(
              t,
              p
            ), Rn(
              f,
              t,
              p
            ), QS;
          D.data === oc || hm(), e = tm(
            t,
            e,
            a
          );
        } else
          D.data === oc ? (e.flags |= 192, e.child = t.child, e = null) : (t = lt.treeContext, Qn = Hi(
            D.nextSibling
          ), co = e, Ve = !0, Ph = null, tc = !1, cs = null, Fr = !1, t !== null && (jn(), rs[us++] = $u, rs[us++] = Fu, rs[us++] = Vh, $u = t.id, Fu = t.overflow, Vh = e), e = Fd(
            e,
            p.children
          ), e.flags |= 4096);
        return e;
      }
      return y ? (fl(e), y = p.fallback, D = e.mode, B = t.child, Y = B.sibling, p = Ja(
        B,
        {
          mode: "hidden",
          children: p.children
        }
      ), p.subtreeFlags = B.subtreeFlags & 65011712, Y !== null ? y = Ja(
        Y,
        y
      ) : (y = Dl(
        y,
        D,
        a,
        null
      ), y.flags |= 2), y.return = e, p.return = e, p.sibling = y, e.child = p, p = y, y = e.child, D = t.child.memoizedState, D === null ? D = oh(a) : (B = D.cachePool, B !== null ? (Y = Ui._currentValue, B = B.parent !== Y ? { parent: Y, pool: Y } : B) : B = Cd(), D = {
        baseLanes: D.baseLanes | a,
        cachePool: B
      }), y.memoizedState = D, y.childLanes = $d(
        t,
        f,
        a
      ), e.memoizedState = vb, p) : (no(e), a = t.child, t = a.sibling, a = Ja(a, {
        mode: "visible",
        children: p.children
      }), a.return = e, a.sibling = null, t !== null && (f = e.deletions, f === null ? (e.deletions = [t], e.flags |= 16) : f.push(t)), e.child = a, e.memoizedState = null, a);
    }
    function Fd(t, e) {
      return e = lh(
        { mode: "visible", children: e },
        t.mode
      ), e.return = t, t.child = e;
    }
    function lh(t, e) {
      return t = z(22, t, null, e), t.lanes = 0, t.stateNode = {
        _visibility: h_,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }, t;
    }
    function tm(t, e, a) {
      return gp(e, t.child, null, a), t = Fd(
        e,
        e.pendingProps.children
      ), t.flags |= 2, e.memoizedState = null, t;
    }
    function em(t, e, a) {
      t.lanes |= e;
      var f = t.alternate;
      f !== null && (f.lanes |= e), jf(
        t.return,
        e,
        a
      );
    }
    function Jp(t, e) {
      var a = de(t);
      return t = !a && typeof Bt(t) == "function", a || t ? (a = a ? "array" : "iterable", console.error(
        "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
        a,
        e,
        a
      ), !1) : !0;
    }
    function nm(t, e, a, f, p) {
      var y = t.memoizedState;
      y === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: f,
        tail: a,
        tailMode: p
      } : (y.isBackwards = e, y.rendering = null, y.renderingStartTime = 0, y.last = f, y.tail = a, y.tailMode = p);
    }
    function Ip(t, e, a) {
      var f = e.pendingProps, p = f.revealOrder, y = f.tail;
      if (f = f.children, p !== void 0 && p !== "forwards" && p !== "backwards" && p !== "together" && !$S[p])
        if ($S[p] = !0, typeof p == "string")
          switch (p.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                p,
                p.toLowerCase()
              );
              break;
            case "forward":
            case "backward":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                p,
                p.toLowerCase()
              );
              break;
            default:
              console.error(
                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                p
              );
          }
        else
          console.error(
            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
            p
          );
      y === void 0 || yb[y] || (y !== "collapsed" && y !== "hidden" ? (yb[y] = !0, console.error(
        '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
        y
      )) : p !== "forwards" && p !== "backwards" && (yb[y] = !0, console.error(
        '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
        y
      )));
      t: if ((p === "forwards" || p === "backwards") && f !== void 0 && f !== null && f !== !1)
        if (de(f)) {
          for (var M = 0; M < f.length; M++)
            if (!Jp(f[M], M)) break t;
        } else if (M = Bt(f), typeof M == "function") {
          if (M = M.call(f))
            for (var D = M.next(), B = 0; !D.done; D = M.next()) {
              if (!Jp(D.value, B)) break t;
              B++;
            }
        } else
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            p
          );
      if (Xn(t, e, f, a), f = Yi.current, (f & Dy) !== 0)
        f = f & yp | Dy, e.flags |= 128;
      else {
        if (t !== null && (t.flags & 128) !== 0)
          t: for (t = e.child; t !== null; ) {
            if (t.tag === 13)
              t.memoizedState !== null && em(
                t,
                a,
                e
              );
            else if (t.tag === 19)
              em(t, a, e);
            else if (t.child !== null) {
              t.child.return = t, t = t.child;
              continue;
            }
            if (t === e) break t;
            for (; t.sibling === null; ) {
              if (t.return === null || t.return === e)
                break t;
              t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
          }
        f &= yp;
      }
      switch (kt(Yi, f, e), p) {
        case "forwards":
          for (a = e.child, p = null; a !== null; )
            t = a.alternate, t !== null && qs(t) === null && (p = a), a = a.sibling;
          a = p, a === null ? (p = e.child, e.child = null) : (p = a.sibling, a.sibling = null), nm(
            e,
            !1,
            p,
            a,
            y
          );
          break;
        case "backwards":
          for (a = null, p = e.child, e.child = null; p !== null; ) {
            if (t = p.alternate, t !== null && qs(t) === null) {
              e.child = p;
              break;
            }
            t = p.sibling, p.sibling = a, a = p, p = t;
          }
          nm(
            e,
            !0,
            a,
            null,
            y
          );
          break;
        case "together":
          nm(e, !1, null, null, void 0);
          break;
        default:
          e.memoizedState = null;
      }
      return e.child;
    }
    function Vl(t, e, a) {
      if (t !== null && (e.dependencies = t.dependencies), Po = -1, mf |= e.lanes, (a & e.childLanes) === 0)
        if (t !== null) {
          if (ti(
            t,
            e,
            a,
            !1
          ), (a & e.childLanes) === 0)
            return null;
        } else return null;
      if (t !== null && e.child !== t.child)
        throw Error("Resuming work not yet implemented.");
      if (e.child !== null) {
        for (t = e.child, a = Ja(t, t.pendingProps), e.child = a, a.return = e; t.sibling !== null; )
          t = t.sibling, a = a.sibling = Ja(t, t.pendingProps), a.return = e;
        a.sibling = null;
      }
      return e.child;
    }
    function im(t, e) {
      return (t.lanes & e) !== 0 ? !0 : (t = t.dependencies, !!(t !== null && gi(t)));
    }
    function L0(t, e, a) {
      switch (e.tag) {
        case 3:
          ge(
            e,
            e.stateNode.containerInfo
          ), zl(
            e,
            Ui,
            t.memoizedState.cache
          ), zs();
          break;
        case 27:
        case 5:
          dt(e);
          break;
        case 4:
          ge(
            e,
            e.stateNode.containerInfo
          );
          break;
        case 10:
          zl(
            e,
            e.type,
            e.memoizedProps.value
          );
          break;
        case 12:
          (a & e.childLanes) !== 0 && (e.flags |= 4), e.flags |= 2048;
          var f = e.stateNode;
          f.effectDuration = -0, f.passiveEffectDuration = -0;
          break;
        case 13:
          if (f = e.memoizedState, f !== null)
            return f.dehydrated !== null ? (no(e), e.flags |= 128, null) : (a & e.child.childLanes) !== 0 ? Dv(
              t,
              e,
              a
            ) : (no(e), t = Vl(
              t,
              e,
              a
            ), t !== null ? t.sibling : null);
          no(e);
          break;
        case 19:
          var p = (t.flags & 128) !== 0;
          if (f = (a & e.childLanes) !== 0, f || (ti(
            t,
            e,
            a,
            !1
          ), f = (a & e.childLanes) !== 0), p) {
            if (f)
              return Ip(
                t,
                e,
                a
              );
            e.flags |= 128;
          }
          if (p = e.memoizedState, p !== null && (p.rendering = null, p.tail = null, p.lastEffect = null), kt(
            Yi,
            Yi.current,
            e
          ), f) break;
          return null;
        case 22:
        case 23:
          return e.lanes = 0, Kd(t, e, a);
        case 24:
          zl(
            e,
            Ui,
            t.memoizedState.cache
          );
      }
      return Vl(t, e, a);
    }
    function am(t, e, a) {
      if (e._debugNeedsRemount && t !== null) {
        a = Sr(
          e.type,
          e.key,
          e.pendingProps,
          e._debugOwner || null,
          e.mode,
          e.lanes
        ), a._debugStack = e._debugStack, a._debugTask = e._debugTask;
        var f = e.return;
        if (f === null) throw Error("Cannot swap the root fiber.");
        if (t.alternate = null, e.alternate = null, a.index = e.index, a.sibling = e.sibling, a.return = e.return, a.ref = e.ref, a._debugInfo = e._debugInfo, e === f.child)
          f.child = a;
        else {
          var p = f.child;
          if (p === null)
            throw Error("Expected parent to have a child.");
          for (; p.sibling !== e; )
            if (p = p.sibling, p === null)
              throw Error("Expected to find the previous sibling.");
          p.sibling = a;
        }
        return e = f.deletions, e === null ? (f.deletions = [t], f.flags |= 16) : e.push(t), a.flags |= 2, a;
      }
      if (t !== null)
        if (t.memoizedProps !== e.pendingProps || e.type !== t.type)
          Ji = !0;
        else {
          if (!im(t, a) && (e.flags & 128) === 0)
            return Ji = !1, L0(
              t,
              e,
              a
            );
          Ji = (t.flags & 131072) !== 0;
        }
      else
        Ji = !1, (f = Ve) && (jn(), f = (e.flags & 1048576) !== 0), f && (f = e.index, jn(), ba(e, m_, f));
      switch (e.lanes = 0, e.tag) {
        case 16:
          t: if (f = e.pendingProps, t = hf(e.elementType), e.type = t, typeof t == "function")
            _c(t) ? (f = Lr(
              t,
              f
            ), e.tag = 1, e.type = t = Ol(t), e = Kp(
              null,
              e,
              t,
              f,
              a
            )) : (e.tag = 0, Id(e, t), e.type = t = Ol(t), e = Jd(
              null,
              e,
              t,
              f,
              a
            ));
          else {
            if (t != null) {
              if (p = t.$$typeof, p === Ws) {
                e.tag = 11, e.type = t = br(t), e = Qd(
                  null,
                  e,
                  t,
                  f,
                  a
                );
                break t;
              } else if (p === Rh) {
                e.tag = 14, e = Zl(
                  null,
                  e,
                  t,
                  f,
                  a
                );
                break t;
              }
            }
            throw e = "", t !== null && typeof t == "object" && t.$$typeof === so && (e = " Did you wrap a component in React.lazy() more than once?"), t = Ct(t) || t, Error(
              "Element type is invalid. Received a promise that resolves to: " + t + ". Lazy element type must resolve to a class or function." + e
            );
          }
          return e;
        case 0:
          return Jd(
            t,
            e,
            e.type,
            e.pendingProps,
            a
          );
        case 1:
          return f = e.type, p = Lr(
            f,
            e.pendingProps
          ), Kp(
            t,
            e,
            f,
            p,
            a
          );
        case 3:
          t: {
            if (ge(
              e,
              e.stateNode.containerInfo
            ), t === null)
              throw Error(
                "Should have a current fiber. This is a bug in React."
              );
            f = e.pendingProps;
            var y = e.memoizedState;
            p = y.element, Nl(t, e), sl(e, f, null, a);
            var M = e.memoizedState;
            if (f = M.cache, zl(e, Ui, f), f !== y.cache && Ll(
              e,
              [Ui],
              a,
              !0
            ), Lo(), f = M.element, y.isDehydrated)
              if (y = {
                element: f,
                isDehydrated: !1,
                cache: M.cache
              }, e.updateQueue.baseState = y, e.memoizedState = y, e.flags & 256) {
                e = Wp(
                  t,
                  e,
                  f,
                  a
                );
                break t;
              } else if (f !== p) {
                p = ji(
                  Error(
                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                  ),
                  e
                ), ol(p), e = Wp(
                  t,
                  e,
                  f,
                  a
                );
                break t;
              } else {
                switch (t = e.stateNode.containerInfo, t.nodeType) {
                  case 9:
                    t = t.body;
                    break;
                  default:
                    t = t.nodeName === "HTML" ? t.ownerDocument.body : t;
                }
                for (Qn = Hi(t.firstChild), co = e, Ve = !0, Ph = null, tc = !1, cs = null, Fr = !0, t = kS(
                  e,
                  null,
                  f,
                  a
                ), e.child = t; t; )
                  t.flags = t.flags & -3 | 4096, t = t.sibling;
              }
            else {
              if (zs(), f === p) {
                e = Vl(
                  t,
                  e,
                  a
                );
                break t;
              }
              Xn(
                t,
                e,
                f,
                a
              );
            }
            e = e.child;
          }
          return e;
        case 26:
          return ah(t, e), t === null ? (t = Ks(
            e.type,
            null,
            e.pendingProps,
            null
          )) ? e.memoizedState = t : Ve || (t = e.type, a = e.pendingProps, f = Ee(
            ns.current
          ), f = He(
            f
          ).createElement(t), f[Wi] = e, f[ka] = a, zn(f, t, a), $(f), e.stateNode = f) : e.memoizedState = Ks(
            e.type,
            t.memoizedProps,
            e.pendingProps,
            t.memoizedState
          ), null;
        case 27:
          return dt(e), t === null && Ve && (f = Ee(ns.current), p = P(), f = e.stateNode = Ng(
            e.type,
            e.pendingProps,
            f,
            p,
            !1
          ), tc || (p = sn(
            f,
            e.type,
            e.pendingProps,
            p
          ), p !== null && (Ia(e, 0).serverProps = p)), co = e, Fr = !0, p = Qn, Fl(e.type) ? (qb = p, Qn = Hi(
            f.firstChild
          )) : Qn = p), Xn(
            t,
            e,
            e.pendingProps.children,
            a
          ), ah(t, e), t === null && (e.flags |= 4194304), e.child;
        case 5:
          return t === null && Ve && (y = P(), f = yr(
            e.type,
            y.ancestorInfo
          ), p = Qn, (M = !p) || (M = jr(
            p,
            e.type,
            e.pendingProps,
            Fr
          ), M !== null ? (e.stateNode = M, tc || (y = sn(
            M,
            e.type,
            e.pendingProps,
            y
          ), y !== null && (Ia(e, 0).serverProps = y)), co = e, Qn = Hi(
            M.firstChild
          ), Fr = !1, y = !0) : y = !1, M = !y), M && (f && Cl(e, p), Eo(e))), dt(e), p = e.type, y = e.pendingProps, M = t !== null ? t.memoizedProps : null, f = y.children, $l(p, y) ? f = null : M !== null && $l(p, M) && (e.flags |= 32), e.memoizedState !== null && (p = Ul(
            t,
            e,
            v,
            null,
            null,
            a
          ), Py._currentValue = p), ah(t, e), Xn(
            t,
            e,
            f,
            a
          ), e.child;
        case 6:
          return t === null && Ve && (t = e.pendingProps, a = P(), f = a.ancestorInfo.current, t = f != null ? $o(
            t,
            f.tag,
            a.ancestorInfo.implicitRootScope
          ) : !0, a = Qn, (f = !a) || (f = Li(
            a,
            e.pendingProps,
            Fr
          ), f !== null ? (e.stateNode = f, co = e, Qn = null, f = !0) : f = !1, f = !f), f && (t && Cl(e, a), Eo(e))), null;
        case 13:
          return Dv(t, e, a);
        case 4:
          return ge(
            e,
            e.stateNode.containerInfo
          ), f = e.pendingProps, t === null ? e.child = gp(
            e,
            null,
            f,
            a
          ) : Xn(
            t,
            e,
            f,
            a
          ), e.child;
        case 11:
          return Qd(
            t,
            e,
            e.type,
            e.pendingProps,
            a
          );
        case 7:
          return Xn(
            t,
            e,
            e.pendingProps,
            a
          ), e.child;
        case 8:
          return Xn(
            t,
            e,
            e.pendingProps.children,
            a
          ), e.child;
        case 12:
          return e.flags |= 4, e.flags |= 2048, f = e.stateNode, f.effectDuration = -0, f.passiveEffectDuration = -0, Xn(
            t,
            e,
            e.pendingProps.children,
            a
          ), e.child;
        case 10:
          return f = e.type, p = e.pendingProps, y = p.value, "value" in p || FS || (FS = !0, console.error(
            "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
          )), zl(e, f, y), Xn(
            t,
            e,
            p.children,
            a
          ), e.child;
        case 9:
          return p = e.type._context, f = e.pendingProps.children, typeof f != "function" && console.error(
            "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
          ), $a(e), p = tn(p), on(e), f = fb(
            f,
            p,
            void 0
          ), ci(), e.flags |= 1, Xn(
            t,
            e,
            f,
            a
          ), e.child;
        case 14:
          return Zl(
            t,
            e,
            e.type,
            e.pendingProps,
            a
          );
        case 15:
          return ih(
            t,
            e,
            e.type,
            e.pendingProps,
            a
          );
        case 19:
          return Ip(
            t,
            e,
            a
          );
        case 31:
          return f = e.pendingProps, a = e.mode, f = {
            mode: f.mode,
            children: f.children
          }, t === null ? (t = lh(
            f,
            a
          ), t.ref = e.ref, e.child = t, t.return = e, e = t) : (t = Ja(t.child, f), t.ref = e.ref, e.child = t, t.return = e, e = t), e;
        case 22:
          return Kd(t, e, a);
        case 24:
          return $a(e), f = tn(Ui), t === null ? (p = qf(), p === null && (p = mn, y = Hs(), p.pooledCache = y, Do(y), y !== null && (p.pooledCacheLanes |= a), p = y), e.memoizedState = {
            parent: f,
            cache: p
          }, Ri(e), zl(e, Ui, p)) : ((t.lanes & a) !== 0 && (Nl(t, e), sl(e, null, null, a), Lo()), p = t.memoizedState, y = e.memoizedState, p.parent !== f ? (p = {
            parent: f,
            cache: f
          }, e.memoizedState = p, e.lanes === 0 && (e.memoizedState = e.updateQueue.baseState = p), zl(e, Ui, f)) : (f = y.cache, zl(e, Ui, f), f !== p.cache && Ll(
            e,
            [Ui],
            a,
            !0
          ))), Xn(
            t,
            e,
            e.pendingProps.children,
            a
          ), e.child;
        case 29:
          throw e.pendingProps;
      }
      throw Error(
        "Unknown unit of work tag (" + e.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Aa(t) {
      t.flags |= 4;
    }
    function sh(t, e) {
      if (e.type !== "stylesheet" || (e.state.loading & ps) !== od)
        t.flags &= -16777217;
      else if (t.flags |= 16777216, !Sh(e)) {
        if (e = ms.current, e !== null && ((Ne & 4194048) === Ne ? eu !== null : (Ne & 62914560) !== Ne && (Ne & 536870912) === 0 || e !== eu))
          throw My = ab, uS;
        t.flags |= 8192;
      }
    }
    function rh(t, e) {
      e !== null && (t.flags |= 4), t.flags & 16384 && (e = t.tag !== 22 ? pa() : 536870912, t.lanes |= e, Fh |= e);
    }
    function Hr(t, e) {
      if (!Ve)
        switch (t.tailMode) {
          case "hidden":
            e = t.tail;
            for (var a = null; e !== null; )
              e.alternate !== null && (a = e), e = e.sibling;
            a === null ? t.tail = null : a.sibling = null;
            break;
          case "collapsed":
            a = t.tail;
            for (var f = null; a !== null; )
              a.alternate !== null && (f = a), a = a.sibling;
            f === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : f.sibling = null;
        }
    }
    function en(t) {
      var e = t.alternate !== null && t.alternate.child === t.child, a = 0, f = 0;
      if (e)
        if ((t.mode & ca) !== bn) {
          for (var p = t.selfBaseDuration, y = t.child; y !== null; )
            a |= y.lanes | y.childLanes, f |= y.subtreeFlags & 65011712, f |= y.flags & 65011712, p += y.treeBaseDuration, y = y.sibling;
          t.treeBaseDuration = p;
        } else
          for (p = t.child; p !== null; )
            a |= p.lanes | p.childLanes, f |= p.subtreeFlags & 65011712, f |= p.flags & 65011712, p.return = t, p = p.sibling;
      else if ((t.mode & ca) !== bn) {
        p = t.actualDuration, y = t.selfBaseDuration;
        for (var M = t.child; M !== null; )
          a |= M.lanes | M.childLanes, f |= M.subtreeFlags, f |= M.flags, p += M.actualDuration, y += M.treeBaseDuration, M = M.sibling;
        t.actualDuration = p, t.treeBaseDuration = y;
      } else
        for (p = t.child; p !== null; )
          a |= p.lanes | p.childLanes, f |= p.subtreeFlags, f |= p.flags, p.return = t, p = p.sibling;
      return t.subtreeFlags |= f, t.childLanes = a, e;
    }
    function Rv(t, e, a) {
      var f = e.pendingProps;
      switch (Sc(e), e.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return en(e), null;
        case 1:
          return en(e), null;
        case 3:
          return a = e.stateNode, f = null, t !== null && (f = t.memoizedState.cache), e.memoizedState.cache !== f && (e.flags |= 2048), Fn(Ui, e), It(e), a.pendingContext && (a.context = a.pendingContext, a.pendingContext = null), (t === null || t.child === null) && (Oo(e) ? (Yf(), Aa(e)) : t === null || t.memoizedState.isDehydrated && (e.flags & 256) === 0 || (e.flags |= 1024, Ao())), en(e), null;
        case 26:
          return a = e.memoizedState, t === null ? (Aa(e), a !== null ? (en(e), sh(
            e,
            a
          )) : (en(e), e.flags &= -16777217)) : a ? a !== t.memoizedState ? (Aa(e), en(e), sh(
            e,
            a
          )) : (en(e), e.flags &= -16777217) : (t.memoizedProps !== f && Aa(e), en(e), e.flags &= -16777217), null;
        case 27:
          ut(e), a = Ee(ns.current);
          var p = e.type;
          if (t !== null && e.stateNode != null)
            t.memoizedProps !== f && Aa(e);
          else {
            if (!f) {
              if (e.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return en(e), null;
            }
            t = P(), Oo(e) ? Cs(e) : (t = Ng(
              p,
              f,
              a,
              t,
              !0
            ), e.stateNode = t, Aa(e));
          }
          return en(e), null;
        case 5:
          if (ut(e), a = e.type, t !== null && e.stateNode != null)
            t.memoizedProps !== f && Aa(e);
          else {
            if (!f) {
              if (e.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return en(e), null;
            }
            if (p = P(), Oo(e))
              Cs(e);
            else {
              switch (t = Ee(ns.current), yr(a, p.ancestorInfo), p = p.context, t = He(t), p) {
                case Ap:
                  t = t.createElementNS(rf, a);
                  break;
                case q_:
                  t = t.createElementNS(
                    qh,
                    a
                  );
                  break;
                default:
                  switch (a) {
                    case "svg":
                      t = t.createElementNS(
                        rf,
                        a
                      );
                      break;
                    case "math":
                      t = t.createElementNS(
                        qh,
                        a
                      );
                      break;
                    case "script":
                      t = t.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild);
                      break;
                    case "select":
                      t = typeof f.is == "string" ? t.createElement("select", { is: f.is }) : t.createElement("select"), f.multiple ? t.multiple = !0 : f.size && (t.size = f.size);
                      break;
                    default:
                      t = typeof f.is == "string" ? t.createElement(a, {
                        is: f.is
                      }) : t.createElement(a), a.indexOf("-") === -1 && (a !== a.toLowerCase() && console.error(
                        "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                        a
                      ), Object.prototype.toString.call(t) !== "[object HTMLUnknownElement]" || Is.call(
                        vT,
                        a
                      ) || (vT[a] = !0, console.error(
                        "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                        a
                      )));
                  }
              }
              t[Wi] = e, t[ka] = f;
              t: for (p = e.child; p !== null; ) {
                if (p.tag === 5 || p.tag === 6)
                  t.appendChild(p.stateNode);
                else if (p.tag !== 4 && p.tag !== 27 && p.child !== null) {
                  p.child.return = p, p = p.child;
                  continue;
                }
                if (p === e) break t;
                for (; p.sibling === null; ) {
                  if (p.return === null || p.return === e)
                    break t;
                  p = p.return;
                }
                p.sibling.return = p.return, p = p.sibling;
              }
              e.stateNode = t;
              t: switch (zn(t, a, f), a) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  t = !!f.autoFocus;
                  break t;
                case "img":
                  t = !0;
                  break t;
                default:
                  t = !1;
              }
              t && Aa(e);
            }
          }
          return en(e), e.flags &= -16777217, null;
        case 6:
          if (t && e.stateNode != null)
            t.memoizedProps !== f && Aa(e);
          else {
            if (typeof f != "string" && e.stateNode === null)
              throw Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            if (t = Ee(ns.current), a = P(), Oo(e)) {
              t = e.stateNode, a = e.memoizedProps, p = !tc, f = null;
              var y = co;
              if (y !== null)
                switch (y.tag) {
                  case 3:
                    p && (p = Rm(
                      t,
                      a,
                      f
                    ), p !== null && (Ia(e, 0).serverProps = p));
                    break;
                  case 27:
                  case 5:
                    f = y.memoizedProps, p && (p = Rm(
                      t,
                      a,
                      f
                    ), p !== null && (Ia(
                      e,
                      0
                    ).serverProps = p));
                }
              t[Wi] = e, t = !!(t.nodeValue === a || f !== null && f.suppressHydrationWarning === !0 || Eg(t.nodeValue, a)), t || Eo(e);
            } else
              p = a.ancestorInfo.current, p != null && $o(
                f,
                p.tag,
                a.ancestorInfo.implicitRootScope
              ), t = He(t).createTextNode(
                f
              ), t[Wi] = e, e.stateNode = t;
          }
          return en(e), null;
        case 13:
          if (f = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (p = Oo(e), f !== null && f.dehydrated !== null) {
              if (t === null) {
                if (!p)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                if (p = e.memoizedState, p = p !== null ? p.dehydrated : null, !p)
                  throw Error(
                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                p[Wi] = e, en(e), (e.mode & ca) !== bn && f !== null && (p = e.child, p !== null && (e.treeBaseDuration -= p.treeBaseDuration));
              } else
                Yf(), zs(), (e.flags & 128) === 0 && (e.memoizedState = null), e.flags |= 4, en(e), (e.mode & ca) !== bn && f !== null && (p = e.child, p !== null && (e.treeBaseDuration -= p.treeBaseDuration));
              p = !1;
            } else
              p = Ao(), t !== null && t.memoizedState !== null && (t.memoizedState.hydrationErrors = p), p = !0;
            if (!p)
              return e.flags & 256 ? (io(e), e) : (io(e), null);
          }
          return io(e), (e.flags & 128) !== 0 ? (e.lanes = a, (e.mode & ca) !== bn && to(e), e) : (a = f !== null, t = t !== null && t.memoizedState !== null, a && (f = e.child, p = null, f.alternate !== null && f.alternate.memoizedState !== null && f.alternate.memoizedState.cachePool !== null && (p = f.alternate.memoizedState.cachePool.pool), y = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (y = f.memoizedState.cachePool.pool), y !== p && (f.flags |= 2048)), a !== t && a && (e.child.flags |= 8192), rh(e, e.updateQueue), en(e), (e.mode & ca) !== bn && a && (t = e.child, t !== null && (e.treeBaseDuration -= t.treeBaseDuration)), null);
        case 4:
          return It(e), t === null && wg(
            e.stateNode.containerInfo
          ), en(e), null;
        case 10:
          return Fn(e.type, e), en(e), null;
        case 19:
          if (Rt(Yi, e), p = e.memoizedState, p === null) return en(e), null;
          if (f = (e.flags & 128) !== 0, y = p.rendering, y === null)
            if (f) Hr(p, !1);
            else {
              if (Kn !== ac || t !== null && (t.flags & 128) !== 0)
                for (t = e.child; t !== null; ) {
                  if (y = qs(t), y !== null) {
                    for (e.flags |= 128, Hr(p, !1), t = y.updateQueue, e.updateQueue = t, rh(e, t), e.subtreeFlags = 0, t = a, a = e.child; a !== null; )
                      Bf(a, t), a = a.sibling;
                    return kt(
                      Yi,
                      Yi.current & yp | Dy,
                      e
                    ), e.child;
                  }
                  t = t.sibling;
                }
              p.tail !== null && is() > D_ && (e.flags |= 128, f = !0, Hr(p, !1), e.lanes = 4194304);
            }
          else {
            if (!f)
              if (t = qs(y), t !== null) {
                if (e.flags |= 128, f = !0, t = t.updateQueue, e.updateQueue = t, rh(e, t), Hr(p, !0), p.tail === null && p.tailMode === "hidden" && !y.alternate && !Ve)
                  return en(e), null;
              } else
                2 * is() - p.renderingStartTime > D_ && a !== 536870912 && (e.flags |= 128, f = !0, Hr(p, !1), e.lanes = 4194304);
            p.isBackwards ? (y.sibling = e.child, e.child = y) : (t = p.last, t !== null ? t.sibling = y : e.child = y, p.last = y);
          }
          return p.tail !== null ? (t = p.tail, p.rendering = t, p.tail = t.sibling, p.renderingStartTime = is(), t.sibling = null, a = Yi.current, a = f ? a & yp | Dy : a & yp, kt(Yi, a, e), t) : (en(e), null);
        case 22:
        case 23:
          return io(e), Ma(e), f = e.memoizedState !== null, t !== null ? t.memoizedState !== null !== f && (e.flags |= 8192) : f && (e.flags |= 8192), f ? (a & 536870912) !== 0 && (e.flags & 128) === 0 && (en(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : en(e), a = e.updateQueue, a !== null && rh(e, a.retryQueue), a = null, t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (a = t.memoizedState.cachePool.pool), f = null, e.memoizedState !== null && e.memoizedState.cachePool !== null && (f = e.memoizedState.cachePool.pool), f !== a && (e.flags |= 2048), t !== null && Rt(Qh, e), null;
        case 24:
          return a = null, t !== null && (a = t.memoizedState.cache), e.memoizedState.cache !== a && (e.flags |= 2048), Fn(Ui, e), en(e), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(
        "Unknown unit of work tag (" + e.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Cv(t, e) {
      switch (Sc(e), e.tag) {
        case 1:
          return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, (e.mode & ca) !== bn && to(e), e) : null;
        case 3:
          return Fn(Ui, e), It(e), t = e.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (e.flags = t & -65537 | 128, e) : null;
        case 26:
        case 27:
        case 5:
          return ut(e), null;
        case 13:
          if (io(e), t = e.memoizedState, t !== null && t.dehydrated !== null) {
            if (e.alternate === null)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            zs();
          }
          return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, (e.mode & ca) !== bn && to(e), e) : null;
        case 19:
          return Rt(Yi, e), null;
        case 4:
          return It(e), null;
        case 10:
          return Fn(e.type, e), null;
        case 22:
        case 23:
          return io(e), Ma(e), t !== null && Rt(Qh, e), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, (e.mode & ca) !== bn && to(e), e) : null;
        case 24:
          return Fn(Ui, e), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function $p(t, e) {
      switch (Sc(e), e.tag) {
        case 3:
          Fn(Ui, e), It(e);
          break;
        case 26:
        case 27:
        case 5:
          ut(e);
          break;
        case 4:
          It(e);
          break;
        case 13:
          io(e);
          break;
        case 19:
          Rt(Yi, e);
          break;
        case 10:
          Fn(e.type, e);
          break;
        case 22:
        case 23:
          io(e), Ma(e), t !== null && Rt(Qh, e);
          break;
        case 24:
          Fn(Ui, e);
      }
    }
    function hl(t) {
      return (t.mode & ca) !== bn;
    }
    function Fp(t, e) {
      hl(t) ? (Fa(), Au(e, t), aa()) : Au(e, t);
    }
    function om(t, e, a) {
      hl(t) ? (Fa(), Du(
        a,
        t,
        e
      ), aa()) : Du(
        a,
        t,
        e
      );
    }
    function Au(t, e) {
      try {
        var a = e.updateQueue, f = a !== null ? a.lastEffect : null;
        if (f !== null) {
          var p = f.next;
          a = p;
          do {
            if ((a.tag & t) === t && ((t & Bi) !== fs ? jt !== null && typeof jt.markComponentPassiveEffectMountStarted == "function" && jt.markComponentPassiveEffectMountStarted(
              e
            ) : (t & fa) !== fs && jt !== null && typeof jt.markComponentLayoutEffectMountStarted == "function" && jt.markComponentLayoutEffectMountStarted(
              e
            ), f = void 0, (t & fo) !== fs && (Ep = !0), f = Vt(
              e,
              uE,
              a
            ), (t & fo) !== fs && (Ep = !1), (t & Bi) !== fs ? jt !== null && typeof jt.markComponentPassiveEffectMountStopped == "function" && jt.markComponentPassiveEffectMountStopped() : (t & fa) !== fs && jt !== null && typeof jt.markComponentLayoutEffectMountStopped == "function" && jt.markComponentLayoutEffectMountStopped(), f !== void 0 && typeof f != "function")) {
              var y = void 0;
              y = (a.tag & fa) !== 0 ? "useLayoutEffect" : (a.tag & fo) !== 0 ? "useInsertionEffect" : "useEffect";
              var M = void 0;
              M = f === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof f.then == "function" ? `

It looks like you wrote ` + y + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + y + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + f, Vt(
                e,
                function(D, B) {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    D,
                    B
                  );
                },
                y,
                M
              );
            }
            a = a.next;
          } while (a !== p);
        }
      } catch (D) {
        ie(e, e.return, D);
      }
    }
    function Du(t, e, a) {
      try {
        var f = e.updateQueue, p = f !== null ? f.lastEffect : null;
        if (p !== null) {
          var y = p.next;
          f = y;
          do {
            if ((f.tag & t) === t) {
              var M = f.inst, D = M.destroy;
              D !== void 0 && (M.destroy = void 0, (t & Bi) !== fs ? jt !== null && typeof jt.markComponentPassiveEffectUnmountStarted == "function" && jt.markComponentPassiveEffectUnmountStarted(
                e
              ) : (t & fa) !== fs && jt !== null && typeof jt.markComponentLayoutEffectUnmountStarted == "function" && jt.markComponentLayoutEffectUnmountStarted(
                e
              ), (t & fo) !== fs && (Ep = !0), p = e, Vt(
                p,
                cE,
                p,
                a,
                D
              ), (t & fo) !== fs && (Ep = !1), (t & Bi) !== fs ? jt !== null && typeof jt.markComponentPassiveEffectUnmountStopped == "function" && jt.markComponentPassiveEffectUnmountStopped() : (t & fa) !== fs && jt !== null && typeof jt.markComponentLayoutEffectUnmountStopped == "function" && jt.markComponentLayoutEffectUnmountStopped());
            }
            f = f.next;
          } while (f !== y);
        }
      } catch (B) {
        ie(e, e.return, B);
      }
    }
    function tg(t, e) {
      hl(t) ? (Fa(), Au(e, t), aa()) : Au(e, t);
    }
    function uh(t, e, a) {
      hl(t) ? (Fa(), Du(
        a,
        t,
        e
      ), aa()) : Du(
        a,
        t,
        e
      );
    }
    function eg(t) {
      var e = t.updateQueue;
      if (e !== null) {
        var a = t.stateNode;
        t.type.defaultProps || "ref" in t.memoizedProps || _p || (a.props !== t.memoizedProps && console.error(
          "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          Mt(t) || "instance"
        ), a.state !== t.memoizedState && console.error(
          "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          Mt(t) || "instance"
        ));
        try {
          Vt(
            t,
            Vf,
            e,
            a
          );
        } catch (f) {
          ie(t, t.return, f);
        }
      }
    }
    function zv(t, e, a) {
      return t.getSnapshotBeforeUpdate(e, a);
    }
    function H0(t, e) {
      var a = e.memoizedProps, f = e.memoizedState;
      e = t.stateNode, t.type.defaultProps || "ref" in t.memoizedProps || _p || (e.props !== t.memoizedProps && console.error(
        "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
        Mt(t) || "instance"
      ), e.state !== t.memoizedState && console.error(
        "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
        Mt(t) || "instance"
      ));
      try {
        var p = Lr(
          t.type,
          a,
          t.elementType === t.type
        ), y = Vt(
          t,
          zv,
          e,
          p,
          f
        );
        a = tT, y !== void 0 || a.has(t.type) || (a.add(t.type), Vt(t, function() {
          console.error(
            "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
            Mt(t)
          );
        })), e.__reactInternalSnapshotBeforeUpdate = y;
      } catch (M) {
        ie(t, t.return, M);
      }
    }
    function lm(t, e, a) {
      a.props = Lr(
        t.type,
        t.memoizedProps
      ), a.state = t.memoizedState, hl(t) ? (Fa(), Vt(
        t,
        OS,
        t,
        e,
        a
      ), aa()) : Vt(
        t,
        OS,
        t,
        e,
        a
      );
    }
    function Lv(t) {
      var e = t.ref;
      if (e !== null) {
        switch (t.tag) {
          case 26:
          case 27:
          case 5:
            var a = t.stateNode;
            break;
          case 30:
            a = t.stateNode;
            break;
          default:
            a = t.stateNode;
        }
        if (typeof e == "function")
          if (hl(t))
            try {
              Fa(), t.refCleanup = e(a);
            } finally {
              aa();
            }
          else t.refCleanup = e(a);
        else
          typeof e == "string" ? console.error("String refs are no longer supported.") : e.hasOwnProperty("current") || console.error(
            "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
            Mt(t)
          ), e.current = a;
      }
    }
    function zc(t, e) {
      try {
        Vt(t, Lv, t);
      } catch (a) {
        ie(t, e, a);
      }
    }
    function Uo(t, e) {
      var a = t.ref, f = t.refCleanup;
      if (a !== null)
        if (typeof f == "function")
          try {
            if (hl(t))
              try {
                Fa(), Vt(t, f);
              } finally {
                aa(t);
              }
            else Vt(t, f);
          } catch (p) {
            ie(t, e, p);
          } finally {
            t.refCleanup = null, t = t.alternate, t != null && (t.refCleanup = null);
          }
        else if (typeof a == "function")
          try {
            if (hl(t))
              try {
                Fa(), Vt(t, a, null);
              } finally {
                aa(t);
              }
            else Vt(t, a, null);
          } catch (p) {
            ie(t, e, p);
          }
        else a.current = null;
    }
    function ng(t, e, a, f) {
      var p = t.memoizedProps, y = p.id, M = p.onCommit;
      p = p.onRender, e = e === null ? "mount" : "update", y_ && (e = "nested-update"), typeof p == "function" && p(
        y,
        e,
        t.actualDuration,
        t.treeBaseDuration,
        t.actualStartTime,
        a
      ), typeof M == "function" && M(
        t.memoizedProps.id,
        e,
        f,
        a
      );
    }
    function Hv(t, e, a, f) {
      var p = t.memoizedProps;
      t = p.id, p = p.onPostCommit, e = e === null ? "mount" : "update", y_ && (e = "nested-update"), typeof p == "function" && p(
        t,
        e,
        f,
        a
      );
    }
    function kv(t) {
      var e = t.type, a = t.memoizedProps, f = t.stateNode;
      try {
        Vt(
          t,
          Xs,
          f,
          e,
          a,
          t
        );
      } catch (p) {
        ie(t, t.return, p);
      }
    }
    function ig(t, e, a) {
      try {
        Vt(
          t,
          Ln,
          t.stateNode,
          t.type,
          a,
          e,
          t
        );
      } catch (f) {
        ie(t, t.return, f);
      }
    }
    function ag(t) {
      return t.tag === 5 || t.tag === 3 || t.tag === 26 || t.tag === 27 && Fl(t.type) || t.tag === 4;
    }
    function Ru(t) {
      t: for (; ; ) {
        for (; t.sibling === null; ) {
          if (t.return === null || ag(t.return)) return null;
          t = t.return;
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
          if (t.tag === 27 && Fl(t.type) || t.flags & 2 || t.child === null || t.tag === 4) continue t;
          t.child.return = t, t = t.child;
        }
        if (!(t.flags & 2)) return t.stateNode;
      }
    }
    function ch(t, e, a) {
      var f = t.tag;
      if (f === 5 || f === 6)
        t = t.stateNode, e ? (a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a).insertBefore(t, e) : (e = a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a, e.appendChild(t), a = a._reactRootContainer, a != null || e.onclick !== null || (e.onclick = Gs));
      else if (f !== 4 && (f === 27 && Fl(t.type) && (a = t.stateNode, e = null), t = t.child, t !== null))
        for (ch(t, e, a), t = t.sibling; t !== null; )
          ch(t, e, a), t = t.sibling;
    }
    function Cu(t, e, a) {
      var f = t.tag;
      if (f === 5 || f === 6)
        t = t.stateNode, e ? a.insertBefore(t, e) : a.appendChild(t);
      else if (f !== 4 && (f === 27 && Fl(t.type) && (a = t.stateNode), t = t.child, t !== null))
        for (Cu(t, e, a), t = t.sibling; t !== null; )
          Cu(t, e, a), t = t.sibling;
    }
    function Nv(t) {
      for (var e, a = t.return; a !== null; ) {
        if (ag(a)) {
          e = a;
          break;
        }
        a = a.return;
      }
      if (e == null)
        throw Error(
          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
        );
      switch (e.tag) {
        case 27:
          e = e.stateNode, a = Ru(t), Cu(
            t,
            a,
            e
          );
          break;
        case 5:
          a = e.stateNode, e.flags & 32 && (Qs(a), e.flags &= -33), e = Ru(t), Cu(
            t,
            e,
            a
          );
          break;
        case 3:
        case 4:
          e = e.stateNode.containerInfo, a = Ru(t), ch(
            t,
            a,
            e
          );
          break;
        default:
          throw Error(
            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
          );
      }
    }
    function og(t) {
      var e = t.stateNode, a = t.memoizedProps;
      try {
        Vt(
          t,
          lo,
          t.type,
          a,
          e,
          t
        );
      } catch (f) {
        ie(t, t.return, f);
      }
    }
    function sm(t, e) {
      if (t = t.containerInfo, Bb = G_, t = kf(t), wo(t)) {
        if ("selectionStart" in t)
          var a = {
            start: t.selectionStart,
            end: t.selectionEnd
          };
        else
          t: {
            a = (a = t.ownerDocument) && a.defaultView || window;
            var f = a.getSelection && a.getSelection();
            if (f && f.rangeCount !== 0) {
              a = f.anchorNode;
              var p = f.anchorOffset, y = f.focusNode;
              f = f.focusOffset;
              try {
                a.nodeType, y.nodeType;
              } catch {
                a = null;
                break t;
              }
              var M = 0, D = -1, B = -1, Y = 0, lt = 0, mt = t, at = null;
              e: for (; ; ) {
                for (var pt; mt !== a || p !== 0 && mt.nodeType !== 3 || (D = M + p), mt !== y || f !== 0 && mt.nodeType !== 3 || (B = M + f), mt.nodeType === 3 && (M += mt.nodeValue.length), (pt = mt.firstChild) !== null; )
                  at = mt, mt = pt;
                for (; ; ) {
                  if (mt === t) break e;
                  if (at === a && ++Y === p && (D = M), at === y && ++lt === f && (B = M), (pt = mt.nextSibling) !== null) break;
                  mt = at, at = mt.parentNode;
                }
                mt = pt;
              }
              a = D === -1 || B === -1 ? null : { start: D, end: B };
            } else a = null;
          }
        a = a || { start: 0, end: 0 };
      } else a = null;
      for (Yb = {
        focusedElem: t,
        selectionRange: a
      }, G_ = !1, Ii = e; Ii !== null; )
        if (e = Ii, t = e.child, (e.subtreeFlags & 1024) !== 0 && t !== null)
          t.return = e, Ii = t;
        else
          for (; Ii !== null; ) {
            switch (t = e = Ii, a = t.alternate, p = t.flags, t.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                (p & 1024) !== 0 && a !== null && H0(t, a);
                break;
              case 3:
                if ((p & 1024) !== 0) {
                  if (t = t.stateNode.containerInfo, a = t.nodeType, a === 9)
                    Vc(t);
                  else if (a === 1)
                    switch (t.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        Vc(t);
                        break;
                      default:
                        t.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((p & 1024) !== 0)
                  throw Error(
                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                  );
            }
            if (t = e.sibling, t !== null) {
              t.return = e.return, Ii = t;
              break;
            }
            Ii = e.return;
          }
    }
    function lg(t, e, a) {
      var f = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 15:
          Pl(t, a), f & 4 && Fp(a, fa | hs);
          break;
        case 1:
          if (Pl(t, a), f & 4)
            if (t = a.stateNode, e === null)
              a.type.defaultProps || "ref" in a.memoizedProps || _p || (t.props !== a.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                Mt(a) || "instance"
              ), t.state !== a.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                Mt(a) || "instance"
              )), hl(a) ? (Fa(), Vt(
                a,
                hb,
                a,
                t
              ), aa()) : Vt(
                a,
                hb,
                a,
                t
              );
            else {
              var p = Lr(
                a.type,
                e.memoizedProps
              );
              e = e.memoizedState, a.type.defaultProps || "ref" in a.memoizedProps || _p || (t.props !== a.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                Mt(a) || "instance"
              ), t.state !== a.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                Mt(a) || "instance"
              )), hl(a) ? (Fa(), Vt(
                a,
                wS,
                a,
                t,
                p,
                e,
                t.__reactInternalSnapshotBeforeUpdate
              ), aa()) : Vt(
                a,
                wS,
                a,
                t,
                p,
                e,
                t.__reactInternalSnapshotBeforeUpdate
              );
            }
          f & 64 && eg(a), f & 512 && zc(a, a.return);
          break;
        case 3:
          if (e = qi(), Pl(t, a), f & 64 && (f = a.updateQueue, f !== null)) {
            if (p = null, a.child !== null)
              switch (a.child.tag) {
                case 27:
                case 5:
                  p = a.child.stateNode;
                  break;
                case 1:
                  p = a.child.stateNode;
              }
            try {
              Vt(
                a,
                Vf,
                f,
                p
              );
            } catch (M) {
              ie(a, a.return, M);
            }
          }
          t.effectDuration += Ro(e);
          break;
        case 27:
          e === null && f & 4 && og(a);
        case 26:
        case 5:
          Pl(t, a), e === null && f & 4 && kv(a), f & 512 && zc(a, a.return);
          break;
        case 12:
          if (f & 4) {
            f = qi(), Pl(t, a), t = a.stateNode, t.effectDuration += Hl(f);
            try {
              Vt(
                a,
                ng,
                a,
                e,
                g_,
                t.effectDuration
              );
            } catch (M) {
              ie(a, a.return, M);
            }
          } else Pl(t, a);
          break;
        case 13:
          Pl(t, a), f & 4 && Lc(t, a), f & 64 && (t = a.memoizedState, t !== null && (t = t.dehydrated, t !== null && (a = vh.bind(
            null,
            a
          ), Pc(t, a))));
          break;
        case 22:
          if (f = a.memoizedState !== null || ic, !f) {
            e = e !== null && e.memoizedState !== null || oi, p = ic;
            var y = oi;
            ic = f, (oi = e) && !y ? Gl(
              t,
              a,
              (a.subtreeFlags & 8772) !== 0
            ) : Pl(t, a), ic = p, oi = y;
          }
          break;
        case 30:
          break;
        default:
          Pl(t, a);
      }
    }
    function sg(t) {
      var e = t.alternate;
      e !== null && (t.alternate = null, sg(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && ga(e)), t.stateNode = null, t._debugOwner = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
    }
    function Zs(t, e, a) {
      for (a = a.child; a !== null; )
        zu(
          t,
          e,
          a
        ), a = a.sibling;
    }
    function zu(t, e, a) {
      if (ki && typeof ki.onCommitFiberUnmount == "function")
        try {
          ki.onCommitFiberUnmount(Qr, a);
        } catch (y) {
          Ha || (Ha = !0, console.error(
            "React instrumentation encountered an error: %s",
            y
          ));
        }
      switch (a.tag) {
        case 26:
          oi || Uo(a, e), Zs(
            t,
            e,
            a
          ), a.memoizedState ? a.memoizedState.count-- : a.stateNode && (a = a.stateNode, a.parentNode.removeChild(a));
          break;
        case 27:
          oi || Uo(a, e);
          var f = xi, p = Go;
          Fl(a.type) && (xi = a.stateNode, Go = !1), Zs(
            t,
            e,
            a
          ), Vt(
            a,
            Xc,
            a.stateNode
          ), xi = f, Go = p;
          break;
        case 5:
          oi || Uo(a, e);
        case 6:
          if (f = xi, p = Go, xi = null, Zs(
            t,
            e,
            a
          ), xi = f, Go = p, xi !== null)
            if (Go)
              try {
                Vt(
                  a,
                  qc,
                  xi,
                  a.stateNode
                );
              } catch (y) {
                ie(
                  a,
                  e,
                  y
                );
              }
            else
              try {
                Vt(
                  a,
                  jo,
                  xi,
                  a.stateNode
                );
              } catch (y) {
                ie(
                  a,
                  e,
                  y
                );
              }
          break;
        case 18:
          xi !== null && (Go ? (t = xi, Zc(
            t.nodeType === 9 ? t.body : t.nodeName === "HTML" ? t.ownerDocument.body : t,
            a.stateNode
          ), Gu(t)) : Zc(xi, a.stateNode));
          break;
        case 4:
          f = xi, p = Go, xi = a.stateNode.containerInfo, Go = !0, Zs(
            t,
            e,
            a
          ), xi = f, Go = p;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          oi || Du(
            fo,
            a,
            e
          ), oi || om(
            a,
            e,
            fa
          ), Zs(
            t,
            e,
            a
          );
          break;
        case 1:
          oi || (Uo(a, e), f = a.stateNode, typeof f.componentWillUnmount == "function" && lm(
            a,
            e,
            f
          )), Zs(
            t,
            e,
            a
          );
          break;
        case 21:
          Zs(
            t,
            e,
            a
          );
          break;
        case 22:
          oi = (f = oi) || a.memoizedState !== null, Zs(
            t,
            e,
            a
          ), oi = f;
          break;
        default:
          Zs(
            t,
            e,
            a
          );
      }
    }
    function Lc(t, e) {
      if (e.memoizedState === null && (t = e.alternate, t !== null && (t = t.memoizedState, t !== null && (t = t.dehydrated, t !== null))))
        try {
          Vt(
            e,
            oo,
            t
          );
        } catch (a) {
          ie(e, e.return, a);
        }
    }
    function rm(t) {
      switch (t.tag) {
        case 13:
        case 19:
          var e = t.stateNode;
          return e === null && (e = t.stateNode = new eT()), e;
        case 22:
          return t = t.stateNode, e = t._retryCache, e === null && (e = t._retryCache = new eT()), e;
        default:
          throw Error(
            "Unexpected Suspense handler tag (" + t.tag + "). This is a bug in React."
          );
      }
    }
    function Lu(t, e) {
      var a = rm(t);
      e.forEach(function(f) {
        var p = Br.bind(null, t, f);
        if (!a.has(f)) {
          if (a.add(f), kn)
            if (bp !== null && Sp !== null)
              Yc(Sp, bp);
            else
              throw Error(
                "Expected finished root and lanes to be set. This is a bug in React."
              );
          f.then(p, p);
        }
      });
    }
    function Xi(t, e) {
      var a = e.deletions;
      if (a !== null)
        for (var f = 0; f < a.length; f++) {
          var p = t, y = e, M = a[f], D = y;
          t: for (; D !== null; ) {
            switch (D.tag) {
              case 27:
                if (Fl(D.type)) {
                  xi = D.stateNode, Go = !1;
                  break t;
                }
                break;
              case 5:
                xi = D.stateNode, Go = !1;
                break t;
              case 3:
              case 4:
                xi = D.stateNode.containerInfo, Go = !0;
                break t;
            }
            D = D.return;
          }
          if (xi === null)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          zu(p, y, M), xi = null, Go = !1, p = M, y = p.alternate, y !== null && (y.return = null), p.return = null;
        }
      if (e.subtreeFlags & 13878)
        for (e = e.child; e !== null; )
          rg(e, t), e = e.sibling;
    }
    function rg(t, e) {
      var a = t.alternate, f = t.flags;
      switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Xi(e, t), Da(t), f & 4 && (Du(
            fo | hs,
            t,
            t.return
          ), Au(fo | hs, t), om(
            t,
            t.return,
            fa | hs
          ));
          break;
        case 1:
          Xi(e, t), Da(t), f & 512 && (oi || a === null || Uo(a, a.return)), f & 64 && ic && (t = t.updateQueue, t !== null && (f = t.callbacks, f !== null && (a = t.shared.hiddenCallbacks, t.shared.hiddenCallbacks = a === null ? f : a.concat(f))));
          break;
        case 26:
          var p = or;
          if (Xi(e, t), Da(t), f & 512 && (oi || a === null || Uo(a, a.return)), f & 4)
            if (e = a !== null ? a.memoizedState : null, f = t.memoizedState, a === null)
              if (f === null)
                if (t.stateNode === null) {
                  t: {
                    f = t.type, a = t.memoizedProps, e = p.ownerDocument || p;
                    e: switch (f) {
                      case "title":
                        p = e.getElementsByTagName("title")[0], (!p || p[af] || p[Wi] || p.namespaceURI === rf || p.hasAttribute("itemprop")) && (p = e.createElement(f), e.head.insertBefore(
                          p,
                          e.querySelector("head > title")
                        )), zn(p, f, a), p[Wi] = t, $(p), f = p;
                        break t;
                      case "link":
                        var y = jg(
                          "link",
                          "href",
                          e
                        ).get(f + (a.href || ""));
                        if (y) {
                          for (var M = 0; M < y.length; M++)
                            if (p = y[M], p.getAttribute("href") === (a.href == null || a.href === "" ? null : a.href) && p.getAttribute("rel") === (a.rel == null ? null : a.rel) && p.getAttribute("title") === (a.title == null ? null : a.title) && p.getAttribute("crossorigin") === (a.crossOrigin == null ? null : a.crossOrigin)) {
                              y.splice(M, 1);
                              break e;
                            }
                        }
                        p = e.createElement(f), zn(p, f, a), e.head.appendChild(p);
                        break;
                      case "meta":
                        if (y = jg(
                          "meta",
                          "content",
                          e
                        ).get(f + (a.content || ""))) {
                          for (M = 0; M < y.length; M++)
                            if (p = y[M], ct(
                              a.content,
                              "content"
                            ), p.getAttribute("content") === (a.content == null ? null : "" + a.content) && p.getAttribute("name") === (a.name == null ? null : a.name) && p.getAttribute("property") === (a.property == null ? null : a.property) && p.getAttribute("http-equiv") === (a.httpEquiv == null ? null : a.httpEquiv) && p.getAttribute("charset") === (a.charSet == null ? null : a.charSet)) {
                              y.splice(M, 1);
                              break e;
                            }
                        }
                        p = e.createElement(f), zn(p, f, a), e.head.appendChild(p);
                        break;
                      default:
                        throw Error(
                          'getNodesForType encountered a type it did not expect: "' + f + '". This is a bug in React.'
                        );
                    }
                    p[Wi] = t, $(p), f = p;
                  }
                  t.stateNode = f;
                } else
                  qg(
                    p,
                    t.type,
                    t.stateNode
                  );
              else
                t.stateNode = Cm(
                  p,
                  f,
                  t.memoizedProps
                );
            else
              e !== f ? (e === null ? a.stateNode !== null && (a = a.stateNode, a.parentNode.removeChild(a)) : e.count--, f === null ? qg(
                p,
                t.type,
                t.stateNode
              ) : Cm(
                p,
                f,
                t.memoizedProps
              )) : f === null && t.stateNode !== null && ig(
                t,
                t.memoizedProps,
                a.memoizedProps
              );
          break;
        case 27:
          Xi(e, t), Da(t), f & 512 && (oi || a === null || Uo(a, a.return)), a !== null && f & 4 && ig(
            t,
            t.memoizedProps,
            a.memoizedProps
          );
          break;
        case 5:
          if (Xi(e, t), Da(t), f & 512 && (oi || a === null || Uo(a, a.return)), t.flags & 32) {
            e = t.stateNode;
            try {
              Vt(t, Qs, e);
            } catch (lt) {
              ie(t, t.return, lt);
            }
          }
          f & 4 && t.stateNode != null && (e = t.memoizedProps, ig(
            t,
            e,
            a !== null ? a.memoizedProps : e
          )), f & 1024 && (_b = !0, t.type !== "form" && console.error(
            "Unexpected host component type. Expected a form. This is a bug in React."
          ));
          break;
        case 6:
          if (Xi(e, t), Da(t), f & 4) {
            if (t.stateNode === null)
              throw Error(
                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
              );
            f = t.memoizedProps, a = a !== null ? a.memoizedProps : f, e = t.stateNode;
            try {
              Vt(
                t,
                qu,
                e,
                a,
                f
              );
            } catch (lt) {
              ie(t, t.return, lt);
            }
          }
          break;
        case 3:
          if (p = qi(), Z_ = null, y = or, or = bh(e.containerInfo), Xi(e, t), or = y, Da(t), f & 4 && a !== null && a.memoizedState.isDehydrated)
            try {
              Vt(
                t,
                kg,
                e.containerInfo
              );
            } catch (lt) {
              ie(t, t.return, lt);
            }
          _b && (_b = !1, Hu(t)), e.effectDuration += Ro(p);
          break;
        case 4:
          f = or, or = bh(
            t.stateNode.containerInfo
          ), Xi(e, t), Da(t), or = f;
          break;
        case 12:
          f = qi(), Xi(e, t), Da(t), t.stateNode.effectDuration += Hl(f);
          break;
        case 13:
          Xi(e, t), Da(t), t.child.flags & 8192 && t.memoizedState !== null != (a !== null && a.memoizedState !== null) && (Mb = is()), f & 4 && (f = t.updateQueue, f !== null && (t.updateQueue = null, Lu(t, f)));
          break;
        case 22:
          p = t.memoizedState !== null;
          var D = a !== null && a.memoizedState !== null, B = ic, Y = oi;
          if (ic = B || p, oi = Y || D, Xi(e, t), oi = Y, ic = B, Da(t), f & 8192)
            t: for (e = t.stateNode, e._visibility = p ? e._visibility & ~h_ : e._visibility | h_, p && (a === null || D || ic || oi || Qi(t)), a = null, e = t; ; ) {
              if (e.tag === 5 || e.tag === 26) {
                if (a === null) {
                  D = a = e;
                  try {
                    y = D.stateNode, p ? Vt(D, za, y) : Vt(
                      D,
                      Lg,
                      D.stateNode,
                      D.memoizedProps
                    );
                  } catch (lt) {
                    ie(D, D.return, lt);
                  }
                }
              } else if (e.tag === 6) {
                if (a === null) {
                  D = e;
                  try {
                    M = D.stateNode, p ? Vt(D, zg, M) : Vt(
                      D,
                      Am,
                      M,
                      D.memoizedProps
                    );
                  } catch (lt) {
                    ie(D, D.return, lt);
                  }
                }
              } else if ((e.tag !== 22 && e.tag !== 23 || e.memoizedState === null || e === t) && e.child !== null) {
                e.child.return = e, e = e.child;
                continue;
              }
              if (e === t) break t;
              for (; e.sibling === null; ) {
                if (e.return === null || e.return === t)
                  break t;
                a === e && (a = null), e = e.return;
              }
              a === e && (a = null), e.sibling.return = e.return, e = e.sibling;
            }
          f & 4 && (f = t.updateQueue, f !== null && (a = f.retryQueue, a !== null && (f.retryQueue = null, Lu(t, a))));
          break;
        case 19:
          Xi(e, t), Da(t), f & 4 && (f = t.updateQueue, f !== null && (t.updateQueue = null, Lu(t, f)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          Xi(e, t), Da(t);
      }
    }
    function Da(t) {
      var e = t.flags;
      if (e & 2) {
        try {
          Vt(t, Nv, t);
        } catch (a) {
          ie(t, t.return, a);
        }
        t.flags &= -3;
      }
      e & 4096 && (t.flags &= -4097);
    }
    function Hu(t) {
      if (t.subtreeFlags & 1024)
        for (t = t.child; t !== null; ) {
          var e = t;
          Hu(e), e.tag === 5 && e.flags & 1024 && e.stateNode.reset(), t = t.sibling;
        }
    }
    function Pl(t, e) {
      if (e.subtreeFlags & 8772)
        for (e = e.child; e !== null; )
          lg(t, e.alternate, e), e = e.sibling;
    }
    function ao(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          om(
            t,
            t.return,
            fa
          ), Qi(t);
          break;
        case 1:
          Uo(t, t.return);
          var e = t.stateNode;
          typeof e.componentWillUnmount == "function" && lm(
            t,
            t.return,
            e
          ), Qi(t);
          break;
        case 27:
          Vt(
            t,
            Xc,
            t.stateNode
          );
        case 26:
        case 5:
          Uo(t, t.return), Qi(t);
          break;
        case 22:
          t.memoizedState === null && Qi(t);
          break;
        case 30:
          Qi(t);
          break;
        default:
          Qi(t);
      }
    }
    function Qi(t) {
      for (t = t.child; t !== null; )
        ao(t), t = t.sibling;
    }
    function Vs(t, e, a, f) {
      var p = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 15:
          Gl(
            t,
            a,
            f
          ), Fp(a, fa);
          break;
        case 1:
          if (Gl(
            t,
            a,
            f
          ), e = a.stateNode, typeof e.componentDidMount == "function" && Vt(
            a,
            hb,
            a,
            e
          ), e = a.updateQueue, e !== null) {
            t = a.stateNode;
            try {
              Vt(
                a,
                Us,
                e,
                t
              );
            } catch (y) {
              ie(a, a.return, y);
            }
          }
          f && p & 64 && eg(a), zc(a, a.return);
          break;
        case 27:
          og(a);
        case 26:
        case 5:
          Gl(
            t,
            a,
            f
          ), f && e === null && p & 4 && kv(a), zc(a, a.return);
          break;
        case 12:
          if (f && p & 4) {
            p = qi(), Gl(
              t,
              a,
              f
            ), f = a.stateNode, f.effectDuration += Hl(p);
            try {
              Vt(
                a,
                ng,
                a,
                e,
                g_,
                f.effectDuration
              );
            } catch (y) {
              ie(a, a.return, y);
            }
          } else
            Gl(
              t,
              a,
              f
            );
          break;
        case 13:
          Gl(
            t,
            a,
            f
          ), f && p & 4 && Lc(t, a);
          break;
        case 22:
          a.memoizedState === null && Gl(
            t,
            a,
            f
          ), zc(a, a.return);
          break;
        case 30:
          break;
        default:
          Gl(
            t,
            a,
            f
          );
      }
    }
    function Gl(t, e, a) {
      for (a = a && (e.subtreeFlags & 8772) !== 0, e = e.child; e !== null; )
        Vs(
          t,
          e.alternate,
          e,
          a
        ), e = e.sibling;
    }
    function Xl(t, e) {
      var a = null;
      t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (a = t.memoizedState.cachePool.pool), t = null, e.memoizedState !== null && e.memoizedState.cachePool !== null && (t = e.memoizedState.cachePool.pool), t !== a && (t != null && Do(t), a != null && Di(a));
    }
    function dl(t, e) {
      t = null, e.alternate !== null && (t = e.alternate.memoizedState.cache), e = e.memoizedState.cache, e !== t && (Do(e), t != null && Di(t));
    }
    function nn(t, e, a, f) {
      if (e.subtreeFlags & 10256)
        for (e = e.child; e !== null; )
          fh(
            t,
            e,
            a,
            f
          ), e = e.sibling;
    }
    function fh(t, e, a, f) {
      var p = e.flags;
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          nn(
            t,
            e,
            a,
            f
          ), p & 2048 && tg(e, Bi | hs);
          break;
        case 1:
          nn(
            t,
            e,
            a,
            f
          );
          break;
        case 3:
          var y = qi();
          nn(
            t,
            e,
            a,
            f
          ), p & 2048 && (a = null, e.alternate !== null && (a = e.alternate.memoizedState.cache), e = e.memoizedState.cache, e !== a && (Do(e), a != null && Di(a))), t.passiveEffectDuration += Ro(y);
          break;
        case 12:
          if (p & 2048) {
            p = qi(), nn(
              t,
              e,
              a,
              f
            ), t = e.stateNode, t.passiveEffectDuration += Hl(p);
            try {
              Vt(
                e,
                Hv,
                e,
                e.alternate,
                g_,
                t.passiveEffectDuration
              );
            } catch (D) {
              ie(e, e.return, D);
            }
          } else
            nn(
              t,
              e,
              a,
              f
            );
          break;
        case 13:
          nn(
            t,
            e,
            a,
            f
          );
          break;
        case 23:
          break;
        case 22:
          y = e.stateNode;
          var M = e.alternate;
          e.memoizedState !== null ? y._visibility & Iu ? nn(
            t,
            e,
            a,
            f
          ) : Hc(
            t,
            e
          ) : y._visibility & Iu ? nn(
            t,
            e,
            a,
            f
          ) : (y._visibility |= Iu, kr(
            t,
            e,
            a,
            f,
            (e.subtreeFlags & 10256) !== 0
          )), p & 2048 && Xl(M, e);
          break;
        case 24:
          nn(
            t,
            e,
            a,
            f
          ), p & 2048 && dl(e.alternate, e);
          break;
        default:
          nn(
            t,
            e,
            a,
            f
          );
      }
    }
    function kr(t, e, a, f, p) {
      for (p = p && (e.subtreeFlags & 10256) !== 0, e = e.child; e !== null; )
        um(
          t,
          e,
          a,
          f,
          p
        ), e = e.sibling;
    }
    function um(t, e, a, f, p) {
      var y = e.flags;
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          kr(
            t,
            e,
            a,
            f,
            p
          ), tg(e, Bi);
          break;
        case 23:
          break;
        case 22:
          var M = e.stateNode;
          e.memoizedState !== null ? M._visibility & Iu ? kr(
            t,
            e,
            a,
            f,
            p
          ) : Hc(
            t,
            e
          ) : (M._visibility |= Iu, kr(
            t,
            e,
            a,
            f,
            p
          )), p && y & 2048 && Xl(
            e.alternate,
            e
          );
          break;
        case 24:
          kr(
            t,
            e,
            a,
            f,
            p
          ), p && y & 2048 && dl(e.alternate, e);
          break;
        default:
          kr(
            t,
            e,
            a,
            f,
            p
          );
      }
    }
    function Hc(t, e) {
      if (e.subtreeFlags & 10256)
        for (e = e.child; e !== null; ) {
          var a = t, f = e, p = f.flags;
          switch (f.tag) {
            case 22:
              Hc(
                a,
                f
              ), p & 2048 && Xl(
                f.alternate,
                f
              );
              break;
            case 24:
              Hc(
                a,
                f
              ), p & 2048 && dl(
                f.alternate,
                f
              );
              break;
            default:
              Hc(
                a,
                f
              );
          }
          e = e.sibling;
        }
    }
    function ku(t) {
      if (t.subtreeFlags & Ry)
        for (t = t.child; t !== null; )
          Nr(t), t = t.sibling;
    }
    function Nr(t) {
      switch (t.tag) {
        case 26:
          ku(t), t.flags & Ry && t.memoizedState !== null && Qv(
            or,
            t.memoizedState,
            t.memoizedProps
          );
          break;
        case 5:
          ku(t);
          break;
        case 3:
        case 4:
          var e = or;
          or = bh(
            t.stateNode.containerInfo
          ), ku(t), or = e;
          break;
        case 22:
          t.memoizedState === null && (e = t.alternate, e !== null && e.memoizedState !== null ? (e = Ry, Ry = 16777216, ku(t), Ry = e) : ku(t));
          break;
        default:
          ku(t);
      }
    }
    function hh(t) {
      var e = t.alternate;
      if (e !== null && (t = e.child, t !== null)) {
        e.child = null;
        do
          e = t.sibling, t.sibling = null, t = e;
        while (t !== null);
      }
    }
    function kc(t) {
      var e = t.deletions;
      if ((t.flags & 16) !== 0) {
        if (e !== null)
          for (var a = 0; a < e.length; a++) {
            var f = e[a];
            Ii = f, cg(
              f,
              t
            );
          }
        hh(t);
      }
      if (t.subtreeFlags & 10256)
        for (t = t.child; t !== null; )
          ug(t), t = t.sibling;
    }
    function ug(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          kc(t), t.flags & 2048 && uh(
            t,
            t.return,
            Bi | hs
          );
          break;
        case 3:
          var e = qi();
          kc(t), t.stateNode.passiveEffectDuration += Ro(e);
          break;
        case 12:
          e = qi(), kc(t), t.stateNode.passiveEffectDuration += Hl(e);
          break;
        case 22:
          e = t.stateNode, t.memoizedState !== null && e._visibility & Iu && (t.return === null || t.return.tag !== 13) ? (e._visibility &= ~Iu, dh(t)) : kc(t);
          break;
        default:
          kc(t);
      }
    }
    function dh(t) {
      var e = t.deletions;
      if ((t.flags & 16) !== 0) {
        if (e !== null)
          for (var a = 0; a < e.length; a++) {
            var f = e[a];
            Ii = f, cg(
              f,
              t
            );
          }
        hh(t);
      }
      for (t = t.child; t !== null; )
        mh(t), t = t.sibling;
    }
    function mh(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          uh(
            t,
            t.return,
            Bi
          ), dh(t);
          break;
        case 22:
          var e = t.stateNode;
          e._visibility & Iu && (e._visibility &= ~Iu, dh(t));
          break;
        default:
          dh(t);
      }
    }
    function cg(t, e) {
      for (; Ii !== null; ) {
        var a = Ii, f = a;
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            uh(
              f,
              e,
              Bi
            );
            break;
          case 23:
          case 22:
            f.memoizedState !== null && f.memoizedState.cachePool !== null && (f = f.memoizedState.cachePool.pool, f != null && Do(f));
            break;
          case 24:
            Di(f.memoizedState.cache);
        }
        if (f = a.child, f !== null) f.return = a, Ii = f;
        else
          t: for (a = t; Ii !== null; ) {
            f = Ii;
            var p = f.sibling, y = f.return;
            if (sg(f), f === a) {
              Ii = null;
              break t;
            }
            if (p !== null) {
              p.return = y, Ii = p;
              break t;
            }
            Ii = y;
          }
      }
    }
    function fg() {
      hE.forEach(function(t) {
        return t();
      });
    }
    function hg() {
      var t = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
      return t || ft.actQueue === null || console.error(
        "The current testing environment is not configured to support act(...)"
      ), t;
    }
    function Ra(t) {
      if ((Ie & ho) !== yl && Ne !== 0)
        return Ne & -Ne;
      var e = ft.T;
      return e !== null ? (e._updatedFibers || (e._updatedFibers = /* @__PURE__ */ new Set()), e._updatedFibers.add(t), t = Xh, t !== 0 ? t : Sg()) : fr();
    }
    function Uv() {
      _l === 0 && (_l = (Ne & 536870912) === 0 || Ve ? pe() : 536870912);
      var t = ms.current;
      return t !== null && (t.flags |= 32), _l;
    }
    function Rn(t, e, a) {
      if (Ep && console.error("useInsertionEffect must not schedule updates."), Rb && (R_ = !0), (t === mn && (an === Ih || an === $h) || t.cancelPendingCommit !== null) && (Uu(t, 0), Ps(
        t,
        Ne,
        _l,
        !1
      )), po(t, a), (Ie & ho) !== 0 && t === mn) {
        if (Na)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              t = ke && Mt(ke) || "Unknown", fT.has(t) || (fT.add(t), e = Mt(e) || "Unknown", console.error(
                "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                e,
                t,
                t
              ));
              break;
            case 1:
              cT || (console.error(
                "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
              ), cT = !0);
          }
      } else
        kn && ta(t, e, a), qv(e), t === mn && ((Ie & ho) === yl && (pf |= a), Kn === Jh && Ps(
          t,
          Ne,
          _l,
          !1
        )), Bo(t);
    }
    function ii(t, e, a) {
      if ((Ie & (ho | lr)) !== yl)
        throw Error("Should not already be working.");
      var f = !a && (e & 124) === 0 && (e & t.expiredLanes) === 0 || Va(t, e), p = f ? mg(t, e) : dm(t, e, !0), y = f;
      do {
        if (p === ac) {
          wp && !f && Ps(t, e, 0, !1);
          break;
        } else {
          if (a = t.current.alternate, y && !Bv(a)) {
            p = dm(t, e, !1), y = !1;
            continue;
          }
          if (p === Tp) {
            if (y = e, t.errorRecoveryDisabledLanes & y)
              var M = 0;
            else
              M = t.pendingLanes & -536870913, M = M !== 0 ? M : M & 536870912 ? 536870912 : 0;
            if (M !== 0) {
              e = M;
              t: {
                p = t;
                var D = M;
                M = Ny;
                var B = p.current.memoizedState.isDehydrated;
                if (B && (Uu(
                  p,
                  D
                ).flags |= 256), D = dm(
                  p,
                  D,
                  !1
                ), D !== Tp) {
                  if (xb && !B) {
                    p.errorRecoveryDisabledLanes |= y, pf |= y, p = Jh;
                    break t;
                  }
                  p = mo, mo = M, p !== null && (mo === null ? mo = p : mo.push.apply(
                    mo,
                    p
                  ));
                }
                p = D;
              }
              if (y = !1, p !== Tp) continue;
            }
          }
          if (p === zy) {
            Uu(t, 0), Ps(t, e, 0, !0);
            break;
          }
          t: {
            switch (f = t, p) {
              case ac:
              case zy:
                throw Error("Root did not complete. This is a bug in React.");
              case Jh:
                if ((e & 4194048) !== e) break;
              case O_:
                Ps(
                  f,
                  e,
                  _l,
                  !df
                );
                break t;
              case Tp:
                mo = null;
                break;
              case bb:
              case nT:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (ft.actQueue !== null)
              vm(
                f,
                a,
                e,
                mo,
                Uy,
                A_,
                _l,
                pf,
                Fh
              );
            else {
              if ((e & 62914560) === e && (y = Mb + aT - is(), 10 < y)) {
                if (Ps(
                  f,
                  e,
                  _l,
                  !df
                ), En(f, 0, !0) !== 0) break t;
                f.timeoutHandle = _T(
                  _i.bind(
                    null,
                    f,
                    a,
                    mo,
                    Uy,
                    A_,
                    e,
                    _l,
                    pf,
                    Fh,
                    df,
                    p,
                    gE,
                    lS,
                    0
                  ),
                  y
                );
                break t;
              }
              _i(
                f,
                a,
                mo,
                Uy,
                A_,
                e,
                _l,
                pf,
                Fh,
                df,
                p,
                mE,
                lS,
                0
              );
            }
          }
        }
        break;
      } while (!0);
      Bo(t);
    }
    function _i(t, e, a, f, p, y, M, D, B, Y, lt, mt, at, pt) {
      if (t.timeoutHandle = ad, mt = e.subtreeFlags, (mt & 8192 || (mt & 16785408) === 16785408) && (Vy = { stylesheets: null, count: 0, unsuspend: Xv }, Nr(e), mt = Kv(), mt !== null)) {
        t.cancelPendingCommit = mt(
          vm.bind(
            null,
            t,
            e,
            y,
            a,
            f,
            p,
            M,
            D,
            B,
            lt,
            pE,
            at,
            pt
          )
        ), Ps(
          t,
          y,
          M,
          !Y
        );
        return;
      }
      vm(
        t,
        e,
        y,
        a,
        f,
        p,
        M,
        D,
        B
      );
    }
    function Bv(t) {
      for (var e = t; ; ) {
        var a = e.tag;
        if ((a === 0 || a === 11 || a === 15) && e.flags & 16384 && (a = e.updateQueue, a !== null && (a = a.stores, a !== null)))
          for (var f = 0; f < a.length; f++) {
            var p = a[f], y = p.getSnapshot;
            p = p.value;
            try {
              if (!uo(y(), p)) return !1;
            } catch {
              return !1;
            }
          }
        if (a = e.child, e.subtreeFlags & 16384 && a !== null)
          a.return = e, e = a;
        else {
          if (e === t) break;
          for (; e.sibling === null; ) {
            if (e.return === null || e.return === t) return !0;
            e = e.return;
          }
          e.sibling.return = e.return, e = e.sibling;
        }
      }
      return !0;
    }
    function Ps(t, e, a, f) {
      e &= ~wb, e &= ~pf, t.suspendedLanes |= e, t.pingedLanes &= ~e, f && (t.warmLanes |= e), f = t.expirationTimes;
      for (var p = e; 0 < p; ) {
        var y = 31 - Ki(p), M = 1 << y;
        f[y] = -1, p &= ~M;
      }
      a !== 0 && hu(t, a, e);
    }
    function Nu() {
      return (Ie & (ho | lr)) === yl ? (Bu(0), !1) : !0;
    }
    function cm() {
      if (ke !== null) {
        if (an === Xo)
          var t = ke.return;
        else
          t = ke, Tr(), H(t), pp = null, Ay = 0, t = ke;
        for (; t !== null; )
          $p(t.alternate, t), t = t.return;
        ke = null;
      }
    }
    function Uu(t, e) {
      var a = t.timeoutHandle;
      a !== ad && (t.timeoutHandle = ad, DE(a)), a = t.cancelPendingCommit, a !== null && (t.cancelPendingCommit = null, a()), cm(), mn = t, ke = a = Ja(t.current, null), Ne = e, an = Xo, vl = null, df = !1, wp = Va(t, e), xb = !1, Kn = ac, Fh = _l = wb = pf = mf = 0, mo = Ny = null, A_ = !1, (e & 8) !== 0 && (e |= e & 32);
      var f = t.entangledLanes;
      if (f !== 0)
        for (t = t.entanglements, f &= e; 0 < f; ) {
          var p = 31 - Ki(f), y = 1 << p;
          e |= t[p], f &= ~y;
        }
      return nu = e, _r(), e = aS(), 1e3 < e - iS && (ft.recentlyCreatedOwnerStacks = 0, iS = e), ir.discardPendingWarnings(), a;
    }
    function ph(t, e) {
      me = null, ft.H = M_, ft.getCurrentStack = null, Na = !1, ro = null, e === wy || e === b_ ? (e = kl(), an = Hy) : e === uS ? (e = kl(), an = iT) : an = e === QS ? Tb : e !== null && typeof e == "object" && typeof e.then == "function" ? xp : Ly, vl = e;
      var a = ke;
      if (a === null)
        Kn = zy, Cc(
          t,
          ji(e, t.current)
        );
      else
        switch (a.mode & ca && Sa(a), ci(), an) {
          case Ly:
            jt !== null && typeof jt.markComponentErrored == "function" && jt.markComponentErrored(
              a,
              e,
              Ne
            );
            break;
          case Ih:
          case $h:
          case Hy:
          case xp:
          case ky:
            jt !== null && typeof jt.markComponentSuspended == "function" && jt.markComponentSuspended(
              a,
              e,
              Ne
            );
        }
    }
    function fm() {
      var t = ft.H;
      return ft.H = M_, t === null ? M_ : t;
    }
    function dg() {
      var t = ft.A;
      return ft.A = fE, t;
    }
    function hm() {
      Kn = Jh, df || (Ne & 4194048) !== Ne && ms.current !== null || (wp = !0), (mf & 134217727) === 0 && (pf & 134217727) === 0 || mn === null || Ps(
        mn,
        Ne,
        _l,
        !1
      );
    }
    function dm(t, e, a) {
      var f = Ie;
      Ie |= ho;
      var p = fm(), y = dg();
      if (mn !== t || Ne !== e) {
        if (kn) {
          var M = t.memoizedUpdaters;
          0 < M.size && (Yc(t, Ne), M.clear()), In(t, e);
        }
        Uy = null, Uu(t, e);
      }
      da(e), e = !1, M = Kn;
      t: do
        try {
          if (an !== Xo && ke !== null) {
            var D = ke, B = vl;
            switch (an) {
              case Tb:
                cm(), M = O_;
                break t;
              case Hy:
              case Ih:
              case $h:
              case xp:
                ms.current === null && (e = !0);
                var Y = an;
                if (an = Xo, vl = null, Ur(t, D, B, Y), a && wp) {
                  M = ac;
                  break t;
                }
                break;
              default:
                Y = an, an = Xo, vl = null, Ur(t, D, B, Y);
            }
          }
          mm(), M = Kn;
          break;
        } catch (lt) {
          ph(t, lt);
        }
      while (!0);
      return e && t.shellSuspendCounter++, Tr(), Ie = f, ft.H = p, ft.A = y, Za(), ke === null && (mn = null, Ne = 0, _r()), M;
    }
    function mm() {
      for (; ke !== null; ) gg(ke);
    }
    function mg(t, e) {
      var a = Ie;
      Ie |= ho;
      var f = fm(), p = dg();
      if (mn !== t || Ne !== e) {
        if (kn) {
          var y = t.memoizedUpdaters;
          0 < y.size && (Yc(t, Ne), y.clear()), In(t, e);
        }
        Uy = null, D_ = is() + oT, Uu(t, e);
      } else
        wp = Va(
          t,
          e
        );
      da(e);
      t: do
        try {
          if (an !== Xo && ke !== null)
            e: switch (e = ke, y = vl, an) {
              case Ly:
                an = Xo, vl = null, Ur(
                  t,
                  e,
                  y,
                  Ly
                );
                break;
              case Ih:
              case $h:
                if (Zf(y)) {
                  an = Xo, vl = null, pm(e);
                  break;
                }
                e = function() {
                  an !== Ih && an !== $h || mn !== t || (an = ky), Bo(t);
                }, y.then(e, e);
                break t;
              case Hy:
                an = ky;
                break t;
              case iT:
                an = Sb;
                break t;
              case ky:
                Zf(y) ? (an = Xo, vl = null, pm(e)) : (an = Xo, vl = null, Ur(
                  t,
                  e,
                  y,
                  ky
                ));
                break;
              case Sb:
                var M = null;
                switch (ke.tag) {
                  case 26:
                    M = ke.memoizedState;
                  case 5:
                  case 27:
                    var D = ke;
                    if (!M || Sh(M)) {
                      an = Xo, vl = null;
                      var B = D.sibling;
                      if (B !== null) ke = B;
                      else {
                        var Y = D.return;
                        Y !== null ? (ke = Y, gh(Y)) : ke = null;
                      }
                      break e;
                    }
                    break;
                  default:
                    console.error(
                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                    );
                }
                an = Xo, vl = null, Ur(
                  t,
                  e,
                  y,
                  Sb
                );
                break;
              case xp:
                an = Xo, vl = null, Ur(
                  t,
                  e,
                  y,
                  xp
                );
                break;
              case Tb:
                cm(), Kn = O_;
                break t;
              default:
                throw Error(
                  "Unexpected SuspendedReason. This is a bug in React."
                );
            }
          ft.actQueue !== null ? mm() : pg();
          break;
        } catch (lt) {
          ph(t, lt);
        }
      while (!0);
      return Tr(), ft.H = f, ft.A = p, Ie = a, ke !== null ? (jt !== null && typeof jt.markRenderYielded == "function" && jt.markRenderYielded(), ac) : (Za(), mn = null, Ne = 0, _r(), Kn);
    }
    function pg() {
      for (; ke !== null && !e_(); )
        gg(ke);
    }
    function gg(t) {
      var e = t.alternate;
      (t.mode & ca) !== bn ? (xc(t), e = Vt(
        t,
        am,
        e,
        t,
        nu
      ), Sa(t)) : e = Vt(
        t,
        am,
        e,
        t,
        nu
      ), t.memoizedProps = t.pendingProps, e === null ? gh(t) : ke = e;
    }
    function pm(t) {
      var e = Vt(t, gm, t);
      t.memoizedProps = t.pendingProps, e === null ? gh(t) : ke = e;
    }
    function gm(t) {
      var e = t.alternate, a = (t.mode & ca) !== bn;
      switch (a && xc(t), t.tag) {
        case 15:
        case 0:
          e = Qp(
            e,
            t,
            t.pendingProps,
            t.type,
            void 0,
            Ne
          );
          break;
        case 11:
          e = Qp(
            e,
            t,
            t.pendingProps,
            t.type.render,
            t.ref,
            Ne
          );
          break;
        case 5:
          H(t);
        default:
          $p(e, t), t = ke = Bf(t, nu), e = am(e, t, nu);
      }
      return a && Sa(t), e;
    }
    function Ur(t, e, a, f) {
      Tr(), H(e), pp = null, Ay = 0;
      var p = e.return;
      try {
        if (nh(
          t,
          p,
          e,
          a,
          Ne
        )) {
          Kn = zy, Cc(
            t,
            ji(a, t.current)
          ), ke = null;
          return;
        }
      } catch (y) {
        if (p !== null) throw ke = p, y;
        Kn = zy, Cc(
          t,
          ji(a, t.current)
        ), ke = null;
        return;
      }
      e.flags & 32768 ? (Ve || f === Ly ? t = !0 : wp || (Ne & 536870912) !== 0 ? t = !1 : (df = t = !0, (f === Ih || f === $h || f === Hy || f === xp) && (f = ms.current, f !== null && f.tag === 13 && (f.flags |= 16384))), ym(e, t)) : gh(e);
    }
    function gh(t) {
      var e = t;
      do {
        if ((e.flags & 32768) !== 0) {
          ym(
            e,
            df
          );
          return;
        }
        var a = e.alternate;
        if (t = e.return, xc(e), a = Vt(
          e,
          Rv,
          a,
          e,
          nu
        ), (e.mode & ca) !== bn && ks(e), a !== null) {
          ke = a;
          return;
        }
        if (e = e.sibling, e !== null) {
          ke = e;
          return;
        }
        ke = e = t;
      } while (e !== null);
      Kn === ac && (Kn = nT);
    }
    function ym(t, e) {
      do {
        var a = Cv(t.alternate, t);
        if (a !== null) {
          a.flags &= 32767, ke = a;
          return;
        }
        if ((t.mode & ca) !== bn) {
          ks(t), a = t.actualDuration;
          for (var f = t.child; f !== null; )
            a += f.actualDuration, f = f.sibling;
          t.actualDuration = a;
        }
        if (a = t.return, a !== null && (a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null), !e && (t = t.sibling, t !== null)) {
          ke = t;
          return;
        }
        ke = t = a;
      } while (t !== null);
      Kn = O_, ke = null;
    }
    function vm(t, e, a, f, p, y, M, D, B) {
      t.cancelPendingCommit = null;
      do
        Nc();
      while (ha !== td);
      if (ir.flushLegacyContextWarning(), ir.flushPendingUnsafeLifecycleWarnings(), (Ie & (ho | lr)) !== yl)
        throw Error("Should not already be working.");
      if (jt !== null && typeof jt.markCommitStarted == "function" && jt.markCommitStarted(a), e === null) $t();
      else {
        if (a === 0 && console.error(
          "finishedLanes should not be empty during a commit. This is a bug in React."
        ), e === t.current)
          throw Error(
            "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
          );
        if (y = e.lanes | e.childLanes, y |= F0, mc(
          t,
          a,
          y,
          M,
          D,
          B
        ), t === mn && (ke = mn = null, Ne = 0), Mp = e, yf = t, vf = a, Ob = y, Ab = p, uT = f, (e.subtreeFlags & 10256) !== 0 || (e.flags & 10256) !== 0 ? (t.callbackNode = null, t.callbackPriority = 0, bg(tf, function() {
          return yh(), null;
        })) : (t.callbackNode = null, t.callbackPriority = 0), g_ = cp(), f = (e.flags & 13878) !== 0, (e.subtreeFlags & 13878) !== 0 || f) {
          f = ft.T, ft.T = null, p = re.p, re.p = Ni, M = Ie, Ie |= lr;
          try {
            sm(t, e, a);
          } finally {
            Ie = M, re.p = p, ft.T = f;
          }
        }
        ha = lT, Ql(), _m(), Yv();
      }
    }
    function Ql() {
      if (ha === lT) {
        ha = td;
        var t = yf, e = Mp, a = vf, f = (e.flags & 13878) !== 0;
        if ((e.subtreeFlags & 13878) !== 0 || f) {
          f = ft.T, ft.T = null;
          var p = re.p;
          re.p = Ni;
          var y = Ie;
          Ie |= lr;
          try {
            bp = a, Sp = t, rg(e, t), Sp = bp = null, a = Yb;
            var M = kf(t.containerInfo), D = a.focusedElem, B = a.selectionRange;
            if (M !== D && D && D.ownerDocument && Od(
              D.ownerDocument.documentElement,
              D
            )) {
              if (B !== null && wo(D)) {
                var Y = B.start, lt = B.end;
                if (lt === void 0 && (lt = Y), "selectionStart" in D)
                  D.selectionStart = Y, D.selectionEnd = Math.min(
                    lt,
                    D.value.length
                  );
                else {
                  var mt = D.ownerDocument || document, at = mt && mt.defaultView || window;
                  if (at.getSelection) {
                    var pt = at.getSelection(), Qt = D.textContent.length, ue = Math.min(
                      B.start,
                      Qt
                    ), pn = B.end === void 0 ? ue : Math.min(B.end, Qt);
                    !pt.extend && ue > pn && (M = pn, pn = ue, ue = M);
                    var Be = _a(
                      D,
                      ue
                    ), V = _a(
                      D,
                      pn
                    );
                    if (Be && V && (pt.rangeCount !== 1 || pt.anchorNode !== Be.node || pt.anchorOffset !== Be.offset || pt.focusNode !== V.node || pt.focusOffset !== V.offset)) {
                      var G = mt.createRange();
                      G.setStart(Be.node, Be.offset), pt.removeAllRanges(), ue > pn ? (pt.addRange(G), pt.extend(V.node, V.offset)) : (G.setEnd(V.node, V.offset), pt.addRange(G));
                    }
                  }
                }
              }
              for (mt = [], pt = D; pt = pt.parentNode; )
                pt.nodeType === 1 && mt.push({
                  element: pt,
                  left: pt.scrollLeft,
                  top: pt.scrollTop
                });
              for (typeof D.focus == "function" && D.focus(), D = 0; D < mt.length; D++) {
                var K = mt[D];
                K.element.scrollLeft = K.left, K.element.scrollTop = K.top;
              }
            }
            G_ = !!Bb, Yb = Bb = null;
          } finally {
            Ie = y, re.p = p, ft.T = f;
          }
        }
        t.current = e, ha = sT;
      }
    }
    function _m() {
      if (ha === sT) {
        ha = td;
        var t = yf, e = Mp, a = vf, f = (e.flags & 8772) !== 0;
        if ((e.subtreeFlags & 8772) !== 0 || f) {
          f = ft.T, ft.T = null;
          var p = re.p;
          re.p = Ni;
          var y = Ie;
          Ie |= lr;
          try {
            jt !== null && typeof jt.markLayoutEffectsStarted == "function" && jt.markLayoutEffectsStarted(a), bp = a, Sp = t, lg(
              t,
              e.alternate,
              e
            ), Sp = bp = null, jt !== null && typeof jt.markLayoutEffectsStopped == "function" && jt.markLayoutEffectsStopped();
          } finally {
            Ie = y, re.p = p, ft.T = f;
          }
        }
        ha = rT;
      }
    }
    function Yv() {
      if (ha === yE || ha === rT) {
        ha = td, Z0();
        var t = yf, e = Mp, a = vf, f = uT, p = (e.subtreeFlags & 10256) !== 0 || (e.flags & 10256) !== 0;
        p ? ha = Eb : (ha = td, Mp = yf = null, Kl(t, t.pendingLanes), ed = 0, Yy = null);
        var y = t.pendingLanes;
        if (y === 0 && (gf = null), p || Bc(t), p = _s(a), e = e.stateNode, ki && typeof ki.onCommitFiberRoot == "function")
          try {
            var M = (e.current.flags & 128) === 128;
            switch (p) {
              case Ni:
                var D = Zm;
                break;
              case gl:
                D = Lh;
                break;
              case Fs:
                D = tf;
                break;
              case Xm:
                D = Hh;
                break;
              default:
                D = tf;
            }
            ki.onCommitFiberRoot(
              Qr,
              e,
              D,
              M
            );
          } catch (mt) {
            Ha || (Ha = !0, console.error(
              "React instrumentation encountered an error: %s",
              mt
            ));
          }
        if (kn && t.memoizedUpdaters.clear(), fg(), f !== null) {
          M = ft.T, D = re.p, re.p = Ni, ft.T = null;
          try {
            var B = t.onRecoverableError;
            for (e = 0; e < f.length; e++) {
              var Y = f[e], lt = jv(Y.stack);
              Vt(
                Y.source,
                B,
                Y.value,
                lt
              );
            }
          } finally {
            ft.T = M, re.p = D;
          }
        }
        (vf & 3) !== 0 && Nc(), Bo(t), y = t.pendingLanes, (a & 4194090) !== 0 && (y & 42) !== 0 ? (v_ = !0, t === Db ? By++ : (By = 0, Db = t)) : By = 0, Bu(0), $t();
      }
    }
    function jv(t) {
      return t = { componentStack: t }, Object.defineProperty(t, "digest", {
        get: function() {
          console.error(
            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
          );
        }
      }), t;
    }
    function Kl(t, e) {
      (t.pooledCacheLanes &= e) === 0 && (e = t.pooledCache, e != null && (t.pooledCache = null, Di(e)));
    }
    function Nc(t) {
      return Ql(), _m(), Yv(), yh();
    }
    function yh() {
      if (ha !== Eb) return !1;
      var t = yf, e = Ob;
      Ob = 0;
      var a = _s(vf), f = Fs > a ? Fs : a;
      a = ft.T;
      var p = re.p;
      try {
        re.p = f, ft.T = null, f = Ab, Ab = null;
        var y = yf, M = vf;
        if (ha = td, Mp = yf = null, vf = 0, (Ie & (ho | lr)) !== yl)
          throw Error("Cannot flush passive effects while already rendering.");
        Rb = !0, R_ = !1, jt !== null && typeof jt.markPassiveEffectsStarted == "function" && jt.markPassiveEffectsStarted(M);
        var D = Ie;
        if (Ie |= lr, ug(y.current), fh(
          y,
          y.current,
          M,
          f
        ), jt !== null && typeof jt.markPassiveEffectsStopped == "function" && jt.markPassiveEffectsStopped(), Bc(y), Ie = D, Bu(0, !1), R_ ? y === Yy ? ed++ : (ed = 0, Yy = y) : ed = 0, R_ = Rb = !1, ki && typeof ki.onPostCommitFiberRoot == "function")
          try {
            ki.onPostCommitFiberRoot(Qr, y);
          } catch (Y) {
            Ha || (Ha = !0, console.error(
              "React instrumentation encountered an error: %s",
              Y
            ));
          }
        var B = y.current.stateNode;
        return B.effectDuration = 0, B.passiveEffectDuration = 0, !0;
      } finally {
        re.p = p, ft.T = a, Kl(t, e);
      }
    }
    function Uc(t, e, a) {
      e = ji(a, e), e = Gi(t.stateNode, e, 2), t = wa(t, e, 2), t !== null && (po(t, 2), Bo(t));
    }
    function ie(t, e, a) {
      if (Ep = !1, t.tag === 3)
        Uc(t, t, a);
      else {
        for (; e !== null; ) {
          if (e.tag === 3) {
            Uc(
              e,
              t,
              a
            );
            return;
          }
          if (e.tag === 1) {
            var f = e.stateNode;
            if (typeof e.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (gf === null || !gf.has(f))) {
              t = ji(a, t), a = Dn(2), f = wa(e, a, 2), f !== null && (eh(
                a,
                f,
                e,
                t
              ), po(f, 2), Bo(f));
              return;
            }
          }
          e = e.return;
        }
        console.error(
          `Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,
          a
        );
      }
    }
    function yg(t, e, a) {
      var f = t.pingCache;
      if (f === null) {
        f = t.pingCache = new dE();
        var p = /* @__PURE__ */ new Set();
        f.set(e, p);
      } else
        p = f.get(e), p === void 0 && (p = /* @__PURE__ */ new Set(), f.set(e, p));
      p.has(a) || (xb = !0, p.add(a), f = k0.bind(null, t, e, a), kn && Yc(t, a), e.then(f, f));
    }
    function k0(t, e, a) {
      var f = t.pingCache;
      f !== null && f.delete(e), t.pingedLanes |= t.suspendedLanes & a, t.warmLanes &= ~a, hg() && ft.actQueue === null && console.error(
        `A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`
      ), mn === t && (Ne & a) === a && (Kn === Jh || Kn === bb && (Ne & 62914560) === Ne && is() - Mb < aT ? (Ie & ho) === yl && Uu(t, 0) : wb |= a, Fh === Ne && (Fh = 0)), Bo(t);
    }
    function vg(t, e) {
      e === 0 && (e = pa()), t = mi(t, e), t !== null && (po(t, e), Bo(t));
    }
    function vh(t) {
      var e = t.memoizedState, a = 0;
      e !== null && (a = e.retryLane), vg(t, a);
    }
    function Br(t, e) {
      var a = 0;
      switch (t.tag) {
        case 13:
          var f = t.stateNode, p = t.memoizedState;
          p !== null && (a = p.retryLane);
          break;
        case 19:
          f = t.stateNode;
          break;
        case 22:
          f = t.stateNode._retryCache;
          break;
        default:
          throw Error(
            "Pinged unknown suspense boundary type. This is probably a bug in React."
          );
      }
      f !== null && f.delete(e), vg(t, a);
    }
    function bm(t, e, a) {
      if ((e.subtreeFlags & 67117056) !== 0)
        for (e = e.child; e !== null; ) {
          var f = t, p = e, y = p.type === Wc;
          y = a || y, p.tag !== 22 ? p.flags & 67108864 ? y && Vt(
            p,
            _g,
            f,
            p,
            (p.mode & tS) === bn
          ) : bm(
            f,
            p,
            y
          ) : p.memoizedState === null && (y && p.flags & 8192 ? Vt(
            p,
            _g,
            f,
            p
          ) : p.subtreeFlags & 67108864 && Vt(
            p,
            bm,
            f,
            p,
            y
          )), e = e.sibling;
        }
    }
    function _g(t, e) {
      var a = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : !0;
      Tt(!0);
      try {
        ao(e), a && mh(e), Vs(t, e.alternate, e, !1), a && um(t, e, 0, null, !1, 0);
      } finally {
        Tt(!1);
      }
    }
    function Bc(t) {
      var e = !0;
      t.current.mode & (Ua | nr) || (e = !1), bm(
        t,
        t.current,
        e
      );
    }
    function ml(t) {
      if ((Ie & ho) === yl) {
        var e = t.tag;
        if (e === 3 || e === 1 || e === 0 || e === 11 || e === 14 || e === 15) {
          if (e = Mt(t) || "ReactComponent", C_ !== null) {
            if (C_.has(e)) return;
            C_.add(e);
          } else C_ = /* @__PURE__ */ new Set([e]);
          Vt(t, function() {
            console.error(
              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
            );
          });
        }
      }
    }
    function Yc(t, e) {
      kn && t.memoizedUpdaters.forEach(function(a) {
        ta(t, a, e);
      });
    }
    function bg(t, e) {
      var a = ft.actQueue;
      return a !== null ? (a.push(e), bE) : qm(t, e);
    }
    function qv(t) {
      hg() && ft.actQueue === null && Vt(t, function() {
        console.error(
          `An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`,
          Mt(t)
        );
      });
    }
    function Bo(t) {
      t !== Op && t.next === null && (Op === null ? z_ = Op = t : Op = Op.next = t), L_ = !0, ft.actQueue !== null ? zb || (zb = !0, ai()) : Cb || (Cb = !0, ai());
    }
    function Bu(t, e) {
      if (!Lb && L_) {
        Lb = !0;
        do
          for (var a = !1, f = z_; f !== null; ) {
            if (t !== 0) {
              var p = f.pendingLanes;
              if (p === 0) var y = 0;
              else {
                var M = f.suspendedLanes, D = f.pingedLanes;
                y = (1 << 31 - Ki(42 | t) + 1) - 1, y &= p & ~(M & ~D), y = y & 201326741 ? y & 201326741 | 1 : y ? y | 2 : 0;
              }
              y !== 0 && (a = !0, xm(f, y));
            } else
              y = Ne, y = En(
                f,
                f === mn ? y : 0,
                f.cancelPendingCommit !== null || f.timeoutHandle !== ad
              ), (y & 3) === 0 || Va(f, y) || (a = !0, xm(f, y));
            f = f.next;
          }
        while (a);
        Lb = !1;
      }
    }
    function Sm() {
      Tm();
    }
    function Tm() {
      L_ = zb = Cb = !1;
      var t = 0;
      nd !== 0 && (jc() && (t = nd), nd = 0);
      for (var e = is(), a = null, f = z_; f !== null; ) {
        var p = f.next, y = Wl(f, e);
        y === 0 ? (f.next = null, a === null ? z_ = p : a.next = p, p === null && (Op = a)) : (a = f, (t !== 0 || (y & 3) !== 0) && (L_ = !0)), f = p;
      }
      Bu(t);
    }
    function Wl(t, e) {
      for (var a = t.suspendedLanes, f = t.pingedLanes, p = t.expirationTimes, y = t.pendingLanes & -62914561; 0 < y; ) {
        var M = 31 - Ki(y), D = 1 << M, B = p[M];
        B === -1 ? ((D & a) === 0 || (D & f) !== 0) && (p[M] = dc(D, e)) : B <= e && (t.expiredLanes |= D), y &= ~D;
      }
      if (e = mn, a = Ne, a = En(
        t,
        t === e ? a : 0,
        t.cancelPendingCommit !== null || t.timeoutHandle !== ad
      ), f = t.callbackNode, a === 0 || t === e && (an === Ih || an === $h) || t.cancelPendingCommit !== null)
        return f !== null && wm(f), t.callbackNode = null, t.callbackPriority = 0;
      if ((a & 3) === 0 || Va(t, a)) {
        if (e = a & -a, e !== t.callbackPriority || ft.actQueue !== null && f !== Hb)
          wm(f);
        else return e;
        switch (_s(a)) {
          case Ni:
          case gl:
            a = Lh;
            break;
          case Fs:
            a = tf;
            break;
          case Xm:
            a = Hh;
            break;
          default:
            a = tf;
        }
        return f = Cn.bind(null, t), ft.actQueue !== null ? (ft.actQueue.push(f), a = Hb) : a = qm(a, f), t.callbackPriority = e, t.callbackNode = a, e;
      }
      return f !== null && wm(f), t.callbackPriority = 2, t.callbackNode = null, 2;
    }
    function Cn(t, e) {
      if (v_ = y_ = !1, ha !== td && ha !== Eb)
        return t.callbackNode = null, t.callbackPriority = 0, null;
      var a = t.callbackNode;
      if (Nc() && t.callbackNode !== a)
        return null;
      var f = Ne;
      return f = En(
        t,
        t === mn ? f : 0,
        t.cancelPendingCommit !== null || t.timeoutHandle !== ad
      ), f === 0 ? null : (ii(
        t,
        f,
        e
      ), Wl(t, is()), t.callbackNode != null && t.callbackNode === a ? Cn.bind(null, t) : null);
    }
    function xm(t, e) {
      if (Nc()) return null;
      y_ = v_, v_ = !1, ii(t, e, !0);
    }
    function wm(t) {
      t !== Hb && t !== null && q0(t);
    }
    function ai() {
      ft.actQueue !== null && ft.actQueue.push(function() {
        return Tm(), null;
      }), RE(function() {
        (Ie & (ho | lr)) !== yl ? qm(
          Zm,
          Sm
        ) : Tm();
      });
    }
    function Sg() {
      return nd === 0 && (nd = pe()), nd;
    }
    function Tg(t) {
      return t == null || typeof t == "symbol" || typeof t == "boolean" ? null : typeof t == "function" ? t : (ct(t, "action"), Ai("" + t));
    }
    function xg(t, e) {
      var a = e.ownerDocument.createElement("input");
      return a.name = e.name, a.value = e.value, t.id && a.setAttribute("form", t.id), e.parentNode.insertBefore(a, e), t = new FormData(t), a.parentNode.removeChild(a), t;
    }
    function vn(t, e, a, f, p) {
      if (e === "submit" && a && a.stateNode === p) {
        var y = Tg(
          (p[ka] || null).action
        ), M = f.submitter;
        M && (e = (e = M[ka] || null) ? Tg(e.formAction) : M.getAttribute("formAction"), e !== null && (y = e, M = null));
        var D = new te(
          "action",
          "action",
          null,
          f,
          p
        );
        t.push({
          event: D,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (f.defaultPrevented) {
                  if (nd !== 0) {
                    var B = M ? xg(
                      p,
                      M
                    ) : new FormData(p), Y = {
                      pending: !0,
                      data: B,
                      method: p.method,
                      action: y
                    };
                    Object.freeze(Y), Mu(
                      a,
                      Y,
                      null,
                      B
                    );
                  }
                } else
                  typeof y == "function" && (D.preventDefault(), B = M ? xg(
                    p,
                    M
                  ) : new FormData(p), Y = {
                    pending: !0,
                    data: B,
                    method: p.method,
                    action: y
                  }, Object.freeze(Y), Mu(
                    a,
                    Y,
                    y,
                    B
                  ));
              },
              currentTarget: p
            }
          ]
        });
      }
    }
    function Ci(t, e, a) {
      t.currentTarget = a;
      try {
        e(t);
      } catch (f) {
        pb(f);
      }
      t.currentTarget = null;
    }
    function Jl(t, e) {
      e = (e & 4) !== 0;
      for (var a = 0; a < t.length; a++) {
        var f = t[a];
        t: {
          var p = void 0, y = f.event;
          if (f = f.listeners, e)
            for (var M = f.length - 1; 0 <= M; M--) {
              var D = f[M], B = D.instance, Y = D.currentTarget;
              if (D = D.listener, B !== p && y.isPropagationStopped())
                break t;
              B !== null ? Vt(
                B,
                Ci,
                y,
                D,
                Y
              ) : Ci(y, D, Y), p = B;
            }
          else
            for (M = 0; M < f.length; M++) {
              if (D = f[M], B = D.instance, Y = D.currentTarget, D = D.listener, B !== p && y.isPropagationStopped())
                break t;
              B !== null ? Vt(
                B,
                Ci,
                y,
                D,
                Y
              ) : Ci(y, D, Y), p = B;
            }
        }
      }
    }
    function Ce(t, e) {
      kb.has(t) || console.error(
        'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
        t
      );
      var a = e[Jg];
      a === void 0 && (a = e[Jg] = /* @__PURE__ */ new Set());
      var f = t + "__bubble";
      a.has(f) || (Em(e, t, 2, !1), a.add(f));
    }
    function Mm(t, e, a) {
      kb.has(t) && !e && console.error(
        'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
        t
      );
      var f = 0;
      e && (f |= 4), Em(
        a,
        t,
        f,
        e
      );
    }
    function wg(t) {
      if (!t[H_]) {
        t[H_] = !0, i_.forEach(function(a) {
          a !== "selectionchange" && (kb.has(a) || Mm(a, !1, t), Mm(a, !0, t));
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[H_] || (e[H_] = !0, Mm("selectionchange", !1, e));
      }
    }
    function Em(t, e, a, f) {
      switch (Um(e)) {
        case Ni:
          var p = B0;
          break;
        case gl:
          p = Nm;
          break;
        default:
          p = Zr;
      }
      a = p.bind(
        null,
        e,
        a,
        t
      ), p = void 0, !it || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (p = !0), f ? p !== void 0 ? t.addEventListener(e, a, {
        capture: !0,
        passive: p
      }) : t.addEventListener(e, a, !0) : p !== void 0 ? t.addEventListener(e, a, {
        passive: p
      }) : t.addEventListener(
        e,
        a,
        !1
      );
    }
    function la(t, e, a, f, p) {
      var y = f;
      if ((e & 1) === 0 && (e & 2) === 0 && f !== null)
        t: for (; ; ) {
          if (f === null) return;
          var M = f.tag;
          if (M === 3 || M === 4) {
            var D = f.stateNode.containerInfo;
            if (D === p) break;
            if (M === 4)
              for (M = f.return; M !== null; ) {
                var B = M.tag;
                if ((B === 3 || B === 4) && M.stateNode.containerInfo === p)
                  return;
                M = M.return;
              }
            for (; D !== null; ) {
              if (M = fi(D), M === null) return;
              if (B = M.tag, B === 5 || B === 6 || B === 26 || B === 27) {
                f = y = M;
                continue t;
              }
              D = D.parentNode;
            }
          }
          f = f.return;
        }
      vr(function() {
        var Y = y, lt = Ye(a), mt = [];
        t: {
          var at = F1.get(t);
          if (at !== void 0) {
            var pt = te, Qt = t;
            switch (t) {
              case "keypress":
                if (va(a) === 0) break t;
              case "keydown":
              case "keyup":
                pt = UM;
                break;
              case "focusin":
                Qt = "focus", pt = je;
                break;
              case "focusout":
                Qt = "blur", pt = je;
                break;
              case "beforeblur":
              case "afterblur":
                pt = je;
                break;
              case "click":
                if (a.button === 2) break t;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                pt = Ae;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                pt = ae;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                pt = jM;
                break;
              case W1:
              case J1:
              case I1:
                pt = X0;
                break;
              case $1:
                pt = ZM;
                break;
              case "scroll":
              case "scrollend":
                pt = tt;
                break;
              case "wheel":
                pt = PM;
                break;
              case "copy":
              case "cut":
              case "paste":
                pt = RM;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                pt = q1;
                break;
              case "toggle":
              case "beforetoggle":
                pt = XM;
            }
            var ue = (e & 4) !== 0, pn = !ue && (t === "scroll" || t === "scrollend"), Be = ue ? at !== null ? at + "Capture" : null : at;
            ue = [];
            for (var V = Y, G; V !== null; ) {
              var K = V;
              if (G = K.stateNode, K = K.tag, K !== 5 && K !== 26 && K !== 27 || G === null || Be === null || (K = Qa(V, Be), K != null && ue.push(
                sa(
                  V,
                  K,
                  G
                )
              )), pn) break;
              V = V.return;
            }
            0 < ue.length && (at = new pt(
              at,
              Qt,
              null,
              a,
              lt
            ), mt.push({
              event: at,
              listeners: ue
            }));
          }
        }
        if ((e & 7) === 0) {
          t: {
            if (at = t === "mouseover" || t === "pointerover", pt = t === "mouseout" || t === "pointerout", at && a !== b && (Qt = a.relatedTarget || a.fromElement) && (fi(Qt) || Qt[Wr]))
              break t;
            if ((pt || at) && (at = lt.window === lt ? lt : (at = lt.ownerDocument) ? at.defaultView || at.parentWindow : window, pt ? (Qt = a.relatedTarget || a.toElement, pt = Y, Qt = Qt ? fi(Qt) : null, Qt !== null && (pn = et(Qt), ue = Qt.tag, Qt !== pn || ue !== 5 && ue !== 27 && ue !== 6) && (Qt = null)) : (pt = null, Qt = Y), pt !== Qt)) {
              if (ue = Ae, K = "onMouseLeave", Be = "onMouseEnter", V = "mouse", (t === "pointerout" || t === "pointerover") && (ue = q1, K = "onPointerLeave", Be = "onPointerEnter", V = "pointer"), pn = pt == null ? at : Pa(pt), G = Qt == null ? at : Pa(Qt), at = new ue(
                K,
                V + "leave",
                pt,
                a,
                lt
              ), at.target = pn, at.relatedTarget = G, K = null, fi(lt) === Y && (ue = new ue(
                Be,
                V + "enter",
                Qt,
                a,
                lt
              ), ue.target = G, ue.relatedTarget = pn, K = ue), pn = K, pt && Qt)
                e: {
                  for (ue = pt, Be = Qt, V = 0, G = ue; G; G = bi(G))
                    V++;
                  for (G = 0, K = Be; K; K = bi(K))
                    G++;
                  for (; 0 < V - G; )
                    ue = bi(ue), V--;
                  for (; 0 < G - V; )
                    Be = bi(Be), G--;
                  for (; V--; ) {
                    if (ue === Be || Be !== null && ue === Be.alternate)
                      break e;
                    ue = bi(ue), Be = bi(Be);
                  }
                  ue = null;
                }
              else ue = null;
              pt !== null && Mg(
                mt,
                at,
                pt,
                ue,
                !1
              ), Qt !== null && pn !== null && Mg(
                mt,
                pn,
                Qt,
                ue,
                !0
              );
            }
          }
          t: {
            if (at = Y ? Pa(Y) : window, pt = at.nodeName && at.nodeName.toLowerCase(), pt === "select" || pt === "input" && at.type === "file")
              var gt = Os;
            else if (xd(at))
              if (Q1)
                gt = Up;
              else {
                gt = Hf;
                var Ut = Lf;
              }
            else
              pt = at.nodeName, !pt || pt.toLowerCase() !== "input" || at.type !== "checkbox" && at.type !== "radio" ? Y && tl(Y.elementType) && (gt = Os) : gt = Md;
            if (gt && (gt = gt(t, Y))) {
              Oe(
                mt,
                gt,
                a,
                lt
              );
              break t;
            }
            Ut && Ut(t, at, Y), t === "focusout" && Y && at.type === "number" && Y.memoizedProps.value != null && bs(at, "number", at.value);
          }
          switch (Ut = Y ? Pa(Y) : window, t) {
            case "focusin":
              (xd(Ut) || Ut.contentEditable === "true") && (np = Ut, K0 = Y, gy = null);
              break;
            case "focusout":
              gy = K0 = np = null;
              break;
            case "mousedown":
              W0 = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              W0 = !1, Nf(
                mt,
                a,
                lt
              );
              break;
            case "selectionchange":
              if (JM) break;
            case "keydown":
            case "keyup":
              Nf(
                mt,
                a,
                lt
              );
          }
          var be;
          if (Q0)
            t: {
              switch (t) {
                case "compositionstart":
                  var Kt = "onCompositionStart";
                  break t;
                case "compositionend":
                  Kt = "onCompositionEnd";
                  break t;
                case "compositionupdate":
                  Kt = "onCompositionUpdate";
                  break t;
              }
              Kt = void 0;
            }
          else
            ep ? di(t, a) && (Kt = "onCompositionEnd") : t === "keydown" && a.keyCode === Z1 && (Kt = "onCompositionStart");
          Kt && (V1 && a.locale !== "ko" && (ep || Kt !== "onCompositionStart" ? Kt === "onCompositionEnd" && ep && (be = Ka()) : (St = lt, ot = "value" in St ? St.value : St.textContent, ep = !0)), Ut = _h(
            Y,
            Kt
          ), 0 < Ut.length && (Kt = new j1(
            Kt,
            t,
            null,
            a,
            lt
          ), mt.push({
            event: Kt,
            listeners: Ut
          }), be ? Kt.data = be : (be = El(a), be !== null && (Kt.data = be)))), (be = KM ? _u(t, a) : Es(t, a)) && (Kt = _h(
            Y,
            "onBeforeInput"
          ), 0 < Kt.length && (Ut = new zM(
            "onBeforeInput",
            "beforeinput",
            null,
            a,
            lt
          ), mt.push({
            event: Ut,
            listeners: Kt
          }), Ut.data = be)), vn(
            mt,
            t,
            Y,
            a,
            lt
          );
        }
        Jl(mt, e);
      });
    }
    function sa(t, e, a) {
      return {
        instance: t,
        listener: e,
        currentTarget: a
      };
    }
    function _h(t, e) {
      for (var a = e + "Capture", f = []; t !== null; ) {
        var p = t, y = p.stateNode;
        if (p = p.tag, p !== 5 && p !== 26 && p !== 27 || y === null || (p = Qa(t, a), p != null && f.unshift(
          sa(t, p, y)
        ), p = Qa(t, e), p != null && f.push(
          sa(t, p, y)
        )), t.tag === 3) return f;
        t = t.return;
      }
      return [];
    }
    function bi(t) {
      if (t === null) return null;
      do
        t = t.return;
      while (t && t.tag !== 5 && t.tag !== 27);
      return t || null;
    }
    function Mg(t, e, a, f, p) {
      for (var y = e._reactName, M = []; a !== null && a !== f; ) {
        var D = a, B = D.alternate, Y = D.stateNode;
        if (D = D.tag, B !== null && B === f) break;
        D !== 5 && D !== 26 && D !== 27 || Y === null || (B = Y, p ? (Y = Qa(a, y), Y != null && M.unshift(
          sa(a, Y, B)
        )) : p || (Y = Qa(a, y), Y != null && M.push(
          sa(a, Y, B)
        ))), a = a.return;
      }
      M.length !== 0 && t.push({ event: e, listeners: M });
    }
    function Il(t, e) {
      Ml(t, e), t !== "input" && t !== "textarea" && t !== "select" || e == null || e.value !== null || hy || (hy = !0, t === "select" && e.multiple ? console.error(
        "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
        t
      ) : console.error(
        "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
        t
      ));
      var a = {
        registrationNameDependencies: Vo,
        possibleRegistrationNames: Qu
      };
      tl(t) || typeof e.is == "string" || ce(t, e, a), e.contentEditable && !e.suppressContentEditableWarning && e.children != null && console.error(
        "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
      );
    }
    function _n(t, e, a, f) {
      e !== a && (a = zi(a), zi(e) !== a && (f[t] = e));
    }
    function Yr(t, e, a) {
      e.forEach(function(f) {
        a[Og(f)] = f === "style" ? ju(t) : t.getAttribute(f);
      });
    }
    function Yo(t, e) {
      e === !1 ? console.error(
        "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
        t,
        t,
        t
      ) : console.error(
        "Expected `%s` listener to be a function, instead got a value of `%s` type.",
        t,
        typeof e
      );
    }
    function Om(t, e) {
      return t = t.namespaceURI === qh || t.namespaceURI === rf ? t.ownerDocument.createElementNS(
        t.namespaceURI,
        t.tagName
      ) : t.ownerDocument.createElement(t.tagName), t.innerHTML = e, t.innerHTML;
    }
    function zi(t) {
      return k(t) && (console.error(
        "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
        Gt(t)
      ), F(t)), (typeof t == "string" ? t : "" + t).replace(SE, `
`).replace(TE, "");
    }
    function Eg(t, e) {
      return e = zi(e), zi(t) === e;
    }
    function Gs() {
    }
    function qe(t, e, a, f, p, y) {
      switch (a) {
        case "children":
          typeof f == "string" ? ($o(f, e, !1), e === "body" || e === "textarea" && f === "" || Fo(t, f)) : (typeof f == "number" || typeof f == "bigint") && ($o("" + f, e, !1), e !== "body" && Fo(t, "" + f));
          break;
        case "className":
          fe(t, "class", f);
          break;
        case "tabIndex":
          fe(t, "tabindex", f);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          fe(t, a, f);
          break;
        case "style":
          Ts(t, f, y);
          break;
        case "data":
          if (e !== "object") {
            fe(t, "data", f);
            break;
          }
        case "src":
        case "href":
          if (f === "" && (e !== "a" || a !== "href")) {
            console.error(
              a === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
              a,
              a
            ), t.removeAttribute(a);
            break;
          }
          if (f == null || typeof f == "function" || typeof f == "symbol" || typeof f == "boolean") {
            t.removeAttribute(a);
            break;
          }
          ct(f, a), f = Ai("" + f), t.setAttribute(a, f);
          break;
        case "action":
        case "formAction":
          if (f != null && (e === "form" ? a === "formAction" ? console.error(
            "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
          ) : typeof f == "function" && (p.encType == null && p.method == null || U_ || (U_ = !0, console.error(
            "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
          )), p.target == null || N_ || (N_ = !0, console.error(
            "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
          ))) : e === "input" || e === "button" ? a === "action" ? console.error(
            "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
          ) : e !== "input" || p.type === "submit" || p.type === "image" || k_ ? e !== "button" || p.type == null || p.type === "submit" || k_ ? typeof f == "function" && (p.name == null || mT || (mT = !0, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          )), p.formEncType == null && p.formMethod == null || U_ || (U_ = !0, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          )), p.formTarget == null || N_ || (N_ = !0, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ))) : (k_ = !0, console.error(
            'A button can only specify a formAction along with type="submit" or no type.'
          )) : (k_ = !0, console.error(
            'An input can only specify a formAction along with type="submit" or type="image".'
          )) : console.error(
            a === "action" ? "You can only pass the action prop to <form>." : "You can only pass the formAction prop to <input> or <button>."
          )), typeof f == "function") {
            t.setAttribute(
              a,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof y == "function" && (a === "formAction" ? (e !== "input" && qe(t, e, "name", p.name, p, null), qe(
              t,
              e,
              "formEncType",
              p.formEncType,
              p,
              null
            ), qe(
              t,
              e,
              "formMethod",
              p.formMethod,
              p,
              null
            ), qe(
              t,
              e,
              "formTarget",
              p.formTarget,
              p,
              null
            )) : (qe(
              t,
              e,
              "encType",
              p.encType,
              p,
              null
            ), qe(t, e, "method", p.method, p, null), qe(
              t,
              e,
              "target",
              p.target,
              p,
              null
            )));
          if (f == null || typeof f == "symbol" || typeof f == "boolean") {
            t.removeAttribute(a);
            break;
          }
          ct(f, a), f = Ai("" + f), t.setAttribute(a, f);
          break;
        case "onClick":
          f != null && (typeof f != "function" && Yo(a, f), t.onclick = Gs);
          break;
        case "onScroll":
          f != null && (typeof f != "function" && Yo(a, f), Ce("scroll", t));
          break;
        case "onScrollEnd":
          f != null && (typeof f != "function" && Yo(a, f), Ce("scrollend", t));
          break;
        case "dangerouslySetInnerHTML":
          if (f != null) {
            if (typeof f != "object" || !("__html" in f))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (a = f.__html, a != null) {
              if (p.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              t.innerHTML = a;
            }
          }
          break;
        case "multiple":
          t.multiple = f && typeof f != "function" && typeof f != "symbol";
          break;
        case "muted":
          t.muted = f && typeof f != "function" && typeof f != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (f == null || typeof f == "function" || typeof f == "boolean" || typeof f == "symbol") {
            t.removeAttribute("xlink:href");
            break;
          }
          ct(f, a), a = Ai("" + f), t.setAttributeNS(id, "xlink:href", a);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          f != null && typeof f != "function" && typeof f != "symbol" ? (ct(f, a), t.setAttribute(a, "" + f)) : t.removeAttribute(a);
          break;
        case "inert":
          f !== "" || B_[a] || (B_[a] = !0, console.error(
            "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
            a
          ));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          f && typeof f != "function" && typeof f != "symbol" ? t.setAttribute(a, "") : t.removeAttribute(a);
          break;
        case "capture":
        case "download":
          f === !0 ? t.setAttribute(a, "") : f !== !1 && f != null && typeof f != "function" && typeof f != "symbol" ? (ct(f, a), t.setAttribute(a, f)) : t.removeAttribute(a);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          f != null && typeof f != "function" && typeof f != "symbol" && !isNaN(f) && 1 <= f ? (ct(f, a), t.setAttribute(a, f)) : t.removeAttribute(a);
          break;
        case "rowSpan":
        case "start":
          f == null || typeof f == "function" || typeof f == "symbol" || isNaN(f) ? t.removeAttribute(a) : (ct(f, a), t.setAttribute(a, f));
          break;
        case "popover":
          Ce("beforetoggle", t), Ce("toggle", t), ze(t, "popover", f);
          break;
        case "xlinkActuate":
          On(
            t,
            id,
            "xlink:actuate",
            f
          );
          break;
        case "xlinkArcrole":
          On(
            t,
            id,
            "xlink:arcrole",
            f
          );
          break;
        case "xlinkRole":
          On(
            t,
            id,
            "xlink:role",
            f
          );
          break;
        case "xlinkShow":
          On(
            t,
            id,
            "xlink:show",
            f
          );
          break;
        case "xlinkTitle":
          On(
            t,
            id,
            "xlink:title",
            f
          );
          break;
        case "xlinkType":
          On(
            t,
            id,
            "xlink:type",
            f
          );
          break;
        case "xmlBase":
          On(
            t,
            Nb,
            "xml:base",
            f
          );
          break;
        case "xmlLang":
          On(
            t,
            Nb,
            "xml:lang",
            f
          );
          break;
        case "xmlSpace":
          On(
            t,
            Nb,
            "xml:space",
            f
          );
          break;
        case "is":
          y != null && console.error(
            'Cannot update the "is" prop after it has been initialized.'
          ), ze(t, "is", f);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          pT || f == null || typeof f != "object" || (pT = !0, console.error(
            "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
            f
          ));
        default:
          !(2 < a.length) || a[0] !== "o" && a[0] !== "O" || a[1] !== "n" && a[1] !== "N" ? (a = xs(a), ze(t, a, f)) : Vo.hasOwnProperty(a) && f != null && typeof f != "function" && Yo(a, f);
      }
    }
    function Yu(t, e, a, f, p, y) {
      switch (a) {
        case "style":
          Ts(t, f, y);
          break;
        case "dangerouslySetInnerHTML":
          if (f != null) {
            if (typeof f != "object" || !("__html" in f))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (a = f.__html, a != null) {
              if (p.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              t.innerHTML = a;
            }
          }
          break;
        case "children":
          typeof f == "string" ? Fo(t, f) : (typeof f == "number" || typeof f == "bigint") && Fo(t, "" + f);
          break;
        case "onScroll":
          f != null && (typeof f != "function" && Yo(a, f), Ce("scroll", t));
          break;
        case "onScrollEnd":
          f != null && (typeof f != "function" && Yo(a, f), Ce("scrollend", t));
          break;
        case "onClick":
          f != null && (typeof f != "function" && Yo(a, f), t.onclick = Gs);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (Vo.hasOwnProperty(a))
            f != null && typeof f != "function" && Yo(a, f);
          else
            t: {
              if (a[0] === "o" && a[1] === "n" && (p = a.endsWith("Capture"), e = a.slice(2, p ? a.length - 7 : void 0), y = t[ka] || null, y = y != null ? y[a] : null, typeof y == "function" && t.removeEventListener(e, y, p), typeof f == "function")) {
                typeof y != "function" && y !== null && (a in t ? t[a] = null : t.hasAttribute(a) && t.removeAttribute(a)), t.addEventListener(e, f, p);
                break t;
              }
              a in t ? t[a] = f : f === !0 ? t.setAttribute(a, "") : ze(t, a, f);
            }
      }
    }
    function zn(t, e, a) {
      switch (Il(e, a), e) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          Ce("error", t), Ce("load", t);
          var f = !1, p = !1, y;
          for (y in a)
            if (a.hasOwnProperty(y)) {
              var M = a[y];
              if (M != null)
                switch (y) {
                  case "src":
                    f = !0;
                    break;
                  case "srcSet":
                    p = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    qe(t, e, y, M, a, null);
                }
            }
          p && qe(t, e, "srcSet", a.srcSet, a, null), f && qe(t, e, "src", a.src, a, null);
          return;
        case "input":
          Xt("input", a), Ce("invalid", t);
          var D = y = M = p = null, B = null, Y = null;
          for (f in a)
            if (a.hasOwnProperty(f)) {
              var lt = a[f];
              if (lt != null)
                switch (f) {
                  case "name":
                    p = lt;
                    break;
                  case "type":
                    M = lt;
                    break;
                  case "checked":
                    B = lt;
                    break;
                  case "defaultChecked":
                    Y = lt;
                    break;
                  case "value":
                    y = lt;
                    break;
                  case "defaultValue":
                    D = lt;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (lt != null)
                      throw Error(
                        e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    qe(t, e, f, lt, a, null);
                }
            }
          Sl(t, a), bd(
            t,
            y,
            D,
            B,
            Y,
            M,
            p,
            !1
          ), vo(t);
          return;
        case "select":
          Xt("select", a), Ce("invalid", t), f = M = y = null;
          for (p in a)
            if (a.hasOwnProperty(p) && (D = a[p], D != null))
              switch (p) {
                case "value":
                  y = D;
                  break;
                case "defaultValue":
                  M = D;
                  break;
                case "multiple":
                  f = D;
                default:
                  qe(
                    t,
                    e,
                    p,
                    D,
                    a,
                    null
                  );
              }
          gu(t, a), e = y, a = M, t.multiple = !!f, e != null ? Jo(t, !!f, e, !1) : a != null && Jo(t, !!f, a, !0);
          return;
        case "textarea":
          Xt("textarea", a), Ce("invalid", t), y = p = f = null;
          for (M in a)
            if (a.hasOwnProperty(M) && (D = a[M], D != null))
              switch (M) {
                case "value":
                  f = D;
                  break;
                case "defaultValue":
                  p = D;
                  break;
                case "children":
                  y = D;
                  break;
                case "dangerouslySetInnerHTML":
                  if (D != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  qe(
                    t,
                    e,
                    M,
                    D,
                    a,
                    null
                  );
              }
          _o(t, a), Ss(t, f, p, y), vo(t);
          return;
        case "option":
          Df(t, a);
          for (B in a)
            if (a.hasOwnProperty(B) && (f = a[B], f != null))
              switch (B) {
                case "selected":
                  t.selected = f && typeof f != "function" && typeof f != "symbol";
                  break;
                default:
                  qe(t, e, B, f, a, null);
              }
          return;
        case "dialog":
          Ce("beforetoggle", t), Ce("toggle", t), Ce("cancel", t), Ce("close", t);
          break;
        case "iframe":
        case "object":
          Ce("load", t);
          break;
        case "video":
        case "audio":
          for (f = 0; f < jy.length; f++)
            Ce(jy[f], t);
          break;
        case "image":
          Ce("error", t), Ce("load", t);
          break;
        case "details":
          Ce("toggle", t);
          break;
        case "embed":
        case "source":
        case "link":
          Ce("error", t), Ce("load", t);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (Y in a)
            if (a.hasOwnProperty(Y) && (f = a[Y], f != null))
              switch (Y) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  qe(t, e, Y, f, a, null);
              }
          return;
        default:
          if (tl(e)) {
            for (lt in a)
              a.hasOwnProperty(lt) && (f = a[lt], f !== void 0 && Yu(
                t,
                e,
                lt,
                f,
                a,
                void 0
              ));
            return;
          }
      }
      for (D in a)
        a.hasOwnProperty(D) && (f = a[D], f != null && qe(t, e, D, f, a, null));
    }
    function Zv(t, e, a, f) {
      switch (Il(e, f), e) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var p = null, y = null, M = null, D = null, B = null, Y = null, lt = null;
          for (pt in a) {
            var mt = a[pt];
            if (a.hasOwnProperty(pt) && mt != null)
              switch (pt) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  B = mt;
                default:
                  f.hasOwnProperty(pt) || qe(
                    t,
                    e,
                    pt,
                    null,
                    f,
                    mt
                  );
              }
          }
          for (var at in f) {
            var pt = f[at];
            if (mt = a[at], f.hasOwnProperty(at) && (pt != null || mt != null))
              switch (at) {
                case "type":
                  y = pt;
                  break;
                case "name":
                  p = pt;
                  break;
                case "checked":
                  Y = pt;
                  break;
                case "defaultChecked":
                  lt = pt;
                  break;
                case "value":
                  M = pt;
                  break;
                case "defaultValue":
                  D = pt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (pt != null)
                    throw Error(
                      e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  pt !== mt && qe(
                    t,
                    e,
                    at,
                    pt,
                    f,
                    mt
                  );
              }
          }
          e = a.type === "checkbox" || a.type === "radio" ? a.checked != null : a.value != null, f = f.type === "checkbox" || f.type === "radio" ? f.checked != null : f.value != null, e || !f || dT || (console.error(
            "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), dT = !0), !e || f || hT || (console.error(
            "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), hT = !0), Wo(
            t,
            M,
            D,
            B,
            Y,
            lt,
            y,
            p
          );
          return;
        case "select":
          pt = M = D = at = null;
          for (y in a)
            if (B = a[y], a.hasOwnProperty(y) && B != null)
              switch (y) {
                case "value":
                  break;
                case "multiple":
                  pt = B;
                default:
                  f.hasOwnProperty(y) || qe(
                    t,
                    e,
                    y,
                    null,
                    f,
                    B
                  );
              }
          for (p in f)
            if (y = f[p], B = a[p], f.hasOwnProperty(p) && (y != null || B != null))
              switch (p) {
                case "value":
                  at = y;
                  break;
                case "defaultValue":
                  D = y;
                  break;
                case "multiple":
                  M = y;
                default:
                  y !== B && qe(
                    t,
                    e,
                    p,
                    y,
                    f,
                    B
                  );
              }
          f = D, e = M, a = pt, at != null ? Jo(t, !!e, at, !1) : !!a != !!e && (f != null ? Jo(t, !!e, f, !0) : Jo(t, !!e, e ? [] : "", !1));
          return;
        case "textarea":
          pt = at = null;
          for (D in a)
            if (p = a[D], a.hasOwnProperty(D) && p != null && !f.hasOwnProperty(D))
              switch (D) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  qe(t, e, D, null, f, p);
              }
          for (M in f)
            if (p = f[M], y = a[M], f.hasOwnProperty(M) && (p != null || y != null))
              switch (M) {
                case "value":
                  at = p;
                  break;
                case "defaultValue":
                  pt = p;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (p != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  p !== y && qe(t, e, M, p, f, y);
              }
          pr(t, at, pt);
          return;
        case "option":
          for (var Qt in a)
            if (at = a[Qt], a.hasOwnProperty(Qt) && at != null && !f.hasOwnProperty(Qt))
              switch (Qt) {
                case "selected":
                  t.selected = !1;
                  break;
                default:
                  qe(
                    t,
                    e,
                    Qt,
                    null,
                    f,
                    at
                  );
              }
          for (B in f)
            if (at = f[B], pt = a[B], f.hasOwnProperty(B) && at !== pt && (at != null || pt != null))
              switch (B) {
                case "selected":
                  t.selected = at && typeof at != "function" && typeof at != "symbol";
                  break;
                default:
                  qe(
                    t,
                    e,
                    B,
                    at,
                    f,
                    pt
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var ue in a)
            at = a[ue], a.hasOwnProperty(ue) && at != null && !f.hasOwnProperty(ue) && qe(
              t,
              e,
              ue,
              null,
              f,
              at
            );
          for (Y in f)
            if (at = f[Y], pt = a[Y], f.hasOwnProperty(Y) && at !== pt && (at != null || pt != null))
              switch (Y) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (at != null)
                    throw Error(
                      e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  qe(
                    t,
                    e,
                    Y,
                    at,
                    f,
                    pt
                  );
              }
          return;
        default:
          if (tl(e)) {
            for (var pn in a)
              at = a[pn], a.hasOwnProperty(pn) && at !== void 0 && !f.hasOwnProperty(pn) && Yu(
                t,
                e,
                pn,
                void 0,
                f,
                at
              );
            for (lt in f)
              at = f[lt], pt = a[lt], !f.hasOwnProperty(lt) || at === pt || at === void 0 && pt === void 0 || Yu(
                t,
                e,
                lt,
                at,
                f,
                pt
              );
            return;
          }
      }
      for (var Be in a)
        at = a[Be], a.hasOwnProperty(Be) && at != null && !f.hasOwnProperty(Be) && qe(t, e, Be, null, f, at);
      for (mt in f)
        at = f[mt], pt = a[mt], !f.hasOwnProperty(mt) || at === pt || at == null && pt == null || qe(t, e, mt, at, f, pt);
    }
    function Og(t) {
      switch (t) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return t;
      }
    }
    function ju(t) {
      var e = {};
      t = t.style;
      for (var a = 0; a < t.length; a++) {
        var f = t[a];
        e[f] = t.getPropertyValue(f);
      }
      return e;
    }
    function Ag(t, e, a) {
      if (e != null && typeof e != "object")
        console.error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      else {
        var f, p = f = "", y;
        for (y in e)
          if (e.hasOwnProperty(y)) {
            var M = e[y];
            M != null && typeof M != "boolean" && M !== "" && (y.indexOf("--") === 0 ? (bt(M, y), f += p + y + ":" + ("" + M).trim()) : typeof M != "number" || M === 0 || jh.has(y) ? (bt(M, y), f += p + y.replace(tr, "-$1").toLowerCase().replace(er, "-ms-") + ":" + ("" + M).trim()) : f += p + y.replace(tr, "-$1").toLowerCase().replace(er, "-ms-") + ":" + M + "px", p = ";");
          }
        f = f || null, e = t.getAttribute("style"), e !== f && (f = zi(f), zi(e) !== f && (a.style = ju(t)));
      }
    }
    function ra(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (ct(f, e), t === "" + f)
              return;
        }
      _n(e, t, f, y);
    }
    function Dg(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null) {
        switch (typeof f) {
          case "function":
          case "symbol":
            return;
        }
        if (!f) return;
      } else
        switch (typeof f) {
          case "function":
          case "symbol":
            break;
          default:
            if (f) return;
        }
      _n(e, t, f, y);
    }
    function Rg(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
            break;
          default:
            if (ct(f, a), t === "" + f)
              return;
        }
      _n(e, t, f, y);
    }
    function Vv(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(f)) return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (!isNaN(f) && (ct(f, e), t === "" + f))
              return;
        }
      _n(e, t, f, y);
    }
    function Qe(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (ct(f, e), a = Ai("" + f), t === a)
              return;
        }
      _n(e, t, f, y);
    }
    function sn(t, e, a, f) {
      for (var p = {}, y = /* @__PURE__ */ new Set(), M = t.attributes, D = 0; D < M.length; D++)
        switch (M[D].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            y.add(M[D].name);
        }
      if (tl(e)) {
        for (var B in a)
          if (a.hasOwnProperty(B)) {
            var Y = a[B];
            if (Y != null) {
              if (Vo.hasOwnProperty(B))
                typeof Y != "function" && Yo(B, Y);
              else if (a.suppressHydrationWarning !== !0)
                switch (B) {
                  case "children":
                    typeof Y != "string" && typeof Y != "number" || _n(
                      "children",
                      t.textContent,
                      Y,
                      p
                    );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    M = t.innerHTML, Y = Y ? Y.__html : void 0, Y != null && (Y = Om(t, Y), _n(
                      B,
                      M,
                      Y,
                      p
                    ));
                    continue;
                  case "style":
                    y.delete(B), Ag(t, Y, p);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    y.delete(B.toLowerCase()), console.error(
                      "Assignment to read-only property will result in a no-op: `%s`",
                      B
                    );
                    continue;
                  case "className":
                    y.delete("class"), M = he(
                      t,
                      "class",
                      Y
                    ), _n(
                      "className",
                      M,
                      Y,
                      p
                    );
                    continue;
                  default:
                    f.context === lc && e !== "svg" && e !== "math" ? y.delete(B.toLowerCase()) : y.delete(B), M = he(
                      t,
                      B,
                      Y
                    ), _n(
                      B,
                      M,
                      Y,
                      p
                    );
                }
            }
          }
      } else
        for (Y in a)
          if (a.hasOwnProperty(Y) && (B = a[Y], B != null)) {
            if (Vo.hasOwnProperty(Y))
              typeof B != "function" && Yo(Y, B);
            else if (a.suppressHydrationWarning !== !0)
              switch (Y) {
                case "children":
                  typeof B != "string" && typeof B != "number" || _n(
                    "children",
                    t.textContent,
                    B,
                    p
                  );
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  M = t.innerHTML, B = B ? B.__html : void 0, B != null && (B = Om(t, B), M !== B && (p[Y] = { __html: M }));
                  continue;
                case "className":
                  ra(
                    t,
                    Y,
                    "class",
                    B,
                    y,
                    p
                  );
                  continue;
                case "tabIndex":
                  ra(
                    t,
                    Y,
                    "tabindex",
                    B,
                    y,
                    p
                  );
                  continue;
                case "style":
                  y.delete(Y), Ag(t, B, p);
                  continue;
                case "multiple":
                  y.delete(Y), _n(
                    Y,
                    t.multiple,
                    B,
                    p
                  );
                  continue;
                case "muted":
                  y.delete(Y), _n(
                    Y,
                    t.muted,
                    B,
                    p
                  );
                  continue;
                case "autoFocus":
                  y.delete("autofocus"), _n(
                    Y,
                    t.autofocus,
                    B,
                    p
                  );
                  continue;
                case "data":
                  if (e !== "object") {
                    y.delete(Y), M = t.getAttribute("data"), _n(
                      Y,
                      M,
                      B,
                      p
                    );
                    continue;
                  }
                case "src":
                case "href":
                  if (!(B !== "" || e === "a" && Y === "href" || e === "object" && Y === "data")) {
                    console.error(
                      Y === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                      Y,
                      Y
                    );
                    continue;
                  }
                  Qe(
                    t,
                    Y,
                    Y,
                    B,
                    y,
                    p
                  );
                  continue;
                case "action":
                case "formAction":
                  if (M = t.getAttribute(Y), typeof B == "function") {
                    y.delete(Y.toLowerCase()), Y === "formAction" ? (y.delete("name"), y.delete("formenctype"), y.delete("formmethod"), y.delete("formtarget")) : (y.delete("enctype"), y.delete("method"), y.delete("target"));
                    continue;
                  } else if (M === xE) {
                    y.delete(Y.toLowerCase()), _n(
                      Y,
                      "function",
                      B,
                      p
                    );
                    continue;
                  }
                  Qe(
                    t,
                    Y,
                    Y.toLowerCase(),
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkHref":
                  Qe(
                    t,
                    Y,
                    "xlink:href",
                    B,
                    y,
                    p
                  );
                  continue;
                case "contentEditable":
                  Rg(
                    t,
                    Y,
                    "contenteditable",
                    B,
                    y,
                    p
                  );
                  continue;
                case "spellCheck":
                  Rg(
                    t,
                    Y,
                    "spellcheck",
                    B,
                    y,
                    p
                  );
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  Rg(
                    t,
                    Y,
                    Y,
                    B,
                    y,
                    p
                  );
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  Dg(
                    t,
                    Y,
                    Y.toLowerCase(),
                    B,
                    y,
                    p
                  );
                  continue;
                case "capture":
                case "download":
                  t: {
                    D = t;
                    var lt = M = Y, mt = p;
                    if (y.delete(lt), D = D.getAttribute(lt), D === null)
                      switch (typeof B) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break t;
                        default:
                          if (B === !1) break t;
                      }
                    else if (B != null)
                      switch (typeof B) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (B === !0 && D === "") break t;
                          break;
                        default:
                          if (ct(B, M), D === "" + B)
                            break t;
                      }
                    _n(
                      M,
                      D,
                      B,
                      mt
                    );
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  t: {
                    if (D = t, lt = M = Y, mt = p, y.delete(lt), D = D.getAttribute(lt), D === null)
                      switch (typeof B) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break t;
                        default:
                          if (isNaN(B) || 1 > B) break t;
                      }
                    else if (B != null)
                      switch (typeof B) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (!(isNaN(B) || 1 > B) && (ct(B, M), D === "" + B))
                            break t;
                      }
                    _n(
                      M,
                      D,
                      B,
                      mt
                    );
                  }
                  continue;
                case "rowSpan":
                  Vv(
                    t,
                    Y,
                    "rowspan",
                    B,
                    y,
                    p
                  );
                  continue;
                case "start":
                  Vv(
                    t,
                    Y,
                    Y,
                    B,
                    y,
                    p
                  );
                  continue;
                case "xHeight":
                  ra(
                    t,
                    Y,
                    "x-height",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkActuate":
                  ra(
                    t,
                    Y,
                    "xlink:actuate",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkArcrole":
                  ra(
                    t,
                    Y,
                    "xlink:arcrole",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkRole":
                  ra(
                    t,
                    Y,
                    "xlink:role",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkShow":
                  ra(
                    t,
                    Y,
                    "xlink:show",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkTitle":
                  ra(
                    t,
                    Y,
                    "xlink:title",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkType":
                  ra(
                    t,
                    Y,
                    "xlink:type",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xmlBase":
                  ra(
                    t,
                    Y,
                    "xml:base",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xmlLang":
                  ra(
                    t,
                    Y,
                    "xml:lang",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xmlSpace":
                  ra(
                    t,
                    Y,
                    "xml:space",
                    B,
                    y,
                    p
                  );
                  continue;
                case "inert":
                  B !== "" || B_[Y] || (B_[Y] = !0, console.error(
                    "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                    Y
                  )), Dg(
                    t,
                    Y,
                    Y,
                    B,
                    y,
                    p
                  );
                  continue;
                default:
                  if (!(2 < Y.length) || Y[0] !== "o" && Y[0] !== "O" || Y[1] !== "n" && Y[1] !== "N") {
                    D = xs(Y), M = !1, f.context === lc && e !== "svg" && e !== "math" ? y.delete(D.toLowerCase()) : (lt = Y.toLowerCase(), lt = Ju.hasOwnProperty(
                      lt
                    ) && Ju[lt] || null, lt !== null && lt !== Y && (M = !0, y.delete(lt)), y.delete(D));
                    t: if (lt = t, mt = D, D = B, se(mt))
                      if (lt.hasAttribute(mt))
                        lt = lt.getAttribute(
                          mt
                        ), ct(
                          D,
                          mt
                        ), D = lt === "" + D ? D : lt;
                      else {
                        switch (typeof D) {
                          case "function":
                          case "symbol":
                            break t;
                          case "boolean":
                            if (lt = mt.toLowerCase().slice(0, 5), lt !== "data-" && lt !== "aria-")
                              break t;
                        }
                        D = D === void 0 ? void 0 : null;
                      }
                    else D = void 0;
                    M || _n(
                      Y,
                      D,
                      B,
                      p
                    );
                  }
              }
          }
      return 0 < y.size && a.suppressHydrationWarning !== !0 && Yr(t, y, p), Object.keys(p).length === 0 ? null : p;
    }
    function Le(t, e) {
      switch (t.length) {
        case 0:
          return "";
        case 1:
          return t[0];
        case 2:
          return t[0] + " " + e + " " + t[1];
        default:
          return t.slice(0, -1).join(", ") + ", " + e + " " + t[t.length - 1];
      }
    }
    function He(t) {
      return t.nodeType === 9 ? t : t.ownerDocument;
    }
    function Ke(t) {
      switch (t) {
        case rf:
          return Ap;
        case qh:
          return q_;
        default:
          return lc;
      }
    }
    function Ca(t, e) {
      if (t === lc)
        switch (e) {
          case "svg":
            return Ap;
          case "math":
            return q_;
          default:
            return lc;
        }
      return t === Ap && e === "foreignObject" ? lc : t;
    }
    function $l(t, e) {
      return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.children == "bigint" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
    }
    function jc() {
      var t = window.event;
      return t && t.type === "popstate" ? t === jb ? !1 : (jb = t, !0) : (jb = null, !1);
    }
    function Cg(t) {
      setTimeout(function() {
        throw t;
      });
    }
    function Xs(t, e, a) {
      switch (e) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          a.autoFocus && t.focus();
          break;
        case "img":
          a.src ? t.src = a.src : a.srcSet && (t.srcset = a.srcSet);
      }
    }
    function Ln(t, e, a, f) {
      Zv(t, e, a, f), t[ka] = f;
    }
    function Qs(t) {
      Fo(t, "");
    }
    function qu(t, e, a) {
      t.nodeValue = a;
    }
    function Fl(t) {
      return t === "head";
    }
    function jo(t, e) {
      t.removeChild(e);
    }
    function qc(t, e) {
      (t.nodeType === 9 ? t.body : t.nodeName === "HTML" ? t.ownerDocument.body : t).removeChild(e);
    }
    function Zc(t, e) {
      var a = e, f = 0, p = 0;
      do {
        var y = a.nextSibling;
        if (t.removeChild(a), y && y.nodeType === 8)
          if (a = y.data, a === j_) {
            if (0 < f && 8 > f) {
              a = f;
              var M = t.ownerDocument;
              if (a & ME && Xc(M.documentElement), a & EE && Xc(M.body), a & OE)
                for (a = M.head, Xc(a), M = a.firstChild; M; ) {
                  var D = M.nextSibling, B = M.nodeName;
                  M[af] || B === "SCRIPT" || B === "STYLE" || B === "LINK" && M.rel.toLowerCase() === "stylesheet" || a.removeChild(M), M = D;
                }
            }
            if (p === 0) {
              t.removeChild(y), Gu(e);
              return;
            }
            p--;
          } else
            a === Y_ || a === oc || a === qy ? p++ : f = a.charCodeAt(0) - 48;
        else f = 0;
        a = y;
      } while (a);
      Gu(e);
    }
    function za(t) {
      t = t.style, typeof t.setProperty == "function" ? t.setProperty("display", "none", "important") : t.display = "none";
    }
    function zg(t) {
      t.nodeValue = "";
    }
    function Lg(t, e) {
      e = e[AE], e = e != null && e.hasOwnProperty("display") ? e.display : null, t.style.display = e == null || typeof e == "boolean" ? "" : ("" + e).trim();
    }
    function Am(t, e) {
      t.nodeValue = e;
    }
    function Vc(t) {
      var e = t.firstChild;
      for (e && e.nodeType === 10 && (e = e.nextSibling); e; ) {
        var a = e;
        switch (e = e.nextSibling, a.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            Vc(a), ga(a);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (a.rel.toLowerCase() === "stylesheet") continue;
        }
        t.removeChild(a);
      }
    }
    function jr(t, e, a, f) {
      for (; t.nodeType === 1; ) {
        var p = a;
        if (t.nodeName.toLowerCase() !== e.toLowerCase()) {
          if (!f && (t.nodeName !== "INPUT" || t.type !== "hidden"))
            break;
        } else if (f) {
          if (!t[af])
            switch (e) {
              case "meta":
                if (!t.hasAttribute("itemprop")) break;
                return t;
              case "link":
                if (y = t.getAttribute("rel"), y === "stylesheet" && t.hasAttribute("data-precedence"))
                  break;
                if (y !== p.rel || t.getAttribute("href") !== (p.href == null || p.href === "" ? null : p.href) || t.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin) || t.getAttribute("title") !== (p.title == null ? null : p.title))
                  break;
                return t;
              case "style":
                if (t.hasAttribute("data-precedence")) break;
                return t;
              case "script":
                if (y = t.getAttribute("src"), (y !== (p.src == null ? null : p.src) || t.getAttribute("type") !== (p.type == null ? null : p.type) || t.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin)) && y && t.hasAttribute("async") && !t.hasAttribute("itemprop"))
                  break;
                return t;
              default:
                return t;
            }
        } else if (e === "input" && t.type === "hidden") {
          ct(p.name, "name");
          var y = p.name == null ? null : "" + p.name;
          if (p.type === "hidden" && t.getAttribute("name") === y)
            return t;
        } else return t;
        if (t = Hi(t.nextSibling), t === null) break;
      }
      return null;
    }
    function Li(t, e, a) {
      if (e === "") return null;
      for (; t.nodeType !== 3; )
        if ((t.nodeType !== 1 || t.nodeName !== "INPUT" || t.type !== "hidden") && !a || (t = Hi(t.nextSibling), t === null)) return null;
      return t;
    }
    function ts(t) {
      return t.data === qy || t.data === oc && t.ownerDocument.readyState === yT;
    }
    function Pc(t, e) {
      var a = t.ownerDocument;
      if (t.data !== oc || a.readyState === yT)
        e();
      else {
        var f = function() {
          e(), a.removeEventListener("DOMContentLoaded", f);
        };
        a.addEventListener("DOMContentLoaded", f), t._reactRetry = f;
      }
    }
    function Hi(t) {
      for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3) break;
        if (e === 8) {
          if (e = t.data, e === Y_ || e === qy || e === oc || e === Ub || e === gT)
            break;
          if (e === j_) return null;
        }
      }
      return t;
    }
    function Dm(t) {
      if (t.nodeType === 1) {
        for (var e = t.nodeName.toLowerCase(), a = {}, f = t.attributes, p = 0; p < f.length; p++) {
          var y = f[p];
          a[Og(y.name)] = y.name.toLowerCase() === "style" ? ju(t) : y.value;
        }
        return { type: e, props: a };
      }
      return t.nodeType === 8 ? { type: "Suspense", props: {} } : t.nodeValue;
    }
    function Rm(t, e, a) {
      return a === null || a[wE] !== !0 ? (t.nodeValue === e ? t = null : (e = zi(e), t = zi(t.nodeValue) === e ? null : t.nodeValue), t) : null;
    }
    function Hg(t) {
      t = t.nextSibling;
      for (var e = 0; t; ) {
        if (t.nodeType === 8) {
          var a = t.data;
          if (a === j_) {
            if (e === 0)
              return Hi(t.nextSibling);
            e--;
          } else
            a !== Y_ && a !== qy && a !== oc || e++;
        }
        t = t.nextSibling;
      }
      return null;
    }
    function Gc(t) {
      t = t.previousSibling;
      for (var e = 0; t; ) {
        if (t.nodeType === 8) {
          var a = t.data;
          if (a === Y_ || a === qy || a === oc) {
            if (e === 0) return t;
            e--;
          } else a === j_ && e++;
        }
        t = t.previousSibling;
      }
      return null;
    }
    function kg(t) {
      Gu(t);
    }
    function oo(t) {
      Gu(t);
    }
    function Ng(t, e, a, f, p) {
      switch (p && yr(t, f.ancestorInfo), e = He(a), t) {
        case "html":
          if (t = e.documentElement, !t)
            throw Error(
              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        case "head":
          if (t = e.head, !t)
            throw Error(
              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        case "body":
          if (t = e.body, !t)
            throw Error(
              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        default:
          throw Error(
            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
    }
    function lo(t, e, a, f) {
      if (!a[Wr] && Vn(a)) {
        var p = a.tagName.toLowerCase();
        console.error(
          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
          p,
          p,
          p
        );
      }
      switch (t) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error(
            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
      for (p = a.attributes; p.length; )
        a.removeAttributeNode(p[0]);
      zn(a, t, e), a[Wi] = f, a[ka] = e;
    }
    function Xc(t) {
      for (var e = t.attributes; e.length; )
        t.removeAttributeNode(e[0]);
      ga(t);
    }
    function bh(t) {
      return typeof t.getRootNode == "function" ? t.getRootNode() : t.nodeType === 9 ? t : t.ownerDocument;
    }
    function Pv(t, e, a) {
      var f = Dp;
      if (f && typeof e == "string" && e) {
        var p = na(e);
        p = 'link[rel="' + t + '"][href="' + p + '"]', typeof a == "string" && (p += '[crossorigin="' + a + '"]'), xT.has(p) || (xT.add(p), t = { rel: t, crossOrigin: a, href: e }, f.querySelector(p) === null && (e = f.createElement("link"), zn(e, "link", t), $(e), f.head.appendChild(e)));
      }
    }
    function Ks(t, e, a, f) {
      var p = (p = ns.current) ? bh(p) : null;
      if (!p)
        throw Error(
          '"resourceRoot" was expected to exist. This is a bug in React.'
        );
      switch (t) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof a.precedence == "string" && typeof a.href == "string" ? (a = qr(a.href), e = N(p).hoistableStyles, f = e.get(a), f || (f = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, e.set(a, f)), f) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (a.rel === "stylesheet" && typeof a.href == "string" && typeof a.precedence == "string") {
            t = qr(a.href);
            var y = N(p).hoistableStyles, M = y.get(t);
            if (!M && (p = p.ownerDocument || p, M = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: od, preload: null }
            }, y.set(t, M), (y = p.querySelector(
              es(t)
            )) && !y._p && (M.instance = y, M.state.loading = Zy | ps), !gs.has(t))) {
              var D = {
                rel: "preload",
                as: "style",
                href: a.href,
                crossOrigin: a.crossOrigin,
                integrity: a.integrity,
                media: a.media,
                hrefLang: a.hrefLang,
                referrerPolicy: a.referrerPolicy
              };
              gs.set(t, D), y || Gv(
                p,
                t,
                D,
                M.state
              );
            }
            if (e && f === null)
              throw a = `

  - ` + Zu(e) + `
  + ` + Zu(a), Error(
                "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + a
              );
            return M;
          }
          if (e && f !== null)
            throw a = `

  - ` + Zu(e) + `
  + ` + Zu(a), Error(
              "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + a
            );
          return null;
        case "script":
          return e = a.async, a = a.src, typeof a == "string" && e && typeof e != "function" && typeof e != "symbol" ? (a = Vu(a), e = N(p).hoistableScripts, f = e.get(a), f || (f = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, e.set(a, f)), f) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(
            'getResource encountered a type it did not expect: "' + t + '". this is a bug in React.'
          );
      }
    }
    function Zu(t) {
      var e = 0, a = "<link";
      return typeof t.rel == "string" ? (e++, a += ' rel="' + t.rel + '"') : Is.call(t, "rel") && (e++, a += ' rel="' + (t.rel === null ? "null" : "invalid type " + typeof t.rel) + '"'), typeof t.href == "string" ? (e++, a += ' href="' + t.href + '"') : Is.call(t, "href") && (e++, a += ' href="' + (t.href === null ? "null" : "invalid type " + typeof t.href) + '"'), typeof t.precedence == "string" ? (e++, a += ' precedence="' + t.precedence + '"') : Is.call(t, "precedence") && (e++, a += " precedence={" + (t.precedence === null ? "null" : "invalid type " + typeof t.precedence) + "}"), Object.getOwnPropertyNames(t).length > e && (a += " ..."), a + " />";
    }
    function qr(t) {
      return 'href="' + na(t) + '"';
    }
    function es(t) {
      return 'link[rel="stylesheet"][' + t + "]";
    }
    function Ug(t) {
      return Me({}, t, {
        "data-precedence": t.precedence,
        precedence: null
      });
    }
    function Gv(t, e, a, f) {
      t.querySelector(
        'link[rel="preload"][as="style"][' + e + "]"
      ) ? f.loading = Zy : (e = t.createElement("link"), f.preload = e, e.addEventListener("load", function() {
        return f.loading |= Zy;
      }), e.addEventListener("error", function() {
        return f.loading |= ST;
      }), zn(e, "link", a), $(e), t.head.appendChild(e));
    }
    function Vu(t) {
      return '[src="' + na(t) + '"]';
    }
    function Pu(t) {
      return "script[async]" + t;
    }
    function Cm(t, e, a) {
      if (e.count++, e.instance === null)
        switch (e.type) {
          case "style":
            var f = t.querySelector(
              'style[data-href~="' + na(a.href) + '"]'
            );
            if (f)
              return e.instance = f, $(f), f;
            var p = Me({}, a, {
              "data-href": a.href,
              "data-precedence": a.precedence,
              href: null,
              precedence: null
            });
            return f = (t.ownerDocument || t).createElement("style"), $(f), zn(f, "style", p), zm(f, a.precedence, t), e.instance = f;
          case "stylesheet":
            p = qr(a.href);
            var y = t.querySelector(
              es(p)
            );
            if (y)
              return e.state.loading |= ps, e.instance = y, $(y), y;
            f = Ug(a), (p = gs.get(p)) && Bg(f, p), y = (t.ownerDocument || t).createElement("link"), $(y);
            var M = y;
            return M._p = new Promise(function(D, B) {
              M.onload = D, M.onerror = B;
            }), zn(y, "link", f), e.state.loading |= ps, zm(y, a.precedence, t), e.instance = y;
          case "script":
            return y = Vu(a.src), (p = t.querySelector(
              Pu(y)
            )) ? (e.instance = p, $(p), p) : (f = a, (p = gs.get(y)) && (f = Me({}, a), Yg(f, p)), t = t.ownerDocument || t, p = t.createElement("script"), $(p), zn(p, "link", f), t.head.appendChild(p), e.instance = p);
          case "void":
            return null;
          default:
            throw Error(
              'acquireResource encountered a resource type it did not expect: "' + e.type + '". this is a bug in React.'
            );
        }
      else
        e.type === "stylesheet" && (e.state.loading & ps) === od && (f = e.instance, e.state.loading |= ps, zm(f, a.precedence, t));
      return e.instance;
    }
    function zm(t, e, a) {
      for (var f = a.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), p = f.length ? f[f.length - 1] : null, y = p, M = 0; M < f.length; M++) {
        var D = f[M];
        if (D.dataset.precedence === e) y = D;
        else if (y !== p) break;
      }
      y ? y.parentNode.insertBefore(t, y.nextSibling) : (e = a.nodeType === 9 ? a.head : a, e.insertBefore(t, e.firstChild));
    }
    function Bg(t, e) {
      t.crossOrigin == null && (t.crossOrigin = e.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = e.referrerPolicy), t.title == null && (t.title = e.title);
    }
    function Yg(t, e) {
      t.crossOrigin == null && (t.crossOrigin = e.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = e.referrerPolicy), t.integrity == null && (t.integrity = e.integrity);
    }
    function jg(t, e, a) {
      if (Z_ === null) {
        var f = /* @__PURE__ */ new Map(), p = Z_ = /* @__PURE__ */ new Map();
        p.set(a, f);
      } else
        p = Z_, f = p.get(a), f || (f = /* @__PURE__ */ new Map(), p.set(a, f));
      if (f.has(t)) return f;
      for (f.set(t, null), a = a.getElementsByTagName(t), p = 0; p < a.length; p++) {
        var y = a[p];
        if (!(y[af] || y[Wi] || t === "link" && y.getAttribute("rel") === "stylesheet") && y.namespaceURI !== rf) {
          var M = y.getAttribute(e) || "";
          M = t + M;
          var D = f.get(M);
          D ? D.push(y) : f.set(M, [y]);
        }
      }
      return f;
    }
    function qg(t, e, a) {
      t = t.ownerDocument || t, t.head.insertBefore(
        a,
        e === "title" ? t.querySelector("head > title") : null
      );
    }
    function Qc(t, e, a) {
      var f = !a.ancestorInfo.containerTagInScope;
      if (a.context === Ap || e.itemProp != null)
        return !f || e.itemProp == null || t !== "meta" && t !== "title" && t !== "style" && t !== "link" && t !== "script" || console.error(
          "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
          t,
          t
        ), !1;
      switch (t) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (typeof e.precedence != "string" || typeof e.href != "string" || e.href === "") {
            f && console.error(
              'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
            );
            break;
          }
          return !0;
        case "link":
          if (typeof e.rel != "string" || typeof e.href != "string" || e.href === "" || e.onLoad || e.onError) {
            if (e.rel === "stylesheet" && typeof e.precedence == "string") {
              t = e.href;
              var p = e.onError, y = e.disabled;
              a = [], e.onLoad && a.push("`onLoad`"), p && a.push("`onError`"), y != null && a.push("`disabled`"), p = Le(a, "and"), p += a.length === 1 ? " prop" : " props", y = a.length === 1 ? "an " + p : "the " + p, a.length && console.error(
                'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                t,
                y,
                p
              );
            }
            f && (typeof e.rel != "string" || typeof e.href != "string" || e.href === "" ? console.error(
              "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
            ) : (e.onError || e.onLoad) && console.error(
              "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ));
            break;
          }
          switch (e.rel) {
            case "stylesheet":
              return t = e.precedence, e = e.disabled, typeof t != "string" && f && console.error(
                'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
              ), typeof t == "string" && e == null;
            default:
              return !0;
          }
        case "script":
          if (t = e.async && typeof e.async != "function" && typeof e.async != "symbol", !t || e.onLoad || e.onError || !e.src || typeof e.src != "string") {
            f && (t ? e.onLoad || e.onError ? console.error(
              "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
            ));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          f && console.error(
            "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
            t
          );
      }
      return !1;
    }
    function Sh(t) {
      return !(t.type === "stylesheet" && (t.state.loading & TT) === od);
    }
    function Xv() {
    }
    function Qv(t, e, a) {
      if (Vy === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var f = Vy;
      if (e.type === "stylesheet" && (typeof a.media != "string" || matchMedia(a.media).matches !== !1) && (e.state.loading & ps) === od) {
        if (e.instance === null) {
          var p = qr(a.href), y = t.querySelector(
            es(p)
          );
          if (y) {
            t = y._p, t !== null && typeof t == "object" && typeof t.then == "function" && (f.count++, f = Th.bind(f), t.then(f, f)), e.state.loading |= ps, e.instance = y, $(y);
            return;
          }
          y = t.ownerDocument || t, a = Ug(a), (p = gs.get(p)) && Bg(a, p), y = y.createElement("link"), $(y);
          var M = y;
          M._p = new Promise(function(D, B) {
            M.onload = D, M.onerror = B;
          }), zn(y, "link", a), e.instance = y;
        }
        f.stylesheets === null && (f.stylesheets = /* @__PURE__ */ new Map()), f.stylesheets.set(e, t), (t = e.state.preload) && (e.state.loading & TT) === od && (f.count++, e = Th.bind(f), t.addEventListener("load", e), t.addEventListener("error", e));
      }
    }
    function Kv() {
      if (Vy === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var t = Vy;
      return t.stylesheets && t.count === 0 && Lm(t, t.stylesheets), 0 < t.count ? function(e) {
        var a = setTimeout(function() {
          if (t.stylesheets && Lm(t, t.stylesheets), t.unsuspend) {
            var f = t.unsuspend;
            t.unsuspend = null, f();
          }
        }, 6e4);
        return t.unsuspend = e, function() {
          t.unsuspend = null, clearTimeout(a);
        };
      } : null;
    }
    function Th() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets)
          Lm(this, this.stylesheets);
        else if (this.unsuspend) {
          var t = this.unsuspend;
          this.unsuspend = null, t();
        }
      }
    }
    function Lm(t, e) {
      t.stylesheets = null, t.unsuspend !== null && (t.count++, V_ = /* @__PURE__ */ new Map(), e.forEach(Wv, t), V_ = null, Th.call(t));
    }
    function Wv(t, e) {
      if (!(e.state.loading & ps)) {
        var a = V_.get(t);
        if (a) var f = a.get(Zb);
        else {
          a = /* @__PURE__ */ new Map(), V_.set(t, a);
          for (var p = t.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), y = 0; y < p.length; y++) {
            var M = p[y];
            (M.nodeName === "LINK" || M.getAttribute("media") !== "not all") && (a.set(M.dataset.precedence, M), f = M);
          }
          f && a.set(Zb, f);
        }
        p = e.instance, M = p.getAttribute("data-precedence"), y = a.get(M) || f, y === f && a.set(Zb, p), a.set(M, p), this.count++, f = Th.bind(this), p.addEventListener("load", f), p.addEventListener("error", f), y ? y.parentNode.insertBefore(p, y.nextSibling) : (t = t.nodeType === 9 ? t.head : t, t.insertBefore(p, t.firstChild)), e.state.loading |= ps;
      }
    }
    function Hm(t, e, a, f, p, y, M, D) {
      for (this.tag = 1, this.containerInfo = t, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = ad, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = vs(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = vs(0), this.hiddenUpdates = vs(null), this.identifierPrefix = f, this.onUncaughtError = p, this.onCaughtError = y, this.onRecoverableError = M, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = D, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), t = this.pendingUpdatersLaneMap = [], e = 0; 31 > e; e++) t.push(/* @__PURE__ */ new Set());
      this._debugRootType = a ? "hydrateRoot()" : "createRoot()";
    }
    function Zg(t, e, a, f, p, y, M, D, B, Y, lt, mt) {
      return t = new Hm(
        t,
        e,
        a,
        M,
        D,
        B,
        Y,
        mt
      ), e = tE, y === !0 && (e |= Ua | nr), kn && (e |= ca), y = z(3, null, null, e), t.current = y, y.stateNode = t, e = Hs(), Do(e), t.pooledCache = e, Do(e), y.memoizedState = {
        element: f,
        isDehydrated: a,
        cache: e
      }, Ri(y), t;
    }
    function Vg(t) {
      return t ? (t = uf, t) : uf;
    }
    function Je(t, e, a, f, p, y) {
      if (ki && typeof ki.onScheduleFiberRoot == "function")
        try {
          ki.onScheduleFiberRoot(Qr, f, a);
        } catch (M) {
          Ha || (Ha = !0, console.error(
            "React instrumentation encountered an error: %s",
            M
          ));
        }
      jt !== null && typeof jt.markRenderScheduled == "function" && jt.markRenderScheduled(e), p = Vg(p), f.context === null ? f.context = p : f.pendingContext = p, Na && ro !== null && !OT && (OT = !0, console.error(
        `Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,
        Mt(ro) || "Unknown"
      )), f = Gn(e), f.payload = { element: a }, y = y === void 0 ? null : y, y !== null && (typeof y != "function" && console.error(
        "Expected the last optional `callback` argument to be a function. Instead received: %s.",
        y
      ), f.callback = y), a = wa(t, f, e), a !== null && (Rn(a, t, e), ll(a, t, e));
    }
    function km(t, e) {
      if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
        var a = t.retryLane;
        t.retryLane = a !== 0 && a < e ? a : e;
      }
    }
    function Pg(t, e) {
      km(t, e), (t = t.alternate) && km(t, e);
    }
    function Gg(t) {
      if (t.tag === 13) {
        var e = mi(t, 67108864);
        e !== null && Rn(e, t, 67108864), Pg(t, 67108864);
      }
    }
    function N0() {
      return ro;
    }
    function U0() {
      for (var t = /* @__PURE__ */ new Map(), e = 1, a = 0; 31 > a; a++) {
        var f = cr(e);
        t.set(e, f), e *= 2;
      }
      return t;
    }
    function B0(t, e, a, f) {
      var p = ft.T;
      ft.T = null;
      var y = re.p;
      try {
        re.p = Ni, Zr(t, e, a, f);
      } finally {
        re.p = y, ft.T = p;
      }
    }
    function Nm(t, e, a, f) {
      var p = ft.T;
      ft.T = null;
      var y = re.p;
      try {
        re.p = gl, Zr(t, e, a, f);
      } finally {
        re.p = y, ft.T = p;
      }
    }
    function Zr(t, e, a, f) {
      if (G_) {
        var p = xh(f);
        if (p === null)
          la(
            t,
            e,
            f,
            X_,
            a
          ), Vr(t, f);
        else if (wh(
          p,
          t,
          e,
          a,
          f
        ))
          f.stopPropagation();
        else if (Vr(t, f), e & 4 && -1 < zE.indexOf(t)) {
          for (; p !== null; ) {
            var y = Vn(p);
            if (y !== null)
              switch (y.tag) {
                case 3:
                  if (y = y.stateNode, y.current.memoizedState.isDehydrated) {
                    var M = Tn(y.pendingLanes);
                    if (M !== 0) {
                      var D = y;
                      for (D.pendingLanes |= 2, D.entangledLanes |= 2; M; ) {
                        var B = 1 << 31 - Ki(M);
                        D.entanglements[1] |= B, M &= ~B;
                      }
                      Bo(y), (Ie & (ho | lr)) === yl && (D_ = is() + oT, Bu(0));
                    }
                  }
                  break;
                case 13:
                  D = mi(y, 2), D !== null && Rn(D, y, 2), Nu(), Pg(y, 2);
              }
            if (y = xh(f), y === null && la(
              t,
              e,
              f,
              X_,
              a
            ), y === p) break;
            p = y;
          }
          p !== null && f.stopPropagation();
        } else
          la(
            t,
            e,
            f,
            null,
            a
          );
      }
    }
    function xh(t) {
      return t = Ye(t), Kc(t);
    }
    function Kc(t) {
      if (X_ = null, t = fi(t), t !== null) {
        var e = et(t);
        if (e === null) t = null;
        else {
          var a = e.tag;
          if (a === 13) {
            if (t = wt(e), t !== null) return t;
            t = null;
          } else if (a === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
              return e.tag === 3 ? e.stateNode.containerInfo : null;
            t = null;
          } else e !== t && (t = null);
        }
      }
      return X_ = t, null;
    }
    function Um(t) {
      switch (t) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Ni;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return gl;
        case "message":
          switch (Xr()) {
            case Zm:
              return Ni;
            case Lh:
              return gl;
            case tf:
            case V0:
              return Fs;
            case Hh:
              return Xm;
            default:
              return Fs;
          }
        default:
          return Fs;
      }
    }
    function Vr(t, e) {
      switch (t) {
        case "focusin":
        case "focusout":
          _f = null;
          break;
        case "dragenter":
        case "dragleave":
          bf = null;
          break;
        case "mouseover":
        case "mouseout":
          Sf = null;
          break;
        case "pointerover":
        case "pointerout":
          Gy.delete(e.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Xy.delete(e.pointerId);
      }
    }
    function La(t, e, a, f, p, y) {
      return t === null || t.nativeEvent !== y ? (t = {
        blockedOn: e,
        domEventName: a,
        eventSystemFlags: f,
        nativeEvent: y,
        targetContainers: [p]
      }, e !== null && (e = Vn(e), e !== null && Gg(e)), t) : (t.eventSystemFlags |= f, e = t.targetContainers, p !== null && e.indexOf(p) === -1 && e.push(p), t);
    }
    function wh(t, e, a, f, p) {
      switch (e) {
        case "focusin":
          return _f = La(
            _f,
            t,
            e,
            a,
            f,
            p
          ), !0;
        case "dragenter":
          return bf = La(
            bf,
            t,
            e,
            a,
            f,
            p
          ), !0;
        case "mouseover":
          return Sf = La(
            Sf,
            t,
            e,
            a,
            f,
            p
          ), !0;
        case "pointerover":
          var y = p.pointerId;
          return Gy.set(
            y,
            La(
              Gy.get(y) || null,
              t,
              e,
              a,
              f,
              p
            )
          ), !0;
        case "gotpointercapture":
          return y = p.pointerId, Xy.set(
            y,
            La(
              Xy.get(y) || null,
              t,
              e,
              a,
              f,
              p
            )
          ), !0;
      }
      return !1;
    }
    function Jv(t) {
      var e = fi(t.target);
      if (e !== null) {
        var a = et(e);
        if (a !== null) {
          if (e = a.tag, e === 13) {
            if (e = wt(a), e !== null) {
              t.blockedOn = e, hr(t.priority, function() {
                if (a.tag === 13) {
                  var f = Ra(a);
                  f = Zn(f);
                  var p = mi(
                    a,
                    f
                  );
                  p !== null && Rn(p, a, f), Pg(a, f);
                }
              });
              return;
            }
          } else if (e === 3 && a.stateNode.current.memoizedState.isDehydrated) {
            t.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null;
            return;
          }
        }
      }
      t.blockedOn = null;
    }
    function Mh(t) {
      if (t.blockedOn !== null) return !1;
      for (var e = t.targetContainers; 0 < e.length; ) {
        var a = xh(t.nativeEvent);
        if (a === null) {
          a = t.nativeEvent;
          var f = new a.constructor(
            a.type,
            a
          ), p = f;
          b !== null && console.error(
            "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
          ), b = p, a.target.dispatchEvent(f), b === null && console.error(
            "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
          ), b = null;
        } else
          return e = Vn(a), e !== null && Gg(e), t.blockedOn = a, !1;
        e.shift();
      }
      return !0;
    }
    function Xg(t, e, a) {
      Mh(t) && a.delete(e);
    }
    function Iv() {
      Vb = !1, _f !== null && Mh(_f) && (_f = null), bf !== null && Mh(bf) && (bf = null), Sf !== null && Mh(Sf) && (Sf = null), Gy.forEach(Xg), Xy.forEach(Xg);
    }
    function Eh(t, e) {
      t.blockedOn === e && (t.blockedOn = null, Vb || (Vb = !0, Hn.unstable_scheduleCallback(
        Hn.unstable_NormalPriority,
        Iv
      )));
    }
    function $v(t) {
      Q_ !== t && (Q_ = t, Hn.unstable_scheduleCallback(
        Hn.unstable_NormalPriority,
        function() {
          Q_ === t && (Q_ = null);
          for (var e = 0; e < t.length; e += 3) {
            var a = t[e], f = t[e + 1], p = t[e + 2];
            if (typeof f != "function") {
              if (Kc(f || a) === null)
                continue;
              break;
            }
            var y = Vn(a);
            y !== null && (t.splice(e, 3), e -= 3, a = {
              pending: !0,
              data: p,
              method: a.method,
              action: f
            }, Object.freeze(a), Mu(
              y,
              a,
              f,
              p
            ));
          }
        }
      ));
    }
    function Gu(t) {
      function e(B) {
        return Eh(B, t);
      }
      _f !== null && Eh(_f, t), bf !== null && Eh(bf, t), Sf !== null && Eh(Sf, t), Gy.forEach(e), Xy.forEach(e);
      for (var a = 0; a < Tf.length; a++) {
        var f = Tf[a];
        f.blockedOn === t && (f.blockedOn = null);
      }
      for (; 0 < Tf.length && (a = Tf[0], a.blockedOn === null); )
        Jv(a), a.blockedOn === null && Tf.shift();
      if (a = (t.ownerDocument || t).$$reactFormReplay, a != null)
        for (f = 0; f < a.length; f += 3) {
          var p = a[f], y = a[f + 1], M = p[ka] || null;
          if (typeof y == "function")
            M || $v(a);
          else if (M) {
            var D = null;
            if (y && y.hasAttribute("formAction")) {
              if (p = y, M = y[ka] || null)
                D = M.formAction;
              else if (Kc(p) !== null) continue;
            } else D = M.action;
            typeof D == "function" ? a[f + 1] = D : (a.splice(f, 3), f -= 3), $v(a);
          }
        }
    }
    function Bm(t) {
      this._internalRoot = t;
    }
    function Oh(t) {
      this._internalRoot = t;
    }
    function Fv(t) {
      t[Wr] && (t._reactRootContainer ? console.error(
        "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
      ) : console.error(
        "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
      ));
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Hn = Sw(), Ah = Np(), Y0 = Tw(), Me = Object.assign, Dh = Symbol.for("react.element"), Pr = Symbol.for("react.transitional.element"), Xu = Symbol.for("react.portal"), _e = Symbol.for("react.fragment"), Wc = Symbol.for("react.strict_mode"), Jc = Symbol.for("react.profiler"), Qg = Symbol.for("react.provider"), Ym = Symbol.for("react.consumer"), qo = Symbol.for("react.context"), Ws = Symbol.for("react.forward_ref"), Ic = Symbol.for("react.suspense"), Gr = Symbol.for("react.suspense_list"), Rh = Symbol.for("react.memo"), so = Symbol.for("react.lazy"), Kg = Symbol.for("react.activity"), t_ = Symbol.for("react.memo_cache_sentinel"), Wg = Symbol.iterator, jm = Symbol.for("react.client.reference"), de = Array.isArray, ft = Ah.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, re = Y0.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, j0 = Object.freeze({
      pending: !1,
      data: null,
      method: null,
      action: null
    }), Ch = [], zh = [], Zo = -1, Js = ne(null), $c = ne(null), ns = ne(null), Fc = ne(null), Is = Object.prototype.hasOwnProperty, qm = Hn.unstable_scheduleCallback, q0 = Hn.unstable_cancelCallback, e_ = Hn.unstable_shouldYield, Z0 = Hn.unstable_requestPaint, is = Hn.unstable_now, Xr = Hn.unstable_getCurrentPriorityLevel, Zm = Hn.unstable_ImmediatePriority, Lh = Hn.unstable_UserBlockingPriority, tf = Hn.unstable_NormalPriority, V0 = Hn.unstable_LowPriority, Hh = Hn.unstable_IdlePriority, P0 = Hn.log, pl = Hn.unstable_setDisableYieldValue, Qr = null, ki = null, jt = null, Ha = !1, kn = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u", Ki = Math.clz32 ? Math.clz32 : ur, Vm = Math.log, $s = Math.LN2, Pm = 256, Gm = 4194304, Ni = 2, gl = 8, Fs = 32, Xm = 268435456, Kr = Math.random().toString(36).slice(2), Wi = "__reactFiber$" + Kr, ka = "__reactProps$" + Kr, Wr = "__reactContainer$" + Kr, Jg = "__reactEvents$" + Kr, n_ = "__reactListeners$" + Kr, ef = "__reactHandles$" + Kr, nf = "__reactResources$" + Kr, af = "__reactMarker$" + Kr, i_ = /* @__PURE__ */ new Set(), Vo = {}, Qu = {}, a_ = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    }, Qm = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Km = {}, Wm = {}, Jr = 0, Ig, $g, o_, Fg, of, l_, s_;
    Ga.__reactDisabledLog = !0;
    var ty, kh, lf = !1, Nh = new (typeof WeakMap == "function" ? WeakMap : Map)(), ro = null, Na = !1, G0 = /[\n"\\]/g, ey = !1, ny = !1, iy = !1, ay = !1, Jm = !1, oy = !1, Uh = ["value", "defaultValue"], r_ = !1, u_ = /["'&<>\n\t]|^\s|\s$/, ly = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
      " "
    ), Im = "applet caption html table td th marquee object template foreignObject desc title".split(
      " "
    ), $m = Im.concat(["button"]), sy = "dd dt li option optgroup p rp rt".split(" "), ry = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null,
      containerTagInScope: null,
      implicitRootScope: !1
    }, sf = {}, as = {
      animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
        " "
      ),
      background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
        " "
      ),
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
        " "
      ),
      borderBlockEnd: [
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth"
      ],
      borderBlockStart: [
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth"
      ],
      borderBottom: [
        "borderBottomColor",
        "borderBottomStyle",
        "borderBottomWidth"
      ],
      borderColor: [
        "borderBottomColor",
        "borderLeftColor",
        "borderRightColor",
        "borderTopColor"
      ],
      borderImage: [
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth"
      ],
      borderInlineEnd: [
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth"
      ],
      borderInlineStart: [
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth"
      ],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: [
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderTopLeftRadius",
        "borderTopRightRadius"
      ],
      borderRight: [
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth"
      ],
      borderStyle: [
        "borderBottomStyle",
        "borderLeftStyle",
        "borderRightStyle",
        "borderTopStyle"
      ],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: [
        "borderBottomWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderTopWidth"
      ],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
        " "
      ),
      fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
        " "
      ),
      gap: ["columnGap", "rowGap"],
      grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
        " "
      ),
      gridArea: [
        "gridColumnEnd",
        "gridColumnStart",
        "gridRowEnd",
        "gridRowStart"
      ],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: [
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows"
      ],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
        " "
      ),
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: [
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationStyle"
      ],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: [
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction"
      ],
      wordWrap: ["overflowWrap"]
    }, tr = /([A-Z])/g, er = /^ms-/, Bh = /^(?:webkit|moz|o)[A-Z]/, Yh = /^-ms-/, Ir = /-(.)/g, c_ = /;\s*$/, Ku = {}, Wu = {}, f_ = !1, uy = !1, jh = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    ), qh = "http://www.w3.org/1998/Math/MathML", rf = "http://www.w3.org/2000/svg", Fm = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), Ju = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, cy = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, os = {}, fy = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), tp = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), hy = !1, ua = {}, Zh = /^on./, n = /^on[^A-Z]/, o = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), c = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), m = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, b = null, x = null, R = null, U = !1, Z = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), it = !1;
    if (Z)
      try {
        var vt = {};
        Object.defineProperty(vt, "passive", {
          get: function() {
            it = !0;
          }
        }), window.addEventListener("test", vt, vt), window.removeEventListener("test", vt, vt);
      } catch {
        it = !1;
      }
    var St = null, ot = null, st = null, Ft = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(t) {
        return t.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, te = Ue(Ft), Ze = Me({}, Ft, { view: 0, detail: 0 }), tt = Ue(Ze), W, nt, _t, Pt = Me({}, Ze, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: vu,
      button: 0,
      buttons: 0,
      relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
      },
      movementX: function(t) {
        return "movementX" in t ? t.movementX : (t !== _t && (_t && t.type === "mousemove" ? (W = t.screenX - _t.screenX, nt = t.screenY - _t.screenY) : nt = W = 0, _t = t), W);
      },
      movementY: function(t) {
        return "movementY" in t ? t.movementY : nt;
      }
    }), Ae = Ue(Pt), Jt = Me({}, Pt, { dataTransfer: 0 }), ae = Ue(Jt), Si = Me({}, Ze, { relatedTarget: 0 }), je = Ue(Si), $r = Me({}, Ft, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), X0 = Ue($r), DM = Me({}, Ft, {
      clipboardData: function(t) {
        return "clipboardData" in t ? t.clipboardData : window.clipboardData;
      }
    }), RM = Ue(DM), CM = Me({}, Ft, { data: 0 }), j1 = Ue(
      CM
    ), zM = j1, LM = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, HM = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, kM = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    }, NM = Me({}, Ze, {
      key: function(t) {
        if (t.key) {
          var e = LM[t.key] || t.key;
          if (e !== "Unidentified") return e;
        }
        return t.type === "keypress" ? (t = va(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? HM[t.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: vu,
      charCode: function(t) {
        return t.type === "keypress" ? va(t) : 0;
      },
      keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      },
      which: function(t) {
        return t.type === "keypress" ? va(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      }
    }), UM = Ue(NM), BM = Me({}, Pt, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), q1 = Ue(BM), YM = Me({}, Ze, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: vu
    }), jM = Ue(YM), qM = Me({}, Ft, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), ZM = Ue(qM), VM = Me({}, Pt, {
      deltaX: function(t) {
        return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
      },
      deltaY: function(t) {
        return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), PM = Ue(VM), GM = Me({}, Ft, {
      newState: 0,
      oldState: 0
    }), XM = Ue(GM), QM = [9, 13, 27, 32], Z1 = 229, Q0 = Z && "CompositionEvent" in window, dy = null;
    Z && "documentMode" in document && (dy = document.documentMode);
    var KM = Z && "TextEvent" in window && !dy, V1 = Z && (!Q0 || dy && 8 < dy && 11 >= dy), P1 = 32, G1 = String.fromCharCode(P1), X1 = !1, ep = !1, WM = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    }, my = null, py = null, Q1 = !1;
    Z && (Q1 = yc("input") && (!document.documentMode || 9 < document.documentMode));
    var uo = typeof Object.is == "function" ? Object.is : Bp, JM = Z && "documentMode" in document && 11 >= document.documentMode, np = null, K0 = null, gy = null, W0 = !1, ip = {
      animationend: Mo("Animation", "AnimationEnd"),
      animationiteration: Mo("Animation", "AnimationIteration"),
      animationstart: Mo("Animation", "AnimationStart"),
      transitionrun: Mo("Transition", "TransitionRun"),
      transitionstart: Mo("Transition", "TransitionStart"),
      transitioncancel: Mo("Transition", "TransitionCancel"),
      transitionend: Mo("Transition", "TransitionEnd")
    }, J0 = {}, K1 = {};
    Z && (K1 = document.createElement("div").style, "AnimationEvent" in window || (delete ip.animationend.animation, delete ip.animationiteration.animation, delete ip.animationstart.animation), "TransitionEvent" in window || delete ip.transitionend.transition);
    var W1 = nl("animationend"), J1 = nl("animationiteration"), I1 = nl("animationstart"), IM = nl("transitionrun"), $M = nl("transitionstart"), FM = nl("transitioncancel"), $1 = nl("transitionend"), F1 = /* @__PURE__ */ new Map(), I0 = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    I0.push("scrollEnd");
    var $0 = /* @__PURE__ */ new WeakMap(), h_ = 1, Iu = 2, ls = [], ap = 0, F0 = 0, uf = {};
    Object.freeze(uf);
    var ss = null, op = null, bn = 0, tE = 1, ca = 2, Ua = 8, nr = 16, tS = 64, eS = !1;
    try {
      var nS = Object.preventExtensions({});
    } catch {
      eS = !0;
    }
    var lp = [], sp = 0, d_ = null, m_ = 0, rs = [], us = 0, Vh = null, $u = 1, Fu = "", co = null, Qn = null, Ve = !1, tc = !1, cs = null, Ph = null, Fr = !1, tb = Error(
      "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), iS = 0;
    if (typeof performance == "object" && typeof performance.now == "function")
      var eE = performance, aS = function() {
        return eE.now();
      };
    else {
      var nE = Date;
      aS = function() {
        return nE.now();
      };
    }
    var eb = ne(null), nb = ne(null), oS = {}, p_ = null, rp = null, up = !1, iE = typeof AbortController < "u" ? AbortController : function() {
      var t = [], e = this.signal = {
        aborted: !1,
        addEventListener: function(a, f) {
          t.push(f);
        }
      };
      this.abort = function() {
        e.aborted = !0, t.forEach(function(a) {
          return a();
        });
      };
    }, aE = Hn.unstable_scheduleCallback, oE = Hn.unstable_NormalPriority, Ui = {
      $$typeof: qo,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, cp = Hn.unstable_now, lS = -0, g_ = -0, Po = -1.1, Gh = -0, y_ = !1, v_ = !1, yy = null, ib = 0, Xh = 0, fp = null, sS = ft.S;
    ft.S = function(t, e) {
      typeof e == "object" && e !== null && typeof e.then == "function" && Rd(t, e), sS !== null && sS(t, e);
    };
    var Qh = ne(null), ir = {
      recordUnsafeLifecycleWarnings: function() {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function() {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    }, vy = [], _y = [], by = [], Sy = [], Ty = [], xy = [], Kh = /* @__PURE__ */ new Set();
    ir.recordUnsafeLifecycleWarnings = function(t, e) {
      Kh.has(t.type) || (typeof e.componentWillMount == "function" && e.componentWillMount.__suppressDeprecationWarning !== !0 && vy.push(t), t.mode & Ua && typeof e.UNSAFE_componentWillMount == "function" && _y.push(t), typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && by.push(t), t.mode & Ua && typeof e.UNSAFE_componentWillReceiveProps == "function" && Sy.push(t), typeof e.componentWillUpdate == "function" && e.componentWillUpdate.__suppressDeprecationWarning !== !0 && Ty.push(t), t.mode & Ua && typeof e.UNSAFE_componentWillUpdate == "function" && xy.push(t));
    }, ir.flushPendingUnsafeLifecycleWarnings = function() {
      var t = /* @__PURE__ */ new Set();
      0 < vy.length && (vy.forEach(function(D) {
        t.add(
          Mt(D) || "Component"
        ), Kh.add(D.type);
      }), vy = []);
      var e = /* @__PURE__ */ new Set();
      0 < _y.length && (_y.forEach(function(D) {
        e.add(
          Mt(D) || "Component"
        ), Kh.add(D.type);
      }), _y = []);
      var a = /* @__PURE__ */ new Set();
      0 < by.length && (by.forEach(function(D) {
        a.add(
          Mt(D) || "Component"
        ), Kh.add(D.type);
      }), by = []);
      var f = /* @__PURE__ */ new Set();
      0 < Sy.length && (Sy.forEach(
        function(D) {
          f.add(
            Mt(D) || "Component"
          ), Kh.add(D.type);
        }
      ), Sy = []);
      var p = /* @__PURE__ */ new Set();
      0 < Ty.length && (Ty.forEach(function(D) {
        p.add(
          Mt(D) || "Component"
        ), Kh.add(D.type);
      }), Ty = []);
      var y = /* @__PURE__ */ new Set();
      if (0 < xy.length && (xy.forEach(function(D) {
        y.add(
          Mt(D) || "Component"
        ), Kh.add(D.type);
      }), xy = []), 0 < e.size) {
        var M = C(
          e
        );
        console.error(
          `Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,
          M
        );
      }
      0 < f.size && (M = C(
        f
      ), console.error(
        `Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`,
        M
      )), 0 < y.size && (M = C(
        y
      ), console.error(
        `Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,
        M
      )), 0 < t.size && (M = C(t), console.warn(
        `componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        M
      )), 0 < a.size && (M = C(
        a
      ), console.warn(
        `componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        M
      )), 0 < p.size && (M = C(p), console.warn(
        `componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        M
      ));
    };
    var __ = /* @__PURE__ */ new Map(), rS = /* @__PURE__ */ new Set();
    ir.recordLegacyContextWarning = function(t, e) {
      for (var a = null, f = t; f !== null; )
        f.mode & Ua && (a = f), f = f.return;
      a === null ? console.error(
        "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
      ) : !rS.has(t.type) && (f = __.get(a), t.type.contextTypes != null || t.type.childContextTypes != null || e !== null && typeof e.getChildContext == "function") && (f === void 0 && (f = [], __.set(a, f)), f.push(t));
    }, ir.flushLegacyContextWarning = function() {
      __.forEach(function(t) {
        if (t.length !== 0) {
          var e = t[0], a = /* @__PURE__ */ new Set();
          t.forEach(function(p) {
            a.add(Mt(p) || "Component"), rS.add(p.type);
          });
          var f = C(a);
          Vt(e, function() {
            console.error(
              `Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`,
              f
            );
          });
        }
      });
    }, ir.discardPendingWarnings = function() {
      vy = [], _y = [], by = [], Sy = [], Ty = [], xy = [], __ = /* @__PURE__ */ new Map();
    };
    var wy = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
    ), uS = Error(
      "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), b_ = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
    ), ab = {
      then: function() {
        console.error(
          'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
        );
      }
    }, My = null, S_ = !1, fs = 0, hs = 1, fo = 2, fa = 4, Bi = 8, cS = 0, fS = 1, hS = 2, ob = 3, cf = !1, dS = !1, lb = null, sb = !1, hp = ne(null), T_ = ne(0), dp, mS = /* @__PURE__ */ new Set(), pS = /* @__PURE__ */ new Set(), rb = /* @__PURE__ */ new Set(), gS = /* @__PURE__ */ new Set(), ff = 0, me = null, hn = null, Ti = null, x_ = !1, mp = !1, Wh = !1, w_ = 0, Ey = 0, ec = null, lE = 0, sE = 25, ht = null, ds = null, nc = -1, Oy = !1, M_ = {
      readContext: tn,
      use: Nt,
      useCallback: cn,
      useContext: cn,
      useEffect: cn,
      useImperativeHandle: cn,
      useLayoutEffect: cn,
      useInsertionEffect: cn,
      useMemo: cn,
      useReducer: cn,
      useRef: cn,
      useState: cn,
      useDebugValue: cn,
      useDeferredValue: cn,
      useTransition: cn,
      useSyncExternalStore: cn,
      useId: cn,
      useHostTransitionStatus: cn,
      useFormState: cn,
      useActionState: cn,
      useOptimistic: cn,
      useMemoCache: cn,
      useCacheRefresh: cn
    }, ub = null, yS = null, cb = null, vS = null, tu = null, ar = null, E_ = null;
    ub = {
      readContext: function(t) {
        return tn(t);
      },
      use: Nt,
      useCallback: function(t, e) {
        return ht = "useCallback", ye(), oa(e), Wf(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", ye(), tn(t);
      },
      useEffect: function(t, e) {
        return ht = "useEffect", ye(), oa(e), Ld(t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", ye(), oa(a), kd(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        ht = "useInsertionEffect", ye(), oa(e), ko(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", ye(), oa(e), Hd(t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", ye(), oa(e);
        var a = ft.H;
        ft.H = tu;
        try {
          return Nd(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", ye();
        var f = ft.H;
        ft.H = tu;
        try {
          return oe(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function(t) {
        return ht = "useRef", ye(), Kf(t);
      },
      useState: function(t) {
        ht = "useState", ye();
        var e = ft.H;
        ft.H = tu;
        try {
          return Ea(t);
        } finally {
          ft.H = e;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", ye();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", ye(), Ud(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", ye(), jl();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", ye(), Pi(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", ye(), ql();
      },
      useFormState: function(t, e) {
        return ht = "useFormState", ye(), Mr(), Ec(t, e);
      },
      useActionState: function(t, e) {
        return ht = "useActionState", ye(), Ec(t, e);
      },
      useOptimistic: function(t) {
        return ht = "useOptimistic", ye(), eo(t);
      },
      useHostTransitionStatus: Oa,
      useMemoCache: qt,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", ye(), Eu();
      }
    }, yS = {
      readContext: function(t) {
        return tn(t);
      },
      use: Nt,
      useCallback: function(t, e) {
        return ht = "useCallback", Ot(), Wf(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", Ot(), tn(t);
      },
      useEffect: function(t, e) {
        return ht = "useEffect", Ot(), Ld(t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", Ot(), kd(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        ht = "useInsertionEffect", Ot(), ko(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", Ot(), Hd(t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", Ot();
        var a = ft.H;
        ft.H = tu;
        try {
          return Nd(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", Ot();
        var f = ft.H;
        ft.H = tu;
        try {
          return oe(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function(t) {
        return ht = "useRef", Ot(), Kf(t);
      },
      useState: function(t) {
        ht = "useState", Ot();
        var e = ft.H;
        ft.H = tu;
        try {
          return Ea(t);
        } finally {
          ft.H = e;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", Ot(), Ud(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", Ot(), jl();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", Ot(), Pi(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", Ot(), ql();
      },
      useActionState: function(t, e) {
        return ht = "useActionState", Ot(), Ec(t, e);
      },
      useFormState: function(t, e) {
        return ht = "useFormState", Ot(), Mr(), Ec(t, e);
      },
      useOptimistic: function(t) {
        return ht = "useOptimistic", Ot(), eo(t);
      },
      useHostTransitionStatus: Oa,
      useMemoCache: qt,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), Eu();
      }
    }, cb = {
      readContext: function(t) {
        return tn(t);
      },
      use: Nt,
      useCallback: function(t, e) {
        return ht = "useCallback", Ot(), wu(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", Ot(), tn(t);
      },
      useEffect: function(t, e) {
        ht = "useEffect", Ot(), ni(2048, Bi, t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", Ot(), Yl(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        return ht = "useInsertionEffect", Ot(), ni(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", Ot(), ni(4, fa, t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", Ot();
        var a = ft.H;
        ft.H = ar;
        try {
          return Cr(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", Ot();
        var f = ft.H;
        ft.H = ar;
        try {
          return Ge(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function() {
        return ht = "useRef", Ot(), I().memoizedState;
      },
      useState: function() {
        ht = "useState", Ot();
        var t = ft.H;
        ft.H = ar;
        try {
          return Ge(Zt);
        } finally {
          ft.H = t;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", Ot(), Jf(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", Ot(), jd();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", Ot(), xu(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", Ot(), I().memoizedState;
      },
      useFormState: function(t) {
        return ht = "useFormState", Ot(), Mr(), zd(t);
      },
      useActionState: function(t) {
        return ht = "useActionState", Ot(), zd(t);
      },
      useOptimistic: function(t, e) {
        return ht = "useOptimistic", Ot(), cl(t, e);
      },
      useHostTransitionStatus: Oa,
      useMemoCache: qt,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), I().memoizedState;
      }
    }, vS = {
      readContext: function(t) {
        return tn(t);
      },
      use: Nt,
      useCallback: function(t, e) {
        return ht = "useCallback", Ot(), wu(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", Ot(), tn(t);
      },
      useEffect: function(t, e) {
        ht = "useEffect", Ot(), ni(2048, Bi, t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", Ot(), Yl(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        return ht = "useInsertionEffect", Ot(), ni(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", Ot(), ni(4, fa, t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", Ot();
        var a = ft.H;
        ft.H = E_;
        try {
          return Cr(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", Ot();
        var f = ft.H;
        ft.H = E_;
        try {
          return An(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function() {
        return ht = "useRef", Ot(), I().memoizedState;
      },
      useState: function() {
        ht = "useState", Ot();
        var t = ft.H;
        ft.H = E_;
        try {
          return An(Zt);
        } finally {
          ft.H = t;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", Ot(), Bd(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", Ot(), qd();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", Ot(), xu(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", Ot(), I().memoizedState;
      },
      useFormState: function(t) {
        return ht = "useFormState", Ot(), Mr(), Oc(t);
      },
      useActionState: function(t) {
        return ht = "useActionState", Ot(), Oc(t);
      },
      useOptimistic: function(t, e) {
        return ht = "useOptimistic", Ot(), Or(t, e);
      },
      useHostTransitionStatus: Oa,
      useMemoCache: qt,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), I().memoizedState;
      }
    }, tu = {
      readContext: function(t) {
        return E(), tn(t);
      },
      use: function(t) {
        return T(), Nt(t);
      },
      useCallback: function(t, e) {
        return ht = "useCallback", T(), ye(), Wf(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", T(), ye(), tn(t);
      },
      useEffect: function(t, e) {
        return ht = "useEffect", T(), ye(), Ld(t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", T(), ye(), kd(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        ht = "useInsertionEffect", T(), ye(), ko(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", T(), ye(), Hd(t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", T(), ye();
        var a = ft.H;
        ft.H = tu;
        try {
          return Nd(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", T(), ye();
        var f = ft.H;
        ft.H = tu;
        try {
          return oe(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function(t) {
        return ht = "useRef", T(), ye(), Kf(t);
      },
      useState: function(t) {
        ht = "useState", T(), ye();
        var e = ft.H;
        ft.H = tu;
        try {
          return Ea(t);
        } finally {
          ft.H = e;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", T(), ye();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", T(), ye(), Ud(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", T(), ye(), jl();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", T(), ye(), Pi(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", T(), ye(), ql();
      },
      useFormState: function(t, e) {
        return ht = "useFormState", T(), ye(), Ec(t, e);
      },
      useActionState: function(t, e) {
        return ht = "useActionState", T(), ye(), Ec(t, e);
      },
      useOptimistic: function(t) {
        return ht = "useOptimistic", T(), ye(), eo(t);
      },
      useMemoCache: function(t) {
        return T(), qt(t);
      },
      useHostTransitionStatus: Oa,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", ye(), Eu();
      }
    }, ar = {
      readContext: function(t) {
        return E(), tn(t);
      },
      use: function(t) {
        return T(), Nt(t);
      },
      useCallback: function(t, e) {
        return ht = "useCallback", T(), Ot(), wu(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", T(), Ot(), tn(t);
      },
      useEffect: function(t, e) {
        ht = "useEffect", T(), Ot(), ni(2048, Bi, t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", T(), Ot(), Yl(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        return ht = "useInsertionEffect", T(), Ot(), ni(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", T(), Ot(), ni(4, fa, t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", T(), Ot();
        var a = ft.H;
        ft.H = ar;
        try {
          return Cr(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", T(), Ot();
        var f = ft.H;
        ft.H = ar;
        try {
          return Ge(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function() {
        return ht = "useRef", T(), Ot(), I().memoizedState;
      },
      useState: function() {
        ht = "useState", T(), Ot();
        var t = ft.H;
        ft.H = ar;
        try {
          return Ge(Zt);
        } finally {
          ft.H = t;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", T(), Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", T(), Ot(), Jf(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", T(), Ot(), jd();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", T(), Ot(), xu(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", T(), Ot(), I().memoizedState;
      },
      useFormState: function(t) {
        return ht = "useFormState", T(), Ot(), zd(t);
      },
      useActionState: function(t) {
        return ht = "useActionState", T(), Ot(), zd(t);
      },
      useOptimistic: function(t, e) {
        return ht = "useOptimistic", T(), Ot(), cl(t, e);
      },
      useMemoCache: function(t) {
        return T(), qt(t);
      },
      useHostTransitionStatus: Oa,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), I().memoizedState;
      }
    }, E_ = {
      readContext: function(t) {
        return E(), tn(t);
      },
      use: function(t) {
        return T(), Nt(t);
      },
      useCallback: function(t, e) {
        return ht = "useCallback", T(), Ot(), wu(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", T(), Ot(), tn(t);
      },
      useEffect: function(t, e) {
        ht = "useEffect", T(), Ot(), ni(2048, Bi, t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", T(), Ot(), Yl(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        return ht = "useInsertionEffect", T(), Ot(), ni(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", T(), Ot(), ni(4, fa, t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", T(), Ot();
        var a = ft.H;
        ft.H = ar;
        try {
          return Cr(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", T(), Ot();
        var f = ft.H;
        ft.H = ar;
        try {
          return An(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function() {
        return ht = "useRef", T(), Ot(), I().memoizedState;
      },
      useState: function() {
        ht = "useState", T(), Ot();
        var t = ft.H;
        ft.H = ar;
        try {
          return An(Zt);
        } finally {
          ft.H = t;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", T(), Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", T(), Ot(), Bd(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", T(), Ot(), qd();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", T(), Ot(), xu(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", T(), Ot(), I().memoizedState;
      },
      useFormState: function(t) {
        return ht = "useFormState", T(), Ot(), Oc(t);
      },
      useActionState: function(t) {
        return ht = "useActionState", T(), Ot(), Oc(t);
      },
      useOptimistic: function(t, e) {
        return ht = "useOptimistic", T(), Ot(), Or(t, e);
      },
      useMemoCache: function(t) {
        return T(), qt(t);
      },
      useHostTransitionStatus: Oa,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), I().memoizedState;
      }
    };
    var _S = {
      react_stack_bottom_frame: function(t, e, a) {
        var f = Na;
        Na = !0;
        try {
          return t(e, a);
        } finally {
          Na = f;
        }
      }
    }, fb = _S.react_stack_bottom_frame.bind(_S), bS = {
      react_stack_bottom_frame: function(t) {
        var e = Na;
        Na = !0;
        try {
          return t.render();
        } finally {
          Na = e;
        }
      }
    }, SS = bS.react_stack_bottom_frame.bind(bS), TS = {
      react_stack_bottom_frame: function(t, e) {
        try {
          e.componentDidMount();
        } catch (a) {
          ie(t, t.return, a);
        }
      }
    }, hb = TS.react_stack_bottom_frame.bind(
      TS
    ), xS = {
      react_stack_bottom_frame: function(t, e, a, f, p) {
        try {
          e.componentDidUpdate(a, f, p);
        } catch (y) {
          ie(t, t.return, y);
        }
      }
    }, wS = xS.react_stack_bottom_frame.bind(
      xS
    ), MS = {
      react_stack_bottom_frame: function(t, e) {
        var a = e.stack;
        t.componentDidCatch(e.value, {
          componentStack: a !== null ? a : ""
        });
      }
    }, rE = MS.react_stack_bottom_frame.bind(
      MS
    ), ES = {
      react_stack_bottom_frame: function(t, e, a) {
        try {
          a.componentWillUnmount();
        } catch (f) {
          ie(t, e, f);
        }
      }
    }, OS = ES.react_stack_bottom_frame.bind(
      ES
    ), AS = {
      react_stack_bottom_frame: function(t) {
        t.resourceKind != null && console.error(
          "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
          t.resourceKind
        );
        var e = t.create;
        return t = t.inst, e = e(), t.destroy = e;
      }
    }, uE = AS.react_stack_bottom_frame.bind(AS), DS = {
      react_stack_bottom_frame: function(t, e, a) {
        try {
          a();
        } catch (f) {
          ie(t, e, f);
        }
      }
    }, cE = DS.react_stack_bottom_frame.bind(DS), RS = {
      react_stack_bottom_frame: function(t) {
        var e = t._init;
        return e(t._payload);
      }
    }, hf = RS.react_stack_bottom_frame.bind(RS), pp = null, Ay = 0, De = null, db, CS = db = !1, zS = {}, LS = {}, HS = {};
    S = function(t, e, a) {
      if (a !== null && typeof a == "object" && a._store && (!a._store.validated && a.key == null || a._store.validated === 2)) {
        if (typeof a._store != "object")
          throw Error(
            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
          );
        a._store.validated = 1;
        var f = Mt(t), p = f || "null";
        if (!zS[p]) {
          zS[p] = !0, a = a._owner, t = t._debugOwner;
          var y = "";
          t && typeof t.tag == "number" && (p = Mt(t)) && (y = `

Check the render method of \`` + p + "`."), y || f && (y = `

Check the top-level render call using <` + f + ">.");
          var M = "";
          a != null && t !== a && (f = null, typeof a.tag == "number" ? f = Mt(a) : typeof a.name == "string" && (f = a.name), f && (M = " It was passed a child from " + f + ".")), Vt(e, function() {
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              y,
              M
            );
          });
        }
      }
    };
    var gp = th(!0), kS = th(!1), ms = ne(null), eu = null, yp = 1, Dy = 2, Yi = ne(0), NS = {}, US = /* @__PURE__ */ new Set(), BS = /* @__PURE__ */ new Set(), YS = /* @__PURE__ */ new Set(), jS = /* @__PURE__ */ new Set(), qS = /* @__PURE__ */ new Set(), ZS = /* @__PURE__ */ new Set(), VS = /* @__PURE__ */ new Set(), PS = /* @__PURE__ */ new Set(), GS = /* @__PURE__ */ new Set(), XS = /* @__PURE__ */ new Set();
    Object.freeze(NS);
    var mb = {
      enqueueSetState: function(t, e, a) {
        t = t._reactInternals;
        var f = Ra(t), p = Gn(f);
        p.payload = e, a != null && (Gp(a), p.callback = a), e = wa(t, p, f), e !== null && (Rn(e, t, f), ll(e, t, f)), ma(t, f);
      },
      enqueueReplaceState: function(t, e, a) {
        t = t._reactInternals;
        var f = Ra(t), p = Gn(f);
        p.tag = fS, p.payload = e, a != null && (Gp(a), p.callback = a), e = wa(t, p, f), e !== null && (Rn(e, t, f), ll(e, t, f)), ma(t, f);
      },
      enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var a = Ra(t), f = Gn(a);
        f.tag = hS, e != null && (Gp(e), f.callback = e), e = wa(t, f, a), e !== null && (Rn(e, t, a), ll(e, t, a)), jt !== null && typeof jt.markForceUpdateScheduled == "function" && jt.markForceUpdateScheduled(t, a);
      }
    }, pb = typeof reportError == "function" ? reportError : function(t) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var e = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof t == "object" && t !== null && typeof t.message == "string" ? String(t.message) : String(t),
          error: t
        });
        if (!window.dispatchEvent(e)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", t);
        return;
      }
      console.error(t);
    }, vp = null, gb = null, QS = Error(
      "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
    ), Ji = !1, KS = {}, WS = {}, JS = {}, IS = {}, _p = !1, $S = {}, yb = {}, vb = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    }, FS = !1, tT = null;
    tT = /* @__PURE__ */ new Set();
    var ic = !1, oi = !1, _b = !1, eT = typeof WeakSet == "function" ? WeakSet : Set, Ii = null, bp = null, Sp = null, xi = null, Go = !1, or = null, Ry = 8192, fE = {
      getCacheForType: function(t) {
        var e = tn(Ui), a = e.data.get(t);
        return a === void 0 && (a = t(), e.data.set(t, a)), a;
      },
      getOwner: function() {
        return ro;
      }
    };
    if (typeof Symbol == "function" && Symbol.for) {
      var Cy = Symbol.for;
      Cy("selector.component"), Cy("selector.has_pseudo_class"), Cy("selector.role"), Cy("selector.test_id"), Cy("selector.text");
    }
    var hE = [], dE = typeof WeakMap == "function" ? WeakMap : Map, yl = 0, ho = 2, lr = 4, ac = 0, zy = 1, Tp = 2, bb = 3, Jh = 4, O_ = 6, nT = 5, Ie = yl, mn = null, ke = null, Ne = 0, Xo = 0, Ly = 1, Ih = 2, Hy = 3, iT = 4, Sb = 5, xp = 6, ky = 7, Tb = 8, $h = 9, an = Xo, vl = null, df = !1, wp = !1, xb = !1, nu = 0, Kn = ac, mf = 0, pf = 0, wb = 0, _l = 0, Fh = 0, Ny = null, mo = null, A_ = !1, Mb = 0, aT = 300, D_ = 1 / 0, oT = 500, Uy = null, gf = null, mE = 0, pE = 1, gE = 2, td = 0, lT = 1, sT = 2, rT = 3, yE = 4, Eb = 5, ha = 0, yf = null, Mp = null, vf = 0, Ob = 0, Ab = null, uT = null, vE = 50, By = 0, Db = null, Rb = !1, R_ = !1, _E = 50, ed = 0, Yy = null, Ep = !1, C_ = null, cT = !1, fT = /* @__PURE__ */ new Set(), bE = {}, z_ = null, Op = null, Cb = !1, zb = !1, L_ = !1, Lb = !1, nd = 0, Hb = {};
    (function() {
      for (var t = 0; t < I0.length; t++) {
        var e = I0[t], a = e.toLowerCase();
        e = e[0].toUpperCase() + e.slice(1), Wa(a, "on" + e);
      }
      Wa(W1, "onAnimationEnd"), Wa(J1, "onAnimationIteration"), Wa(I1, "onAnimationStart"), Wa("dblclick", "onDoubleClick"), Wa("focusin", "onFocus"), Wa("focusout", "onBlur"), Wa(IM, "onTransitionRun"), Wa($M, "onTransitionStart"), Wa(FM, "onTransitionCancel"), Wa($1, "onTransitionEnd");
    })(), Ht("onMouseEnter", ["mouseout", "mouseover"]), Ht("onMouseLeave", ["mouseout", "mouseover"]), Ht("onPointerEnter", ["pointerout", "pointerover"]), Ht("onPointerLeave", ["pointerout", "pointerover"]), Dt(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ), Dt(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ), Dt("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), Dt(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ), Dt(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ), Dt(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var jy = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), kb = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(jy)
    ), H_ = "_reactListening" + Math.random().toString(36).slice(2), hT = !1, dT = !1, k_ = !1, mT = !1, N_ = !1, U_ = !1, pT = !1, B_ = {}, SE = /\r\n?/g, TE = /\u0000|\uFFFD/g, id = "http://www.w3.org/1999/xlink", Nb = "http://www.w3.org/XML/1998/namespace", xE = "javascript:throw new Error('React form unexpectedly submitted.')", wE = "suppressHydrationWarning", Y_ = "$", j_ = "/$", oc = "$?", qy = "$!", ME = 1, EE = 2, OE = 4, Ub = "F!", gT = "F", yT = "complete", AE = "style", lc = 0, Ap = 1, q_ = 2, Bb = null, Yb = null, vT = { dialog: !0, webview: !0 }, jb = null, _T = typeof setTimeout == "function" ? setTimeout : void 0, DE = typeof clearTimeout == "function" ? clearTimeout : void 0, ad = -1, bT = typeof Promise == "function" ? Promise : void 0, RE = typeof queueMicrotask == "function" ? queueMicrotask : typeof bT < "u" ? function(t) {
      return bT.resolve(null).then(t).catch(Cg);
    } : _T, qb = null, od = 0, Zy = 1, ST = 2, TT = 3, ps = 4, gs = /* @__PURE__ */ new Map(), xT = /* @__PURE__ */ new Set(), sc = re.d;
    re.d = {
      f: function() {
        var t = sc.f(), e = Nu();
        return t || e;
      },
      r: function(t) {
        var e = Vn(t);
        e !== null && e.tag === 5 && e.type === "form" ? Zp(e) : sc.r(t);
      },
      D: function(t) {
        sc.D(t), Pv("dns-prefetch", t, null);
      },
      C: function(t, e) {
        sc.C(t, e), Pv("preconnect", t, e);
      },
      L: function(t, e, a) {
        sc.L(t, e, a);
        var f = Dp;
        if (f && t && e) {
          var p = 'link[rel="preload"][as="' + na(e) + '"]';
          e === "image" && a && a.imageSrcSet ? (p += '[imagesrcset="' + na(
            a.imageSrcSet
          ) + '"]', typeof a.imageSizes == "string" && (p += '[imagesizes="' + na(
            a.imageSizes
          ) + '"]')) : p += '[href="' + na(t) + '"]';
          var y = p;
          switch (e) {
            case "style":
              y = qr(t);
              break;
            case "script":
              y = Vu(t);
          }
          gs.has(y) || (t = Me(
            {
              rel: "preload",
              href: e === "image" && a && a.imageSrcSet ? void 0 : t,
              as: e
            },
            a
          ), gs.set(y, t), f.querySelector(p) !== null || e === "style" && f.querySelector(
            es(y)
          ) || e === "script" && f.querySelector(Pu(y)) || (e = f.createElement("link"), zn(e, "link", t), $(e), f.head.appendChild(e)));
        }
      },
      m: function(t, e) {
        sc.m(t, e);
        var a = Dp;
        if (a && t) {
          var f = e && typeof e.as == "string" ? e.as : "script", p = 'link[rel="modulepreload"][as="' + na(f) + '"][href="' + na(t) + '"]', y = p;
          switch (f) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              y = Vu(t);
          }
          if (!gs.has(y) && (t = Me({ rel: "modulepreload", href: t }, e), gs.set(y, t), a.querySelector(p) === null)) {
            switch (f) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (a.querySelector(Pu(y)))
                  return;
            }
            f = a.createElement("link"), zn(f, "link", t), $(f), a.head.appendChild(f);
          }
        }
      },
      X: function(t, e) {
        sc.X(t, e);
        var a = Dp;
        if (a && t) {
          var f = N(a).hoistableScripts, p = Vu(t), y = f.get(p);
          y || (y = a.querySelector(
            Pu(p)
          ), y || (t = Me({ src: t, async: !0 }, e), (e = gs.get(p)) && Yg(t, e), y = a.createElement("script"), $(y), zn(y, "link", t), a.head.appendChild(y)), y = {
            type: "script",
            instance: y,
            count: 1,
            state: null
          }, f.set(p, y));
        }
      },
      S: function(t, e, a) {
        sc.S(t, e, a);
        var f = Dp;
        if (f && t) {
          var p = N(f).hoistableStyles, y = qr(t);
          e = e || "default";
          var M = p.get(y);
          if (!M) {
            var D = { loading: od, preload: null };
            if (M = f.querySelector(
              es(y)
            ))
              D.loading = Zy | ps;
            else {
              t = Me(
                {
                  rel: "stylesheet",
                  href: t,
                  "data-precedence": e
                },
                a
              ), (a = gs.get(y)) && Bg(t, a);
              var B = M = f.createElement("link");
              $(B), zn(B, "link", t), B._p = new Promise(function(Y, lt) {
                B.onload = Y, B.onerror = lt;
              }), B.addEventListener("load", function() {
                D.loading |= Zy;
              }), B.addEventListener("error", function() {
                D.loading |= ST;
              }), D.loading |= ps, zm(M, e, f);
            }
            M = {
              type: "stylesheet",
              instance: M,
              count: 1,
              state: D
            }, p.set(y, M);
          }
        }
      },
      M: function(t, e) {
        sc.M(t, e);
        var a = Dp;
        if (a && t) {
          var f = N(a).hoistableScripts, p = Vu(t), y = f.get(p);
          y || (y = a.querySelector(
            Pu(p)
          ), y || (t = Me({ src: t, async: !0, type: "module" }, e), (e = gs.get(p)) && Yg(t, e), y = a.createElement("script"), $(y), zn(y, "link", t), a.head.appendChild(y)), y = {
            type: "script",
            instance: y,
            count: 1,
            state: null
          }, f.set(p, y));
        }
      }
    };
    var Dp = typeof document > "u" ? null : document, Z_ = null, Vy = null, Zb = null, V_ = null, ld = j0, Py = {
      $$typeof: qo,
      Provider: null,
      Consumer: null,
      _currentValue: ld,
      _currentValue2: ld,
      _threadCount: 0
    }, wT = "%c%s%c ", MT = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", ET = "", P_ = " ", CE = Function.prototype.bind, OT = !1, AT = null, DT = null, RT = null, CT = null, zT = null, LT = null, HT = null, kT = null, NT = null;
    AT = function(t, e, a, f) {
      e = s(t, e), e !== null && (a = i(e.memoizedState, a, 0, f), e.memoizedState = a, e.baseState = a, t.memoizedProps = Me({}, t.memoizedProps), a = mi(t, 2), a !== null && Rn(a, t, 2));
    }, DT = function(t, e, a) {
      e = s(t, e), e !== null && (a = h(e.memoizedState, a, 0), e.memoizedState = a, e.baseState = a, t.memoizedProps = Me({}, t.memoizedProps), a = mi(t, 2), a !== null && Rn(a, t, 2));
    }, RT = function(t, e, a, f) {
      e = s(t, e), e !== null && (a = l(e.memoizedState, a, f), e.memoizedState = a, e.baseState = a, t.memoizedProps = Me({}, t.memoizedProps), a = mi(t, 2), a !== null && Rn(a, t, 2));
    }, CT = function(t, e, a) {
      t.pendingProps = i(t.memoizedProps, e, 0, a), t.alternate && (t.alternate.pendingProps = t.pendingProps), e = mi(t, 2), e !== null && Rn(e, t, 2);
    }, zT = function(t, e) {
      t.pendingProps = h(t.memoizedProps, e, 0), t.alternate && (t.alternate.pendingProps = t.pendingProps), e = mi(t, 2), e !== null && Rn(e, t, 2);
    }, LT = function(t, e, a) {
      t.pendingProps = l(
        t.memoizedProps,
        e,
        a
      ), t.alternate && (t.alternate.pendingProps = t.pendingProps), e = mi(t, 2), e !== null && Rn(e, t, 2);
    }, HT = function(t) {
      var e = mi(t, 2);
      e !== null && Rn(e, t, 2);
    }, kT = function(t) {
      _ = t;
    }, NT = function(t) {
      g = t;
    };
    var G_ = !0, X_ = null, Vb = !1, _f = null, bf = null, Sf = null, Gy = /* @__PURE__ */ new Map(), Xy = /* @__PURE__ */ new Map(), Tf = [], zE = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    ), Q_ = null;
    if (Oh.prototype.render = Bm.prototype.render = function(t) {
      var e = this._internalRoot;
      if (e === null) throw Error("Cannot update an unmounted root.");
      var a = arguments;
      typeof a[1] == "function" ? console.error(
        "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ) : X(a[1]) ? console.error(
        "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
      ) : typeof a[1] < "u" && console.error(
        "You passed a second argument to root.render(...) but it only accepts one argument."
      ), a = t;
      var f = e.current, p = Ra(f);
      Je(f, p, a, e, null, null);
    }, Oh.prototype.unmount = Bm.prototype.unmount = function() {
      var t = arguments;
      if (typeof t[0] == "function" && console.error(
        "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ), t = this._internalRoot, t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        (Ie & (ho | lr)) !== yl && console.error(
          "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
        ), Je(t.current, 2, null, t, null, null), Nu(), e[Wr] = null;
      }
    }, Oh.prototype.unstable_scheduleHydration = function(t) {
      if (t) {
        var e = fr();
        t = { blockedOn: null, target: t, priority: e };
        for (var a = 0; a < Tf.length && e !== 0 && e < Tf[a].priority; a++) ;
        Tf.splice(a, 0, t), a === 0 && Jv(t);
      }
    }, function() {
      var t = Ah.version;
      if (t !== "19.1.1")
        throw Error(
          `Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (t + `
  - react-dom:  19.1.1
Learn more: https://react.dev/warnings/version-mismatch`)
        );
    }(), typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
    ), re.findDOMNode = function(t) {
      var e = t._reactInternals;
      if (e === void 0)
        throw typeof t.render == "function" ? Error("Unable to find node on an unmounted component.") : (t = Object.keys(t).join(","), Error(
          "Argument appears to not be a ReactComponent. Keys: " + t
        ));
      return t = Lt(e), t = t !== null ? yt(t) : null, t = t === null ? null : t.stateNode, t;
    }, !function() {
      var t = {
        bundleType: 1,
        version: "19.1.1",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ft,
        reconcilerVersion: "19.1.1"
      };
      return t.overrideHookState = AT, t.overrideHookStateDeletePath = DT, t.overrideHookStateRenamePath = RT, t.overrideProps = CT, t.overridePropsDeletePath = zT, t.overridePropsRenamePath = LT, t.scheduleUpdate = HT, t.setErrorHandler = kT, t.setSuspenseHandler = NT, t.scheduleRefresh = J, t.scheduleRoot = j, t.setRefreshHandler = Q, t.getCurrentFiber = N0, t.getLaneLabelMap = U0, t.injectProfilingHooks = We, zt(t);
    }() && Z && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && navigator.userAgent.indexOf("Edge") === -1 || -1 < navigator.userAgent.indexOf("Firefox"))) {
      var UT = window.location.protocol;
      /^(https?|file):$/.test(UT) && console.info(
        "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (UT === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq` : ""),
        "font-weight:bold"
      );
    }
    Jy.createRoot = function(t, e) {
      if (!X(t))
        throw Error("Target container is not a DOM element.");
      Fv(t);
      var a = !1, f = "", p = Xp, y = Av, M = Gd, D = null;
      return e != null && (e.hydrate ? console.warn(
        "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
      ) : typeof e == "object" && e !== null && e.$$typeof === Pr && console.error(
        `You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`
      ), e.unstable_strictMode === !0 && (a = !0), e.identifierPrefix !== void 0 && (f = e.identifierPrefix), e.onUncaughtError !== void 0 && (p = e.onUncaughtError), e.onCaughtError !== void 0 && (y = e.onCaughtError), e.onRecoverableError !== void 0 && (M = e.onRecoverableError), e.unstable_transitionCallbacks !== void 0 && (D = e.unstable_transitionCallbacks)), e = Zg(
        t,
        1,
        !1,
        null,
        null,
        a,
        f,
        p,
        y,
        M,
        D,
        null
      ), t[Wr] = e.current, wg(t), new Bm(e);
    }, Jy.hydrateRoot = function(t, e, a) {
      if (!X(t))
        throw Error("Target container is not a DOM element.");
      Fv(t), e === void 0 && console.error(
        "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
      );
      var f = !1, p = "", y = Xp, M = Av, D = Gd, B = null, Y = null;
      return a != null && (a.unstable_strictMode === !0 && (f = !0), a.identifierPrefix !== void 0 && (p = a.identifierPrefix), a.onUncaughtError !== void 0 && (y = a.onUncaughtError), a.onCaughtError !== void 0 && (M = a.onCaughtError), a.onRecoverableError !== void 0 && (D = a.onRecoverableError), a.unstable_transitionCallbacks !== void 0 && (B = a.unstable_transitionCallbacks), a.formState !== void 0 && (Y = a.formState)), e = Zg(
        t,
        1,
        !0,
        e,
        a ?? null,
        f,
        p,
        y,
        M,
        D,
        B,
        Y
      ), e.context = Vg(null), a = e.current, f = Ra(a), f = Zn(f), p = Gn(f), p.callback = null, wa(a, p, f), a = f, e.current.lanes = a, po(e, a), Bo(e), t[Wr] = e.current, wg(t), new Oh(e);
    }, Jy.version = "19.1.1", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Jy;
}
var $T;
function XE() {
  if ($T) return J_.exports;
  $T = 1;
  function s() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s);
      } catch (i) {
        console.error(i);
      }
    }
  }
  return process.env.NODE_ENV === "production" ? (s(), J_.exports = PE()) : J_.exports = GE(), J_.exports;
}
var QE = XE();
function KE({ value: s, onChange: i }) {
  const [l, u] = $i.useState([]);
  return $i.useEffect(() => {
    fetch("/api/products").then((h) => h.json()).then(u).catch((h) => console.error("products error", h));
  }, []), /* @__PURE__ */ ee.jsx("select", { value: s, onChange: (h) => i(h.target.value), className: "form-select", children: l.map((h) => /* @__PURE__ */ ee.jsx("option", { value: h.name, children: h.label }, h.name)) });
}
function WE({ value: s, onChange: i }) {
  const [l, u] = $i.useState([]);
  return $i.useEffect(() => {
    fetch("/api/cities").then((h) => h.json()).then(u).catch((h) => console.error("cities error", h));
  }, []), /* @__PURE__ */ ee.jsxs("select", { value: s, onChange: (h) => i(h.target.value), className: "form-select", children: [
    /* @__PURE__ */ ee.jsx("option", { value: "", children: "Wszystkie miasta..." }),
    l.map((h) => /* @__PURE__ */ ee.jsx("option", { value: h, children: h }, h))
  ] });
}
function JE({ sort: s, order: i, onSortChange: l, onOrderChange: u }) {
  return /* @__PURE__ */ ee.jsxs("div", { className: "d-flex gap-2 my-2", children: [
    /* @__PURE__ */ ee.jsxs("select", { value: s, onChange: (h) => l(h.target.value), className: "form-select form-select-sm", children: [
      /* @__PURE__ */ ee.jsx("option", { value: "price", children: "Cena" }),
      /* @__PURE__ */ ee.jsx("option", { value: "expiration", children: "Wano" }),
      /* @__PURE__ */ ee.jsx("option", { value: "fetched_at", children: "Data pobrania" })
    ] }),
    /* @__PURE__ */ ee.jsxs("select", { value: i, onChange: (h) => u(h.target.value), className: "form-select form-select-sm", children: [
      /* @__PURE__ */ ee.jsx("option", { value: "asc", children: "Rosnco" }),
      /* @__PURE__ */ ee.jsx("option", { value: "desc", children: "Malejco" })
    ] })
  ] });
}
function IE({ offers: s }) {
  return /* @__PURE__ */ ee.jsx("div", { className: "table-responsive", children: /* @__PURE__ */ ee.jsxs("table", { className: "table table-bordered", children: [
    /* @__PURE__ */ ee.jsx("thead", { children: /* @__PURE__ */ ee.jsxs("tr", { children: [
      /* @__PURE__ */ ee.jsx("th", { children: "Cena (za 1 g)" }),
      /* @__PURE__ */ ee.jsx("th", { children: "Apteka" }),
      /* @__PURE__ */ ee.jsx("th", { children: "Adres" }),
      /* @__PURE__ */ ee.jsx("th", { children: "Mapa" })
    ] }) }),
    /* @__PURE__ */ ee.jsx("tbody", { children: s.map((i, l) => /* @__PURE__ */ ee.jsxs("tr", { children: [
      /* @__PURE__ */ ee.jsxs("td", { children: [
        (i.price_per_g ?? i.price).toFixed(2),
        " z"
      ] }),
      /* @__PURE__ */ ee.jsx("td", { children: i.pharmacy ?? "" }),
      /* @__PURE__ */ ee.jsx("td", { children: i.address ?? "" }),
      /* @__PURE__ */ ee.jsx("td", { children: i.map_url ? /* @__PURE__ */ ee.jsx("a", { href: i.map_url, target: "_blank", className: "btn btn-sm btn-outline-light", children: "Mapa" }) : "" })
    ] }, l)) })
  ] }) });
}
function $E({ total: s, limit: i, offset: l, onChange: u }) {
  const h = Math.ceil(s / i), g = Math.floor(l / i) + 1;
  return h <= 1 ? null : /* @__PURE__ */ ee.jsx("div", { className: "my-3", id: "pagination", children: Array.from({ length: h }, (_, S) => S + 1).map((_) => /* @__PURE__ */ ee.jsx(
    "button",
    {
      className: "btn btn-outline-light btn-sm mx-1",
      disabled: _ === g,
      onClick: () => u((_ - 1) * i),
      children: _
    },
    _
  )) });
}
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function bv(s) {
  return s + 0.5 | 0;
}
const wf = (s, i, l) => Math.max(Math.min(s, l), i);
function lv(s) {
  return wf(bv(s * 2.55), 0, 255);
}
function Mf(s) {
  return wf(bv(s * 255), 0, 255);
}
function hc(s) {
  return wf(bv(s / 2.55) / 100, 0, 1);
}
function FT(s) {
  return wf(bv(s * 100), 0, 100);
}
const ys = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, s1 = [..."0123456789ABCDEF"], FE = (s) => s1[s & 15], t2 = (s) => s1[(s & 240) >> 4] + s1[s & 15], F_ = (s) => (s & 240) >> 4 === (s & 15), e2 = (s) => F_(s.r) && F_(s.g) && F_(s.b) && F_(s.a);
function n2(s) {
  var i = s.length, l;
  return s[0] === "#" && (i === 4 || i === 5 ? l = {
    r: 255 & ys[s[1]] * 17,
    g: 255 & ys[s[2]] * 17,
    b: 255 & ys[s[3]] * 17,
    a: i === 5 ? ys[s[4]] * 17 : 255
  } : (i === 7 || i === 9) && (l = {
    r: ys[s[1]] << 4 | ys[s[2]],
    g: ys[s[3]] << 4 | ys[s[4]],
    b: ys[s[5]] << 4 | ys[s[6]],
    a: i === 9 ? ys[s[7]] << 4 | ys[s[8]] : 255
  })), l;
}
const i2 = (s, i) => s < 255 ? i(s) : "";
function a2(s) {
  var i = e2(s) ? FE : t2;
  return s ? "#" + i(s.r) + i(s.g) + i(s.b) + i2(s.a, i) : void 0;
}
const o2 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function xw(s, i, l) {
  const u = i * Math.min(l, 1 - l), h = (g, _ = (g + s / 30) % 12) => l - u * Math.max(Math.min(_ - 3, 9 - _, 1), -1);
  return [h(0), h(8), h(4)];
}
function l2(s, i, l) {
  const u = (h, g = (h + s / 60) % 6) => l - l * i * Math.max(Math.min(g, 4 - g, 1), 0);
  return [u(5), u(3), u(1)];
}
function s2(s, i, l) {
  const u = xw(s, 1, 0.5);
  let h;
  for (i + l > 1 && (h = 1 / (i + l), i *= h, l *= h), h = 0; h < 3; h++)
    u[h] *= 1 - i - l, u[h] += i;
  return u;
}
function r2(s, i, l, u, h) {
  return s === h ? (i - l) / u + (i < l ? 6 : 0) : i === h ? (l - s) / u + 2 : (s - i) / u + 4;
}
function _1(s) {
  const l = s.r / 255, u = s.g / 255, h = s.b / 255, g = Math.max(l, u, h), _ = Math.min(l, u, h), S = (g + _) / 2;
  let T, E, A;
  return g !== _ && (A = g - _, E = S > 0.5 ? A / (2 - g - _) : A / (g + _), T = r2(l, u, h, A, g), T = T * 60 + 0.5), [T | 0, E || 0, S];
}
function b1(s, i, l, u) {
  return (Array.isArray(i) ? s(i[0], i[1], i[2]) : s(i, l, u)).map(Mf);
}
function S1(s, i, l) {
  return b1(xw, s, i, l);
}
function u2(s, i, l) {
  return b1(s2, s, i, l);
}
function c2(s, i, l) {
  return b1(l2, s, i, l);
}
function ww(s) {
  return (s % 360 + 360) % 360;
}
function f2(s) {
  const i = o2.exec(s);
  let l = 255, u;
  if (!i)
    return;
  i[5] !== u && (l = i[6] ? lv(+i[5]) : Mf(+i[5]));
  const h = ww(+i[2]), g = +i[3] / 100, _ = +i[4] / 100;
  return i[1] === "hwb" ? u = u2(h, g, _) : i[1] === "hsv" ? u = c2(h, g, _) : u = S1(h, g, _), {
    r: u[0],
    g: u[1],
    b: u[2],
    a: l
  };
}
function h2(s, i) {
  var l = _1(s);
  l[0] = ww(l[0] + i), l = S1(l), s.r = l[0], s.g = l[1], s.b = l[2];
}
function d2(s) {
  if (!s)
    return;
  const i = _1(s), l = i[0], u = FT(i[1]), h = FT(i[2]);
  return s.a < 255 ? `hsla(${l}, ${u}%, ${h}%, ${hc(s.a)})` : `hsl(${l}, ${u}%, ${h}%)`;
}
const tx = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, ex = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function m2() {
  const s = {}, i = Object.keys(ex), l = Object.keys(tx);
  let u, h, g, _, S;
  for (u = 0; u < i.length; u++) {
    for (_ = S = i[u], h = 0; h < l.length; h++)
      g = l[h], S = S.replace(g, tx[g]);
    g = parseInt(ex[_], 16), s[S] = [g >> 16 & 255, g >> 8 & 255, g & 255];
  }
  return s;
}
let t0;
function p2(s) {
  t0 || (t0 = m2(), t0.transparent = [0, 0, 0, 0]);
  const i = t0[s.toLowerCase()];
  return i && {
    r: i[0],
    g: i[1],
    b: i[2],
    a: i.length === 4 ? i[3] : 255
  };
}
const g2 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function y2(s) {
  const i = g2.exec(s);
  let l = 255, u, h, g;
  if (i) {
    if (i[7] !== u) {
      const _ = +i[7];
      l = i[8] ? lv(_) : wf(_ * 255, 0, 255);
    }
    return u = +i[1], h = +i[3], g = +i[5], u = 255 & (i[2] ? lv(u) : wf(u, 0, 255)), h = 255 & (i[4] ? lv(h) : wf(h, 0, 255)), g = 255 & (i[6] ? lv(g) : wf(g, 0, 255)), {
      r: u,
      g: h,
      b: g,
      a: l
    };
  }
}
function v2(s) {
  return s && (s.a < 255 ? `rgba(${s.r}, ${s.g}, ${s.b}, ${hc(s.a)})` : `rgb(${s.r}, ${s.g}, ${s.b})`);
}
const Xb = (s) => s <= 31308e-7 ? s * 12.92 : Math.pow(s, 1 / 2.4) * 1.055 - 0.055, Rp = (s) => s <= 0.04045 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);
function _2(s, i, l) {
  const u = Rp(hc(s.r)), h = Rp(hc(s.g)), g = Rp(hc(s.b));
  return {
    r: Mf(Xb(u + l * (Rp(hc(i.r)) - u))),
    g: Mf(Xb(h + l * (Rp(hc(i.g)) - h))),
    b: Mf(Xb(g + l * (Rp(hc(i.b)) - g))),
    a: s.a + l * (i.a - s.a)
  };
}
function e0(s, i, l) {
  if (s) {
    let u = _1(s);
    u[i] = Math.max(0, Math.min(u[i] + u[i] * l, i === 0 ? 360 : 1)), u = S1(u), s.r = u[0], s.g = u[1], s.b = u[2];
  }
}
function Mw(s, i) {
  return s && Object.assign(i || {}, s);
}
function nx(s) {
  var i = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(s) ? s.length >= 3 && (i = { r: s[0], g: s[1], b: s[2], a: 255 }, s.length > 3 && (i.a = Mf(s[3]))) : (i = Mw(s, { r: 0, g: 0, b: 0, a: 1 }), i.a = Mf(i.a)), i;
}
function b2(s) {
  return s.charAt(0) === "r" ? y2(s) : f2(s);
}
class pv {
  constructor(i) {
    if (i instanceof pv)
      return i;
    const l = typeof i;
    let u;
    l === "object" ? u = nx(i) : l === "string" && (u = n2(i) || p2(i) || b2(i)), this._rgb = u, this._valid = !!u;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var i = Mw(this._rgb);
    return i && (i.a = hc(i.a)), i;
  }
  set rgb(i) {
    this._rgb = nx(i);
  }
  rgbString() {
    return this._valid ? v2(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? a2(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? d2(this._rgb) : void 0;
  }
  mix(i, l) {
    if (i) {
      const u = this.rgb, h = i.rgb;
      let g;
      const _ = l === g ? 0.5 : l, S = 2 * _ - 1, T = u.a - h.a, E = ((S * T === -1 ? S : (S + T) / (1 + S * T)) + 1) / 2;
      g = 1 - E, u.r = 255 & E * u.r + g * h.r + 0.5, u.g = 255 & E * u.g + g * h.g + 0.5, u.b = 255 & E * u.b + g * h.b + 0.5, u.a = _ * u.a + (1 - _) * h.a, this.rgb = u;
    }
    return this;
  }
  interpolate(i, l) {
    return i && (this._rgb = _2(this._rgb, i._rgb, l)), this;
  }
  clone() {
    return new pv(this.rgb);
  }
  alpha(i) {
    return this._rgb.a = Mf(i), this;
  }
  clearer(i) {
    const l = this._rgb;
    return l.a *= 1 - i, this;
  }
  greyscale() {
    const i = this._rgb, l = bv(i.r * 0.3 + i.g * 0.59 + i.b * 0.11);
    return i.r = i.g = i.b = l, this;
  }
  opaquer(i) {
    const l = this._rgb;
    return l.a *= 1 + i, this;
  }
  negate() {
    const i = this._rgb;
    return i.r = 255 - i.r, i.g = 255 - i.g, i.b = 255 - i.b, this;
  }
  lighten(i) {
    return e0(this._rgb, 2, i), this;
  }
  darken(i) {
    return e0(this._rgb, 2, -i), this;
  }
  saturate(i) {
    return e0(this._rgb, 1, i), this;
  }
  desaturate(i) {
    return e0(this._rgb, 1, -i), this;
  }
  rotate(i) {
    return h2(this._rgb, i), this;
  }
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
function uc() {
}
const S2 = /* @__PURE__ */ (() => {
  let s = 0;
  return () => s++;
})();
function Mn(s) {
  return s == null;
}
function Fi(s) {
  if (Array.isArray && Array.isArray(s))
    return !0;
  const i = Object.prototype.toString.call(s);
  return i.slice(0, 7) === "[object" && i.slice(-6) === "Array]";
}
function Pe(s) {
  return s !== null && Object.prototype.toString.call(s) === "[object Object]";
}
function qa(s) {
  return (typeof s == "number" || s instanceof Number) && isFinite(+s);
}
function iu(s, i) {
  return qa(s) ? s : i;
}
function gn(s, i) {
  return typeof s > "u" ? i : s;
}
const T2 = (s, i) => typeof s == "string" && s.endsWith("%") ? parseFloat(s) / 100 * i : +s;
function si(s, i, l) {
  if (s && typeof s.call == "function")
    return s.apply(l, i);
}
function un(s, i, l, u) {
  let h, g, _;
  if (Fi(s))
    for (g = s.length, h = 0; h < g; h++)
      i.call(l, s[h], h);
  else if (Pe(s))
    for (_ = Object.keys(s), g = _.length, h = 0; h < g; h++)
      i.call(l, s[_[h]], _[h]);
}
function v0(s, i) {
  let l, u, h, g;
  if (!s || !i || s.length !== i.length)
    return !1;
  for (l = 0, u = s.length; l < u; ++l)
    if (h = s[l], g = i[l], h.datasetIndex !== g.datasetIndex || h.index !== g.index)
      return !1;
  return !0;
}
function _0(s) {
  if (Fi(s))
    return s.map(_0);
  if (Pe(s)) {
    const i = /* @__PURE__ */ Object.create(null), l = Object.keys(s), u = l.length;
    let h = 0;
    for (; h < u; ++h)
      i[l[h]] = _0(s[l[h]]);
    return i;
  }
  return s;
}
function Ew(s) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(s) === -1;
}
function x2(s, i, l, u) {
  if (!Ew(s))
    return;
  const h = i[s], g = l[s];
  Pe(h) && Pe(g) ? gv(h, g, u) : i[s] = _0(g);
}
function gv(s, i, l) {
  const u = Fi(i) ? i : [
    i
  ], h = u.length;
  if (!Pe(s))
    return s;
  l = l || {};
  const g = l.merger || x2;
  let _;
  for (let S = 0; S < h; ++S) {
    if (_ = u[S], !Pe(_))
      continue;
    const T = Object.keys(_);
    for (let E = 0, A = T.length; E < A; ++E)
      g(T[E], s, _, l);
  }
  return s;
}
function cv(s, i) {
  return gv(s, i, {
    merger: w2
  });
}
function w2(s, i, l) {
  if (!Ew(s))
    return;
  const u = i[s], h = l[s];
  Pe(u) && Pe(h) ? cv(u, h) : Object.prototype.hasOwnProperty.call(i, s) || (i[s] = _0(h));
}
const ix = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (s) => s,
  // default resolvers
  x: (s) => s.x,
  y: (s) => s.y
};
function M2(s) {
  const i = s.split("."), l = [];
  let u = "";
  for (const h of i)
    u += h, u.endsWith("\\") ? u = u.slice(0, -1) + "." : (l.push(u), u = "");
  return l;
}
function E2(s) {
  const i = M2(s);
  return (l) => {
    for (const u of i) {
      if (u === "")
        break;
      l = l && l[u];
    }
    return l;
  };
}
function b0(s, i) {
  return (ix[i] || (ix[i] = E2(i)))(s);
}
function T1(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
const S0 = (s) => typeof s < "u", Ef = (s) => typeof s == "function", ax = (s, i) => {
  if (s.size !== i.size)
    return !1;
  for (const l of s)
    if (!i.has(l))
      return !1;
  return !0;
};
function O2(s) {
  return s.type === "mouseup" || s.type === "click" || s.type === "contextmenu";
}
const ja = Math.PI, cu = 2 * ja, A2 = cu + ja, T0 = Number.POSITIVE_INFINITY, D2 = ja / 180, sr = ja / 2, sd = ja / 4, ox = ja * 2 / 3, Ow = Math.log10, zp = Math.sign;
function fv(s, i, l) {
  return Math.abs(s - i) < l;
}
function lx(s) {
  const i = Math.round(s);
  s = fv(s, i, s / 1e3) ? i : s;
  const l = Math.pow(10, Math.floor(Ow(s))), u = s / l;
  return (u <= 1 ? 1 : u <= 2 ? 2 : u <= 5 ? 5 : 10) * l;
}
function R2(s) {
  const i = [], l = Math.sqrt(s);
  let u;
  for (u = 1; u < l; u++)
    s % u === 0 && (i.push(u), i.push(s / u));
  return l === (l | 0) && i.push(l), i.sort((h, g) => h - g).pop(), i;
}
function C2(s) {
  return typeof s == "symbol" || typeof s == "object" && s !== null && !(Symbol.toPrimitive in s || "toString" in s || "valueOf" in s);
}
function yv(s) {
  return !C2(s) && !isNaN(parseFloat(s)) && isFinite(s);
}
function z2(s, i) {
  const l = Math.round(s);
  return l - i <= s && l + i >= s;
}
function L2(s, i, l) {
  let u, h, g;
  for (u = 0, h = s.length; u < h; u++)
    g = s[u][l], isNaN(g) || (i.min = Math.min(i.min, g), i.max = Math.max(i.max, g));
}
function dd(s) {
  return s * (ja / 180);
}
function H2(s) {
  return s * (180 / ja);
}
function sx(s) {
  if (!qa(s))
    return;
  let i = 1, l = 0;
  for (; Math.round(s * i) / i !== s; )
    i *= 10, l++;
  return l;
}
function k2(s, i) {
  const l = i.x - s.x, u = i.y - s.y, h = Math.sqrt(l * l + u * u);
  let g = Math.atan2(u, l);
  return g < -0.5 * ja && (g += cu), {
    angle: g,
    distance: h
  };
}
function r1(s, i) {
  return Math.sqrt(Math.pow(i.x - s.x, 2) + Math.pow(i.y - s.y, 2));
}
function N2(s, i) {
  return (s - i + A2) % cu - ja;
}
function lu(s) {
  return (s % cu + cu) % cu;
}
function Aw(s, i, l, u) {
  const h = lu(s), g = lu(i), _ = lu(l), S = lu(g - h), T = lu(_ - h), E = lu(h - g), A = lu(h - _);
  return h === g || h === _ || u && g === _ || S > T && E < A;
}
function rr(s, i, l) {
  return Math.max(i, Math.min(l, s));
}
function U2(s) {
  return rr(s, -32768, 32767);
}
function Dw(s, i, l, u = 1e-6) {
  return s >= Math.min(i, l) - u && s <= Math.max(i, l) + u;
}
function x1(s, i, l) {
  l = l || ((_) => s[_] < i);
  let u = s.length - 1, h = 0, g;
  for (; u - h > 1; )
    g = h + u >> 1, l(g) ? h = g : u = g;
  return {
    lo: h,
    hi: u
  };
}
const md = (s, i, l, u) => x1(s, l, u ? (h) => {
  const g = s[h][i];
  return g < l || g === l && s[h + 1][i] === l;
} : (h) => s[h][i] < l), B2 = (s, i, l) => x1(s, l, (u) => s[u][i] >= l);
function Y2(s, i, l) {
  let u = 0, h = s.length;
  for (; u < h && s[u] < i; )
    u++;
  for (; h > u && s[h - 1] > l; )
    h--;
  return u > 0 || h < s.length ? s.slice(u, h) : s;
}
const Rw = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function j2(s, i) {
  if (s._chartjs) {
    s._chartjs.listeners.push(i);
    return;
  }
  Object.defineProperty(s, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        i
      ]
    }
  }), Rw.forEach((l) => {
    const u = "_onData" + T1(l), h = s[l];
    Object.defineProperty(s, l, {
      configurable: !0,
      enumerable: !1,
      value(...g) {
        const _ = h.apply(this, g);
        return s._chartjs.listeners.forEach((S) => {
          typeof S[u] == "function" && S[u](...g);
        }), _;
      }
    });
  });
}
function rx(s, i) {
  const l = s._chartjs;
  if (!l)
    return;
  const u = l.listeners, h = u.indexOf(i);
  h !== -1 && u.splice(h, 1), !(u.length > 0) && (Rw.forEach((g) => {
    delete s[g];
  }), delete s._chartjs);
}
function q2(s) {
  const i = new Set(s);
  return i.size === s.length ? s : Array.from(i);
}
const Cw = function() {
  return typeof window > "u" ? function(s) {
    return s();
  } : window.requestAnimationFrame;
}();
function zw(s, i) {
  let l = [], u = !1;
  return function(...h) {
    l = h, u || (u = !0, Cw.call(window, () => {
      u = !1, s.apply(i, l);
    }));
  };
}
function Z2(s, i) {
  let l;
  return function(...u) {
    return i ? (clearTimeout(l), l = setTimeout(s, i, u)) : s.apply(this, u), i;
  };
}
const V2 = (s) => s === "start" ? "left" : s === "end" ? "right" : "center", ux = (s, i, l) => s === "start" ? i : s === "end" ? l : (i + l) / 2;
function P2(s, i, l) {
  const u = i.length;
  let h = 0, g = u;
  if (s._sorted) {
    const { iScale: _, vScale: S, _parsed: T } = s, E = s.dataset && s.dataset.options ? s.dataset.options.spanGaps : null, A = _.axis, { min: C, max: z, minDefined: j, maxDefined: J } = _.getUserBounds();
    if (j) {
      if (h = Math.min(
        // @ts-expect-error Need to type _parsed
        md(T, A, C).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        l ? u : md(i, A, _.getPixelForValue(C)).lo
      ), E) {
        const Q = T.slice(0, h + 1).reverse().findIndex((X) => !Mn(X[S.axis]));
        h -= Math.max(0, Q);
      }
      h = rr(h, 0, u - 1);
    }
    if (J) {
      let Q = Math.max(
        // @ts-expect-error Need to type _parsed
        md(T, _.axis, z, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        l ? 0 : md(i, A, _.getPixelForValue(z), !0).hi + 1
      );
      if (E) {
        const X = T.slice(Q - 1).findIndex((et) => !Mn(et[S.axis]));
        Q += Math.max(0, X);
      }
      g = rr(Q, h, u) - h;
    } else
      g = u - h;
  }
  return {
    start: h,
    count: g
  };
}
function G2(s) {
  const { xScale: i, yScale: l, _scaleRanges: u } = s, h = {
    xmin: i.min,
    xmax: i.max,
    ymin: l.min,
    ymax: l.max
  };
  if (!u)
    return s._scaleRanges = h, !0;
  const g = u.xmin !== i.min || u.xmax !== i.max || u.ymin !== l.min || u.ymax !== l.max;
  return Object.assign(u, h), g;
}
const n0 = (s) => s === 0 || s === 1, cx = (s, i, l) => -(Math.pow(2, 10 * (s -= 1)) * Math.sin((s - i) * cu / l)), fx = (s, i, l) => Math.pow(2, -10 * s) * Math.sin((s - i) * cu / l) + 1, hv = {
  linear: (s) => s,
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => -s * (s - 2),
  easeInOutQuad: (s) => (s /= 0.5) < 1 ? 0.5 * s * s : -0.5 * (--s * (s - 2) - 1),
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => (s -= 1) * s * s + 1,
  easeInOutCubic: (s) => (s /= 0.5) < 1 ? 0.5 * s * s * s : 0.5 * ((s -= 2) * s * s + 2),
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => -((s -= 1) * s * s * s - 1),
  easeInOutQuart: (s) => (s /= 0.5) < 1 ? 0.5 * s * s * s * s : -0.5 * ((s -= 2) * s * s * s - 2),
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => (s -= 1) * s * s * s * s + 1,
  easeInOutQuint: (s) => (s /= 0.5) < 1 ? 0.5 * s * s * s * s * s : 0.5 * ((s -= 2) * s * s * s * s + 2),
  easeInSine: (s) => -Math.cos(s * sr) + 1,
  easeOutSine: (s) => Math.sin(s * sr),
  easeInOutSine: (s) => -0.5 * (Math.cos(ja * s) - 1),
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * (s - 1)),
  easeOutExpo: (s) => s === 1 ? 1 : -Math.pow(2, -10 * s) + 1,
  easeInOutExpo: (s) => n0(s) ? s : s < 0.5 ? 0.5 * Math.pow(2, 10 * (s * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (s * 2 - 1)) + 2),
  easeInCirc: (s) => s >= 1 ? s : -(Math.sqrt(1 - s * s) - 1),
  easeOutCirc: (s) => Math.sqrt(1 - (s -= 1) * s),
  easeInOutCirc: (s) => (s /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - s * s) - 1) : 0.5 * (Math.sqrt(1 - (s -= 2) * s) + 1),
  easeInElastic: (s) => n0(s) ? s : cx(s, 0.075, 0.3),
  easeOutElastic: (s) => n0(s) ? s : fx(s, 0.075, 0.3),
  easeInOutElastic(s) {
    return n0(s) ? s : s < 0.5 ? 0.5 * cx(s * 2, 0.1125, 0.45) : 0.5 + 0.5 * fx(s * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(s) {
    return s * s * ((1.70158 + 1) * s - 1.70158);
  },
  easeOutBack(s) {
    return (s -= 1) * s * ((1.70158 + 1) * s + 1.70158) + 1;
  },
  easeInOutBack(s) {
    let i = 1.70158;
    return (s /= 0.5) < 1 ? 0.5 * (s * s * (((i *= 1.525) + 1) * s - i)) : 0.5 * ((s -= 2) * s * (((i *= 1.525) + 1) * s + i) + 2);
  },
  easeInBounce: (s) => 1 - hv.easeOutBounce(1 - s),
  easeOutBounce(s) {
    return s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375;
  },
  easeInOutBounce: (s) => s < 0.5 ? hv.easeInBounce(s * 2) * 0.5 : hv.easeOutBounce(s * 2 - 1) * 0.5 + 0.5
};
function w1(s) {
  if (s && typeof s == "object") {
    const i = s.toString();
    return i === "[object CanvasPattern]" || i === "[object CanvasGradient]";
  }
  return !1;
}
function hx(s) {
  return w1(s) ? s : new pv(s);
}
function Qb(s) {
  return w1(s) ? s : new pv(s).saturate(0.5).darken(0.1).hexString();
}
const X2 = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], Q2 = [
  "color",
  "borderColor",
  "backgroundColor"
];
function K2(s) {
  s.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), s.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (i) => i !== "onProgress" && i !== "onComplete" && i !== "fn"
  }), s.set("animations", {
    colors: {
      type: "color",
      properties: Q2
    },
    numbers: {
      type: "number",
      properties: X2
    }
  }), s.describe("animations", {
    _fallback: "animation"
  }), s.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (i) => i | 0
        }
      }
    }
  });
}
function W2(s) {
  s.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const dx = /* @__PURE__ */ new Map();
function J2(s, i) {
  i = i || {};
  const l = s + JSON.stringify(i);
  let u = dx.get(l);
  return u || (u = new Intl.NumberFormat(s, i), dx.set(l, u)), u;
}
function Lw(s, i, l) {
  return J2(i, l).format(s);
}
const I2 = {
  values(s) {
    return Fi(s) ? s : "" + s;
  },
  numeric(s, i, l) {
    if (s === 0)
      return "0";
    const u = this.chart.options.locale;
    let h, g = s;
    if (l.length > 1) {
      const E = Math.max(Math.abs(l[0].value), Math.abs(l[l.length - 1].value));
      (E < 1e-4 || E > 1e15) && (h = "scientific"), g = $2(s, l);
    }
    const _ = Ow(Math.abs(g)), S = isNaN(_) ? 1 : Math.max(Math.min(-1 * Math.floor(_), 20), 0), T = {
      notation: h,
      minimumFractionDigits: S,
      maximumFractionDigits: S
    };
    return Object.assign(T, this.options.ticks.format), Lw(s, u, T);
  }
};
function $2(s, i) {
  let l = i.length > 3 ? i[2].value - i[1].value : i[1].value - i[0].value;
  return Math.abs(l) >= 1 && s !== Math.floor(s) && (l = s - Math.floor(s)), l;
}
var Hw = {
  formatters: I2
};
function F2(s) {
  s.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (i, l) => l.lineWidth,
      tickColor: (i, l) => l.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Hw.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), s.route("scale.ticks", "color", "", "color"), s.route("scale.grid", "color", "", "borderColor"), s.route("scale.border", "color", "", "borderColor"), s.route("scale.title", "color", "", "color"), s.describe("scale", {
    _fallback: !1,
    _scriptable: (i) => !i.startsWith("before") && !i.startsWith("after") && i !== "callback" && i !== "parser",
    _indexable: (i) => i !== "borderDash" && i !== "tickBorderDash" && i !== "dash"
  }), s.describe("scales", {
    _fallback: "scale"
  }), s.describe("scale.ticks", {
    _scriptable: (i) => i !== "backdropPadding" && i !== "callback",
    _indexable: (i) => i !== "backdropPadding"
  });
}
const gd = /* @__PURE__ */ Object.create(null), u1 = /* @__PURE__ */ Object.create(null);
function dv(s, i) {
  if (!i)
    return s;
  const l = i.split(".");
  for (let u = 0, h = l.length; u < h; ++u) {
    const g = l[u];
    s = s[g] || (s[g] = /* @__PURE__ */ Object.create(null));
  }
  return s;
}
function Kb(s, i, l) {
  return typeof i == "string" ? gv(dv(s, i), l) : gv(dv(s, ""), i);
}
class tO {
  constructor(i, l) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (u) => u.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (u, h) => Qb(h.backgroundColor), this.hoverBorderColor = (u, h) => Qb(h.borderColor), this.hoverColor = (u, h) => Qb(h.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(i), this.apply(l);
  }
  set(i, l) {
    return Kb(this, i, l);
  }
  get(i) {
    return dv(this, i);
  }
  describe(i, l) {
    return Kb(u1, i, l);
  }
  override(i, l) {
    return Kb(gd, i, l);
  }
  route(i, l, u, h) {
    const g = dv(this, i), _ = dv(this, u), S = "_" + l;
    Object.defineProperties(g, {
      [S]: {
        value: g[l],
        writable: !0
      },
      [l]: {
        enumerable: !0,
        get() {
          const T = this[S], E = _[h];
          return Pe(T) ? Object.assign({}, E, T) : gn(T, E);
        },
        set(T) {
          this[S] = T;
        }
      }
    });
  }
  apply(i) {
    i.forEach((l) => l(this));
  }
}
var wi = /* @__PURE__ */ new tO({
  _scriptable: (s) => !s.startsWith("on"),
  _indexable: (s) => s !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  K2,
  W2,
  F2
]);
function eO(s) {
  return !s || Mn(s.size) || Mn(s.family) ? null : (s.style ? s.style + " " : "") + (s.weight ? s.weight + " " : "") + s.size + "px " + s.family;
}
function mx(s, i, l, u, h) {
  let g = i[h];
  return g || (g = i[h] = s.measureText(h).width, l.push(h)), g > u && (u = g), u;
}
function rd(s, i, l) {
  const u = s.currentDevicePixelRatio, h = l !== 0 ? Math.max(l / 2, 0.5) : 0;
  return Math.round((i - h) * u) / u + h;
}
function px(s, i) {
  !i && !s || (i = i || s.getContext("2d"), i.save(), i.resetTransform(), i.clearRect(0, 0, s.width, s.height), i.restore());
}
function c1(s, i, l, u) {
  nO(s, i, l, u);
}
function nO(s, i, l, u, h) {
  let g, _, S, T, E, A, C, z;
  const j = i.pointStyle, J = i.rotation, Q = i.radius;
  let X = (J || 0) * D2;
  if (j && typeof j == "object" && (g = j.toString(), g === "[object HTMLImageElement]" || g === "[object HTMLCanvasElement]")) {
    s.save(), s.translate(l, u), s.rotate(X), s.drawImage(j, -j.width / 2, -j.height / 2, j.width, j.height), s.restore();
    return;
  }
  if (!(isNaN(Q) || Q <= 0)) {
    switch (s.beginPath(), j) {
      // Default includes circle
      default:
        s.arc(l, u, Q, 0, cu), s.closePath();
        break;
      case "triangle":
        A = Q, s.moveTo(l + Math.sin(X) * A, u - Math.cos(X) * Q), X += ox, s.lineTo(l + Math.sin(X) * A, u - Math.cos(X) * Q), X += ox, s.lineTo(l + Math.sin(X) * A, u - Math.cos(X) * Q), s.closePath();
        break;
      case "rectRounded":
        E = Q * 0.516, T = Q - E, _ = Math.cos(X + sd) * T, C = Math.cos(X + sd) * T, S = Math.sin(X + sd) * T, z = Math.sin(X + sd) * T, s.arc(l - C, u - S, E, X - ja, X - sr), s.arc(l + z, u - _, E, X - sr, X), s.arc(l + C, u + S, E, X, X + sr), s.arc(l - z, u + _, E, X + sr, X + ja), s.closePath();
        break;
      case "rect":
        if (!J) {
          T = Math.SQRT1_2 * Q, A = T, s.rect(l - A, u - T, 2 * A, 2 * T);
          break;
        }
        X += sd;
      /* falls through */
      case "rectRot":
        C = Math.cos(X) * Q, _ = Math.cos(X) * Q, S = Math.sin(X) * Q, z = Math.sin(X) * Q, s.moveTo(l - C, u - S), s.lineTo(l + z, u - _), s.lineTo(l + C, u + S), s.lineTo(l - z, u + _), s.closePath();
        break;
      case "crossRot":
        X += sd;
      /* falls through */
      case "cross":
        C = Math.cos(X) * Q, _ = Math.cos(X) * Q, S = Math.sin(X) * Q, z = Math.sin(X) * Q, s.moveTo(l - C, u - S), s.lineTo(l + C, u + S), s.moveTo(l + z, u - _), s.lineTo(l - z, u + _);
        break;
      case "star":
        C = Math.cos(X) * Q, _ = Math.cos(X) * Q, S = Math.sin(X) * Q, z = Math.sin(X) * Q, s.moveTo(l - C, u - S), s.lineTo(l + C, u + S), s.moveTo(l + z, u - _), s.lineTo(l - z, u + _), X += sd, C = Math.cos(X) * Q, _ = Math.cos(X) * Q, S = Math.sin(X) * Q, z = Math.sin(X) * Q, s.moveTo(l - C, u - S), s.lineTo(l + C, u + S), s.moveTo(l + z, u - _), s.lineTo(l - z, u + _);
        break;
      case "line":
        _ = Math.cos(X) * Q, S = Math.sin(X) * Q, s.moveTo(l - _, u - S), s.lineTo(l + _, u + S);
        break;
      case "dash":
        s.moveTo(l, u), s.lineTo(l + Math.cos(X) * Q, u + Math.sin(X) * Q);
        break;
      case !1:
        s.closePath();
        break;
    }
    s.fill(), i.borderWidth > 0 && s.stroke();
  }
}
function vv(s, i, l) {
  return l = l || 0.5, !i || s && s.x > i.left - l && s.x < i.right + l && s.y > i.top - l && s.y < i.bottom + l;
}
function M1(s, i) {
  s.save(), s.beginPath(), s.rect(i.left, i.top, i.right - i.left, i.bottom - i.top), s.clip();
}
function E1(s) {
  s.restore();
}
function iO(s, i, l, u, h) {
  if (!i)
    return s.lineTo(l.x, l.y);
  if (h === "middle") {
    const g = (i.x + l.x) / 2;
    s.lineTo(g, i.y), s.lineTo(g, l.y);
  } else h === "after" != !!u ? s.lineTo(i.x, l.y) : s.lineTo(l.x, i.y);
  s.lineTo(l.x, l.y);
}
function aO(s, i, l, u) {
  if (!i)
    return s.lineTo(l.x, l.y);
  s.bezierCurveTo(u ? i.cp1x : i.cp2x, u ? i.cp1y : i.cp2y, u ? l.cp2x : l.cp1x, u ? l.cp2y : l.cp1y, l.x, l.y);
}
function oO(s, i) {
  i.translation && s.translate(i.translation[0], i.translation[1]), Mn(i.rotation) || s.rotate(i.rotation), i.color && (s.fillStyle = i.color), i.textAlign && (s.textAlign = i.textAlign), i.textBaseline && (s.textBaseline = i.textBaseline);
}
function lO(s, i, l, u, h) {
  if (h.strikethrough || h.underline) {
    const g = s.measureText(u), _ = i - g.actualBoundingBoxLeft, S = i + g.actualBoundingBoxRight, T = l - g.actualBoundingBoxAscent, E = l + g.actualBoundingBoxDescent, A = h.strikethrough ? (T + E) / 2 : E;
    s.strokeStyle = s.fillStyle, s.beginPath(), s.lineWidth = h.decorationWidth || 2, s.moveTo(_, A), s.lineTo(S, A), s.stroke();
  }
}
function sO(s, i) {
  const l = s.fillStyle;
  s.fillStyle = i.color, s.fillRect(i.left, i.top, i.width, i.height), s.fillStyle = l;
}
function gx(s, i, l, u, h, g = {}) {
  const _ = Fi(i) ? i : [
    i
  ], S = g.strokeWidth > 0 && g.strokeColor !== "";
  let T, E;
  for (s.save(), s.font = h.string, oO(s, g), T = 0; T < _.length; ++T)
    E = _[T], g.backdrop && sO(s, g.backdrop), S && (g.strokeColor && (s.strokeStyle = g.strokeColor), Mn(g.strokeWidth) || (s.lineWidth = g.strokeWidth), s.strokeText(E, l, u, g.maxWidth)), s.fillText(E, l, u, g.maxWidth), lO(s, l, u, E, g), u += Number(h.lineHeight);
  s.restore();
}
function yx(s, i) {
  const { x: l, y: u, w: h, h: g, radius: _ } = i;
  s.arc(l + _.topLeft, u + _.topLeft, _.topLeft, 1.5 * ja, ja, !0), s.lineTo(l, u + g - _.bottomLeft), s.arc(l + _.bottomLeft, u + g - _.bottomLeft, _.bottomLeft, ja, sr, !0), s.lineTo(l + h - _.bottomRight, u + g), s.arc(l + h - _.bottomRight, u + g - _.bottomRight, _.bottomRight, sr, 0, !0), s.lineTo(l + h, u + _.topRight), s.arc(l + h - _.topRight, u + _.topRight, _.topRight, 0, -sr, !0), s.lineTo(l + _.topLeft, u);
}
const rO = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, uO = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function cO(s, i) {
  const l = ("" + s).match(rO);
  if (!l || l[1] === "normal")
    return i * 1.2;
  switch (s = +l[2], l[3]) {
    case "px":
      return s;
    case "%":
      s /= 100;
      break;
  }
  return i * s;
}
const fO = (s) => +s || 0;
function kw(s, i) {
  const l = {}, u = Pe(i), h = u ? Object.keys(i) : i, g = Pe(s) ? u ? (_) => gn(s[_], s[i[_]]) : (_) => s[_] : () => s;
  for (const _ of h)
    l[_] = fO(g(_));
  return l;
}
function hO(s) {
  return kw(s, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function p0(s) {
  return kw(s, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function Of(s) {
  const i = hO(s);
  return i.width = i.left + i.right, i.height = i.top + i.bottom, i;
}
function uu(s, i) {
  s = s || {}, i = i || wi.font;
  let l = gn(s.size, i.size);
  typeof l == "string" && (l = parseInt(l, 10));
  let u = gn(s.style, i.style);
  u && !("" + u).match(uO) && (console.warn('Invalid font style specified: "' + u + '"'), u = void 0);
  const h = {
    family: gn(s.family, i.family),
    lineHeight: cO(gn(s.lineHeight, i.lineHeight), l),
    size: l,
    style: u,
    weight: gn(s.weight, i.weight),
    string: ""
  };
  return h.string = eO(h), h;
}
function i0(s, i, l, u) {
  let h, g, _;
  for (h = 0, g = s.length; h < g; ++h)
    if (_ = s[h], _ !== void 0 && _ !== void 0)
      return _;
}
function dO(s, i, l) {
  const { min: u, max: h } = s, g = T2(i, (h - u) / 2), _ = (S, T) => l && S === 0 ? 0 : S + T;
  return {
    min: _(u, -Math.abs(g)),
    max: _(h, g)
  };
}
function yd(s, i) {
  return Object.assign(Object.create(s), i);
}
function O1(s, i = [
  ""
], l, u, h = () => s[0]) {
  const g = l || s;
  typeof u > "u" && (u = Yw("_fallback", s));
  const _ = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: s,
    _rootScopes: g,
    _fallback: u,
    _getTarget: h,
    override: (S) => O1([
      S,
      ...s
    ], i, g, u)
  };
  return new Proxy(_, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(S, T) {
      return delete S[T], delete S._keys, delete s[0][T], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(S, T) {
      return Uw(S, T, () => SO(T, i, s, S));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(S, T) {
      return Reflect.getOwnPropertyDescriptor(S._scopes[0], T);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(s[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(S, T) {
      return _x(S).includes(T);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(S) {
      return _x(S);
    },
    /**
    * A trap for setting property values.
    */
    set(S, T, E) {
      const A = S._storage || (S._storage = h());
      return S[T] = A[T] = E, delete S._keys, !0;
    }
  });
}
function Lp(s, i, l, u) {
  const h = {
    _cacheable: !1,
    _proxy: s,
    _context: i,
    _subProxy: l,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: Nw(s, u),
    setContext: (g) => Lp(s, g, l, u),
    override: (g) => Lp(s.override(g), i, l, u)
  };
  return new Proxy(h, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(g, _) {
      return delete g[_], delete s[_], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(g, _, S) {
      return Uw(g, _, () => pO(g, _, S));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(g, _) {
      return g._descriptors.allKeys ? Reflect.has(s, _) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(s, _);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(s);
    },
    /**
    * A trap for the in operator.
    */
    has(g, _) {
      return Reflect.has(s, _);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(s);
    },
    /**
    * A trap for setting property values.
    */
    set(g, _, S) {
      return s[_] = S, delete g[_], !0;
    }
  });
}
function Nw(s, i = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: l = i.scriptable, _indexable: u = i.indexable, _allKeys: h = i.allKeys } = s;
  return {
    allKeys: h,
    scriptable: l,
    indexable: u,
    isScriptable: Ef(l) ? l : () => l,
    isIndexable: Ef(u) ? u : () => u
  };
}
const mO = (s, i) => s ? s + T1(i) : i, A1 = (s, i) => Pe(i) && s !== "adapters" && (Object.getPrototypeOf(i) === null || i.constructor === Object);
function Uw(s, i, l) {
  if (Object.prototype.hasOwnProperty.call(s, i) || i === "constructor")
    return s[i];
  const u = l();
  return s[i] = u, u;
}
function pO(s, i, l) {
  const { _proxy: u, _context: h, _subProxy: g, _descriptors: _ } = s;
  let S = u[i];
  return Ef(S) && _.isScriptable(i) && (S = gO(i, S, s, l)), Fi(S) && S.length && (S = yO(i, S, s, _.isIndexable)), A1(i, S) && (S = Lp(S, h, g && g[i], _)), S;
}
function gO(s, i, l, u) {
  const { _proxy: h, _context: g, _subProxy: _, _stack: S } = l;
  if (S.has(s))
    throw new Error("Recursion detected: " + Array.from(S).join("->") + "->" + s);
  S.add(s);
  let T = i(g, _ || u);
  return S.delete(s), A1(s, T) && (T = D1(h._scopes, h, s, T)), T;
}
function yO(s, i, l, u) {
  const { _proxy: h, _context: g, _subProxy: _, _descriptors: S } = l;
  if (typeof g.index < "u" && u(s))
    return i[g.index % i.length];
  if (Pe(i[0])) {
    const T = i, E = h._scopes.filter((A) => A !== T);
    i = [];
    for (const A of T) {
      const C = D1(E, h, s, A);
      i.push(Lp(C, g, _ && _[s], S));
    }
  }
  return i;
}
function Bw(s, i, l) {
  return Ef(s) ? s(i, l) : s;
}
const vO = (s, i) => s === !0 ? i : typeof s == "string" ? b0(i, s) : void 0;
function _O(s, i, l, u, h) {
  for (const g of i) {
    const _ = vO(l, g);
    if (_) {
      s.add(_);
      const S = Bw(_._fallback, l, h);
      if (typeof S < "u" && S !== l && S !== u)
        return S;
    } else if (_ === !1 && typeof u < "u" && l !== u)
      return null;
  }
  return !1;
}
function D1(s, i, l, u) {
  const h = i._rootScopes, g = Bw(i._fallback, l, u), _ = [
    ...s,
    ...h
  ], S = /* @__PURE__ */ new Set();
  S.add(u);
  let T = vx(S, _, l, g || l, u);
  return T === null || typeof g < "u" && g !== l && (T = vx(S, _, g, T, u), T === null) ? !1 : O1(Array.from(S), [
    ""
  ], h, g, () => bO(i, l, u));
}
function vx(s, i, l, u, h) {
  for (; l; )
    l = _O(s, i, l, u, h);
  return l;
}
function bO(s, i, l) {
  const u = s._getTarget();
  i in u || (u[i] = {});
  const h = u[i];
  return Fi(h) && Pe(l) ? l : h || {};
}
function SO(s, i, l, u) {
  let h;
  for (const g of i)
    if (h = Yw(mO(g, s), l), typeof h < "u")
      return A1(s, h) ? D1(l, u, s, h) : h;
}
function Yw(s, i) {
  for (const l of i) {
    if (!l)
      continue;
    const u = l[s];
    if (typeof u < "u")
      return u;
  }
}
function _x(s) {
  let i = s._keys;
  return i || (i = s._keys = TO(s._scopes)), i;
}
function TO(s) {
  const i = /* @__PURE__ */ new Set();
  for (const l of s)
    for (const u of Object.keys(l).filter((h) => !h.startsWith("_")))
      i.add(u);
  return Array.from(i);
}
const xO = Number.EPSILON || 1e-14, Hp = (s, i) => i < s.length && !s[i].skip && s[i], jw = (s) => s === "x" ? "y" : "x";
function wO(s, i, l, u) {
  const h = s.skip ? i : s, g = i, _ = l.skip ? i : l, S = r1(g, h), T = r1(_, g);
  let E = S / (S + T), A = T / (S + T);
  E = isNaN(E) ? 0 : E, A = isNaN(A) ? 0 : A;
  const C = u * E, z = u * A;
  return {
    previous: {
      x: g.x - C * (_.x - h.x),
      y: g.y - C * (_.y - h.y)
    },
    next: {
      x: g.x + z * (_.x - h.x),
      y: g.y + z * (_.y - h.y)
    }
  };
}
function MO(s, i, l) {
  const u = s.length;
  let h, g, _, S, T, E = Hp(s, 0);
  for (let A = 0; A < u - 1; ++A)
    if (T = E, E = Hp(s, A + 1), !(!T || !E)) {
      if (fv(i[A], 0, xO)) {
        l[A] = l[A + 1] = 0;
        continue;
      }
      h = l[A] / i[A], g = l[A + 1] / i[A], S = Math.pow(h, 2) + Math.pow(g, 2), !(S <= 9) && (_ = 3 / Math.sqrt(S), l[A] = h * _ * i[A], l[A + 1] = g * _ * i[A]);
    }
}
function EO(s, i, l = "x") {
  const u = jw(l), h = s.length;
  let g, _, S, T = Hp(s, 0);
  for (let E = 0; E < h; ++E) {
    if (_ = S, S = T, T = Hp(s, E + 1), !S)
      continue;
    const A = S[l], C = S[u];
    _ && (g = (A - _[l]) / 3, S[`cp1${l}`] = A - g, S[`cp1${u}`] = C - g * i[E]), T && (g = (T[l] - A) / 3, S[`cp2${l}`] = A + g, S[`cp2${u}`] = C + g * i[E]);
  }
}
function OO(s, i = "x") {
  const l = jw(i), u = s.length, h = Array(u).fill(0), g = Array(u);
  let _, S, T, E = Hp(s, 0);
  for (_ = 0; _ < u; ++_)
    if (S = T, T = E, E = Hp(s, _ + 1), !!T) {
      if (E) {
        const A = E[i] - T[i];
        h[_] = A !== 0 ? (E[l] - T[l]) / A : 0;
      }
      g[_] = S ? E ? zp(h[_ - 1]) !== zp(h[_]) ? 0 : (h[_ - 1] + h[_]) / 2 : h[_ - 1] : h[_];
    }
  MO(s, h, g), EO(s, g, i);
}
function a0(s, i, l) {
  return Math.max(Math.min(s, l), i);
}
function AO(s, i) {
  let l, u, h, g, _, S = vv(s[0], i);
  for (l = 0, u = s.length; l < u; ++l)
    _ = g, g = S, S = l < u - 1 && vv(s[l + 1], i), g && (h = s[l], _ && (h.cp1x = a0(h.cp1x, i.left, i.right), h.cp1y = a0(h.cp1y, i.top, i.bottom)), S && (h.cp2x = a0(h.cp2x, i.left, i.right), h.cp2y = a0(h.cp2y, i.top, i.bottom)));
}
function DO(s, i, l, u, h) {
  let g, _, S, T;
  if (i.spanGaps && (s = s.filter((E) => !E.skip)), i.cubicInterpolationMode === "monotone")
    OO(s, h);
  else {
    let E = u ? s[s.length - 1] : s[0];
    for (g = 0, _ = s.length; g < _; ++g)
      S = s[g], T = wO(E, S, s[Math.min(g + 1, _ - (u ? 0 : 1)) % _], i.tension), S.cp1x = T.previous.x, S.cp1y = T.previous.y, S.cp2x = T.next.x, S.cp2y = T.next.y, E = S;
  }
  i.capBezierPoints && AO(s, l);
}
function R1() {
  return typeof window < "u" && typeof document < "u";
}
function C1(s) {
  let i = s.parentNode;
  return i && i.toString() === "[object ShadowRoot]" && (i = i.host), i;
}
function x0(s, i, l) {
  let u;
  return typeof s == "string" ? (u = parseInt(s, 10), s.indexOf("%") !== -1 && (u = u / 100 * i.parentNode[l])) : u = s, u;
}
const O0 = (s) => s.ownerDocument.defaultView.getComputedStyle(s, null);
function RO(s, i) {
  return O0(s).getPropertyValue(i);
}
const CO = [
  "top",
  "right",
  "bottom",
  "left"
];
function pd(s, i, l) {
  const u = {};
  l = l ? "-" + l : "";
  for (let h = 0; h < 4; h++) {
    const g = CO[h];
    u[g] = parseFloat(s[i + "-" + g + l]) || 0;
  }
  return u.width = u.left + u.right, u.height = u.top + u.bottom, u;
}
const zO = (s, i, l) => (s > 0 || i > 0) && (!l || !l.shadowRoot);
function LO(s, i) {
  const l = s.touches, u = l && l.length ? l[0] : s, { offsetX: h, offsetY: g } = u;
  let _ = !1, S, T;
  if (zO(h, g, s.target))
    S = h, T = g;
  else {
    const E = i.getBoundingClientRect();
    S = u.clientX - E.left, T = u.clientY - E.top, _ = !0;
  }
  return {
    x: S,
    y: T,
    box: _
  };
}
function cd(s, i) {
  if ("native" in s)
    return s;
  const { canvas: l, currentDevicePixelRatio: u } = i, h = O0(l), g = h.boxSizing === "border-box", _ = pd(h, "padding"), S = pd(h, "border", "width"), { x: T, y: E, box: A } = LO(s, l), C = _.left + (A && S.left), z = _.top + (A && S.top);
  let { width: j, height: J } = i;
  return g && (j -= _.width + S.width, J -= _.height + S.height), {
    x: Math.round((T - C) / j * l.width / u),
    y: Math.round((E - z) / J * l.height / u)
  };
}
function HO(s, i, l) {
  let u, h;
  if (i === void 0 || l === void 0) {
    const g = s && C1(s);
    if (!g)
      i = s.clientWidth, l = s.clientHeight;
    else {
      const _ = g.getBoundingClientRect(), S = O0(g), T = pd(S, "border", "width"), E = pd(S, "padding");
      i = _.width - E.width - T.width, l = _.height - E.height - T.height, u = x0(S.maxWidth, g, "clientWidth"), h = x0(S.maxHeight, g, "clientHeight");
    }
  }
  return {
    width: i,
    height: l,
    maxWidth: u || T0,
    maxHeight: h || T0
  };
}
const o0 = (s) => Math.round(s * 10) / 10;
function kO(s, i, l, u) {
  const h = O0(s), g = pd(h, "margin"), _ = x0(h.maxWidth, s, "clientWidth") || T0, S = x0(h.maxHeight, s, "clientHeight") || T0, T = HO(s, i, l);
  let { width: E, height: A } = T;
  if (h.boxSizing === "content-box") {
    const z = pd(h, "border", "width"), j = pd(h, "padding");
    E -= j.width + z.width, A -= j.height + z.height;
  }
  return E = Math.max(0, E - g.width), A = Math.max(0, u ? E / u : A - g.height), E = o0(Math.min(E, _, T.maxWidth)), A = o0(Math.min(A, S, T.maxHeight)), E && !A && (A = o0(E / 2)), (i !== void 0 || l !== void 0) && u && T.height && A > T.height && (A = T.height, E = o0(Math.floor(A * u))), {
    width: E,
    height: A
  };
}
function bx(s, i, l) {
  const u = i || 1, h = Math.floor(s.height * u), g = Math.floor(s.width * u);
  s.height = Math.floor(s.height), s.width = Math.floor(s.width);
  const _ = s.canvas;
  return _.style && (l || !_.style.height && !_.style.width) && (_.style.height = `${s.height}px`, _.style.width = `${s.width}px`), s.currentDevicePixelRatio !== u || _.height !== h || _.width !== g ? (s.currentDevicePixelRatio = u, _.height = h, _.width = g, s.ctx.setTransform(u, 0, 0, u, 0, 0), !0) : !1;
}
const NO = function() {
  let s = !1;
  try {
    const i = {
      get passive() {
        return s = !0, !1;
      }
    };
    R1() && (window.addEventListener("test", null, i), window.removeEventListener("test", null, i));
  } catch {
  }
  return s;
}();
function Sx(s, i) {
  const l = RO(s, i), u = l && l.match(/^(\d+)(\.\d+)?px$/);
  return u ? +u[1] : void 0;
}
function fd(s, i, l, u) {
  return {
    x: s.x + l * (i.x - s.x),
    y: s.y + l * (i.y - s.y)
  };
}
function UO(s, i, l, u) {
  return {
    x: s.x + l * (i.x - s.x),
    y: u === "middle" ? l < 0.5 ? s.y : i.y : u === "after" ? l < 1 ? s.y : i.y : l > 0 ? i.y : s.y
  };
}
function BO(s, i, l, u) {
  const h = {
    x: s.cp2x,
    y: s.cp2y
  }, g = {
    x: i.cp1x,
    y: i.cp1y
  }, _ = fd(s, h, l), S = fd(h, g, l), T = fd(g, i, l), E = fd(_, S, l), A = fd(S, T, l);
  return fd(E, A, l);
}
const YO = function(s, i) {
  return {
    x(l) {
      return s + s + i - l;
    },
    setWidth(l) {
      i = l;
    },
    textAlign(l) {
      return l === "center" ? l : l === "right" ? "left" : "right";
    },
    xPlus(l, u) {
      return l - u;
    },
    leftForLtr(l, u) {
      return l - u;
    }
  };
}, jO = function() {
  return {
    x(s) {
      return s;
    },
    setWidth(s) {
    },
    textAlign(s) {
      return s;
    },
    xPlus(s, i) {
      return s + i;
    },
    leftForLtr(s, i) {
      return s;
    }
  };
};
function Wb(s, i, l) {
  return s ? YO(i, l) : jO();
}
function qO(s, i) {
  let l, u;
  (i === "ltr" || i === "rtl") && (l = s.canvas.style, u = [
    l.getPropertyValue("direction"),
    l.getPropertyPriority("direction")
  ], l.setProperty("direction", i, "important"), s.prevTextDirection = u);
}
function ZO(s, i) {
  i !== void 0 && (delete s.prevTextDirection, s.canvas.style.setProperty("direction", i[0], i[1]));
}
function qw(s) {
  return s === "angle" ? {
    between: Aw,
    compare: N2,
    normalize: lu
  } : {
    between: Dw,
    compare: (i, l) => i - l,
    normalize: (i) => i
  };
}
function Tx({ start: s, end: i, count: l, loop: u, style: h }) {
  return {
    start: s % l,
    end: i % l,
    loop: u && (i - s + 1) % l === 0,
    style: h
  };
}
function VO(s, i, l) {
  const { property: u, start: h, end: g } = l, { between: _, normalize: S } = qw(u), T = i.length;
  let { start: E, end: A, loop: C } = s, z, j;
  if (C) {
    for (E += T, A += T, z = 0, j = T; z < j && _(S(i[E % T][u]), h, g); ++z)
      E--, A--;
    E %= T, A %= T;
  }
  return A < E && (A += T), {
    start: E,
    end: A,
    loop: C,
    style: s.style
  };
}
function Zw(s, i, l) {
  if (!l)
    return [
      s
    ];
  const { property: u, start: h, end: g } = l, _ = i.length, { compare: S, between: T, normalize: E } = qw(u), { start: A, end: C, loop: z, style: j } = VO(s, i, l), J = [];
  let Q = !1, X = null, et, wt, At;
  const Lt = () => T(h, At, et) && S(h, At) !== 0, yt = () => S(g, et) === 0 || T(g, At, et), Bt = () => Q || Lt(), Ct = () => !Q || yt();
  for (let Yt = A, Mt = A; Yt <= C; ++Yt)
    wt = i[Yt % _], !wt.skip && (et = E(wt[u]), et !== At && (Q = T(et, h, g), X === null && Bt() && (X = S(et, h) === 0 ? Yt : Mt), X !== null && Ct() && (J.push(Tx({
      start: X,
      end: Yt,
      loop: z,
      count: _,
      style: j
    })), X = null), Mt = Yt, At = et));
  return X !== null && J.push(Tx({
    start: X,
    end: C,
    loop: z,
    count: _,
    style: j
  })), J;
}
function Vw(s, i) {
  const l = [], u = s.segments;
  for (let h = 0; h < u.length; h++) {
    const g = Zw(u[h], s.points, i);
    g.length && l.push(...g);
  }
  return l;
}
function PO(s, i, l, u) {
  let h = 0, g = i - 1;
  if (l && !u)
    for (; h < i && !s[h].skip; )
      h++;
  for (; h < i && s[h].skip; )
    h++;
  for (h %= i, l && (g += h); g > h && s[g % i].skip; )
    g--;
  return g %= i, {
    start: h,
    end: g
  };
}
function GO(s, i, l, u) {
  const h = s.length, g = [];
  let _ = i, S = s[i], T;
  for (T = i + 1; T <= l; ++T) {
    const E = s[T % h];
    E.skip || E.stop ? S.skip || (u = !1, g.push({
      start: i % h,
      end: (T - 1) % h,
      loop: u
    }), i = _ = E.stop ? T : null) : (_ = T, S.skip && (i = T)), S = E;
  }
  return _ !== null && g.push({
    start: i % h,
    end: _ % h,
    loop: u
  }), g;
}
function XO(s, i) {
  const l = s.points, u = s.options.spanGaps, h = l.length;
  if (!h)
    return [];
  const g = !!s._loop, { start: _, end: S } = PO(l, h, g, u);
  if (u === !0)
    return xx(s, [
      {
        start: _,
        end: S,
        loop: g
      }
    ], l, i);
  const T = S < _ ? S + h : S, E = !!s._fullLoop && _ === 0 && S === h - 1;
  return xx(s, GO(l, _, T, E), l, i);
}
function xx(s, i, l, u) {
  return !u || !u.setContext || !l ? i : QO(s, i, l, u);
}
function QO(s, i, l, u) {
  const h = s._chart.getContext(), g = wx(s.options), { _datasetIndex: _, options: { spanGaps: S } } = s, T = l.length, E = [];
  let A = g, C = i[0].start, z = C;
  function j(J, Q, X, et) {
    const wt = S ? -1 : 1;
    if (J !== Q) {
      for (J += T; l[J % T].skip; )
        J -= wt;
      for (; l[Q % T].skip; )
        Q += wt;
      J % T !== Q % T && (E.push({
        start: J % T,
        end: Q % T,
        loop: X,
        style: et
      }), A = et, C = Q % T);
    }
  }
  for (const J of i) {
    C = S ? C : J.start;
    let Q = l[C % T], X;
    for (z = C + 1; z <= J.end; z++) {
      const et = l[z % T];
      X = wx(u.setContext(yd(h, {
        type: "segment",
        p0: Q,
        p1: et,
        p0DataIndex: (z - 1) % T,
        p1DataIndex: z % T,
        datasetIndex: _
      }))), KO(X, A) && j(C, z - 1, J.loop, A), Q = et, A = X;
    }
    C < z - 1 && j(C, z - 1, J.loop, A);
  }
  return E;
}
function wx(s) {
  return {
    backgroundColor: s.backgroundColor,
    borderCapStyle: s.borderCapStyle,
    borderDash: s.borderDash,
    borderDashOffset: s.borderDashOffset,
    borderJoinStyle: s.borderJoinStyle,
    borderWidth: s.borderWidth,
    borderColor: s.borderColor
  };
}
function KO(s, i) {
  if (!i)
    return !1;
  const l = [], u = function(h, g) {
    return w1(g) ? (l.includes(g) || l.push(g), l.indexOf(g)) : g;
  };
  return JSON.stringify(s, u) !== JSON.stringify(i, u);
}
function l0(s, i, l) {
  return s.options.clip ? s[l] : i[l];
}
function WO(s, i) {
  const { xScale: l, yScale: u } = s;
  return l && u ? {
    left: l0(l, i, "left"),
    right: l0(l, i, "right"),
    top: l0(u, i, "top"),
    bottom: l0(u, i, "bottom")
  } : i;
}
function Pw(s, i) {
  const l = i._clip;
  if (l.disabled)
    return !1;
  const u = WO(i, s.chartArea);
  return {
    left: l.left === !1 ? 0 : u.left - (l.left === !0 ? 0 : l.left),
    right: l.right === !1 ? s.width : u.right + (l.right === !0 ? 0 : l.right),
    top: l.top === !1 ? 0 : u.top - (l.top === !0 ? 0 : l.top),
    bottom: l.bottom === !1 ? s.height : u.bottom + (l.bottom === !0 ? 0 : l.bottom)
  };
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
class JO {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(i, l, u, h) {
    const g = l.listeners[h], _ = l.duration;
    g.forEach((S) => S({
      chart: i,
      initial: l.initial,
      numSteps: _,
      currentStep: Math.min(u - l.start, _)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Cw.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(i = Date.now()) {
    let l = 0;
    this._charts.forEach((u, h) => {
      if (!u.running || !u.items.length)
        return;
      const g = u.items;
      let _ = g.length - 1, S = !1, T;
      for (; _ >= 0; --_)
        T = g[_], T._active ? (T._total > u.duration && (u.duration = T._total), T.tick(i), S = !0) : (g[_] = g[g.length - 1], g.pop());
      S && (h.draw(), this._notify(h, u, i, "progress")), g.length || (u.running = !1, this._notify(h, u, i, "complete"), u.initial = !1), l += g.length;
    }), this._lastDate = i, l === 0 && (this._running = !1);
  }
  _getAnims(i) {
    const l = this._charts;
    let u = l.get(i);
    return u || (u = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, l.set(i, u)), u;
  }
  listen(i, l, u) {
    this._getAnims(i).listeners[l].push(u);
  }
  add(i, l) {
    !l || !l.length || this._getAnims(i).items.push(...l);
  }
  has(i) {
    return this._getAnims(i).items.length > 0;
  }
  start(i) {
    const l = this._charts.get(i);
    l && (l.running = !0, l.start = Date.now(), l.duration = l.items.reduce((u, h) => Math.max(u, h._duration), 0), this._refresh());
  }
  running(i) {
    if (!this._running)
      return !1;
    const l = this._charts.get(i);
    return !(!l || !l.running || !l.items.length);
  }
  stop(i) {
    const l = this._charts.get(i);
    if (!l || !l.items.length)
      return;
    const u = l.items;
    let h = u.length - 1;
    for (; h >= 0; --h)
      u[h].cancel();
    l.items = [], this._notify(i, l, Date.now(), "complete");
  }
  remove(i) {
    return this._charts.delete(i);
  }
}
var cc = /* @__PURE__ */ new JO();
const Mx = "transparent", IO = {
  boolean(s, i, l) {
    return l > 0.5 ? i : s;
  },
  color(s, i, l) {
    const u = hx(s || Mx), h = u.valid && hx(i || Mx);
    return h && h.valid ? h.mix(u, l).hexString() : i;
  },
  number(s, i, l) {
    return s + (i - s) * l;
  }
};
class $O {
  constructor(i, l, u, h) {
    const g = l[u];
    h = i0([
      i.to,
      h,
      g,
      i.from
    ]);
    const _ = i0([
      i.from,
      g,
      h
    ]);
    this._active = !0, this._fn = i.fn || IO[i.type || typeof _], this._easing = hv[i.easing] || hv.linear, this._start = Math.floor(Date.now() + (i.delay || 0)), this._duration = this._total = Math.floor(i.duration), this._loop = !!i.loop, this._target = l, this._prop = u, this._from = _, this._to = h, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(i, l, u) {
    if (this._active) {
      this._notify(!1);
      const h = this._target[this._prop], g = u - this._start, _ = this._duration - g;
      this._start = u, this._duration = Math.floor(Math.max(_, i.duration)), this._total += g, this._loop = !!i.loop, this._to = i0([
        i.to,
        l,
        h,
        i.from
      ]), this._from = i0([
        i.from,
        h,
        l
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(i) {
    const l = i - this._start, u = this._duration, h = this._prop, g = this._from, _ = this._loop, S = this._to;
    let T;
    if (this._active = g !== S && (_ || l < u), !this._active) {
      this._target[h] = S, this._notify(!0);
      return;
    }
    if (l < 0) {
      this._target[h] = g;
      return;
    }
    T = l / u % 2, T = _ && T > 1 ? 2 - T : T, T = this._easing(Math.min(1, Math.max(0, T))), this._target[h] = this._fn(g, S, T);
  }
  wait() {
    const i = this._promises || (this._promises = []);
    return new Promise((l, u) => {
      i.push({
        res: l,
        rej: u
      });
    });
  }
  _notify(i) {
    const l = i ? "res" : "rej", u = this._promises || [];
    for (let h = 0; h < u.length; h++)
      u[h][l]();
  }
}
class Gw {
  constructor(i, l) {
    this._chart = i, this._properties = /* @__PURE__ */ new Map(), this.configure(l);
  }
  configure(i) {
    if (!Pe(i))
      return;
    const l = Object.keys(wi.animation), u = this._properties;
    Object.getOwnPropertyNames(i).forEach((h) => {
      const g = i[h];
      if (!Pe(g))
        return;
      const _ = {};
      for (const S of l)
        _[S] = g[S];
      (Fi(g.properties) && g.properties || [
        h
      ]).forEach((S) => {
        (S === h || !u.has(S)) && u.set(S, _);
      });
    });
  }
  _animateOptions(i, l) {
    const u = l.options, h = tA(i, u);
    if (!h)
      return [];
    const g = this._createAnimations(h, u);
    return u.$shared && FO(i.options.$animations, u).then(() => {
      i.options = u;
    }, () => {
    }), g;
  }
  _createAnimations(i, l) {
    const u = this._properties, h = [], g = i.$animations || (i.$animations = {}), _ = Object.keys(l), S = Date.now();
    let T;
    for (T = _.length - 1; T >= 0; --T) {
      const E = _[T];
      if (E.charAt(0) === "$")
        continue;
      if (E === "options") {
        h.push(...this._animateOptions(i, l));
        continue;
      }
      const A = l[E];
      let C = g[E];
      const z = u.get(E);
      if (C)
        if (z && C.active()) {
          C.update(z, A, S);
          continue;
        } else
          C.cancel();
      if (!z || !z.duration) {
        i[E] = A;
        continue;
      }
      g[E] = C = new $O(z, i, E, A), h.push(C);
    }
    return h;
  }
  update(i, l) {
    if (this._properties.size === 0) {
      Object.assign(i, l);
      return;
    }
    const u = this._createAnimations(i, l);
    if (u.length)
      return cc.add(this._chart, u), !0;
  }
}
function FO(s, i) {
  const l = [], u = Object.keys(i);
  for (let h = 0; h < u.length; h++) {
    const g = s[u[h]];
    g && g.active() && l.push(g.wait());
  }
  return Promise.all(l);
}
function tA(s, i) {
  if (!i)
    return;
  let l = s.options;
  if (!l) {
    s.options = i;
    return;
  }
  return l.$shared && (s.options = l = Object.assign({}, l, {
    $shared: !1,
    $animations: {}
  })), l;
}
function Ex(s, i) {
  const l = s && s.options || {}, u = l.reverse, h = l.min === void 0 ? i : 0, g = l.max === void 0 ? i : 0;
  return {
    start: u ? g : h,
    end: u ? h : g
  };
}
function eA(s, i, l) {
  if (l === !1)
    return !1;
  const u = Ex(s, l), h = Ex(i, l);
  return {
    top: h.end,
    right: u.end,
    bottom: h.start,
    left: u.start
  };
}
function nA(s) {
  let i, l, u, h;
  return Pe(s) ? (i = s.top, l = s.right, u = s.bottom, h = s.left) : i = l = u = h = s, {
    top: i,
    right: l,
    bottom: u,
    left: h,
    disabled: s === !1
  };
}
function Xw(s, i) {
  const l = [], u = s._getSortedDatasetMetas(i);
  let h, g;
  for (h = 0, g = u.length; h < g; ++h)
    l.push(u[h].index);
  return l;
}
function Ox(s, i, l, u = {}) {
  const h = s.keys, g = u.mode === "single";
  let _, S, T, E;
  if (i === null)
    return;
  let A = !1;
  for (_ = 0, S = h.length; _ < S; ++_) {
    if (T = +h[_], T === l) {
      if (A = !0, u.all)
        continue;
      break;
    }
    E = s.values[T], qa(E) && (g || i === 0 || zp(i) === zp(E)) && (i += E);
  }
  return !A && !u.all ? 0 : i;
}
function iA(s, i) {
  const { iScale: l, vScale: u } = i, h = l.axis === "x" ? "x" : "y", g = u.axis === "x" ? "x" : "y", _ = Object.keys(s), S = new Array(_.length);
  let T, E, A;
  for (T = 0, E = _.length; T < E; ++T)
    A = _[T], S[T] = {
      [h]: A,
      [g]: s[A]
    };
  return S;
}
function Jb(s, i) {
  const l = s && s.options.stacked;
  return l || l === void 0 && i.stack !== void 0;
}
function aA(s, i, l) {
  return `${s.id}.${i.id}.${l.stack || l.type}`;
}
function oA(s) {
  const { min: i, max: l, minDefined: u, maxDefined: h } = s.getUserBounds();
  return {
    min: u ? i : Number.NEGATIVE_INFINITY,
    max: h ? l : Number.POSITIVE_INFINITY
  };
}
function lA(s, i, l) {
  const u = s[i] || (s[i] = {});
  return u[l] || (u[l] = {});
}
function Ax(s, i, l, u) {
  for (const h of i.getMatchingVisibleMetas(u).reverse()) {
    const g = s[h.index];
    if (l && g > 0 || !l && g < 0)
      return h.index;
  }
  return null;
}
function Dx(s, i) {
  const { chart: l, _cachedMeta: u } = s, h = l._stacks || (l._stacks = {}), { iScale: g, vScale: _, index: S } = u, T = g.axis, E = _.axis, A = aA(g, _, u), C = i.length;
  let z;
  for (let j = 0; j < C; ++j) {
    const J = i[j], { [T]: Q, [E]: X } = J, et = J._stacks || (J._stacks = {});
    z = et[E] = lA(h, A, Q), z[S] = X, z._top = Ax(z, _, !0, u.type), z._bottom = Ax(z, _, !1, u.type);
    const wt = z._visualValues || (z._visualValues = {});
    wt[S] = X;
  }
}
function Ib(s, i) {
  const l = s.scales;
  return Object.keys(l).filter((u) => l[u].axis === i).shift();
}
function sA(s, i) {
  return yd(s, {
    active: !1,
    dataset: void 0,
    datasetIndex: i,
    index: i,
    mode: "default",
    type: "dataset"
  });
}
function rA(s, i, l) {
  return yd(s, {
    active: !1,
    dataIndex: i,
    parsed: void 0,
    raw: void 0,
    element: l,
    index: i,
    mode: "default",
    type: "data"
  });
}
function Iy(s, i) {
  const l = s.controller.index, u = s.vScale && s.vScale.axis;
  if (u) {
    i = i || s._parsed;
    for (const h of i) {
      const g = h._stacks;
      if (!g || g[u] === void 0 || g[u][l] === void 0)
        return;
      delete g[u][l], g[u]._visualValues !== void 0 && g[u]._visualValues[l] !== void 0 && delete g[u]._visualValues[l];
    }
  }
}
const $b = (s) => s === "reset" || s === "none", Rx = (s, i) => i ? s : Object.assign({}, s), uA = (s, i, l) => s && !i.hidden && i._stacked && {
  keys: Xw(l, !0),
  values: null
};
class Qw {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(i, l) {
    this.chart = i, this._ctx = i.ctx, this.index = l, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const i = this._cachedMeta;
    this.configure(), this.linkScales(), i._stacked = Jb(i.vScale, i), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(i) {
    this.index !== i && Iy(this._cachedMeta), this.index = i;
  }
  linkScales() {
    const i = this.chart, l = this._cachedMeta, u = this.getDataset(), h = (C, z, j, J) => C === "x" ? z : C === "r" ? J : j, g = l.xAxisID = gn(u.xAxisID, Ib(i, "x")), _ = l.yAxisID = gn(u.yAxisID, Ib(i, "y")), S = l.rAxisID = gn(u.rAxisID, Ib(i, "r")), T = l.indexAxis, E = l.iAxisID = h(T, g, _, S), A = l.vAxisID = h(T, _, g, S);
    l.xScale = this.getScaleForId(g), l.yScale = this.getScaleForId(_), l.rScale = this.getScaleForId(S), l.iScale = this.getScaleForId(E), l.vScale = this.getScaleForId(A);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(i) {
    return this.chart.scales[i];
  }
  _getOtherScale(i) {
    const l = this._cachedMeta;
    return i === l.iScale ? l.vScale : l.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const i = this._cachedMeta;
    this._data && rx(this._data, this), i._stacked && Iy(i);
  }
  _dataCheck() {
    const i = this.getDataset(), l = i.data || (i.data = []), u = this._data;
    if (Pe(l)) {
      const h = this._cachedMeta;
      this._data = iA(l, h);
    } else if (u !== l) {
      if (u) {
        rx(u, this);
        const h = this._cachedMeta;
        Iy(h), h._parsed = [];
      }
      l && Object.isExtensible(l) && j2(l, this), this._syncList = [], this._data = l;
    }
  }
  addElements() {
    const i = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (i.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(i) {
    const l = this._cachedMeta, u = this.getDataset();
    let h = !1;
    this._dataCheck();
    const g = l._stacked;
    l._stacked = Jb(l.vScale, l), l.stack !== u.stack && (h = !0, Iy(l), l.stack = u.stack), this._resyncElements(i), (h || g !== l._stacked) && (Dx(this, l._parsed), l._stacked = Jb(l.vScale, l));
  }
  configure() {
    const i = this.chart.config, l = i.datasetScopeKeys(this._type), u = i.getOptionScopes(this.getDataset(), l, !0);
    this.options = i.createResolver(u, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(i, l) {
    const { _cachedMeta: u, _data: h } = this, { iScale: g, _stacked: _ } = u, S = g.axis;
    let T = i === 0 && l === h.length ? !0 : u._sorted, E = i > 0 && u._parsed[i - 1], A, C, z;
    if (this._parsing === !1)
      u._parsed = h, u._sorted = !0, z = h;
    else {
      Fi(h[i]) ? z = this.parseArrayData(u, h, i, l) : Pe(h[i]) ? z = this.parseObjectData(u, h, i, l) : z = this.parsePrimitiveData(u, h, i, l);
      const j = () => C[S] === null || E && C[S] < E[S];
      for (A = 0; A < l; ++A)
        u._parsed[A + i] = C = z[A], T && (j() && (T = !1), E = C);
      u._sorted = T;
    }
    _ && Dx(this, z);
  }
  parsePrimitiveData(i, l, u, h) {
    const { iScale: g, vScale: _ } = i, S = g.axis, T = _.axis, E = g.getLabels(), A = g === _, C = new Array(h);
    let z, j, J;
    for (z = 0, j = h; z < j; ++z)
      J = z + u, C[z] = {
        [S]: A || g.parse(E[J], J),
        [T]: _.parse(l[J], J)
      };
    return C;
  }
  parseArrayData(i, l, u, h) {
    const { xScale: g, yScale: _ } = i, S = new Array(h);
    let T, E, A, C;
    for (T = 0, E = h; T < E; ++T)
      A = T + u, C = l[A], S[T] = {
        x: g.parse(C[0], A),
        y: _.parse(C[1], A)
      };
    return S;
  }
  parseObjectData(i, l, u, h) {
    const { xScale: g, yScale: _ } = i, { xAxisKey: S = "x", yAxisKey: T = "y" } = this._parsing, E = new Array(h);
    let A, C, z, j;
    for (A = 0, C = h; A < C; ++A)
      z = A + u, j = l[z], E[A] = {
        x: g.parse(b0(j, S), z),
        y: _.parse(b0(j, T), z)
      };
    return E;
  }
  getParsed(i) {
    return this._cachedMeta._parsed[i];
  }
  getDataElement(i) {
    return this._cachedMeta.data[i];
  }
  applyStack(i, l, u) {
    const h = this.chart, g = this._cachedMeta, _ = l[i.axis], S = {
      keys: Xw(h, !0),
      values: l._stacks[i.axis]._visualValues
    };
    return Ox(S, _, g.index, {
      mode: u
    });
  }
  updateRangeFromParsed(i, l, u, h) {
    const g = u[l.axis];
    let _ = g === null ? NaN : g;
    const S = h && u._stacks[l.axis];
    h && S && (h.values = S, _ = Ox(h, g, this._cachedMeta.index)), i.min = Math.min(i.min, _), i.max = Math.max(i.max, _);
  }
  getMinMax(i, l) {
    const u = this._cachedMeta, h = u._parsed, g = u._sorted && i === u.iScale, _ = h.length, S = this._getOtherScale(i), T = uA(l, u, this.chart), E = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: A, max: C } = oA(S);
    let z, j;
    function J() {
      j = h[z];
      const Q = j[S.axis];
      return !qa(j[i.axis]) || A > Q || C < Q;
    }
    for (z = 0; z < _ && !(!J() && (this.updateRangeFromParsed(E, i, j, T), g)); ++z)
      ;
    if (g) {
      for (z = _ - 1; z >= 0; --z)
        if (!J()) {
          this.updateRangeFromParsed(E, i, j, T);
          break;
        }
    }
    return E;
  }
  getAllParsedValues(i) {
    const l = this._cachedMeta._parsed, u = [];
    let h, g, _;
    for (h = 0, g = l.length; h < g; ++h)
      _ = l[h][i.axis], qa(_) && u.push(_);
    return u;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(i) {
    const l = this._cachedMeta, u = l.iScale, h = l.vScale, g = this.getParsed(i);
    return {
      label: u ? "" + u.getLabelForValue(g[u.axis]) : "",
      value: h ? "" + h.getLabelForValue(g[h.axis]) : ""
    };
  }
  _update(i) {
    const l = this._cachedMeta;
    this.update(i || "default"), l._clip = nA(gn(this.options.clip, eA(l.xScale, l.yScale, this.getMaxOverflow())));
  }
  update(i) {
  }
  draw() {
    const i = this._ctx, l = this.chart, u = this._cachedMeta, h = u.data || [], g = l.chartArea, _ = [], S = this._drawStart || 0, T = this._drawCount || h.length - S, E = this.options.drawActiveElementsOnTop;
    let A;
    for (u.dataset && u.dataset.draw(i, g, S, T), A = S; A < S + T; ++A) {
      const C = h[A];
      C.hidden || (C.active && E ? _.push(C) : C.draw(i, g));
    }
    for (A = 0; A < _.length; ++A)
      _[A].draw(i, g);
  }
  getStyle(i, l) {
    const u = l ? "active" : "default";
    return i === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(u) : this.resolveDataElementOptions(i || 0, u);
  }
  getContext(i, l, u) {
    const h = this.getDataset();
    let g;
    if (i >= 0 && i < this._cachedMeta.data.length) {
      const _ = this._cachedMeta.data[i];
      g = _.$context || (_.$context = rA(this.getContext(), i, _)), g.parsed = this.getParsed(i), g.raw = h.data[i], g.index = g.dataIndex = i;
    } else
      g = this.$context || (this.$context = sA(this.chart.getContext(), this.index)), g.dataset = h, g.index = g.datasetIndex = this.index;
    return g.active = !!l, g.mode = u, g;
  }
  resolveDatasetElementOptions(i) {
    return this._resolveElementOptions(this.datasetElementType.id, i);
  }
  resolveDataElementOptions(i, l) {
    return this._resolveElementOptions(this.dataElementType.id, l, i);
  }
  _resolveElementOptions(i, l = "default", u) {
    const h = l === "active", g = this._cachedDataOpts, _ = i + "-" + l, S = g[_], T = this.enableOptionSharing && S0(u);
    if (S)
      return Rx(S, T);
    const E = this.chart.config, A = E.datasetElementScopeKeys(this._type, i), C = h ? [
      `${i}Hover`,
      "hover",
      i,
      ""
    ] : [
      i,
      ""
    ], z = E.getOptionScopes(this.getDataset(), A), j = Object.keys(wi.elements[i]), J = () => this.getContext(u, h, l), Q = E.resolveNamedOptions(z, j, J, C);
    return Q.$shared && (Q.$shared = T, g[_] = Object.freeze(Rx(Q, T))), Q;
  }
  _resolveAnimations(i, l, u) {
    const h = this.chart, g = this._cachedDataOpts, _ = `animation-${l}`, S = g[_];
    if (S)
      return S;
    let T;
    if (h.options.animation !== !1) {
      const A = this.chart.config, C = A.datasetAnimationScopeKeys(this._type, l), z = A.getOptionScopes(this.getDataset(), C);
      T = A.createResolver(z, this.getContext(i, u, l));
    }
    const E = new Gw(h, T && T.animations);
    return T && T._cacheable && (g[_] = Object.freeze(E)), E;
  }
  getSharedOptions(i) {
    if (i.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, i));
  }
  includeOptions(i, l) {
    return !l || $b(i) || this.chart._animationsDisabled;
  }
  _getSharedOptions(i, l) {
    const u = this.resolveDataElementOptions(i, l), h = this._sharedOptions, g = this.getSharedOptions(u), _ = this.includeOptions(l, g) || g !== h;
    return this.updateSharedOptions(g, l, u), {
      sharedOptions: g,
      includeOptions: _
    };
  }
  updateElement(i, l, u, h) {
    $b(h) ? Object.assign(i, u) : this._resolveAnimations(l, h).update(i, u);
  }
  updateSharedOptions(i, l, u) {
    i && !$b(l) && this._resolveAnimations(void 0, l).update(i, u);
  }
  _setStyle(i, l, u, h) {
    i.active = h;
    const g = this.getStyle(l, h);
    this._resolveAnimations(l, u, h).update(i, {
      options: !h && this.getSharedOptions(g) || g
    });
  }
  removeHoverStyle(i, l, u) {
    this._setStyle(i, u, "active", !1);
  }
  setHoverStyle(i, l, u) {
    this._setStyle(i, u, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const i = this._cachedMeta.dataset;
    i && this._setStyle(i, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const i = this._cachedMeta.dataset;
    i && this._setStyle(i, void 0, "active", !0);
  }
  _resyncElements(i) {
    const l = this._data, u = this._cachedMeta.data;
    for (const [S, T, E] of this._syncList)
      this[S](T, E);
    this._syncList = [];
    const h = u.length, g = l.length, _ = Math.min(g, h);
    _ && this.parse(0, _), g > h ? this._insertElements(h, g - h, i) : g < h && this._removeElements(g, h - g);
  }
  _insertElements(i, l, u = !0) {
    const h = this._cachedMeta, g = h.data, _ = i + l;
    let S;
    const T = (E) => {
      for (E.length += l, S = E.length - 1; S >= _; S--)
        E[S] = E[S - l];
    };
    for (T(g), S = i; S < _; ++S)
      g[S] = new this.dataElementType();
    this._parsing && T(h._parsed), this.parse(i, l), u && this.updateElements(g, i, l, "reset");
  }
  updateElements(i, l, u, h) {
  }
  _removeElements(i, l) {
    const u = this._cachedMeta;
    if (this._parsing) {
      const h = u._parsed.splice(i, l);
      u._stacked && Iy(u, h);
    }
    u.data.splice(i, l);
  }
  _sync(i) {
    if (this._parsing)
      this._syncList.push(i);
    else {
      const [l, u, h] = i;
      this[l](u, h);
    }
    this.chart._dataChanges.push([
      this.index,
      ...i
    ]);
  }
  _onDataPush() {
    const i = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - i,
      i
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(i, l) {
    l && this._sync([
      "_removeElements",
      i,
      l
    ]);
    const u = arguments.length - 2;
    u && this._sync([
      "_insertElements",
      i,
      u
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
class cA extends Qw {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(i) {
    const l = this._cachedMeta, { dataset: u, data: h = [], _dataset: g } = l, _ = this.chart._animationsDisabled;
    let { start: S, count: T } = P2(l, h, _);
    this._drawStart = S, this._drawCount = T, G2(l) && (S = 0, T = h.length), u._chart = this.chart, u._datasetIndex = this.index, u._decimated = !!g._decimated, u.points = h;
    const E = this.resolveDatasetElementOptions(i);
    this.options.showLine || (E.borderWidth = 0), E.segment = this.options.segment, this.updateElement(u, void 0, {
      animated: !_,
      options: E
    }, i), this.updateElements(h, S, T, i);
  }
  updateElements(i, l, u, h) {
    const g = h === "reset", { iScale: _, vScale: S, _stacked: T, _dataset: E } = this._cachedMeta, { sharedOptions: A, includeOptions: C } = this._getSharedOptions(l, h), z = _.axis, j = S.axis, { spanGaps: J, segment: Q } = this.options, X = yv(J) ? J : Number.POSITIVE_INFINITY, et = this.chart._animationsDisabled || g || h === "none", wt = l + u, At = i.length;
    let Lt = l > 0 && this.getParsed(l - 1);
    for (let yt = 0; yt < At; ++yt) {
      const Bt = i[yt], Ct = et ? Bt : {};
      if (yt < l || yt >= wt) {
        Ct.skip = !0;
        continue;
      }
      const Yt = this.getParsed(yt), Mt = Mn(Yt[j]), ne = Ct[z] = _.getPixelForValue(Yt[z], yt), Rt = Ct[j] = g || Mt ? S.getBasePixel() : S.getPixelForValue(T ? this.applyStack(S, Yt, T) : Yt[j], yt);
      Ct.skip = isNaN(ne) || isNaN(Rt) || Mt, Ct.stop = yt > 0 && Math.abs(Yt[z] - Lt[z]) > X, Q && (Ct.parsed = Yt, Ct.raw = E.data[yt]), C && (Ct.options = A || this.resolveDataElementOptions(yt, Bt.active ? "active" : h)), et || this.updateElement(Bt, yt, Ct, h), Lt = Yt;
    }
  }
  getMaxOverflow() {
    const i = this._cachedMeta, l = i.dataset, u = l.options && l.options.borderWidth || 0, h = i.data || [];
    if (!h.length)
      return u;
    const g = h[0].size(this.resolveDataElementOptions(0)), _ = h[h.length - 1].size(this.resolveDataElementOptions(h.length - 1));
    return Math.max(u, g, _) / 2;
  }
  draw() {
    const i = this._cachedMeta;
    i.dataset.updateControlPoints(this.chart.chartArea, i.iScale.axis), super.draw();
  }
}
function ud() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class z1 {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(i) {
    Object.assign(z1.prototype, i);
  }
  options;
  constructor(i) {
    this.options = i || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return ud();
  }
  parse() {
    return ud();
  }
  format() {
    return ud();
  }
  add() {
    return ud();
  }
  diff() {
    return ud();
  }
  startOf() {
    return ud();
  }
  endOf() {
    return ud();
  }
}
var Kw = {
  _date: z1
};
function fA(s, i, l, u) {
  const { controller: h, data: g, _sorted: _ } = s, S = h._cachedMeta.iScale, T = s.dataset && s.dataset.options ? s.dataset.options.spanGaps : null;
  if (S && i === S.axis && i !== "r" && _ && g.length) {
    const E = S._reversePixels ? B2 : md;
    if (u) {
      if (h._sharedOptions) {
        const A = g[0], C = typeof A.getRange == "function" && A.getRange(i);
        if (C) {
          const z = E(g, i, l - C), j = E(g, i, l + C);
          return {
            lo: z.lo,
            hi: j.hi
          };
        }
      }
    } else {
      const A = E(g, i, l);
      if (T) {
        const { vScale: C } = h._cachedMeta, { _parsed: z } = s, j = z.slice(0, A.lo + 1).reverse().findIndex((Q) => !Mn(Q[C.axis]));
        A.lo -= Math.max(0, j);
        const J = z.slice(A.hi).findIndex((Q) => !Mn(Q[C.axis]));
        A.hi += Math.max(0, J);
      }
      return A;
    }
  }
  return {
    lo: 0,
    hi: g.length - 1
  };
}
function A0(s, i, l, u, h) {
  const g = s.getSortedVisibleDatasetMetas(), _ = l[i];
  for (let S = 0, T = g.length; S < T; ++S) {
    const { index: E, data: A } = g[S], { lo: C, hi: z } = fA(g[S], i, _, h);
    for (let j = C; j <= z; ++j) {
      const J = A[j];
      J.skip || u(J, E, j);
    }
  }
}
function hA(s) {
  const i = s.indexOf("x") !== -1, l = s.indexOf("y") !== -1;
  return function(u, h) {
    const g = i ? Math.abs(u.x - h.x) : 0, _ = l ? Math.abs(u.y - h.y) : 0;
    return Math.sqrt(Math.pow(g, 2) + Math.pow(_, 2));
  };
}
function Fb(s, i, l, u, h) {
  const g = [];
  return !h && !s.isPointInArea(i) || A0(s, l, i, function(S, T, E) {
    !h && !vv(S, s.chartArea, 0) || S.inRange(i.x, i.y, u) && g.push({
      element: S,
      datasetIndex: T,
      index: E
    });
  }, !0), g;
}
function dA(s, i, l, u) {
  let h = [];
  function g(_, S, T) {
    const { startAngle: E, endAngle: A } = _.getProps([
      "startAngle",
      "endAngle"
    ], u), { angle: C } = k2(_, {
      x: i.x,
      y: i.y
    });
    Aw(C, E, A) && h.push({
      element: _,
      datasetIndex: S,
      index: T
    });
  }
  return A0(s, l, i, g), h;
}
function mA(s, i, l, u, h, g) {
  let _ = [];
  const S = hA(l);
  let T = Number.POSITIVE_INFINITY;
  function E(A, C, z) {
    const j = A.inRange(i.x, i.y, h);
    if (u && !j)
      return;
    const J = A.getCenterPoint(h);
    if (!(!!g || s.isPointInArea(J)) && !j)
      return;
    const X = S(i, J);
    X < T ? (_ = [
      {
        element: A,
        datasetIndex: C,
        index: z
      }
    ], T = X) : X === T && _.push({
      element: A,
      datasetIndex: C,
      index: z
    });
  }
  return A0(s, l, i, E), _;
}
function t1(s, i, l, u, h, g) {
  return !g && !s.isPointInArea(i) ? [] : l === "r" && !u ? dA(s, i, l, h) : mA(s, i, l, u, h, g);
}
function Cx(s, i, l, u, h) {
  const g = [], _ = l === "x" ? "inXRange" : "inYRange";
  let S = !1;
  return A0(s, l, i, (T, E, A) => {
    T[_] && T[_](i[l], h) && (g.push({
      element: T,
      datasetIndex: E,
      index: A
    }), S = S || T.inRange(i.x, i.y, h));
  }), u && !S ? [] : g;
}
var pA = {
  modes: {
    index(s, i, l, u) {
      const h = cd(i, s), g = l.axis || "x", _ = l.includeInvisible || !1, S = l.intersect ? Fb(s, h, g, u, _) : t1(s, h, g, !1, u, _), T = [];
      return S.length ? (s.getSortedVisibleDatasetMetas().forEach((E) => {
        const A = S[0].index, C = E.data[A];
        C && !C.skip && T.push({
          element: C,
          datasetIndex: E.index,
          index: A
        });
      }), T) : [];
    },
    dataset(s, i, l, u) {
      const h = cd(i, s), g = l.axis || "xy", _ = l.includeInvisible || !1;
      let S = l.intersect ? Fb(s, h, g, u, _) : t1(s, h, g, !1, u, _);
      if (S.length > 0) {
        const T = S[0].datasetIndex, E = s.getDatasetMeta(T).data;
        S = [];
        for (let A = 0; A < E.length; ++A)
          S.push({
            element: E[A],
            datasetIndex: T,
            index: A
          });
      }
      return S;
    },
    point(s, i, l, u) {
      const h = cd(i, s), g = l.axis || "xy", _ = l.includeInvisible || !1;
      return Fb(s, h, g, u, _);
    },
    nearest(s, i, l, u) {
      const h = cd(i, s), g = l.axis || "xy", _ = l.includeInvisible || !1;
      return t1(s, h, g, l.intersect, u, _);
    },
    x(s, i, l, u) {
      const h = cd(i, s);
      return Cx(s, h, "x", l.intersect, u);
    },
    y(s, i, l, u) {
      const h = cd(i, s);
      return Cx(s, h, "y", l.intersect, u);
    }
  }
};
const Ww = [
  "left",
  "top",
  "right",
  "bottom"
];
function $y(s, i) {
  return s.filter((l) => l.pos === i);
}
function zx(s, i) {
  return s.filter((l) => Ww.indexOf(l.pos) === -1 && l.box.axis === i);
}
function Fy(s, i) {
  return s.sort((l, u) => {
    const h = i ? u : l, g = i ? l : u;
    return h.weight === g.weight ? h.index - g.index : h.weight - g.weight;
  });
}
function gA(s) {
  const i = [];
  let l, u, h, g, _, S;
  for (l = 0, u = (s || []).length; l < u; ++l)
    h = s[l], { position: g, options: { stack: _, stackWeight: S = 1 } } = h, i.push({
      index: l,
      box: h,
      pos: g,
      horizontal: h.isHorizontal(),
      weight: h.weight,
      stack: _ && g + _,
      stackWeight: S
    });
  return i;
}
function yA(s) {
  const i = {};
  for (const l of s) {
    const { stack: u, pos: h, stackWeight: g } = l;
    if (!u || !Ww.includes(h))
      continue;
    const _ = i[u] || (i[u] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _.count++, _.weight += g;
  }
  return i;
}
function vA(s, i) {
  const l = yA(s), { vBoxMaxWidth: u, hBoxMaxHeight: h } = i;
  let g, _, S;
  for (g = 0, _ = s.length; g < _; ++g) {
    S = s[g];
    const { fullSize: T } = S.box, E = l[S.stack], A = E && S.stackWeight / E.weight;
    S.horizontal ? (S.width = A ? A * u : T && i.availableWidth, S.height = h) : (S.width = u, S.height = A ? A * h : T && i.availableHeight);
  }
  return l;
}
function _A(s) {
  const i = gA(s), l = Fy(i.filter((E) => E.box.fullSize), !0), u = Fy($y(i, "left"), !0), h = Fy($y(i, "right")), g = Fy($y(i, "top"), !0), _ = Fy($y(i, "bottom")), S = zx(i, "x"), T = zx(i, "y");
  return {
    fullSize: l,
    leftAndTop: u.concat(g),
    rightAndBottom: h.concat(T).concat(_).concat(S),
    chartArea: $y(i, "chartArea"),
    vertical: u.concat(h).concat(T),
    horizontal: g.concat(_).concat(S)
  };
}
function Lx(s, i, l, u) {
  return Math.max(s[l], i[l]) + Math.max(s[u], i[u]);
}
function Jw(s, i) {
  s.top = Math.max(s.top, i.top), s.left = Math.max(s.left, i.left), s.bottom = Math.max(s.bottom, i.bottom), s.right = Math.max(s.right, i.right);
}
function bA(s, i, l, u) {
  const { pos: h, box: g } = l, _ = s.maxPadding;
  if (!Pe(h)) {
    l.size && (s[h] -= l.size);
    const C = u[l.stack] || {
      size: 0,
      count: 1
    };
    C.size = Math.max(C.size, l.horizontal ? g.height : g.width), l.size = C.size / C.count, s[h] += l.size;
  }
  g.getPadding && Jw(_, g.getPadding());
  const S = Math.max(0, i.outerWidth - Lx(_, s, "left", "right")), T = Math.max(0, i.outerHeight - Lx(_, s, "top", "bottom")), E = S !== s.w, A = T !== s.h;
  return s.w = S, s.h = T, l.horizontal ? {
    same: E,
    other: A
  } : {
    same: A,
    other: E
  };
}
function SA(s) {
  const i = s.maxPadding;
  function l(u) {
    const h = Math.max(i[u] - s[u], 0);
    return s[u] += h, h;
  }
  s.y += l("top"), s.x += l("left"), l("right"), l("bottom");
}
function TA(s, i) {
  const l = i.maxPadding;
  function u(h) {
    const g = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return h.forEach((_) => {
      g[_] = Math.max(i[_], l[_]);
    }), g;
  }
  return u(s ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function sv(s, i, l, u) {
  const h = [];
  let g, _, S, T, E, A;
  for (g = 0, _ = s.length, E = 0; g < _; ++g) {
    S = s[g], T = S.box, T.update(S.width || i.w, S.height || i.h, TA(S.horizontal, i));
    const { same: C, other: z } = bA(i, l, S, u);
    E |= C && h.length, A = A || z, T.fullSize || h.push(S);
  }
  return E && sv(h, i, l, u) || A;
}
function s0(s, i, l, u, h) {
  s.top = l, s.left = i, s.right = i + u, s.bottom = l + h, s.width = u, s.height = h;
}
function Hx(s, i, l, u) {
  const h = l.padding;
  let { x: g, y: _ } = i;
  for (const S of s) {
    const T = S.box, E = u[S.stack] || {
      placed: 0,
      weight: 1
    }, A = S.stackWeight / E.weight || 1;
    if (S.horizontal) {
      const C = i.w * A, z = E.size || T.height;
      S0(E.start) && (_ = E.start), T.fullSize ? s0(T, h.left, _, l.outerWidth - h.right - h.left, z) : s0(T, i.left + E.placed, _, C, z), E.start = _, E.placed += C, _ = T.bottom;
    } else {
      const C = i.h * A, z = E.size || T.width;
      S0(E.start) && (g = E.start), T.fullSize ? s0(T, g, h.top, z, l.outerHeight - h.bottom - h.top) : s0(T, g, i.top + E.placed, z, C), E.start = g, E.placed += C, g = T.right;
    }
  }
  i.x = g, i.y = _;
}
var r0 = {
  addBox(s, i) {
    s.boxes || (s.boxes = []), i.fullSize = i.fullSize || !1, i.position = i.position || "top", i.weight = i.weight || 0, i._layers = i._layers || function() {
      return [
        {
          z: 0,
          draw(l) {
            i.draw(l);
          }
        }
      ];
    }, s.boxes.push(i);
  },
  removeBox(s, i) {
    const l = s.boxes ? s.boxes.indexOf(i) : -1;
    l !== -1 && s.boxes.splice(l, 1);
  },
  configure(s, i, l) {
    i.fullSize = l.fullSize, i.position = l.position, i.weight = l.weight;
  },
  update(s, i, l, u) {
    if (!s)
      return;
    const h = Of(s.options.layout.padding), g = Math.max(i - h.width, 0), _ = Math.max(l - h.height, 0), S = _A(s.boxes), T = S.vertical, E = S.horizontal;
    un(s.boxes, (Q) => {
      typeof Q.beforeLayout == "function" && Q.beforeLayout();
    });
    const A = T.reduce((Q, X) => X.box.options && X.box.options.display === !1 ? Q : Q + 1, 0) || 1, C = Object.freeze({
      outerWidth: i,
      outerHeight: l,
      padding: h,
      availableWidth: g,
      availableHeight: _,
      vBoxMaxWidth: g / 2 / A,
      hBoxMaxHeight: _ / 2
    }), z = Object.assign({}, h);
    Jw(z, Of(u));
    const j = Object.assign({
      maxPadding: z,
      w: g,
      h: _,
      x: h.left,
      y: h.top
    }, h), J = vA(T.concat(E), C);
    sv(S.fullSize, j, C, J), sv(T, j, C, J), sv(E, j, C, J) && sv(T, j, C, J), SA(j), Hx(S.leftAndTop, j, C, J), j.x += j.w, j.y += j.h, Hx(S.rightAndBottom, j, C, J), s.chartArea = {
      left: j.left,
      top: j.top,
      right: j.left + j.w,
      bottom: j.top + j.h,
      height: j.h,
      width: j.w
    }, un(S.chartArea, (Q) => {
      const X = Q.box;
      Object.assign(X, s.chartArea), X.update(j.w, j.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class Iw {
  acquireContext(i, l) {
  }
  releaseContext(i) {
    return !1;
  }
  addEventListener(i, l, u) {
  }
  removeEventListener(i, l, u) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(i, l, u, h) {
    return l = Math.max(0, l || i.width), u = u || i.height, {
      width: l,
      height: Math.max(0, h ? Math.floor(l / h) : u)
    };
  }
  isAttached(i) {
    return !0;
  }
  updateConfig(i) {
  }
}
class xA extends Iw {
  acquireContext(i) {
    return i && i.getContext && i.getContext("2d") || null;
  }
  updateConfig(i) {
    i.options.animation = !1;
  }
}
const g0 = "$chartjs", wA = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, kx = (s) => s === null || s === "";
function MA(s, i) {
  const l = s.style, u = s.getAttribute("height"), h = s.getAttribute("width");
  if (s[g0] = {
    initial: {
      height: u,
      width: h,
      style: {
        display: l.display,
        height: l.height,
        width: l.width
      }
    }
  }, l.display = l.display || "block", l.boxSizing = l.boxSizing || "border-box", kx(h)) {
    const g = Sx(s, "width");
    g !== void 0 && (s.width = g);
  }
  if (kx(u))
    if (s.style.height === "")
      s.height = s.width / (i || 2);
    else {
      const g = Sx(s, "height");
      g !== void 0 && (s.height = g);
    }
  return s;
}
const $w = NO ? {
  passive: !0
} : !1;
function EA(s, i, l) {
  s && s.addEventListener(i, l, $w);
}
function OA(s, i, l) {
  s && s.canvas && s.canvas.removeEventListener(i, l, $w);
}
function AA(s, i) {
  const l = wA[s.type] || s.type, { x: u, y: h } = cd(s, i);
  return {
    type: l,
    chart: i,
    native: s,
    x: u !== void 0 ? u : null,
    y: h !== void 0 ? h : null
  };
}
function w0(s, i) {
  for (const l of s)
    if (l === i || l.contains(i))
      return !0;
}
function DA(s, i, l) {
  const u = s.canvas, h = new MutationObserver((g) => {
    let _ = !1;
    for (const S of g)
      _ = _ || w0(S.addedNodes, u), _ = _ && !w0(S.removedNodes, u);
    _ && l();
  });
  return h.observe(document, {
    childList: !0,
    subtree: !0
  }), h;
}
function RA(s, i, l) {
  const u = s.canvas, h = new MutationObserver((g) => {
    let _ = !1;
    for (const S of g)
      _ = _ || w0(S.removedNodes, u), _ = _ && !w0(S.addedNodes, u);
    _ && l();
  });
  return h.observe(document, {
    childList: !0,
    subtree: !0
  }), h;
}
const _v = /* @__PURE__ */ new Map();
let Nx = 0;
function Fw() {
  const s = window.devicePixelRatio;
  s !== Nx && (Nx = s, _v.forEach((i, l) => {
    l.currentDevicePixelRatio !== s && i();
  }));
}
function CA(s, i) {
  _v.size || window.addEventListener("resize", Fw), _v.set(s, i);
}
function zA(s) {
  _v.delete(s), _v.size || window.removeEventListener("resize", Fw);
}
function LA(s, i, l) {
  const u = s.canvas, h = u && C1(u);
  if (!h)
    return;
  const g = zw((S, T) => {
    const E = h.clientWidth;
    l(S, T), E < h.clientWidth && l();
  }, window), _ = new ResizeObserver((S) => {
    const T = S[0], E = T.contentRect.width, A = T.contentRect.height;
    E === 0 && A === 0 || g(E, A);
  });
  return _.observe(h), CA(s, g), _;
}
function e1(s, i, l) {
  l && l.disconnect(), i === "resize" && zA(s);
}
function HA(s, i, l) {
  const u = s.canvas, h = zw((g) => {
    s.ctx !== null && l(AA(g, s));
  }, s);
  return EA(u, i, h), h;
}
class kA extends Iw {
  acquireContext(i, l) {
    const u = i && i.getContext && i.getContext("2d");
    return u && u.canvas === i ? (MA(i, l), u) : null;
  }
  releaseContext(i) {
    const l = i.canvas;
    if (!l[g0])
      return !1;
    const u = l[g0].initial;
    [
      "height",
      "width"
    ].forEach((g) => {
      const _ = u[g];
      Mn(_) ? l.removeAttribute(g) : l.setAttribute(g, _);
    });
    const h = u.style || {};
    return Object.keys(h).forEach((g) => {
      l.style[g] = h[g];
    }), l.width = l.width, delete l[g0], !0;
  }
  addEventListener(i, l, u) {
    this.removeEventListener(i, l);
    const h = i.$proxies || (i.$proxies = {}), _ = {
      attach: DA,
      detach: RA,
      resize: LA
    }[l] || HA;
    h[l] = _(i, l, u);
  }
  removeEventListener(i, l) {
    const u = i.$proxies || (i.$proxies = {}), h = u[l];
    if (!h)
      return;
    ({
      attach: e1,
      detach: e1,
      resize: e1
    }[l] || OA)(i, l, h), u[l] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(i, l, u, h) {
    return kO(i, l, u, h);
  }
  isAttached(i) {
    const l = i && C1(i);
    return !!(l && l.isConnected);
  }
}
function NA(s) {
  return !R1() || typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas ? xA : kA;
}
let Sv = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = !1;
  options;
  $animations;
  tooltipPosition(i) {
    const { x: l, y: u } = this.getProps([
      "x",
      "y"
    ], i);
    return {
      x: l,
      y: u
    };
  }
  hasValue() {
    return yv(this.x) && yv(this.y);
  }
  getProps(i, l) {
    const u = this.$animations;
    if (!l || !u)
      return this;
    const h = {};
    return i.forEach((g) => {
      h[g] = u[g] && u[g].active() ? u[g]._to : this[g];
    }), h;
  }
};
function UA(s, i) {
  const l = s.options.ticks, u = BA(s), h = Math.min(l.maxTicksLimit || u, u), g = l.major.enabled ? jA(i) : [], _ = g.length, S = g[0], T = g[_ - 1], E = [];
  if (_ > h)
    return qA(i, E, g, _ / h), E;
  const A = YA(g, i, h);
  if (_ > 0) {
    let C, z;
    const j = _ > 1 ? Math.round((T - S) / (_ - 1)) : null;
    for (u0(i, E, A, Mn(j) ? 0 : S - j, S), C = 0, z = _ - 1; C < z; C++)
      u0(i, E, A, g[C], g[C + 1]);
    return u0(i, E, A, T, Mn(j) ? i.length : T + j), E;
  }
  return u0(i, E, A), E;
}
function BA(s) {
  const i = s.options.offset, l = s._tickSize(), u = s._length / l + (i ? 0 : 1), h = s._maxLength / l;
  return Math.floor(Math.min(u, h));
}
function YA(s, i, l) {
  const u = ZA(s), h = i.length / l;
  if (!u)
    return Math.max(h, 1);
  const g = R2(u);
  for (let _ = 0, S = g.length - 1; _ < S; _++) {
    const T = g[_];
    if (T > h)
      return T;
  }
  return Math.max(h, 1);
}
function jA(s) {
  const i = [];
  let l, u;
  for (l = 0, u = s.length; l < u; l++)
    s[l].major && i.push(l);
  return i;
}
function qA(s, i, l, u) {
  let h = 0, g = l[0], _;
  for (u = Math.ceil(u), _ = 0; _ < s.length; _++)
    _ === g && (i.push(s[_]), h++, g = l[h * u]);
}
function u0(s, i, l, u, h) {
  const g = gn(u, 0), _ = Math.min(gn(h, s.length), s.length);
  let S = 0, T, E, A;
  for (l = Math.ceil(l), h && (T = h - u, l = T / Math.floor(T / l)), A = g; A < 0; )
    S++, A = Math.round(g + S * l);
  for (E = Math.max(g, 0); E < _; E++)
    E === A && (i.push(s[E]), S++, A = Math.round(g + S * l));
}
function ZA(s) {
  const i = s.length;
  let l, u;
  if (i < 2)
    return !1;
  for (u = s[0], l = 1; l < i; ++l)
    if (s[l] - s[l - 1] !== u)
      return !1;
  return u;
}
const VA = (s) => s === "left" ? "right" : s === "right" ? "left" : s, Ux = (s, i, l) => i === "top" || i === "left" ? s[i] + l : s[i] - l, Bx = (s, i) => Math.min(i || s, s);
function Yx(s, i) {
  const l = [], u = s.length / i, h = s.length;
  let g = 0;
  for (; g < h; g += u)
    l.push(s[Math.floor(g)]);
  return l;
}
function PA(s, i, l) {
  const u = s.ticks.length, h = Math.min(i, u - 1), g = s._startPixel, _ = s._endPixel, S = 1e-6;
  let T = s.getPixelForTick(h), E;
  if (!(l && (u === 1 ? E = Math.max(T - g, _ - T) : i === 0 ? E = (s.getPixelForTick(1) - T) / 2 : E = (T - s.getPixelForTick(h - 1)) / 2, T += h < i ? E : -E, T < g - S || T > _ + S)))
    return T;
}
function GA(s, i) {
  un(s, (l) => {
    const u = l.gc, h = u.length / 2;
    let g;
    if (h > i) {
      for (g = 0; g < h; ++g)
        delete l.data[u[g]];
      u.splice(0, h);
    }
  });
}
function tv(s) {
  return s.drawTicks ? s.tickLength : 0;
}
function jx(s, i) {
  if (!s.display)
    return 0;
  const l = uu(s.font, i), u = Of(s.padding);
  return (Fi(s.text) ? s.text.length : 1) * l.lineHeight + u.height;
}
function XA(s, i) {
  return yd(s, {
    scale: i,
    type: "scale"
  });
}
function QA(s, i, l) {
  return yd(s, {
    tick: l,
    index: i,
    type: "tick"
  });
}
function KA(s, i, l) {
  let u = V2(s);
  return (l && i !== "right" || !l && i === "right") && (u = VA(u)), u;
}
function WA(s, i, l, u) {
  const { top: h, left: g, bottom: _, right: S, chart: T } = s, { chartArea: E, scales: A } = T;
  let C = 0, z, j, J;
  const Q = _ - h, X = S - g;
  if (s.isHorizontal()) {
    if (j = ux(u, g, S), Pe(l)) {
      const et = Object.keys(l)[0], wt = l[et];
      J = A[et].getPixelForValue(wt) + Q - i;
    } else l === "center" ? J = (E.bottom + E.top) / 2 + Q - i : J = Ux(s, l, i);
    z = S - g;
  } else {
    if (Pe(l)) {
      const et = Object.keys(l)[0], wt = l[et];
      j = A[et].getPixelForValue(wt) - X + i;
    } else l === "center" ? j = (E.left + E.right) / 2 - X + i : j = Ux(s, l, i);
    J = ux(u, _, h), C = l === "left" ? -sr : sr;
  }
  return {
    titleX: j,
    titleY: J,
    maxWidth: z,
    rotation: C
  };
}
class Tv extends Sv {
  constructor(i) {
    super(), this.id = i.id, this.type = i.type, this.options = void 0, this.ctx = i.ctx, this.chart = i.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(i) {
    this.options = i.setContext(this.getContext()), this.axis = i.axis, this._userMin = this.parse(i.min), this._userMax = this.parse(i.max), this._suggestedMin = this.parse(i.suggestedMin), this._suggestedMax = this.parse(i.suggestedMax);
  }
  parse(i, l) {
    return i;
  }
  getUserBounds() {
    let { _userMin: i, _userMax: l, _suggestedMin: u, _suggestedMax: h } = this;
    return i = iu(i, Number.POSITIVE_INFINITY), l = iu(l, Number.NEGATIVE_INFINITY), u = iu(u, Number.POSITIVE_INFINITY), h = iu(h, Number.NEGATIVE_INFINITY), {
      min: iu(i, u),
      max: iu(l, h),
      minDefined: qa(i),
      maxDefined: qa(l)
    };
  }
  getMinMax(i) {
    let { min: l, max: u, minDefined: h, maxDefined: g } = this.getUserBounds(), _;
    if (h && g)
      return {
        min: l,
        max: u
      };
    const S = this.getMatchingVisibleMetas();
    for (let T = 0, E = S.length; T < E; ++T)
      _ = S[T].controller.getMinMax(this, i), h || (l = Math.min(l, _.min)), g || (u = Math.max(u, _.max));
    return l = g && l > u ? u : l, u = h && l > u ? l : u, {
      min: iu(l, iu(u, l)),
      max: iu(u, iu(l, u))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const i = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? i.xLabels : i.yLabels) || i.labels || [];
  }
  getLabelItems(i = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(i));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    si(this.options.beforeUpdate, [
      this
    ]);
  }
  update(i, l, u) {
    const { beginAtZero: h, grace: g, ticks: _ } = this.options, S = _.sampleSize;
    this.beforeUpdate(), this.maxWidth = i, this.maxHeight = l, this._margins = u = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, u), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + u.left + u.right : this.height + u.top + u.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = dO(this, g, h), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const T = S < this.ticks.length;
    this._convertTicksToLabels(T ? Yx(this.ticks, S) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), _.display && (_.autoSkip || _.source === "auto") && (this.ticks = UA(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), T && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let i = this.options.reverse, l, u;
    this.isHorizontal() ? (l = this.left, u = this.right) : (l = this.top, u = this.bottom, i = !i), this._startPixel = l, this._endPixel = u, this._reversePixels = i, this._length = u - l, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    si(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    si(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    si(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(i) {
    this.chart.notifyPlugins(i, this.getContext()), si(this.options[i], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    si(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(i) {
    const l = this.options.ticks;
    let u, h, g;
    for (u = 0, h = i.length; u < h; u++)
      g = i[u], g.label = si(l.callback, [
        g.value,
        u,
        i
      ], this);
  }
  afterTickToLabelConversion() {
    si(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    si(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const i = this.options, l = i.ticks, u = Bx(this.ticks.length, i.ticks.maxTicksLimit), h = l.minRotation || 0, g = l.maxRotation;
    let _ = h, S, T, E;
    if (!this._isVisible() || !l.display || h >= g || u <= 1 || !this.isHorizontal()) {
      this.labelRotation = h;
      return;
    }
    const A = this._getLabelSizes(), C = A.widest.width, z = A.highest.height, j = rr(this.chart.width - C, 0, this.maxWidth);
    S = i.offset ? this.maxWidth / u : j / (u - 1), C + 6 > S && (S = j / (u - (i.offset ? 0.5 : 1)), T = this.maxHeight - tv(i.grid) - l.padding - jx(i.title, this.chart.options.font), E = Math.sqrt(C * C + z * z), _ = H2(Math.min(Math.asin(rr((A.highest.height + 6) / S, -1, 1)), Math.asin(rr(T / E, -1, 1)) - Math.asin(rr(z / E, -1, 1)))), _ = Math.max(h, Math.min(g, _))), this.labelRotation = _;
  }
  afterCalculateLabelRotation() {
    si(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    si(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const i = {
      width: 0,
      height: 0
    }, { chart: l, options: { ticks: u, title: h, grid: g } } = this, _ = this._isVisible(), S = this.isHorizontal();
    if (_) {
      const T = jx(h, l.options.font);
      if (S ? (i.width = this.maxWidth, i.height = tv(g) + T) : (i.height = this.maxHeight, i.width = tv(g) + T), u.display && this.ticks.length) {
        const { first: E, last: A, widest: C, highest: z } = this._getLabelSizes(), j = u.padding * 2, J = dd(this.labelRotation), Q = Math.cos(J), X = Math.sin(J);
        if (S) {
          const et = u.mirror ? 0 : X * C.width + Q * z.height;
          i.height = Math.min(this.maxHeight, i.height + et + j);
        } else {
          const et = u.mirror ? 0 : Q * C.width + X * z.height;
          i.width = Math.min(this.maxWidth, i.width + et + j);
        }
        this._calculatePadding(E, A, X, Q);
      }
    }
    this._handleMargins(), S ? (this.width = this._length = l.width - this._margins.left - this._margins.right, this.height = i.height) : (this.width = i.width, this.height = this._length = l.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(i, l, u, h) {
    const { ticks: { align: g, padding: _ }, position: S } = this.options, T = this.labelRotation !== 0, E = S !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const A = this.getPixelForTick(0) - this.left, C = this.right - this.getPixelForTick(this.ticks.length - 1);
      let z = 0, j = 0;
      T ? E ? (z = h * i.width, j = u * l.height) : (z = u * i.height, j = h * l.width) : g === "start" ? j = l.width : g === "end" ? z = i.width : g !== "inner" && (z = i.width / 2, j = l.width / 2), this.paddingLeft = Math.max((z - A + _) * this.width / (this.width - A), 0), this.paddingRight = Math.max((j - C + _) * this.width / (this.width - C), 0);
    } else {
      let A = l.height / 2, C = i.height / 2;
      g === "start" ? (A = 0, C = i.height) : g === "end" && (A = l.height, C = 0), this.paddingTop = A + _, this.paddingBottom = C + _;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    si(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: i, position: l } = this.options;
    return l === "top" || l === "bottom" || i === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(i) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(i);
    let l, u;
    for (l = 0, u = i.length; l < u; l++)
      Mn(i[l].label) && (i.splice(l, 1), u--, l--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let i = this._labelSizes;
    if (!i) {
      const l = this.options.ticks.sampleSize;
      let u = this.ticks;
      l < u.length && (u = Yx(u, l)), this._labelSizes = i = this._computeLabelSizes(u, u.length, this.options.ticks.maxTicksLimit);
    }
    return i;
  }
  _computeLabelSizes(i, l, u) {
    const { ctx: h, _longestTextCache: g } = this, _ = [], S = [], T = Math.floor(l / Bx(l, u));
    let E = 0, A = 0, C, z, j, J, Q, X, et, wt, At, Lt, yt;
    for (C = 0; C < l; C += T) {
      if (J = i[C].label, Q = this._resolveTickFontOptions(C), h.font = X = Q.string, et = g[X] = g[X] || {
        data: {},
        gc: []
      }, wt = Q.lineHeight, At = Lt = 0, !Mn(J) && !Fi(J))
        At = mx(h, et.data, et.gc, At, J), Lt = wt;
      else if (Fi(J))
        for (z = 0, j = J.length; z < j; ++z)
          yt = J[z], !Mn(yt) && !Fi(yt) && (At = mx(h, et.data, et.gc, At, yt), Lt += wt);
      _.push(At), S.push(Lt), E = Math.max(At, E), A = Math.max(Lt, A);
    }
    GA(g, l);
    const Bt = _.indexOf(E), Ct = S.indexOf(A), Yt = (Mt) => ({
      width: _[Mt] || 0,
      height: S[Mt] || 0
    });
    return {
      first: Yt(0),
      last: Yt(l - 1),
      widest: Yt(Bt),
      highest: Yt(Ct),
      widths: _,
      heights: S
    };
  }
  getLabelForValue(i) {
    return i;
  }
  getPixelForValue(i, l) {
    return NaN;
  }
  getValueForPixel(i) {
  }
  getPixelForTick(i) {
    const l = this.ticks;
    return i < 0 || i > l.length - 1 ? null : this.getPixelForValue(l[i].value);
  }
  getPixelForDecimal(i) {
    this._reversePixels && (i = 1 - i);
    const l = this._startPixel + i * this._length;
    return U2(this._alignToPixels ? rd(this.chart, l, 0) : l);
  }
  getDecimalForPixel(i) {
    const l = (i - this._startPixel) / this._length;
    return this._reversePixels ? 1 - l : l;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: i, max: l } = this;
    return i < 0 && l < 0 ? l : i > 0 && l > 0 ? i : 0;
  }
  getContext(i) {
    const l = this.ticks || [];
    if (i >= 0 && i < l.length) {
      const u = l[i];
      return u.$context || (u.$context = QA(this.getContext(), i, u));
    }
    return this.$context || (this.$context = XA(this.chart.getContext(), this));
  }
  _tickSize() {
    const i = this.options.ticks, l = dd(this.labelRotation), u = Math.abs(Math.cos(l)), h = Math.abs(Math.sin(l)), g = this._getLabelSizes(), _ = i.autoSkipPadding || 0, S = g ? g.widest.width + _ : 0, T = g ? g.highest.height + _ : 0;
    return this.isHorizontal() ? T * u > S * h ? S / u : T / h : T * h < S * u ? T / u : S / h;
  }
  _isVisible() {
    const i = this.options.display;
    return i !== "auto" ? !!i : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(i) {
    const l = this.axis, u = this.chart, h = this.options, { grid: g, position: _, border: S } = h, T = g.offset, E = this.isHorizontal(), C = this.ticks.length + (T ? 1 : 0), z = tv(g), j = [], J = S.setContext(this.getContext()), Q = J.display ? J.width : 0, X = Q / 2, et = function(P) {
      return rd(u, P, Q);
    };
    let wt, At, Lt, yt, Bt, Ct, Yt, Mt, ne, Rt, kt, Ee;
    if (_ === "top")
      wt = et(this.bottom), Ct = this.bottom - z, Mt = wt - X, Rt = et(i.top) + X, Ee = i.bottom;
    else if (_ === "bottom")
      wt = et(this.top), Rt = i.top, Ee = et(i.bottom) - X, Ct = wt + X, Mt = this.top + z;
    else if (_ === "left")
      wt = et(this.right), Bt = this.right - z, Yt = wt - X, ne = et(i.left) + X, kt = i.right;
    else if (_ === "right")
      wt = et(this.left), ne = i.left, kt = et(i.right) - X, Bt = wt + X, Yt = this.left + z;
    else if (l === "x") {
      if (_ === "center")
        wt = et((i.top + i.bottom) / 2 + 0.5);
      else if (Pe(_)) {
        const P = Object.keys(_)[0], dt = _[P];
        wt = et(this.chart.scales[P].getPixelForValue(dt));
      }
      Rt = i.top, Ee = i.bottom, Ct = wt + X, Mt = Ct + z;
    } else if (l === "y") {
      if (_ === "center")
        wt = et((i.left + i.right) / 2);
      else if (Pe(_)) {
        const P = Object.keys(_)[0], dt = _[P];
        wt = et(this.chart.scales[P].getPixelForValue(dt));
      }
      Bt = wt - X, Yt = Bt - z, ne = i.left, kt = i.right;
    }
    const ge = gn(h.ticks.maxTicksLimit, C), It = Math.max(1, Math.ceil(C / ge));
    for (At = 0; At < C; At += It) {
      const P = this.getContext(At), dt = g.setContext(P), ut = S.setContext(P), Gt = dt.lineWidth, k = dt.color, F = ut.dash || [], ct = ut.dashOffset, bt = dt.tickWidth, Et = dt.tickColor, zt = dt.tickBorderDash || [], Tt = dt.tickBorderDashOffset;
      Lt = PA(this, At, T), Lt !== void 0 && (yt = rd(u, Lt, Gt), E ? Bt = Yt = ne = kt = yt : Ct = Mt = Rt = Ee = yt, j.push({
        tx1: Bt,
        ty1: Ct,
        tx2: Yt,
        ty2: Mt,
        x1: ne,
        y1: Rt,
        x2: kt,
        y2: Ee,
        width: Gt,
        color: k,
        borderDash: F,
        borderDashOffset: ct,
        tickWidth: bt,
        tickColor: Et,
        tickBorderDash: zt,
        tickBorderDashOffset: Tt
      }));
    }
    return this._ticksLength = C, this._borderValue = wt, j;
  }
  _computeLabelItems(i) {
    const l = this.axis, u = this.options, { position: h, ticks: g } = u, _ = this.isHorizontal(), S = this.ticks, { align: T, crossAlign: E, padding: A, mirror: C } = g, z = tv(u.grid), j = z + A, J = C ? -A : j, Q = -dd(this.labelRotation), X = [];
    let et, wt, At, Lt, yt, Bt, Ct, Yt, Mt, ne, Rt, kt, Ee = "middle";
    if (h === "top")
      Bt = this.bottom - J, Ct = this._getXAxisLabelAlignment();
    else if (h === "bottom")
      Bt = this.top + J, Ct = this._getXAxisLabelAlignment();
    else if (h === "left") {
      const It = this._getYAxisLabelAlignment(z);
      Ct = It.textAlign, yt = It.x;
    } else if (h === "right") {
      const It = this._getYAxisLabelAlignment(z);
      Ct = It.textAlign, yt = It.x;
    } else if (l === "x") {
      if (h === "center")
        Bt = (i.top + i.bottom) / 2 + j;
      else if (Pe(h)) {
        const It = Object.keys(h)[0], P = h[It];
        Bt = this.chart.scales[It].getPixelForValue(P) + j;
      }
      Ct = this._getXAxisLabelAlignment();
    } else if (l === "y") {
      if (h === "center")
        yt = (i.left + i.right) / 2 - j;
      else if (Pe(h)) {
        const It = Object.keys(h)[0], P = h[It];
        yt = this.chart.scales[It].getPixelForValue(P);
      }
      Ct = this._getYAxisLabelAlignment(z).textAlign;
    }
    l === "y" && (T === "start" ? Ee = "top" : T === "end" && (Ee = "bottom"));
    const ge = this._getLabelSizes();
    for (et = 0, wt = S.length; et < wt; ++et) {
      At = S[et], Lt = At.label;
      const It = g.setContext(this.getContext(et));
      Yt = this.getPixelForTick(et) + g.labelOffset, Mt = this._resolveTickFontOptions(et), ne = Mt.lineHeight, Rt = Fi(Lt) ? Lt.length : 1;
      const P = Rt / 2, dt = It.color, ut = It.textStrokeColor, Gt = It.textStrokeWidth;
      let k = Ct;
      _ ? (yt = Yt, Ct === "inner" && (et === wt - 1 ? k = this.options.reverse ? "left" : "right" : et === 0 ? k = this.options.reverse ? "right" : "left" : k = "center"), h === "top" ? E === "near" || Q !== 0 ? kt = -Rt * ne + ne / 2 : E === "center" ? kt = -ge.highest.height / 2 - P * ne + ne : kt = -ge.highest.height + ne / 2 : E === "near" || Q !== 0 ? kt = ne / 2 : E === "center" ? kt = ge.highest.height / 2 - P * ne : kt = ge.highest.height - Rt * ne, C && (kt *= -1), Q !== 0 && !It.showLabelBackdrop && (yt += ne / 2 * Math.sin(Q))) : (Bt = Yt, kt = (1 - Rt) * ne / 2);
      let F;
      if (It.showLabelBackdrop) {
        const ct = Of(It.backdropPadding), bt = ge.heights[et], Et = ge.widths[et];
        let zt = kt - ct.top, Tt = 0 - ct.left;
        switch (Ee) {
          case "middle":
            zt -= bt / 2;
            break;
          case "bottom":
            zt -= bt;
            break;
        }
        switch (Ct) {
          case "center":
            Tt -= Et / 2;
            break;
          case "right":
            Tt -= Et;
            break;
          case "inner":
            et === wt - 1 ? Tt -= Et : et > 0 && (Tt -= Et / 2);
            break;
        }
        F = {
          left: Tt,
          top: zt,
          width: Et + ct.width,
          height: bt + ct.height,
          color: It.backdropColor
        };
      }
      X.push({
        label: Lt,
        font: Mt,
        textOffset: kt,
        options: {
          rotation: Q,
          color: dt,
          strokeColor: ut,
          strokeWidth: Gt,
          textAlign: k,
          textBaseline: Ee,
          translation: [
            yt,
            Bt
          ],
          backdrop: F
        }
      });
    }
    return X;
  }
  _getXAxisLabelAlignment() {
    const { position: i, ticks: l } = this.options;
    if (-dd(this.labelRotation))
      return i === "top" ? "left" : "right";
    let h = "center";
    return l.align === "start" ? h = "left" : l.align === "end" ? h = "right" : l.align === "inner" && (h = "inner"), h;
  }
  _getYAxisLabelAlignment(i) {
    const { position: l, ticks: { crossAlign: u, mirror: h, padding: g } } = this.options, _ = this._getLabelSizes(), S = i + g, T = _.widest.width;
    let E, A;
    return l === "left" ? h ? (A = this.right + g, u === "near" ? E = "left" : u === "center" ? (E = "center", A += T / 2) : (E = "right", A += T)) : (A = this.right - S, u === "near" ? E = "right" : u === "center" ? (E = "center", A -= T / 2) : (E = "left", A = this.left)) : l === "right" ? h ? (A = this.left + g, u === "near" ? E = "right" : u === "center" ? (E = "center", A -= T / 2) : (E = "left", A -= T)) : (A = this.left + S, u === "near" ? E = "left" : u === "center" ? (E = "center", A += T / 2) : (E = "right", A = this.right)) : E = "right", {
      textAlign: E,
      x: A
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const i = this.chart, l = this.options.position;
    if (l === "left" || l === "right")
      return {
        top: 0,
        left: this.left,
        bottom: i.height,
        right: this.right
      };
    if (l === "top" || l === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: i.width
      };
  }
  drawBackground() {
    const { ctx: i, options: { backgroundColor: l }, left: u, top: h, width: g, height: _ } = this;
    l && (i.save(), i.fillStyle = l, i.fillRect(u, h, g, _), i.restore());
  }
  getLineWidthForValue(i) {
    const l = this.options.grid;
    if (!this._isVisible() || !l.display)
      return 0;
    const h = this.ticks.findIndex((g) => g.value === i);
    return h >= 0 ? l.setContext(this.getContext(h)).lineWidth : 0;
  }
  drawGrid(i) {
    const l = this.options.grid, u = this.ctx, h = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(i));
    let g, _;
    const S = (T, E, A) => {
      !A.width || !A.color || (u.save(), u.lineWidth = A.width, u.strokeStyle = A.color, u.setLineDash(A.borderDash || []), u.lineDashOffset = A.borderDashOffset, u.beginPath(), u.moveTo(T.x, T.y), u.lineTo(E.x, E.y), u.stroke(), u.restore());
    };
    if (l.display)
      for (g = 0, _ = h.length; g < _; ++g) {
        const T = h[g];
        l.drawOnChartArea && S({
          x: T.x1,
          y: T.y1
        }, {
          x: T.x2,
          y: T.y2
        }, T), l.drawTicks && S({
          x: T.tx1,
          y: T.ty1
        }, {
          x: T.tx2,
          y: T.ty2
        }, {
          color: T.tickColor,
          width: T.tickWidth,
          borderDash: T.tickBorderDash,
          borderDashOffset: T.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: i, ctx: l, options: { border: u, grid: h } } = this, g = u.setContext(this.getContext()), _ = u.display ? g.width : 0;
    if (!_)
      return;
    const S = h.setContext(this.getContext(0)).lineWidth, T = this._borderValue;
    let E, A, C, z;
    this.isHorizontal() ? (E = rd(i, this.left, _) - _ / 2, A = rd(i, this.right, S) + S / 2, C = z = T) : (C = rd(i, this.top, _) - _ / 2, z = rd(i, this.bottom, S) + S / 2, E = A = T), l.save(), l.lineWidth = g.width, l.strokeStyle = g.color, l.beginPath(), l.moveTo(E, C), l.lineTo(A, z), l.stroke(), l.restore();
  }
  drawLabels(i) {
    if (!this.options.ticks.display)
      return;
    const u = this.ctx, h = this._computeLabelArea();
    h && M1(u, h);
    const g = this.getLabelItems(i);
    for (const _ of g) {
      const S = _.options, T = _.font, E = _.label, A = _.textOffset;
      gx(u, E, 0, A, T, S);
    }
    h && E1(u);
  }
  drawTitle() {
    const { ctx: i, options: { position: l, title: u, reverse: h } } = this;
    if (!u.display)
      return;
    const g = uu(u.font), _ = Of(u.padding), S = u.align;
    let T = g.lineHeight / 2;
    l === "bottom" || l === "center" || Pe(l) ? (T += _.bottom, Fi(u.text) && (T += g.lineHeight * (u.text.length - 1))) : T += _.top;
    const { titleX: E, titleY: A, maxWidth: C, rotation: z } = WA(this, T, l, S);
    gx(i, u.text, 0, 0, g, {
      color: u.color,
      maxWidth: C,
      rotation: z,
      textAlign: KA(S, l, h),
      textBaseline: "middle",
      translation: [
        E,
        A
      ]
    });
  }
  draw(i) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(i), this.drawBorder(), this.drawTitle(), this.drawLabels(i));
  }
  _layers() {
    const i = this.options, l = i.ticks && i.ticks.z || 0, u = gn(i.grid && i.grid.z, -1), h = gn(i.border && i.border.z, 0);
    return !this._isVisible() || this.draw !== Tv.prototype.draw ? [
      {
        z: l,
        draw: (g) => {
          this.draw(g);
        }
      }
    ] : [
      {
        z: u,
        draw: (g) => {
          this.drawBackground(), this.drawGrid(g), this.drawTitle();
        }
      },
      {
        z: h,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: l,
        draw: (g) => {
          this.drawLabels(g);
        }
      }
    ];
  }
  getMatchingVisibleMetas(i) {
    const l = this.chart.getSortedVisibleDatasetMetas(), u = this.axis + "AxisID", h = [];
    let g, _;
    for (g = 0, _ = l.length; g < _; ++g) {
      const S = l[g];
      S[u] === this.id && (!i || S.type === i) && h.push(S);
    }
    return h;
  }
  _resolveTickFontOptions(i) {
    const l = this.options.ticks.setContext(this.getContext(i));
    return uu(l.font);
  }
  _maxDigits() {
    const i = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / i;
  }
}
class c0 {
  constructor(i, l, u) {
    this.type = i, this.scope = l, this.override = u, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(i) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, i.prototype);
  }
  register(i) {
    const l = Object.getPrototypeOf(i);
    let u;
    $A(l) && (u = this.register(l));
    const h = this.items, g = i.id, _ = this.scope + "." + g;
    if (!g)
      throw new Error("class does not have id: " + i);
    return g in h || (h[g] = i, JA(i, _, u), this.override && wi.override(i.id, i.overrides)), _;
  }
  get(i) {
    return this.items[i];
  }
  unregister(i) {
    const l = this.items, u = i.id, h = this.scope;
    u in l && delete l[u], h && u in wi[h] && (delete wi[h][u], this.override && delete gd[u]);
  }
}
function JA(s, i, l) {
  const u = gv(/* @__PURE__ */ Object.create(null), [
    l ? wi.get(l) : {},
    wi.get(i),
    s.defaults
  ]);
  wi.set(i, u), s.defaultRoutes && IA(i, s.defaultRoutes), s.descriptors && wi.describe(i, s.descriptors);
}
function IA(s, i) {
  Object.keys(i).forEach((l) => {
    const u = l.split("."), h = u.pop(), g = [
      s
    ].concat(u).join("."), _ = i[l].split("."), S = _.pop(), T = _.join(".");
    wi.route(g, h, T, S);
  });
}
function $A(s) {
  return "id" in s && "defaults" in s;
}
class FA {
  constructor() {
    this.controllers = new c0(Qw, "datasets", !0), this.elements = new c0(Sv, "elements"), this.plugins = new c0(Object, "plugins"), this.scales = new c0(Tv, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...i) {
    this._each("register", i);
  }
  remove(...i) {
    this._each("unregister", i);
  }
  addControllers(...i) {
    this._each("register", i, this.controllers);
  }
  addElements(...i) {
    this._each("register", i, this.elements);
  }
  addPlugins(...i) {
    this._each("register", i, this.plugins);
  }
  addScales(...i) {
    this._each("register", i, this.scales);
  }
  getController(i) {
    return this._get(i, this.controllers, "controller");
  }
  getElement(i) {
    return this._get(i, this.elements, "element");
  }
  getPlugin(i) {
    return this._get(i, this.plugins, "plugin");
  }
  getScale(i) {
    return this._get(i, this.scales, "scale");
  }
  removeControllers(...i) {
    this._each("unregister", i, this.controllers);
  }
  removeElements(...i) {
    this._each("unregister", i, this.elements);
  }
  removePlugins(...i) {
    this._each("unregister", i, this.plugins);
  }
  removeScales(...i) {
    this._each("unregister", i, this.scales);
  }
  _each(i, l, u) {
    [
      ...l
    ].forEach((h) => {
      const g = u || this._getRegistryForType(h);
      u || g.isForType(h) || g === this.plugins && h.id ? this._exec(i, g, h) : un(h, (_) => {
        const S = u || this._getRegistryForType(_);
        this._exec(i, S, _);
      });
    });
  }
  _exec(i, l, u) {
    const h = T1(i);
    si(u["before" + h], [], u), l[i](u), si(u["after" + h], [], u);
  }
  _getRegistryForType(i) {
    for (let l = 0; l < this._typedRegistries.length; l++) {
      const u = this._typedRegistries[l];
      if (u.isForType(i))
        return u;
    }
    return this.plugins;
  }
  _get(i, l, u) {
    const h = l.get(i);
    if (h === void 0)
      throw new Error('"' + i + '" is not a registered ' + u + ".");
    return h;
  }
}
var ou = /* @__PURE__ */ new FA();
class tD {
  constructor() {
    this._init = [];
  }
  notify(i, l, u, h) {
    l === "beforeInit" && (this._init = this._createDescriptors(i, !0), this._notify(this._init, i, "install"));
    const g = h ? this._descriptors(i).filter(h) : this._descriptors(i), _ = this._notify(g, i, l, u);
    return l === "afterDestroy" && (this._notify(g, i, "stop"), this._notify(this._init, i, "uninstall")), _;
  }
  _notify(i, l, u, h) {
    h = h || {};
    for (const g of i) {
      const _ = g.plugin, S = _[u], T = [
        l,
        h,
        g.options
      ];
      if (si(S, T, _) === !1 && h.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    Mn(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(i) {
    if (this._cache)
      return this._cache;
    const l = this._cache = this._createDescriptors(i);
    return this._notifyStateChanges(i), l;
  }
  _createDescriptors(i, l) {
    const u = i && i.config, h = gn(u.options && u.options.plugins, {}), g = eD(u);
    return h === !1 && !l ? [] : iD(i, g, h, l);
  }
  _notifyStateChanges(i) {
    const l = this._oldCache || [], u = this._cache, h = (g, _) => g.filter((S) => !_.some((T) => S.plugin.id === T.plugin.id));
    this._notify(h(l, u), i, "stop"), this._notify(h(u, l), i, "start");
  }
}
function eD(s) {
  const i = {}, l = [], u = Object.keys(ou.plugins.items);
  for (let g = 0; g < u.length; g++)
    l.push(ou.getPlugin(u[g]));
  const h = s.plugins || [];
  for (let g = 0; g < h.length; g++) {
    const _ = h[g];
    l.indexOf(_) === -1 && (l.push(_), i[_.id] = !0);
  }
  return {
    plugins: l,
    localIds: i
  };
}
function nD(s, i) {
  return !i && s === !1 ? null : s === !0 ? {} : s;
}
function iD(s, { plugins: i, localIds: l }, u, h) {
  const g = [], _ = s.getContext();
  for (const S of i) {
    const T = S.id, E = nD(u[T], h);
    E !== null && g.push({
      plugin: S,
      options: aD(s.config, {
        plugin: S,
        local: l[T]
      }, E, _)
    });
  }
  return g;
}
function aD(s, { plugin: i, local: l }, u, h) {
  const g = s.pluginScopeKeys(i), _ = s.getOptionScopes(u, g);
  return l && i.defaults && _.push(i.defaults), s.createResolver(_, h, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function f1(s, i) {
  const l = wi.datasets[s] || {};
  return ((i.datasets || {})[s] || {}).indexAxis || i.indexAxis || l.indexAxis || "x";
}
function oD(s, i) {
  let l = s;
  return s === "_index_" ? l = i : s === "_value_" && (l = i === "x" ? "y" : "x"), l;
}
function lD(s, i) {
  return s === i ? "_index_" : "_value_";
}
function qx(s) {
  if (s === "x" || s === "y" || s === "r")
    return s;
}
function sD(s) {
  if (s === "top" || s === "bottom")
    return "x";
  if (s === "left" || s === "right")
    return "y";
}
function h1(s, ...i) {
  if (qx(s))
    return s;
  for (const l of i) {
    const u = l.axis || sD(l.position) || s.length > 1 && qx(s[0].toLowerCase());
    if (u)
      return u;
  }
  throw new Error(`Cannot determine type of '${s}' axis. Please provide 'axis' or 'position' option.`);
}
function Zx(s, i, l) {
  if (l[i + "AxisID"] === s)
    return {
      axis: i
    };
}
function rD(s, i) {
  if (i.data && i.data.datasets) {
    const l = i.data.datasets.filter((u) => u.xAxisID === s || u.yAxisID === s);
    if (l.length)
      return Zx(s, "x", l[0]) || Zx(s, "y", l[0]);
  }
  return {};
}
function uD(s, i) {
  const l = gd[s.type] || {
    scales: {}
  }, u = i.scales || {}, h = f1(s.type, i), g = /* @__PURE__ */ Object.create(null);
  return Object.keys(u).forEach((_) => {
    const S = u[_];
    if (!Pe(S))
      return console.error(`Invalid scale configuration for scale: ${_}`);
    if (S._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${_}`);
    const T = h1(_, S, rD(_, s), wi.scales[S.type]), E = lD(T, h), A = l.scales || {};
    g[_] = cv(/* @__PURE__ */ Object.create(null), [
      {
        axis: T
      },
      S,
      A[T],
      A[E]
    ]);
  }), s.data.datasets.forEach((_) => {
    const S = _.type || s.type, T = _.indexAxis || f1(S, i), A = (gd[S] || {}).scales || {};
    Object.keys(A).forEach((C) => {
      const z = oD(C, T), j = _[z + "AxisID"] || z;
      g[j] = g[j] || /* @__PURE__ */ Object.create(null), cv(g[j], [
        {
          axis: z
        },
        u[j],
        A[C]
      ]);
    });
  }), Object.keys(g).forEach((_) => {
    const S = g[_];
    cv(S, [
      wi.scales[S.type],
      wi.scale
    ]);
  }), g;
}
function tM(s) {
  const i = s.options || (s.options = {});
  i.plugins = gn(i.plugins, {}), i.scales = uD(s, i);
}
function eM(s) {
  return s = s || {}, s.datasets = s.datasets || [], s.labels = s.labels || [], s;
}
function cD(s) {
  return s = s || {}, s.data = eM(s.data), tM(s), s;
}
const Vx = /* @__PURE__ */ new Map(), nM = /* @__PURE__ */ new Set();
function f0(s, i) {
  let l = Vx.get(s);
  return l || (l = i(), Vx.set(s, l), nM.add(l)), l;
}
const ev = (s, i, l) => {
  const u = b0(i, l);
  u !== void 0 && s.add(u);
};
class fD {
  constructor(i) {
    this._config = cD(i), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(i) {
    this._config.type = i;
  }
  get data() {
    return this._config.data;
  }
  set data(i) {
    this._config.data = eM(i);
  }
  get options() {
    return this._config.options;
  }
  set options(i) {
    this._config.options = i;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const i = this._config;
    this.clearCache(), tM(i);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(i) {
    return f0(i, () => [
      [
        `datasets.${i}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(i, l) {
    return f0(`${i}.transition.${l}`, () => [
      [
        `datasets.${i}.transitions.${l}`,
        `transitions.${l}`
      ],
      [
        `datasets.${i}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(i, l) {
    return f0(`${i}-${l}`, () => [
      [
        `datasets.${i}.elements.${l}`,
        `datasets.${i}`,
        `elements.${l}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(i) {
    const l = i.id, u = this.type;
    return f0(`${u}-plugin-${l}`, () => [
      [
        `plugins.${l}`,
        ...i.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(i, l) {
    const u = this._scopeCache;
    let h = u.get(i);
    return (!h || l) && (h = /* @__PURE__ */ new Map(), u.set(i, h)), h;
  }
  getOptionScopes(i, l, u) {
    const { options: h, type: g } = this, _ = this._cachedScopes(i, u), S = _.get(l);
    if (S)
      return S;
    const T = /* @__PURE__ */ new Set();
    l.forEach((A) => {
      i && (T.add(i), A.forEach((C) => ev(T, i, C))), A.forEach((C) => ev(T, h, C)), A.forEach((C) => ev(T, gd[g] || {}, C)), A.forEach((C) => ev(T, wi, C)), A.forEach((C) => ev(T, u1, C));
    });
    const E = Array.from(T);
    return E.length === 0 && E.push(/* @__PURE__ */ Object.create(null)), nM.has(l) && _.set(l, E), E;
  }
  chartOptionScopes() {
    const { options: i, type: l } = this;
    return [
      i,
      gd[l] || {},
      wi.datasets[l] || {},
      {
        type: l
      },
      wi,
      u1
    ];
  }
  resolveNamedOptions(i, l, u, h = [
    ""
  ]) {
    const g = {
      $shared: !0
    }, { resolver: _, subPrefixes: S } = Px(this._resolverCache, i, h);
    let T = _;
    if (dD(_, l)) {
      g.$shared = !1, u = Ef(u) ? u() : u;
      const E = this.createResolver(i, u, S);
      T = Lp(_, u, E);
    }
    for (const E of l)
      g[E] = T[E];
    return g;
  }
  createResolver(i, l, u = [
    ""
  ], h) {
    const { resolver: g } = Px(this._resolverCache, i, u);
    return Pe(l) ? Lp(g, l, void 0, h) : g;
  }
}
function Px(s, i, l) {
  let u = s.get(i);
  u || (u = /* @__PURE__ */ new Map(), s.set(i, u));
  const h = l.join();
  let g = u.get(h);
  return g || (g = {
    resolver: O1(i, l),
    subPrefixes: l.filter((S) => !S.toLowerCase().includes("hover"))
  }, u.set(h, g)), g;
}
const hD = (s) => Pe(s) && Object.getOwnPropertyNames(s).some((i) => Ef(s[i]));
function dD(s, i) {
  const { isScriptable: l, isIndexable: u } = Nw(s);
  for (const h of i) {
    const g = l(h), _ = u(h), S = (_ || g) && s[h];
    if (g && (Ef(S) || hD(S)) || _ && Fi(S))
      return !0;
  }
  return !1;
}
var mD = "4.5.0";
const pD = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function Gx(s, i) {
  return s === "top" || s === "bottom" || pD.indexOf(s) === -1 && i === "x";
}
function Xx(s, i) {
  return function(l, u) {
    return l[s] === u[s] ? l[i] - u[i] : l[s] - u[s];
  };
}
function Qx(s) {
  const i = s.chart, l = i.options.animation;
  i.notifyPlugins("afterRender"), si(l && l.onComplete, [
    s
  ], i);
}
function gD(s) {
  const i = s.chart, l = i.options.animation;
  si(l && l.onProgress, [
    s
  ], i);
}
function iM(s) {
  return R1() && typeof s == "string" ? s = document.getElementById(s) : s && s.length && (s = s[0]), s && s.canvas && (s = s.canvas), s;
}
const y0 = {}, Kx = (s) => {
  const i = iM(s);
  return Object.values(y0).filter((l) => l.canvas === i).pop();
};
function yD(s, i, l) {
  const u = Object.keys(s);
  for (const h of u) {
    const g = +h;
    if (g >= i) {
      const _ = s[h];
      delete s[h], (l > 0 || g > i) && (s[g + l] = _);
    }
  }
}
function vD(s, i, l, u) {
  return !l || s.type === "mouseout" ? null : u ? i : s;
}
class L1 {
  static defaults = wi;
  static instances = y0;
  static overrides = gd;
  static registry = ou;
  static version = mD;
  static getChart = Kx;
  static register(...i) {
    ou.add(...i), Wx();
  }
  static unregister(...i) {
    ou.remove(...i), Wx();
  }
  constructor(i, l) {
    const u = this.config = new fD(l), h = iM(i), g = Kx(h);
    if (g)
      throw new Error("Canvas is already in use. Chart with ID '" + g.id + "' must be destroyed before the canvas with ID '" + g.canvas.id + "' can be reused.");
    const _ = u.createResolver(u.chartOptionScopes(), this.getContext());
    this.platform = new (u.platform || NA(h))(), this.platform.updateConfig(u);
    const S = this.platform.acquireContext(h, _.aspectRatio), T = S && S.canvas, E = T && T.height, A = T && T.width;
    if (this.id = S2(), this.ctx = S, this.canvas = T, this.width = A, this.height = E, this._options = _, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new tD(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Z2((C) => this.update(C), _.resizeDelay || 0), this._dataChanges = [], y0[this.id] = this, !S || !T) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    cc.listen(this, "complete", Qx), cc.listen(this, "progress", gD), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: i, maintainAspectRatio: l }, width: u, height: h, _aspectRatio: g } = this;
    return Mn(i) ? l && g ? g : h ? u / h : null : i;
  }
  get data() {
    return this.config.data;
  }
  set data(i) {
    this.config.data = i;
  }
  get options() {
    return this._options;
  }
  set options(i) {
    this.config.options = i;
  }
  get registry() {
    return ou;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : bx(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return px(this.canvas, this.ctx), this;
  }
  stop() {
    return cc.stop(this), this;
  }
  resize(i, l) {
    cc.running(this) ? this._resizeBeforeDraw = {
      width: i,
      height: l
    } : this._resize(i, l);
  }
  _resize(i, l) {
    const u = this.options, h = this.canvas, g = u.maintainAspectRatio && this.aspectRatio, _ = this.platform.getMaximumSize(h, i, l, g), S = u.devicePixelRatio || this.platform.getDevicePixelRatio(), T = this.width ? "resize" : "attach";
    this.width = _.width, this.height = _.height, this._aspectRatio = this.aspectRatio, bx(this, S, !0) && (this.notifyPlugins("resize", {
      size: _
    }), si(u.onResize, [
      this,
      _
    ], this), this.attached && this._doResize(T) && this.render());
  }
  ensureScalesHaveIDs() {
    const l = this.options.scales || {};
    un(l, (u, h) => {
      u.id = h;
    });
  }
  buildOrUpdateScales() {
    const i = this.options, l = i.scales, u = this.scales, h = Object.keys(u).reduce((_, S) => (_[S] = !1, _), {});
    let g = [];
    l && (g = g.concat(Object.keys(l).map((_) => {
      const S = l[_], T = h1(_, S), E = T === "r", A = T === "x";
      return {
        options: S,
        dposition: E ? "chartArea" : A ? "bottom" : "left",
        dtype: E ? "radialLinear" : A ? "category" : "linear"
      };
    }))), un(g, (_) => {
      const S = _.options, T = S.id, E = h1(T, S), A = gn(S.type, _.dtype);
      (S.position === void 0 || Gx(S.position, E) !== Gx(_.dposition)) && (S.position = _.dposition), h[T] = !0;
      let C = null;
      if (T in u && u[T].type === A)
        C = u[T];
      else {
        const z = ou.getScale(A);
        C = new z({
          id: T,
          type: A,
          ctx: this.ctx,
          chart: this
        }), u[C.id] = C;
      }
      C.init(S, i);
    }), un(h, (_, S) => {
      _ || delete u[S];
    }), un(u, (_) => {
      r0.configure(this, _, _.options), r0.addBox(this, _);
    });
  }
  _updateMetasets() {
    const i = this._metasets, l = this.data.datasets.length, u = i.length;
    if (i.sort((h, g) => h.index - g.index), u > l) {
      for (let h = l; h < u; ++h)
        this._destroyDatasetMeta(h);
      i.splice(l, u - l);
    }
    this._sortedMetasets = i.slice(0).sort(Xx("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: i, data: { datasets: l } } = this;
    i.length > l.length && delete this._stacks, i.forEach((u, h) => {
      l.filter((g) => g === u._dataset).length === 0 && this._destroyDatasetMeta(h);
    });
  }
  buildOrUpdateControllers() {
    const i = [], l = this.data.datasets;
    let u, h;
    for (this._removeUnreferencedMetasets(), u = 0, h = l.length; u < h; u++) {
      const g = l[u];
      let _ = this.getDatasetMeta(u);
      const S = g.type || this.config.type;
      if (_.type && _.type !== S && (this._destroyDatasetMeta(u), _ = this.getDatasetMeta(u)), _.type = S, _.indexAxis = g.indexAxis || f1(S, this.options), _.order = g.order || 0, _.index = u, _.label = "" + g.label, _.visible = this.isDatasetVisible(u), _.controller)
        _.controller.updateIndex(u), _.controller.linkScales();
      else {
        const T = ou.getController(S), { datasetElementType: E, dataElementType: A } = wi.datasets[S];
        Object.assign(T, {
          dataElementType: ou.getElement(A),
          datasetElementType: E && ou.getElement(E)
        }), _.controller = new T(this, u), i.push(_.controller);
      }
    }
    return this._updateMetasets(), i;
  }
  _resetElements() {
    un(this.data.datasets, (i, l) => {
      this.getDatasetMeta(l).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(i) {
    const l = this.config;
    l.update();
    const u = this._options = l.createResolver(l.chartOptionScopes(), this.getContext()), h = this._animationsDisabled = !u.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: i,
      cancelable: !0
    }) === !1)
      return;
    const g = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let _ = 0;
    for (let E = 0, A = this.data.datasets.length; E < A; E++) {
      const { controller: C } = this.getDatasetMeta(E), z = !h && g.indexOf(C) === -1;
      C.buildOrUpdateElements(z), _ = Math.max(+C.getMaxOverflow(), _);
    }
    _ = this._minPadding = u.layout.autoPadding ? _ : 0, this._updateLayout(_), h || un(g, (E) => {
      E.reset();
    }), this._updateDatasets(i), this.notifyPlugins("afterUpdate", {
      mode: i
    }), this._layers.sort(Xx("z", "_idx"));
    const { _active: S, _lastEvent: T } = this;
    T ? this._eventHandler(T, !0) : S.length && this._updateHoverStyles(S, S, !0), this.render();
  }
  _updateScales() {
    un(this.scales, (i) => {
      r0.removeBox(this, i);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const i = this.options, l = new Set(Object.keys(this._listeners)), u = new Set(i.events);
    (!ax(l, u) || !!this._responsiveListeners !== i.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: i } = this, l = this._getUniformDataChanges() || [];
    for (const { method: u, start: h, count: g } of l) {
      const _ = u === "_removeElements" ? -g : g;
      yD(i, h, _);
    }
  }
  _getUniformDataChanges() {
    const i = this._dataChanges;
    if (!i || !i.length)
      return;
    this._dataChanges = [];
    const l = this.data.datasets.length, u = (g) => new Set(i.filter((_) => _[0] === g).map((_, S) => S + "," + _.splice(1).join(","))), h = u(0);
    for (let g = 1; g < l; g++)
      if (!ax(h, u(g)))
        return;
    return Array.from(h).map((g) => g.split(",")).map((g) => ({
      method: g[1],
      start: +g[2],
      count: +g[3]
    }));
  }
  _updateLayout(i) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    r0.update(this, this.width, this.height, i);
    const l = this.chartArea, u = l.width <= 0 || l.height <= 0;
    this._layers = [], un(this.boxes, (h) => {
      u && h.position === "chartArea" || (h.configure && h.configure(), this._layers.push(...h._layers()));
    }, this), this._layers.forEach((h, g) => {
      h._idx = g;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(i) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: i,
      cancelable: !0
    }) !== !1) {
      for (let l = 0, u = this.data.datasets.length; l < u; ++l)
        this.getDatasetMeta(l).controller.configure();
      for (let l = 0, u = this.data.datasets.length; l < u; ++l)
        this._updateDataset(l, Ef(i) ? i({
          datasetIndex: l
        }) : i);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: i
      });
    }
  }
  _updateDataset(i, l) {
    const u = this.getDatasetMeta(i), h = {
      meta: u,
      index: i,
      mode: l,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", h) !== !1 && (u.controller._update(l), h.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", h));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (cc.has(this) ? this.attached && !cc.running(this) && cc.start(this) : (this.draw(), Qx({
      chart: this
    })));
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width: u, height: h } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(u, h);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const l = this._layers;
    for (i = 0; i < l.length && l[i].z <= 0; ++i)
      l[i].draw(this.chartArea);
    for (this._drawDatasets(); i < l.length; ++i)
      l[i].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(i) {
    const l = this._sortedMetasets, u = [];
    let h, g;
    for (h = 0, g = l.length; h < g; ++h) {
      const _ = l[h];
      (!i || _.visible) && u.push(_);
    }
    return u;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const i = this.getSortedVisibleDatasetMetas();
    for (let l = i.length - 1; l >= 0; --l)
      this._drawDataset(i[l]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(i) {
    const l = this.ctx, u = {
      meta: i,
      index: i.index,
      cancelable: !0
    }, h = Pw(this, i);
    this.notifyPlugins("beforeDatasetDraw", u) !== !1 && (h && M1(l, h), i.controller.draw(), h && E1(l), u.cancelable = !1, this.notifyPlugins("afterDatasetDraw", u));
  }
  isPointInArea(i) {
    return vv(i, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(i, l, u, h) {
    const g = pA.modes[l];
    return typeof g == "function" ? g(this, i, u, h) : [];
  }
  getDatasetMeta(i) {
    const l = this.data.datasets[i], u = this._metasets;
    let h = u.filter((g) => g && g._dataset === l).pop();
    return h || (h = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: l && l.order || 0,
      index: i,
      _dataset: l,
      _parsed: [],
      _sorted: !1
    }, u.push(h)), h;
  }
  getContext() {
    return this.$context || (this.$context = yd(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(i) {
    const l = this.data.datasets[i];
    if (!l)
      return !1;
    const u = this.getDatasetMeta(i);
    return typeof u.hidden == "boolean" ? !u.hidden : !l.hidden;
  }
  setDatasetVisibility(i, l) {
    const u = this.getDatasetMeta(i);
    u.hidden = !l;
  }
  toggleDataVisibility(i) {
    this._hiddenIndices[i] = !this._hiddenIndices[i];
  }
  getDataVisibility(i) {
    return !this._hiddenIndices[i];
  }
  _updateVisibility(i, l, u) {
    const h = u ? "show" : "hide", g = this.getDatasetMeta(i), _ = g.controller._resolveAnimations(void 0, h);
    S0(l) ? (g.data[l].hidden = !u, this.update()) : (this.setDatasetVisibility(i, u), _.update(g, {
      visible: u
    }), this.update((S) => S.datasetIndex === i ? h : void 0));
  }
  hide(i, l) {
    this._updateVisibility(i, l, !1);
  }
  show(i, l) {
    this._updateVisibility(i, l, !0);
  }
  _destroyDatasetMeta(i) {
    const l = this._metasets[i];
    l && l.controller && l.controller._destroy(), delete this._metasets[i];
  }
  _stop() {
    let i, l;
    for (this.stop(), cc.remove(this), i = 0, l = this.data.datasets.length; i < l; ++i)
      this._destroyDatasetMeta(i);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: i, ctx: l } = this;
    this._stop(), this.config.clearCache(), i && (this.unbindEvents(), px(i, l), this.platform.releaseContext(l), this.canvas = null, this.ctx = null), delete y0[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...i) {
    return this.canvas.toDataURL(...i);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const i = this._listeners, l = this.platform, u = (g, _) => {
      l.addEventListener(this, g, _), i[g] = _;
    }, h = (g, _, S) => {
      g.offsetX = _, g.offsetY = S, this._eventHandler(g);
    };
    un(this.options.events, (g) => u(g, h));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const i = this._responsiveListeners, l = this.platform, u = (T, E) => {
      l.addEventListener(this, T, E), i[T] = E;
    }, h = (T, E) => {
      i[T] && (l.removeEventListener(this, T, E), delete i[T]);
    }, g = (T, E) => {
      this.canvas && this.resize(T, E);
    };
    let _;
    const S = () => {
      h("attach", S), this.attached = !0, this.resize(), u("resize", g), u("detach", _);
    };
    _ = () => {
      this.attached = !1, h("resize", g), this._stop(), this._resize(0, 0), u("attach", S);
    }, l.isAttached(this.canvas) ? S() : _();
  }
  unbindEvents() {
    un(this._listeners, (i, l) => {
      this.platform.removeEventListener(this, l, i);
    }), this._listeners = {}, un(this._responsiveListeners, (i, l) => {
      this.platform.removeEventListener(this, l, i);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(i, l, u) {
    const h = u ? "set" : "remove";
    let g, _, S, T;
    for (l === "dataset" && (g = this.getDatasetMeta(i[0].datasetIndex), g.controller["_" + h + "DatasetHoverStyle"]()), S = 0, T = i.length; S < T; ++S) {
      _ = i[S];
      const E = _ && this.getDatasetMeta(_.datasetIndex).controller;
      E && E[h + "HoverStyle"](_.element, _.datasetIndex, _.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(i) {
    const l = this._active || [], u = i.map(({ datasetIndex: g, index: _ }) => {
      const S = this.getDatasetMeta(g);
      if (!S)
        throw new Error("No dataset found at index " + g);
      return {
        datasetIndex: g,
        element: S.data[_],
        index: _
      };
    });
    !v0(u, l) && (this._active = u, this._lastEvent = null, this._updateHoverStyles(u, l));
  }
  notifyPlugins(i, l, u) {
    return this._plugins.notify(this, i, l, u);
  }
  isPluginEnabled(i) {
    return this._plugins._cache.filter((l) => l.plugin.id === i).length === 1;
  }
  _updateHoverStyles(i, l, u) {
    const h = this.options.hover, g = (T, E) => T.filter((A) => !E.some((C) => A.datasetIndex === C.datasetIndex && A.index === C.index)), _ = g(l, i), S = u ? i : g(i, l);
    _.length && this.updateHoverStyle(_, h.mode, !1), S.length && h.mode && this.updateHoverStyle(S, h.mode, !0);
  }
  _eventHandler(i, l) {
    const u = {
      event: i,
      replay: l,
      cancelable: !0,
      inChartArea: this.isPointInArea(i)
    }, h = (_) => (_.options.events || this.options.events).includes(i.native.type);
    if (this.notifyPlugins("beforeEvent", u, h) === !1)
      return;
    const g = this._handleEvent(i, l, u.inChartArea);
    return u.cancelable = !1, this.notifyPlugins("afterEvent", u, h), (g || u.changed) && this.render(), this;
  }
  _handleEvent(i, l, u) {
    const { _active: h = [], options: g } = this, _ = l, S = this._getActiveElements(i, h, u, _), T = O2(i), E = vD(i, this._lastEvent, u, T);
    u && (this._lastEvent = null, si(g.onHover, [
      i,
      S,
      this
    ], this), T && si(g.onClick, [
      i,
      S,
      this
    ], this));
    const A = !v0(S, h);
    return (A || l) && (this._active = S, this._updateHoverStyles(S, h, l)), this._lastEvent = E, A;
  }
  _getActiveElements(i, l, u, h) {
    if (i.type === "mouseout")
      return [];
    if (!u)
      return l;
    const g = this.options.hover;
    return this.getElementsAtEventForMode(i, g.mode, g, h);
  }
}
function Wx() {
  return un(L1.instances, (s) => s._plugins.invalidate());
}
function aM(s, i, l = i) {
  s.lineCap = gn(l.borderCapStyle, i.borderCapStyle), s.setLineDash(gn(l.borderDash, i.borderDash)), s.lineDashOffset = gn(l.borderDashOffset, i.borderDashOffset), s.lineJoin = gn(l.borderJoinStyle, i.borderJoinStyle), s.lineWidth = gn(l.borderWidth, i.borderWidth), s.strokeStyle = gn(l.borderColor, i.borderColor);
}
function _D(s, i, l) {
  s.lineTo(l.x, l.y);
}
function bD(s) {
  return s.stepped ? iO : s.tension || s.cubicInterpolationMode === "monotone" ? aO : _D;
}
function oM(s, i, l = {}) {
  const u = s.length, { start: h = 0, end: g = u - 1 } = l, { start: _, end: S } = i, T = Math.max(h, _), E = Math.min(g, S), A = h < _ && g < _ || h > S && g > S;
  return {
    count: u,
    start: T,
    loop: i.loop,
    ilen: E < T && !A ? u + E - T : E - T
  };
}
function SD(s, i, l, u) {
  const { points: h, options: g } = i, { count: _, start: S, loop: T, ilen: E } = oM(h, l, u), A = bD(g);
  let { move: C = !0, reverse: z } = u || {}, j, J, Q;
  for (j = 0; j <= E; ++j)
    J = h[(S + (z ? E - j : j)) % _], !J.skip && (C ? (s.moveTo(J.x, J.y), C = !1) : A(s, Q, J, z, g.stepped), Q = J);
  return T && (J = h[(S + (z ? E : 0)) % _], A(s, Q, J, z, g.stepped)), !!T;
}
function TD(s, i, l, u) {
  const h = i.points, { count: g, start: _, ilen: S } = oM(h, l, u), { move: T = !0, reverse: E } = u || {};
  let A = 0, C = 0, z, j, J, Q, X, et;
  const wt = (Lt) => (_ + (E ? S - Lt : Lt)) % g, At = () => {
    Q !== X && (s.lineTo(A, X), s.lineTo(A, Q), s.lineTo(A, et));
  };
  for (T && (j = h[wt(0)], s.moveTo(j.x, j.y)), z = 0; z <= S; ++z) {
    if (j = h[wt(z)], j.skip)
      continue;
    const Lt = j.x, yt = j.y, Bt = Lt | 0;
    Bt === J ? (yt < Q ? Q = yt : yt > X && (X = yt), A = (C * A + Lt) / ++C) : (At(), s.lineTo(Lt, yt), J = Bt, C = 0, Q = X = yt), et = yt;
  }
  At();
}
function d1(s) {
  const i = s.options, l = i.borderDash && i.borderDash.length;
  return !s._decimated && !s._loop && !i.tension && i.cubicInterpolationMode !== "monotone" && !i.stepped && !l ? TD : SD;
}
function xD(s) {
  return s.stepped ? UO : s.tension || s.cubicInterpolationMode === "monotone" ? BO : fd;
}
function wD(s, i, l, u) {
  let h = i._path;
  h || (h = i._path = new Path2D(), i.path(h, l, u) && h.closePath()), aM(s, i.options), s.stroke(h);
}
function MD(s, i, l, u) {
  const { segments: h, options: g } = i, _ = d1(i);
  for (const S of h)
    aM(s, g, S.style), s.beginPath(), _(s, i, S, {
      start: l,
      end: l + u - 1
    }) && s.closePath(), s.stroke();
}
const ED = typeof Path2D == "function";
function OD(s, i, l, u) {
  ED && !i.options.segment ? wD(s, i, l, u) : MD(s, i, l, u);
}
class D0 extends Sv {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (i) => i !== "borderDash" && i !== "fill"
  };
  constructor(i) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, i && Object.assign(this, i);
  }
  updateControlPoints(i, l) {
    const u = this.options;
    if ((u.tension || u.cubicInterpolationMode === "monotone") && !u.stepped && !this._pointsUpdated) {
      const h = u.spanGaps ? this._loop : this._fullLoop;
      DO(this._points, u, i, h, l), this._pointsUpdated = !0;
    }
  }
  set points(i) {
    this._points = i, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = XO(this, this.options.segment));
  }
  first() {
    const i = this.segments, l = this.points;
    return i.length && l[i[0].start];
  }
  last() {
    const i = this.segments, l = this.points, u = i.length;
    return u && l[i[u - 1].end];
  }
  interpolate(i, l) {
    const u = this.options, h = i[l], g = this.points, _ = Vw(this, {
      property: l,
      start: h,
      end: h
    });
    if (!_.length)
      return;
    const S = [], T = xD(u);
    let E, A;
    for (E = 0, A = _.length; E < A; ++E) {
      const { start: C, end: z } = _[E], j = g[C], J = g[z];
      if (j === J) {
        S.push(j);
        continue;
      }
      const Q = Math.abs((h - j[l]) / (J[l] - j[l])), X = T(j, J, Q, u.stepped);
      X[l] = i[l], S.push(X);
    }
    return S.length === 1 ? S[0] : S;
  }
  pathSegment(i, l, u) {
    return d1(this)(i, this, l, u);
  }
  path(i, l, u) {
    const h = this.segments, g = d1(this);
    let _ = this._loop;
    l = l || 0, u = u || this.points.length - l;
    for (const S of h)
      _ &= g(i, this, S, {
        start: l,
        end: l + u - 1
      });
    return !!_;
  }
  draw(i, l, u, h) {
    const g = this.options || {};
    (this.points || []).length && g.borderWidth && (i.save(), OD(i, this, u, h), i.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
function Jx(s, i, l, u) {
  const h = s.options, { [l]: g } = s.getProps([
    l
  ], u);
  return Math.abs(i - g) < h.radius + h.hitRadius;
}
class AD extends Sv {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(i) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, i && Object.assign(this, i);
  }
  inRange(i, l, u) {
    const h = this.options, { x: g, y: _ } = this.getProps([
      "x",
      "y"
    ], u);
    return Math.pow(i - g, 2) + Math.pow(l - _, 2) < Math.pow(h.hitRadius + h.radius, 2);
  }
  inXRange(i, l) {
    return Jx(this, i, "x", l);
  }
  inYRange(i, l) {
    return Jx(this, i, "y", l);
  }
  getCenterPoint(i) {
    const { x: l, y: u } = this.getProps([
      "x",
      "y"
    ], i);
    return {
      x: l,
      y: u
    };
  }
  size(i) {
    i = i || this.options || {};
    let l = i.radius || 0;
    l = Math.max(l, l && i.hoverRadius || 0);
    const u = l && i.borderWidth || 0;
    return (l + u) * 2;
  }
  draw(i, l) {
    const u = this.options;
    this.skip || u.radius < 0.1 || !vv(this, l, this.size(u) / 2) || (i.strokeStyle = u.borderColor, i.lineWidth = u.borderWidth, i.fillStyle = u.backgroundColor, c1(i, u, this.x, this.y));
  }
  getRange() {
    const i = this.options || {};
    return i.radius + i.hitRadius;
  }
}
function DD(s, i, l) {
  const u = s.segments, h = s.points, g = i.points, _ = [];
  for (const S of u) {
    let { start: T, end: E } = S;
    E = R0(T, E, h);
    const A = m1(l, h[T], h[E], S.loop);
    if (!i.segments) {
      _.push({
        source: S,
        target: A,
        start: h[T],
        end: h[E]
      });
      continue;
    }
    const C = Vw(i, A);
    for (const z of C) {
      const j = m1(l, g[z.start], g[z.end], z.loop), J = Zw(S, h, j);
      for (const Q of J)
        _.push({
          source: Q,
          target: z,
          start: {
            [l]: Ix(A, j, "start", Math.max)
          },
          end: {
            [l]: Ix(A, j, "end", Math.min)
          }
        });
    }
  }
  return _;
}
function m1(s, i, l, u) {
  if (u)
    return;
  let h = i[s], g = l[s];
  return s === "angle" && (h = lu(h), g = lu(g)), {
    property: s,
    start: h,
    end: g
  };
}
function RD(s, i) {
  const { x: l = null, y: u = null } = s || {}, h = i.points, g = [];
  return i.segments.forEach(({ start: _, end: S }) => {
    S = R0(_, S, h);
    const T = h[_], E = h[S];
    u !== null ? (g.push({
      x: T.x,
      y: u
    }), g.push({
      x: E.x,
      y: u
    })) : l !== null && (g.push({
      x: l,
      y: T.y
    }), g.push({
      x: l,
      y: E.y
    }));
  }), g;
}
function R0(s, i, l) {
  for (; i > s; i--) {
    const u = l[i];
    if (!isNaN(u.x) && !isNaN(u.y))
      break;
  }
  return i;
}
function Ix(s, i, l, u) {
  return s && i ? u(s[l], i[l]) : s ? s[l] : i ? i[l] : 0;
}
function lM(s, i) {
  let l = [], u = !1;
  return Fi(s) ? (u = !0, l = s) : l = RD(s, i), l.length ? new D0({
    points: l,
    options: {
      tension: 0
    },
    _loop: u,
    _fullLoop: u
  }) : null;
}
function $x(s) {
  return s && s.fill !== !1;
}
function CD(s, i, l) {
  let h = s[i].fill;
  const g = [
    i
  ];
  let _;
  if (!l)
    return h;
  for (; h !== !1 && g.indexOf(h) === -1; ) {
    if (!qa(h))
      return h;
    if (_ = s[h], !_)
      return !1;
    if (_.visible)
      return h;
    g.push(h), h = _.fill;
  }
  return !1;
}
function zD(s, i, l) {
  const u = ND(s);
  if (Pe(u))
    return isNaN(u.value) ? !1 : u;
  let h = parseFloat(u);
  return qa(h) && Math.floor(h) === h ? LD(u[0], i, h, l) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(u) >= 0 && u;
}
function LD(s, i, l, u) {
  return (s === "-" || s === "+") && (l = i + l), l === i || l < 0 || l >= u ? !1 : l;
}
function HD(s, i) {
  let l = null;
  return s === "start" ? l = i.bottom : s === "end" ? l = i.top : Pe(s) ? l = i.getPixelForValue(s.value) : i.getBasePixel && (l = i.getBasePixel()), l;
}
function kD(s, i, l) {
  let u;
  return s === "start" ? u = l : s === "end" ? u = i.options.reverse ? i.min : i.max : Pe(s) ? u = s.value : u = i.getBaseValue(), u;
}
function ND(s) {
  const i = s.options, l = i.fill;
  let u = gn(l && l.target, l);
  return u === void 0 && (u = !!i.backgroundColor), u === !1 || u === null ? !1 : u === !0 ? "origin" : u;
}
function UD(s) {
  const { scale: i, index: l, line: u } = s, h = [], g = u.segments, _ = u.points, S = BD(i, l);
  S.push(lM({
    x: null,
    y: i.bottom
  }, u));
  for (let T = 0; T < g.length; T++) {
    const E = g[T];
    for (let A = E.start; A <= E.end; A++)
      YD(h, _[A], S);
  }
  return new D0({
    points: h,
    options: {}
  });
}
function BD(s, i) {
  const l = [], u = s.getMatchingVisibleMetas("line");
  for (let h = 0; h < u.length; h++) {
    const g = u[h];
    if (g.index === i)
      break;
    g.hidden || l.unshift(g.dataset);
  }
  return l;
}
function YD(s, i, l) {
  const u = [];
  for (let h = 0; h < l.length; h++) {
    const g = l[h], { first: _, last: S, point: T } = jD(g, i, "x");
    if (!(!T || _ && S)) {
      if (_)
        u.unshift(T);
      else if (s.push(T), !S)
        break;
    }
  }
  s.push(...u);
}
function jD(s, i, l) {
  const u = s.interpolate(i, l);
  if (!u)
    return {};
  const h = u[l], g = s.segments, _ = s.points;
  let S = !1, T = !1;
  for (let E = 0; E < g.length; E++) {
    const A = g[E], C = _[A.start][l], z = _[A.end][l];
    if (Dw(h, C, z)) {
      S = h === C, T = h === z;
      break;
    }
  }
  return {
    first: S,
    last: T,
    point: u
  };
}
class sM {
  constructor(i) {
    this.x = i.x, this.y = i.y, this.radius = i.radius;
  }
  pathSegment(i, l, u) {
    const { x: h, y: g, radius: _ } = this;
    return l = l || {
      start: 0,
      end: cu
    }, i.arc(h, g, _, l.end, l.start, !0), !u.bounds;
  }
  interpolate(i) {
    const { x: l, y: u, radius: h } = this, g = i.angle;
    return {
      x: l + Math.cos(g) * h,
      y: u + Math.sin(g) * h,
      angle: g
    };
  }
}
function qD(s) {
  const { chart: i, fill: l, line: u } = s;
  if (qa(l))
    return ZD(i, l);
  if (l === "stack")
    return UD(s);
  if (l === "shape")
    return !0;
  const h = VD(s);
  return h instanceof sM ? h : lM(h, u);
}
function ZD(s, i) {
  const l = s.getDatasetMeta(i);
  return l && s.isDatasetVisible(i) ? l.dataset : null;
}
function VD(s) {
  return (s.scale || {}).getPointPositionForValue ? GD(s) : PD(s);
}
function PD(s) {
  const { scale: i = {}, fill: l } = s, u = HD(l, i);
  if (qa(u)) {
    const h = i.isHorizontal();
    return {
      x: h ? u : null,
      y: h ? null : u
    };
  }
  return null;
}
function GD(s) {
  const { scale: i, fill: l } = s, u = i.options, h = i.getLabels().length, g = u.reverse ? i.max : i.min, _ = kD(l, i, g), S = [];
  if (u.grid.circular) {
    const T = i.getPointPositionForValue(0, g);
    return new sM({
      x: T.x,
      y: T.y,
      radius: i.getDistanceFromCenterForValue(_)
    });
  }
  for (let T = 0; T < h; ++T)
    S.push(i.getPointPositionForValue(T, _));
  return S;
}
function n1(s, i, l) {
  const u = qD(i), { chart: h, index: g, line: _, scale: S, axis: T } = i, E = _.options, A = E.fill, C = E.backgroundColor, { above: z = C, below: j = C } = A || {}, J = h.getDatasetMeta(g), Q = Pw(h, J);
  u && _.points.length && (M1(s, l), XD(s, {
    line: _,
    target: u,
    above: z,
    below: j,
    area: l,
    scale: S,
    axis: T,
    clip: Q
  }), E1(s));
}
function XD(s, i) {
  const { line: l, target: u, above: h, below: g, area: _, scale: S, clip: T } = i, E = l._loop ? "angle" : i.axis;
  s.save();
  let A = g;
  g !== h && (E === "x" ? (Fx(s, u, _.top), i1(s, {
    line: l,
    target: u,
    color: h,
    scale: S,
    property: E,
    clip: T
  }), s.restore(), s.save(), Fx(s, u, _.bottom)) : E === "y" && (tw(s, u, _.left), i1(s, {
    line: l,
    target: u,
    color: g,
    scale: S,
    property: E,
    clip: T
  }), s.restore(), s.save(), tw(s, u, _.right), A = h)), i1(s, {
    line: l,
    target: u,
    color: A,
    scale: S,
    property: E,
    clip: T
  }), s.restore();
}
function Fx(s, i, l) {
  const { segments: u, points: h } = i;
  let g = !0, _ = !1;
  s.beginPath();
  for (const S of u) {
    const { start: T, end: E } = S, A = h[T], C = h[R0(T, E, h)];
    g ? (s.moveTo(A.x, A.y), g = !1) : (s.lineTo(A.x, l), s.lineTo(A.x, A.y)), _ = !!i.pathSegment(s, S, {
      move: _
    }), _ ? s.closePath() : s.lineTo(C.x, l);
  }
  s.lineTo(i.first().x, l), s.closePath(), s.clip();
}
function tw(s, i, l) {
  const { segments: u, points: h } = i;
  let g = !0, _ = !1;
  s.beginPath();
  for (const S of u) {
    const { start: T, end: E } = S, A = h[T], C = h[R0(T, E, h)];
    g ? (s.moveTo(A.x, A.y), g = !1) : (s.lineTo(l, A.y), s.lineTo(A.x, A.y)), _ = !!i.pathSegment(s, S, {
      move: _
    }), _ ? s.closePath() : s.lineTo(l, C.y);
  }
  s.lineTo(l, i.first().y), s.closePath(), s.clip();
}
function i1(s, i) {
  const { line: l, target: u, property: h, color: g, scale: _, clip: S } = i, T = DD(l, u, h);
  for (const { source: E, target: A, start: C, end: z } of T) {
    const { style: { backgroundColor: j = g } = {} } = E, J = u !== !0;
    s.save(), s.fillStyle = j, QD(s, _, S, J && m1(h, C, z)), s.beginPath();
    const Q = !!l.pathSegment(s, E);
    let X;
    if (J) {
      Q ? s.closePath() : ew(s, u, z, h);
      const et = !!u.pathSegment(s, A, {
        move: Q,
        reverse: !0
      });
      X = Q && et, X || ew(s, u, C, h);
    }
    s.closePath(), s.fill(X ? "evenodd" : "nonzero"), s.restore();
  }
}
function QD(s, i, l, u) {
  const h = i.chart.chartArea, { property: g, start: _, end: S } = u || {};
  if (g === "x" || g === "y") {
    let T, E, A, C;
    g === "x" ? (T = _, E = h.top, A = S, C = h.bottom) : (T = h.left, E = _, A = h.right, C = S), s.beginPath(), l && (T = Math.max(T, l.left), A = Math.min(A, l.right), E = Math.max(E, l.top), C = Math.min(C, l.bottom)), s.rect(T, E, A - T, C - E), s.clip();
  }
}
function ew(s, i, l, u) {
  const h = i.interpolate(l, u);
  h && s.lineTo(h.x, h.y);
}
var KD = {
  id: "filler",
  afterDatasetsUpdate(s, i, l) {
    const u = (s.data.datasets || []).length, h = [];
    let g, _, S, T;
    for (_ = 0; _ < u; ++_)
      g = s.getDatasetMeta(_), S = g.dataset, T = null, S && S.options && S instanceof D0 && (T = {
        visible: s.isDatasetVisible(_),
        index: _,
        fill: zD(S, _, u),
        chart: s,
        axis: g.controller.options.indexAxis,
        scale: g.vScale,
        line: S
      }), g.$filler = T, h.push(T);
    for (_ = 0; _ < u; ++_)
      T = h[_], !(!T || T.fill === !1) && (T.fill = CD(h, _, l.propagate));
  },
  beforeDraw(s, i, l) {
    const u = l.drawTime === "beforeDraw", h = s.getSortedVisibleDatasetMetas(), g = s.chartArea;
    for (let _ = h.length - 1; _ >= 0; --_) {
      const S = h[_].$filler;
      S && (S.line.updateControlPoints(g, S.axis), u && S.fill && n1(s.ctx, S, g));
    }
  },
  beforeDatasetsDraw(s, i, l) {
    if (l.drawTime !== "beforeDatasetsDraw")
      return;
    const u = s.getSortedVisibleDatasetMetas();
    for (let h = u.length - 1; h >= 0; --h) {
      const g = u[h].$filler;
      $x(g) && n1(s.ctx, g, s.chartArea);
    }
  },
  beforeDatasetDraw(s, i, l) {
    const u = i.meta.$filler;
    !$x(u) || l.drawTime !== "beforeDatasetDraw" || n1(s.ctx, u, s.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const rv = {
  average(s) {
    if (!s.length)
      return !1;
    let i, l, u = /* @__PURE__ */ new Set(), h = 0, g = 0;
    for (i = 0, l = s.length; i < l; ++i) {
      const S = s[i].element;
      if (S && S.hasValue()) {
        const T = S.tooltipPosition();
        u.add(T.x), h += T.y, ++g;
      }
    }
    return g === 0 || u.size === 0 ? !1 : {
      x: [
        ...u
      ].reduce((S, T) => S + T) / u.size,
      y: h / g
    };
  },
  nearest(s, i) {
    if (!s.length)
      return !1;
    let l = i.x, u = i.y, h = Number.POSITIVE_INFINITY, g, _, S;
    for (g = 0, _ = s.length; g < _; ++g) {
      const T = s[g].element;
      if (T && T.hasValue()) {
        const E = T.getCenterPoint(), A = r1(i, E);
        A < h && (h = A, S = T);
      }
    }
    if (S) {
      const T = S.tooltipPosition();
      l = T.x, u = T.y;
    }
    return {
      x: l,
      y: u
    };
  }
};
function au(s, i) {
  return i && (Fi(i) ? Array.prototype.push.apply(s, i) : s.push(i)), s;
}
function fc(s) {
  return (typeof s == "string" || s instanceof String) && s.indexOf(`
`) > -1 ? s.split(`
`) : s;
}
function WD(s, i) {
  const { element: l, datasetIndex: u, index: h } = i, g = s.getDatasetMeta(u).controller, { label: _, value: S } = g.getLabelAndValue(h);
  return {
    chart: s,
    label: _,
    parsed: g.getParsed(h),
    raw: s.data.datasets[u].data[h],
    formattedValue: S,
    dataset: g.getDataset(),
    dataIndex: h,
    datasetIndex: u,
    element: l
  };
}
function nw(s, i) {
  const l = s.chart.ctx, { body: u, footer: h, title: g } = s, { boxWidth: _, boxHeight: S } = i, T = uu(i.bodyFont), E = uu(i.titleFont), A = uu(i.footerFont), C = g.length, z = h.length, j = u.length, J = Of(i.padding);
  let Q = J.height, X = 0, et = u.reduce((Lt, yt) => Lt + yt.before.length + yt.lines.length + yt.after.length, 0);
  if (et += s.beforeBody.length + s.afterBody.length, C && (Q += C * E.lineHeight + (C - 1) * i.titleSpacing + i.titleMarginBottom), et) {
    const Lt = i.displayColors ? Math.max(S, T.lineHeight) : T.lineHeight;
    Q += j * Lt + (et - j) * T.lineHeight + (et - 1) * i.bodySpacing;
  }
  z && (Q += i.footerMarginTop + z * A.lineHeight + (z - 1) * i.footerSpacing);
  let wt = 0;
  const At = function(Lt) {
    X = Math.max(X, l.measureText(Lt).width + wt);
  };
  return l.save(), l.font = E.string, un(s.title, At), l.font = T.string, un(s.beforeBody.concat(s.afterBody), At), wt = i.displayColors ? _ + 2 + i.boxPadding : 0, un(u, (Lt) => {
    un(Lt.before, At), un(Lt.lines, At), un(Lt.after, At);
  }), wt = 0, l.font = A.string, un(s.footer, At), l.restore(), X += J.width, {
    width: X,
    height: Q
  };
}
function JD(s, i) {
  const { y: l, height: u } = i;
  return l < u / 2 ? "top" : l > s.height - u / 2 ? "bottom" : "center";
}
function ID(s, i, l, u) {
  const { x: h, width: g } = u, _ = l.caretSize + l.caretPadding;
  if (s === "left" && h + g + _ > i.width || s === "right" && h - g - _ < 0)
    return !0;
}
function $D(s, i, l, u) {
  const { x: h, width: g } = l, { width: _, chartArea: { left: S, right: T } } = s;
  let E = "center";
  return u === "center" ? E = h <= (S + T) / 2 ? "left" : "right" : h <= g / 2 ? E = "left" : h >= _ - g / 2 && (E = "right"), ID(E, s, i, l) && (E = "center"), E;
}
function iw(s, i, l) {
  const u = l.yAlign || i.yAlign || JD(s, l);
  return {
    xAlign: l.xAlign || i.xAlign || $D(s, i, l, u),
    yAlign: u
  };
}
function FD(s, i) {
  let { x: l, width: u } = s;
  return i === "right" ? l -= u : i === "center" && (l -= u / 2), l;
}
function tR(s, i, l) {
  let { y: u, height: h } = s;
  return i === "top" ? u += l : i === "bottom" ? u -= h + l : u -= h / 2, u;
}
function aw(s, i, l, u) {
  const { caretSize: h, caretPadding: g, cornerRadius: _ } = s, { xAlign: S, yAlign: T } = l, E = h + g, { topLeft: A, topRight: C, bottomLeft: z, bottomRight: j } = p0(_);
  let J = FD(i, S);
  const Q = tR(i, T, E);
  return T === "center" ? S === "left" ? J += E : S === "right" && (J -= E) : S === "left" ? J -= Math.max(A, z) + h : S === "right" && (J += Math.max(C, j) + h), {
    x: rr(J, 0, u.width - i.width),
    y: rr(Q, 0, u.height - i.height)
  };
}
function h0(s, i, l) {
  const u = Of(l.padding);
  return i === "center" ? s.x + s.width / 2 : i === "right" ? s.x + s.width - u.right : s.x + u.left;
}
function ow(s) {
  return au([], fc(s));
}
function eR(s, i, l) {
  return yd(s, {
    tooltip: i,
    tooltipItems: l,
    type: "tooltip"
  });
}
function lw(s, i) {
  const l = i && i.dataset && i.dataset.tooltip && i.dataset.tooltip.callbacks;
  return l ? s.override(l) : s;
}
const rM = {
  beforeTitle: uc,
  title(s) {
    if (s.length > 0) {
      const i = s[0], l = i.chart.data.labels, u = l ? l.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return i.dataset.label || "";
      if (i.label)
        return i.label;
      if (u > 0 && i.dataIndex < u)
        return l[i.dataIndex];
    }
    return "";
  },
  afterTitle: uc,
  beforeBody: uc,
  beforeLabel: uc,
  label(s) {
    if (this && this.options && this.options.mode === "dataset")
      return s.label + ": " + s.formattedValue || s.formattedValue;
    let i = s.dataset.label || "";
    i && (i += ": ");
    const l = s.formattedValue;
    return Mn(l) || (i += l), i;
  },
  labelColor(s) {
    const l = s.chart.getDatasetMeta(s.datasetIndex).controller.getStyle(s.dataIndex);
    return {
      borderColor: l.borderColor,
      backgroundColor: l.backgroundColor,
      borderWidth: l.borderWidth,
      borderDash: l.borderDash,
      borderDashOffset: l.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(s) {
    const l = s.chart.getDatasetMeta(s.datasetIndex).controller.getStyle(s.dataIndex);
    return {
      pointStyle: l.pointStyle,
      rotation: l.rotation
    };
  },
  afterLabel: uc,
  afterBody: uc,
  beforeFooter: uc,
  footer: uc,
  afterFooter: uc
};
function Qo(s, i, l, u) {
  const h = s[i].call(l, u);
  return typeof h > "u" ? rM[i].call(l, u) : h;
}
class sw extends Sv {
  static positioners = rv;
  constructor(i) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = i.chart, this.options = i.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(i) {
    this.options = i, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const i = this._cachedAnimations;
    if (i)
      return i;
    const l = this.chart, u = this.options.setContext(this.getContext()), h = u.enabled && l.options.animation && u.animations, g = new Gw(this.chart, h);
    return h._cacheable && (this._cachedAnimations = Object.freeze(g)), g;
  }
  getContext() {
    return this.$context || (this.$context = eR(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(i, l) {
    const { callbacks: u } = l, h = Qo(u, "beforeTitle", this, i), g = Qo(u, "title", this, i), _ = Qo(u, "afterTitle", this, i);
    let S = [];
    return S = au(S, fc(h)), S = au(S, fc(g)), S = au(S, fc(_)), S;
  }
  getBeforeBody(i, l) {
    return ow(Qo(l.callbacks, "beforeBody", this, i));
  }
  getBody(i, l) {
    const { callbacks: u } = l, h = [];
    return un(i, (g) => {
      const _ = {
        before: [],
        lines: [],
        after: []
      }, S = lw(u, g);
      au(_.before, fc(Qo(S, "beforeLabel", this, g))), au(_.lines, Qo(S, "label", this, g)), au(_.after, fc(Qo(S, "afterLabel", this, g))), h.push(_);
    }), h;
  }
  getAfterBody(i, l) {
    return ow(Qo(l.callbacks, "afterBody", this, i));
  }
  getFooter(i, l) {
    const { callbacks: u } = l, h = Qo(u, "beforeFooter", this, i), g = Qo(u, "footer", this, i), _ = Qo(u, "afterFooter", this, i);
    let S = [];
    return S = au(S, fc(h)), S = au(S, fc(g)), S = au(S, fc(_)), S;
  }
  _createItems(i) {
    const l = this._active, u = this.chart.data, h = [], g = [], _ = [];
    let S = [], T, E;
    for (T = 0, E = l.length; T < E; ++T)
      S.push(WD(this.chart, l[T]));
    return i.filter && (S = S.filter((A, C, z) => i.filter(A, C, z, u))), i.itemSort && (S = S.sort((A, C) => i.itemSort(A, C, u))), un(S, (A) => {
      const C = lw(i.callbacks, A);
      h.push(Qo(C, "labelColor", this, A)), g.push(Qo(C, "labelPointStyle", this, A)), _.push(Qo(C, "labelTextColor", this, A));
    }), this.labelColors = h, this.labelPointStyles = g, this.labelTextColors = _, this.dataPoints = S, S;
  }
  update(i, l) {
    const u = this.options.setContext(this.getContext()), h = this._active;
    let g, _ = [];
    if (!h.length)
      this.opacity !== 0 && (g = {
        opacity: 0
      });
    else {
      const S = rv[u.position].call(this, h, this._eventPosition);
      _ = this._createItems(u), this.title = this.getTitle(_, u), this.beforeBody = this.getBeforeBody(_, u), this.body = this.getBody(_, u), this.afterBody = this.getAfterBody(_, u), this.footer = this.getFooter(_, u);
      const T = this._size = nw(this, u), E = Object.assign({}, S, T), A = iw(this.chart, u, E), C = aw(u, E, A, this.chart);
      this.xAlign = A.xAlign, this.yAlign = A.yAlign, g = {
        opacity: 1,
        x: C.x,
        y: C.y,
        width: T.width,
        height: T.height,
        caretX: S.x,
        caretY: S.y
      };
    }
    this._tooltipItems = _, this.$context = void 0, g && this._resolveAnimations().update(this, g), i && u.external && u.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: l
    });
  }
  drawCaret(i, l, u, h) {
    const g = this.getCaretPosition(i, u, h);
    l.lineTo(g.x1, g.y1), l.lineTo(g.x2, g.y2), l.lineTo(g.x3, g.y3);
  }
  getCaretPosition(i, l, u) {
    const { xAlign: h, yAlign: g } = this, { caretSize: _, cornerRadius: S } = u, { topLeft: T, topRight: E, bottomLeft: A, bottomRight: C } = p0(S), { x: z, y: j } = i, { width: J, height: Q } = l;
    let X, et, wt, At, Lt, yt;
    return g === "center" ? (Lt = j + Q / 2, h === "left" ? (X = z, et = X - _, At = Lt + _, yt = Lt - _) : (X = z + J, et = X + _, At = Lt - _, yt = Lt + _), wt = X) : (h === "left" ? et = z + Math.max(T, A) + _ : h === "right" ? et = z + J - Math.max(E, C) - _ : et = this.caretX, g === "top" ? (At = j, Lt = At - _, X = et - _, wt = et + _) : (At = j + Q, Lt = At + _, X = et + _, wt = et - _), yt = At), {
      x1: X,
      x2: et,
      x3: wt,
      y1: At,
      y2: Lt,
      y3: yt
    };
  }
  drawTitle(i, l, u) {
    const h = this.title, g = h.length;
    let _, S, T;
    if (g) {
      const E = Wb(u.rtl, this.x, this.width);
      for (i.x = h0(this, u.titleAlign, u), l.textAlign = E.textAlign(u.titleAlign), l.textBaseline = "middle", _ = uu(u.titleFont), S = u.titleSpacing, l.fillStyle = u.titleColor, l.font = _.string, T = 0; T < g; ++T)
        l.fillText(h[T], E.x(i.x), i.y + _.lineHeight / 2), i.y += _.lineHeight + S, T + 1 === g && (i.y += u.titleMarginBottom - S);
    }
  }
  _drawColorBox(i, l, u, h, g) {
    const _ = this.labelColors[u], S = this.labelPointStyles[u], { boxHeight: T, boxWidth: E } = g, A = uu(g.bodyFont), C = h0(this, "left", g), z = h.x(C), j = T < A.lineHeight ? (A.lineHeight - T) / 2 : 0, J = l.y + j;
    if (g.usePointStyle) {
      const Q = {
        radius: Math.min(E, T) / 2,
        pointStyle: S.pointStyle,
        rotation: S.rotation,
        borderWidth: 1
      }, X = h.leftForLtr(z, E) + E / 2, et = J + T / 2;
      i.strokeStyle = g.multiKeyBackground, i.fillStyle = g.multiKeyBackground, c1(i, Q, X, et), i.strokeStyle = _.borderColor, i.fillStyle = _.backgroundColor, c1(i, Q, X, et);
    } else {
      i.lineWidth = Pe(_.borderWidth) ? Math.max(...Object.values(_.borderWidth)) : _.borderWidth || 1, i.strokeStyle = _.borderColor, i.setLineDash(_.borderDash || []), i.lineDashOffset = _.borderDashOffset || 0;
      const Q = h.leftForLtr(z, E), X = h.leftForLtr(h.xPlus(z, 1), E - 2), et = p0(_.borderRadius);
      Object.values(et).some((wt) => wt !== 0) ? (i.beginPath(), i.fillStyle = g.multiKeyBackground, yx(i, {
        x: Q,
        y: J,
        w: E,
        h: T,
        radius: et
      }), i.fill(), i.stroke(), i.fillStyle = _.backgroundColor, i.beginPath(), yx(i, {
        x: X,
        y: J + 1,
        w: E - 2,
        h: T - 2,
        radius: et
      }), i.fill()) : (i.fillStyle = g.multiKeyBackground, i.fillRect(Q, J, E, T), i.strokeRect(Q, J, E, T), i.fillStyle = _.backgroundColor, i.fillRect(X, J + 1, E - 2, T - 2));
    }
    i.fillStyle = this.labelTextColors[u];
  }
  drawBody(i, l, u) {
    const { body: h } = this, { bodySpacing: g, bodyAlign: _, displayColors: S, boxHeight: T, boxWidth: E, boxPadding: A } = u, C = uu(u.bodyFont);
    let z = C.lineHeight, j = 0;
    const J = Wb(u.rtl, this.x, this.width), Q = function(Yt) {
      l.fillText(Yt, J.x(i.x + j), i.y + z / 2), i.y += z + g;
    }, X = J.textAlign(_);
    let et, wt, At, Lt, yt, Bt, Ct;
    for (l.textAlign = _, l.textBaseline = "middle", l.font = C.string, i.x = h0(this, X, u), l.fillStyle = u.bodyColor, un(this.beforeBody, Q), j = S && X !== "right" ? _ === "center" ? E / 2 + A : E + 2 + A : 0, Lt = 0, Bt = h.length; Lt < Bt; ++Lt) {
      for (et = h[Lt], wt = this.labelTextColors[Lt], l.fillStyle = wt, un(et.before, Q), At = et.lines, S && At.length && (this._drawColorBox(l, i, Lt, J, u), z = Math.max(C.lineHeight, T)), yt = 0, Ct = At.length; yt < Ct; ++yt)
        Q(At[yt]), z = C.lineHeight;
      un(et.after, Q);
    }
    j = 0, z = C.lineHeight, un(this.afterBody, Q), i.y -= g;
  }
  drawFooter(i, l, u) {
    const h = this.footer, g = h.length;
    let _, S;
    if (g) {
      const T = Wb(u.rtl, this.x, this.width);
      for (i.x = h0(this, u.footerAlign, u), i.y += u.footerMarginTop, l.textAlign = T.textAlign(u.footerAlign), l.textBaseline = "middle", _ = uu(u.footerFont), l.fillStyle = u.footerColor, l.font = _.string, S = 0; S < g; ++S)
        l.fillText(h[S], T.x(i.x), i.y + _.lineHeight / 2), i.y += _.lineHeight + u.footerSpacing;
    }
  }
  drawBackground(i, l, u, h) {
    const { xAlign: g, yAlign: _ } = this, { x: S, y: T } = i, { width: E, height: A } = u, { topLeft: C, topRight: z, bottomLeft: j, bottomRight: J } = p0(h.cornerRadius);
    l.fillStyle = h.backgroundColor, l.strokeStyle = h.borderColor, l.lineWidth = h.borderWidth, l.beginPath(), l.moveTo(S + C, T), _ === "top" && this.drawCaret(i, l, u, h), l.lineTo(S + E - z, T), l.quadraticCurveTo(S + E, T, S + E, T + z), _ === "center" && g === "right" && this.drawCaret(i, l, u, h), l.lineTo(S + E, T + A - J), l.quadraticCurveTo(S + E, T + A, S + E - J, T + A), _ === "bottom" && this.drawCaret(i, l, u, h), l.lineTo(S + j, T + A), l.quadraticCurveTo(S, T + A, S, T + A - j), _ === "center" && g === "left" && this.drawCaret(i, l, u, h), l.lineTo(S, T + C), l.quadraticCurveTo(S, T, S + C, T), l.closePath(), l.fill(), h.borderWidth > 0 && l.stroke();
  }
  _updateAnimationTarget(i) {
    const l = this.chart, u = this.$animations, h = u && u.x, g = u && u.y;
    if (h || g) {
      const _ = rv[i.position].call(this, this._active, this._eventPosition);
      if (!_)
        return;
      const S = this._size = nw(this, i), T = Object.assign({}, _, this._size), E = iw(l, i, T), A = aw(i, T, E, l);
      (h._to !== A.x || g._to !== A.y) && (this.xAlign = E.xAlign, this.yAlign = E.yAlign, this.width = S.width, this.height = S.height, this.caretX = _.x, this.caretY = _.y, this._resolveAnimations().update(this, A));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(i) {
    const l = this.options.setContext(this.getContext());
    let u = this.opacity;
    if (!u)
      return;
    this._updateAnimationTarget(l);
    const h = {
      width: this.width,
      height: this.height
    }, g = {
      x: this.x,
      y: this.y
    };
    u = Math.abs(u) < 1e-3 ? 0 : u;
    const _ = Of(l.padding), S = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    l.enabled && S && (i.save(), i.globalAlpha = u, this.drawBackground(g, i, h, l), qO(i, l.textDirection), g.y += _.top, this.drawTitle(g, i, l), this.drawBody(g, i, l), this.drawFooter(g, i, l), ZO(i, l.textDirection), i.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(i, l) {
    const u = this._active, h = i.map(({ datasetIndex: S, index: T }) => {
      const E = this.chart.getDatasetMeta(S);
      if (!E)
        throw new Error("Cannot find a dataset at index " + S);
      return {
        datasetIndex: S,
        element: E.data[T],
        index: T
      };
    }), g = !v0(u, h), _ = this._positionChanged(h, l);
    (g || _) && (this._active = h, this._eventPosition = l, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(i, l, u = !0) {
    if (l && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const h = this.options, g = this._active || [], _ = this._getActiveElements(i, g, l, u), S = this._positionChanged(_, i), T = l || !v0(_, g) || S;
    return T && (this._active = _, (h.enabled || h.external) && (this._eventPosition = {
      x: i.x,
      y: i.y
    }, this.update(!0, l))), T;
  }
  _getActiveElements(i, l, u, h) {
    const g = this.options;
    if (i.type === "mouseout")
      return [];
    if (!h)
      return l.filter((S) => this.chart.data.datasets[S.datasetIndex] && this.chart.getDatasetMeta(S.datasetIndex).controller.getParsed(S.index) !== void 0);
    const _ = this.chart.getElementsAtEventForMode(i, g.mode, g, u);
    return g.reverse && _.reverse(), _;
  }
  _positionChanged(i, l) {
    const { caretX: u, caretY: h, options: g } = this, _ = rv[g.position].call(this, i, l);
    return _ !== !1 && (u !== _.x || h !== _.y);
  }
}
var nR = {
  id: "tooltip",
  _element: sw,
  positioners: rv,
  afterInit(s, i, l) {
    l && (s.tooltip = new sw({
      chart: s,
      options: l
    }));
  },
  beforeUpdate(s, i, l) {
    s.tooltip && s.tooltip.initialize(l);
  },
  reset(s, i, l) {
    s.tooltip && s.tooltip.initialize(l);
  },
  afterDraw(s) {
    const i = s.tooltip;
    if (i && i._willRender()) {
      const l = {
        tooltip: i
      };
      if (s.notifyPlugins("beforeTooltipDraw", {
        ...l,
        cancelable: !0
      }) === !1)
        return;
      i.draw(s.ctx), s.notifyPlugins("afterTooltipDraw", l);
    }
  },
  afterEvent(s, i) {
    if (s.tooltip) {
      const l = i.replay;
      s.tooltip.handleEvent(i.event, l, i.inChartArea) && (i.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (s, i) => i.bodyFont.size,
    boxWidth: (s, i) => i.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: rM
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (s) => s !== "filter" && s !== "itemSort" && s !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
function iR(s, i) {
  const l = [], { bounds: h, step: g, min: _, max: S, precision: T, count: E, maxTicks: A, maxDigits: C, includeBounds: z } = s, j = g || 1, J = A - 1, { min: Q, max: X } = i, et = !Mn(_), wt = !Mn(S), At = !Mn(E), Lt = (X - Q) / (C + 1);
  let yt = lx((X - Q) / J / j) * j, Bt, Ct, Yt, Mt;
  if (yt < 1e-14 && !et && !wt)
    return [
      {
        value: Q
      },
      {
        value: X
      }
    ];
  Mt = Math.ceil(X / yt) - Math.floor(Q / yt), Mt > J && (yt = lx(Mt * yt / J / j) * j), Mn(T) || (Bt = Math.pow(10, T), yt = Math.ceil(yt * Bt) / Bt), h === "ticks" ? (Ct = Math.floor(Q / yt) * yt, Yt = Math.ceil(X / yt) * yt) : (Ct = Q, Yt = X), et && wt && g && z2((S - _) / g, yt / 1e3) ? (Mt = Math.round(Math.min((S - _) / yt, A)), yt = (S - _) / Mt, Ct = _, Yt = S) : At ? (Ct = et ? _ : Ct, Yt = wt ? S : Yt, Mt = E - 1, yt = (Yt - Ct) / Mt) : (Mt = (Yt - Ct) / yt, fv(Mt, Math.round(Mt), yt / 1e3) ? Mt = Math.round(Mt) : Mt = Math.ceil(Mt));
  const ne = Math.max(sx(yt), sx(Ct));
  Bt = Math.pow(10, Mn(T) ? ne : T), Ct = Math.round(Ct * Bt) / Bt, Yt = Math.round(Yt * Bt) / Bt;
  let Rt = 0;
  for (et && (z && Ct !== _ ? (l.push({
    value: _
  }), Ct < _ && Rt++, fv(Math.round((Ct + Rt * yt) * Bt) / Bt, _, rw(_, Lt, s)) && Rt++) : Ct < _ && Rt++); Rt < Mt; ++Rt) {
    const kt = Math.round((Ct + Rt * yt) * Bt) / Bt;
    if (wt && kt > S)
      break;
    l.push({
      value: kt
    });
  }
  return wt && z && Yt !== S ? l.length && fv(l[l.length - 1].value, S, rw(S, Lt, s)) ? l[l.length - 1].value = S : l.push({
    value: S
  }) : (!wt || Yt === S) && l.push({
    value: Yt
  }), l;
}
function rw(s, i, { horizontal: l, minRotation: u }) {
  const h = dd(u), g = (l ? Math.sin(h) : Math.cos(h)) || 1e-3, _ = 0.75 * i * ("" + s).length;
  return Math.min(i / g, _);
}
class aR extends Tv {
  constructor(i) {
    super(i), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(i, l) {
    return Mn(i) || (typeof i == "number" || i instanceof Number) && !isFinite(+i) ? null : +i;
  }
  handleTickRangeOptions() {
    const { beginAtZero: i } = this.options, { minDefined: l, maxDefined: u } = this.getUserBounds();
    let { min: h, max: g } = this;
    const _ = (T) => h = l ? h : T, S = (T) => g = u ? g : T;
    if (i) {
      const T = zp(h), E = zp(g);
      T < 0 && E < 0 ? S(0) : T > 0 && E > 0 && _(0);
    }
    if (h === g) {
      let T = g === 0 ? 1 : Math.abs(g * 0.05);
      S(g + T), i || _(h - T);
    }
    this.min = h, this.max = g;
  }
  getTickLimit() {
    const i = this.options.ticks;
    let { maxTicksLimit: l, stepSize: u } = i, h;
    return u ? (h = Math.ceil(this.max / u) - Math.floor(this.min / u) + 1, h > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${u} would result generating up to ${h} ticks. Limiting to 1000.`), h = 1e3)) : (h = this.computeTickLimit(), l = l || 11), l && (h = Math.min(l, h)), h;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const i = this.options, l = i.ticks;
    let u = this.getTickLimit();
    u = Math.max(2, u);
    const h = {
      maxTicks: u,
      bounds: i.bounds,
      min: i.min,
      max: i.max,
      precision: l.precision,
      step: l.stepSize,
      count: l.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: l.minRotation || 0,
      includeBounds: l.includeBounds !== !1
    }, g = this._range || this, _ = iR(h, g);
    return i.bounds === "ticks" && L2(_, this, "value"), i.reverse ? (_.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), _;
  }
  configure() {
    const i = this.ticks;
    let l = this.min, u = this.max;
    if (super.configure(), this.options.offset && i.length) {
      const h = (u - l) / Math.max(i.length - 1, 1) / 2;
      l -= h, u += h;
    }
    this._startValue = l, this._endValue = u, this._valueRange = u - l;
  }
  getLabelForValue(i) {
    return Lw(i, this.chart.options.locale, this.options.ticks.format);
  }
}
class oR extends aR {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: Hw.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min: i, max: l } = this.getMinMax(!0);
    this.min = qa(i) ? i : 0, this.max = qa(l) ? l : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const i = this.isHorizontal(), l = i ? this.width : this.height, u = dd(this.options.ticks.minRotation), h = (i ? Math.sin(u) : Math.cos(u)) || 1e-3, g = this._resolveTickFontOptions(0);
    return Math.ceil(l / Math.min(40, g.lineHeight / h));
  }
  getPixelForValue(i) {
    return i === null ? NaN : this.getPixelForDecimal((i - this._startValue) / this._valueRange);
  }
  getValueForPixel(i) {
    return this._startValue + this.getDecimalForPixel(i) * this._valueRange;
  }
}
const C0 = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, Ko = /* @__PURE__ */ Object.keys(C0);
function uw(s, i) {
  return s - i;
}
function cw(s, i) {
  if (Mn(i))
    return null;
  const l = s._adapter, { parser: u, round: h, isoWeekday: g } = s._parseOpts;
  let _ = i;
  return typeof u == "function" && (_ = u(_)), qa(_) || (_ = typeof u == "string" ? l.parse(_, u) : l.parse(_)), _ === null ? null : (h && (_ = h === "week" && (yv(g) || g === !0) ? l.startOf(_, "isoWeek", g) : l.startOf(_, h)), +_);
}
function fw(s, i, l, u) {
  const h = Ko.length;
  for (let g = Ko.indexOf(s); g < h - 1; ++g) {
    const _ = C0[Ko[g]], S = _.steps ? _.steps : Number.MAX_SAFE_INTEGER;
    if (_.common && Math.ceil((l - i) / (S * _.size)) <= u)
      return Ko[g];
  }
  return Ko[h - 1];
}
function lR(s, i, l, u, h) {
  for (let g = Ko.length - 1; g >= Ko.indexOf(l); g--) {
    const _ = Ko[g];
    if (C0[_].common && s._adapter.diff(h, u, _) >= i - 1)
      return _;
  }
  return Ko[l ? Ko.indexOf(l) : 0];
}
function sR(s) {
  for (let i = Ko.indexOf(s) + 1, l = Ko.length; i < l; ++i)
    if (C0[Ko[i]].common)
      return Ko[i];
}
function hw(s, i, l) {
  if (!l)
    s[i] = !0;
  else if (l.length) {
    const { lo: u, hi: h } = x1(l, i), g = l[u] >= i ? l[u] : l[h];
    s[g] = !0;
  }
}
function rR(s, i, l, u) {
  const h = s._adapter, g = +h.startOf(i[0].value, u), _ = i[i.length - 1].value;
  let S, T;
  for (S = g; S <= _; S = +h.add(S, 1, u))
    T = l[S], T >= 0 && (i[T].major = !0);
  return i;
}
function dw(s, i, l) {
  const u = [], h = {}, g = i.length;
  let _, S;
  for (_ = 0; _ < g; ++_)
    S = i[_], h[S] = _, u.push({
      value: S,
      major: !1
    });
  return g === 0 || !l ? u : rR(s, u, h, l);
}
class p1 extends Tv {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  };
  constructor(i) {
    super(i), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(i, l = {}) {
    const u = i.time || (i.time = {}), h = this._adapter = new Kw._date(i.adapters.date);
    h.init(l), cv(u.displayFormats, h.formats()), this._parseOpts = {
      parser: u.parser,
      round: u.round,
      isoWeekday: u.isoWeekday
    }, super.init(i), this._normalized = l.normalized;
  }
  parse(i, l) {
    return i === void 0 ? null : cw(this, i);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const i = this.options, l = this._adapter, u = i.time.unit || "day";
    let { min: h, max: g, minDefined: _, maxDefined: S } = this.getUserBounds();
    function T(E) {
      !_ && !isNaN(E.min) && (h = Math.min(h, E.min)), !S && !isNaN(E.max) && (g = Math.max(g, E.max));
    }
    (!_ || !S) && (T(this._getLabelBounds()), (i.bounds !== "ticks" || i.ticks.source !== "labels") && T(this.getMinMax(!1))), h = qa(h) && !isNaN(h) ? h : +l.startOf(Date.now(), u), g = qa(g) && !isNaN(g) ? g : +l.endOf(Date.now(), u) + 1, this.min = Math.min(h, g - 1), this.max = Math.max(h + 1, g);
  }
  _getLabelBounds() {
    const i = this.getLabelTimestamps();
    let l = Number.POSITIVE_INFINITY, u = Number.NEGATIVE_INFINITY;
    return i.length && (l = i[0], u = i[i.length - 1]), {
      min: l,
      max: u
    };
  }
  buildTicks() {
    const i = this.options, l = i.time, u = i.ticks, h = u.source === "labels" ? this.getLabelTimestamps() : this._generate();
    i.bounds === "ticks" && h.length && (this.min = this._userMin || h[0], this.max = this._userMax || h[h.length - 1]);
    const g = this.min, _ = this.max, S = Y2(h, g, _);
    return this._unit = l.unit || (u.autoSkip ? fw(l.minUnit, this.min, this.max, this._getLabelCapacity(g)) : lR(this, S.length, l.minUnit, this.min, this.max)), this._majorUnit = !u.major.enabled || this._unit === "year" ? void 0 : sR(this._unit), this.initOffsets(h), i.reverse && S.reverse(), dw(this, S, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((i) => +i.value));
  }
  initOffsets(i = []) {
    let l = 0, u = 0, h, g;
    this.options.offset && i.length && (h = this.getDecimalForValue(i[0]), i.length === 1 ? l = 1 - h : l = (this.getDecimalForValue(i[1]) - h) / 2, g = this.getDecimalForValue(i[i.length - 1]), i.length === 1 ? u = g : u = (g - this.getDecimalForValue(i[i.length - 2])) / 2);
    const _ = i.length < 3 ? 0.5 : 0.25;
    l = rr(l, 0, _), u = rr(u, 0, _), this._offsets = {
      start: l,
      end: u,
      factor: 1 / (l + 1 + u)
    };
  }
  _generate() {
    const i = this._adapter, l = this.min, u = this.max, h = this.options, g = h.time, _ = g.unit || fw(g.minUnit, l, u, this._getLabelCapacity(l)), S = gn(h.ticks.stepSize, 1), T = _ === "week" ? g.isoWeekday : !1, E = yv(T) || T === !0, A = {};
    let C = l, z, j;
    if (E && (C = +i.startOf(C, "isoWeek", T)), C = +i.startOf(C, E ? "day" : _), i.diff(u, l, _) > 1e5 * S)
      throw new Error(l + " and " + u + " are too far apart with stepSize of " + S + " " + _);
    const J = h.ticks.source === "data" && this.getDataTimestamps();
    for (z = C, j = 0; z < u; z = +i.add(z, S, _), j++)
      hw(A, z, J);
    return (z === u || h.bounds === "ticks" || j === 1) && hw(A, z, J), Object.keys(A).sort(uw).map((Q) => +Q);
  }
  getLabelForValue(i) {
    const l = this._adapter, u = this.options.time;
    return u.tooltipFormat ? l.format(i, u.tooltipFormat) : l.format(i, u.displayFormats.datetime);
  }
  format(i, l) {
    const h = this.options.time.displayFormats, g = this._unit, _ = l || h[g];
    return this._adapter.format(i, _);
  }
  _tickFormatFunction(i, l, u, h) {
    const g = this.options, _ = g.ticks.callback;
    if (_)
      return si(_, [
        i,
        l,
        u
      ], this);
    const S = g.time.displayFormats, T = this._unit, E = this._majorUnit, A = T && S[T], C = E && S[E], z = u[l], j = E && C && z && z.major;
    return this._adapter.format(i, h || (j ? C : A));
  }
  generateTickLabels(i) {
    let l, u, h;
    for (l = 0, u = i.length; l < u; ++l)
      h = i[l], h.label = this._tickFormatFunction(h.value, l, i);
  }
  getDecimalForValue(i) {
    return i === null ? NaN : (i - this.min) / (this.max - this.min);
  }
  getPixelForValue(i) {
    const l = this._offsets, u = this.getDecimalForValue(i);
    return this.getPixelForDecimal((l.start + u) * l.factor);
  }
  getValueForPixel(i) {
    const l = this._offsets, u = this.getDecimalForPixel(i) / l.factor - l.end;
    return this.min + u * (this.max - this.min);
  }
  _getLabelSize(i) {
    const l = this.options.ticks, u = this.ctx.measureText(i).width, h = dd(this.isHorizontal() ? l.maxRotation : l.minRotation), g = Math.cos(h), _ = Math.sin(h), S = this._resolveTickFontOptions(0).size;
    return {
      w: u * g + S * _,
      h: u * _ + S * g
    };
  }
  _getLabelCapacity(i) {
    const l = this.options.time, u = l.displayFormats, h = u[l.unit] || u.millisecond, g = this._tickFormatFunction(i, 0, dw(this, [
      i
    ], this._majorUnit), h), _ = this._getLabelSize(g), S = Math.floor(this.isHorizontal() ? this.width / _.w : this.height / _.h) - 1;
    return S > 0 ? S : 1;
  }
  getDataTimestamps() {
    let i = this._cache.data || [], l, u;
    if (i.length)
      return i;
    const h = this.getMatchingVisibleMetas();
    if (this._normalized && h.length)
      return this._cache.data = h[0].controller.getAllParsedValues(this);
    for (l = 0, u = h.length; l < u; ++l)
      i = i.concat(h[l].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(i);
  }
  getLabelTimestamps() {
    const i = this._cache.labels || [];
    let l, u;
    if (i.length)
      return i;
    const h = this.getLabels();
    for (l = 0, u = h.length; l < u; ++l)
      i.push(cw(this, h[l]));
    return this._cache.labels = this._normalized ? i : this.normalize(i);
  }
  normalize(i) {
    return q2(i.sort(uw));
  }
}
function d0(s, i, l) {
  let u = 0, h = s.length - 1, g, _, S, T;
  l ? (i >= s[u].pos && i <= s[h].pos && ({ lo: u, hi: h } = md(s, "pos", i)), { pos: g, time: S } = s[u], { pos: _, time: T } = s[h]) : (i >= s[u].time && i <= s[h].time && ({ lo: u, hi: h } = md(s, "time", i)), { time: g, pos: S } = s[u], { time: _, pos: T } = s[h]);
  const E = _ - g;
  return E ? S + (T - S) * (i - g) / E : S;
}
class tL extends p1 {
  static id = "timeseries";
  static defaults = p1.defaults;
  constructor(i) {
    super(i), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const i = this._getTimestampsForTable(), l = this._table = this.buildLookupTable(i);
    this._minPos = d0(l, this.min), this._tableRange = d0(l, this.max) - this._minPos, super.initOffsets(i);
  }
  buildLookupTable(i) {
    const { min: l, max: u } = this, h = [], g = [];
    let _, S, T, E, A;
    for (_ = 0, S = i.length; _ < S; ++_)
      E = i[_], E >= l && E <= u && h.push(E);
    if (h.length < 2)
      return [
        {
          time: l,
          pos: 0
        },
        {
          time: u,
          pos: 1
        }
      ];
    for (_ = 0, S = h.length; _ < S; ++_)
      A = h[_ + 1], T = h[_ - 1], E = h[_], Math.round((A + T) / 2) !== E && g.push({
        time: E,
        pos: _ / (S - 1)
      });
    return g;
  }
  _generate() {
    const i = this.min, l = this.max;
    let u = super.getDataTimestamps();
    return (!u.includes(i) || !u.length) && u.splice(0, 0, i), (!u.includes(l) || u.length === 1) && u.push(l), u.sort((h, g) => h - g);
  }
  _getTimestampsForTable() {
    let i = this._cache.all || [];
    if (i.length)
      return i;
    const l = this.getDataTimestamps(), u = this.getLabelTimestamps();
    return l.length && u.length ? i = this.normalize(l.concat(u)) : i = l.length ? l : u, i = this._cache.all = i, i;
  }
  getDecimalForValue(i) {
    return (d0(this._table, i) - this._minPos) / this._tableRange;
  }
  getValueForPixel(i) {
    const l = this._offsets, u = this.getDecimalForPixel(i) / l.factor - l.end;
    return d0(this._table, u * this._tableRange + this._minPos, !0);
  }
}
const uM = 6048e5, uR = 864e5, xv = 6e4, wv = 36e5, cR = 1e3, mw = Symbol.for("constructDateFrom");
function Wn(s, i) {
  return typeof s == "function" ? s(i) : s && typeof s == "object" && mw in s ? s[mw](i) : s instanceof Date ? new s.constructor(i) : new Date(i);
}
function Te(s, i) {
  return Wn(i || s, s);
}
function z0(s, i, l) {
  const u = Te(s, l?.in);
  return isNaN(i) ? Wn(l?.in || s, NaN) : (i && u.setDate(u.getDate() + i), u);
}
function H1(s, i, l) {
  const u = Te(s, l?.in);
  if (isNaN(i)) return Wn(s, NaN);
  if (!i)
    return u;
  const h = u.getDate(), g = Wn(s, u.getTime());
  g.setMonth(u.getMonth() + i + 1, 0);
  const _ = g.getDate();
  return h >= _ ? g : (u.setFullYear(
    g.getFullYear(),
    g.getMonth(),
    h
  ), u);
}
function k1(s, i, l) {
  return Wn(s, +Te(s) + i);
}
function fR(s, i, l) {
  return k1(s, i * wv);
}
let hR = {};
function vd() {
  return hR;
}
function fu(s, i) {
  const l = vd(), u = i?.weekStartsOn ?? i?.locale?.options?.weekStartsOn ?? l.weekStartsOn ?? l.locale?.options?.weekStartsOn ?? 0, h = Te(s, i?.in), g = h.getDay(), _ = (g < u ? 7 : 0) + g - u;
  return h.setDate(h.getDate() - _), h.setHours(0, 0, 0, 0), h;
}
function kp(s, i) {
  return fu(s, { ...i, weekStartsOn: 1 });
}
function cM(s, i) {
  const l = Te(s, i?.in), u = l.getFullYear(), h = Wn(l, 0);
  h.setFullYear(u + 1, 0, 4), h.setHours(0, 0, 0, 0);
  const g = kp(h), _ = Wn(l, 0);
  _.setFullYear(u, 0, 4), _.setHours(0, 0, 0, 0);
  const S = kp(_);
  return l.getTime() >= g.getTime() ? u + 1 : l.getTime() >= S.getTime() ? u : u - 1;
}
function M0(s) {
  const i = Te(s), l = new Date(
    Date.UTC(
      i.getFullYear(),
      i.getMonth(),
      i.getDate(),
      i.getHours(),
      i.getMinutes(),
      i.getSeconds(),
      i.getMilliseconds()
    )
  );
  return l.setUTCFullYear(i.getFullYear()), +s - +l;
}
function _d(s, ...i) {
  const l = Wn.bind(
    null,
    i.find((u) => typeof u == "object")
  );
  return i.map(l);
}
function g1(s, i) {
  const l = Te(s, i?.in);
  return l.setHours(0, 0, 0, 0), l;
}
function fM(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = g1(u), _ = g1(h), S = +g - M0(g), T = +_ - M0(_);
  return Math.round((S - T) / uR);
}
function dR(s, i) {
  const l = cM(s, i), u = Wn(s, 0);
  return u.setFullYear(l, 0, 4), u.setHours(0, 0, 0, 0), kp(u);
}
function mR(s, i, l) {
  const u = Te(s, l?.in);
  return u.setTime(u.getTime() + i * xv), u;
}
function pR(s, i, l) {
  return H1(s, i * 3, l);
}
function gR(s, i, l) {
  return k1(s, i * 1e3);
}
function yR(s, i, l) {
  return z0(s, i * 7, l);
}
function vR(s, i, l) {
  return H1(s, i * 12, l);
}
function mv(s, i) {
  const l = +Te(s) - +Te(i);
  return l < 0 ? -1 : l > 0 ? 1 : l;
}
function _R(s) {
  return s instanceof Date || typeof s == "object" && Object.prototype.toString.call(s) === "[object Date]";
}
function hM(s) {
  return !(!_R(s) && typeof s != "number" || isNaN(+Te(s)));
}
function bR(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = u.getFullYear() - h.getFullYear(), _ = u.getMonth() - h.getMonth();
  return g * 12 + _;
}
function SR(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  );
  return u.getFullYear() - h.getFullYear();
}
function dM(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = pw(u, h), _ = Math.abs(
    fM(u, h)
  );
  u.setDate(u.getDate() - g * _);
  const S = +(pw(u, h) === -g), T = g * (_ - S);
  return T === 0 ? 0 : T;
}
function pw(s, i) {
  const l = s.getFullYear() - i.getFullYear() || s.getMonth() - i.getMonth() || s.getDate() - i.getDate() || s.getHours() - i.getHours() || s.getMinutes() - i.getMinutes() || s.getSeconds() - i.getSeconds() || s.getMilliseconds() - i.getMilliseconds();
  return l < 0 ? -1 : l > 0 ? 1 : l;
}
function Mv(s) {
  return (i) => {
    const u = (s ? Math[s] : Math.trunc)(i);
    return u === 0 ? 0 : u;
  };
}
function TR(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = (+u - +h) / wv;
  return Mv(l?.roundingMethod)(g);
}
function N1(s, i) {
  return +Te(s) - +Te(i);
}
function xR(s, i, l) {
  const u = N1(s, i) / xv;
  return Mv(l?.roundingMethod)(u);
}
function mM(s, i) {
  const l = Te(s, i?.in);
  return l.setHours(23, 59, 59, 999), l;
}
function pM(s, i) {
  const l = Te(s, i?.in), u = l.getMonth();
  return l.setFullYear(l.getFullYear(), u + 1, 0), l.setHours(23, 59, 59, 999), l;
}
function wR(s, i) {
  const l = Te(s, i?.in);
  return +mM(l, i) == +pM(l, i);
}
function gM(s, i, l) {
  const [u, h, g] = _d(
    l?.in,
    s,
    s,
    i
  ), _ = mv(h, g), S = Math.abs(
    bR(h, g)
  );
  if (S < 1) return 0;
  h.getMonth() === 1 && h.getDate() > 27 && h.setDate(30), h.setMonth(h.getMonth() - _ * S);
  let T = mv(h, g) === -_;
  wR(u) && S === 1 && mv(u, g) === 1 && (T = !1);
  const E = _ * (S - +T);
  return E === 0 ? 0 : E;
}
function MR(s, i, l) {
  const u = gM(s, i, l) / 3;
  return Mv(l?.roundingMethod)(u);
}
function ER(s, i, l) {
  const u = N1(s, i) / 1e3;
  return Mv(l?.roundingMethod)(u);
}
function OR(s, i, l) {
  const u = dM(s, i, l) / 7;
  return Mv(l?.roundingMethod)(u);
}
function AR(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = mv(u, h), _ = Math.abs(SR(u, h));
  u.setFullYear(1584), h.setFullYear(1584);
  const S = mv(u, h) === -g, T = g * (_ - +S);
  return T === 0 ? 0 : T;
}
function DR(s, i) {
  const l = Te(s, i?.in), u = l.getMonth(), h = u - u % 3;
  return l.setMonth(h, 1), l.setHours(0, 0, 0, 0), l;
}
function RR(s, i) {
  const l = Te(s, i?.in);
  return l.setDate(1), l.setHours(0, 0, 0, 0), l;
}
function CR(s, i) {
  const l = Te(s, i?.in), u = l.getFullYear();
  return l.setFullYear(u + 1, 0, 0), l.setHours(23, 59, 59, 999), l;
}
function yM(s, i) {
  const l = Te(s, i?.in);
  return l.setFullYear(l.getFullYear(), 0, 1), l.setHours(0, 0, 0, 0), l;
}
function zR(s, i) {
  const l = Te(s, i?.in);
  return l.setMinutes(59, 59, 999), l;
}
function LR(s, i) {
  const l = vd(), u = l.weekStartsOn ?? l.locale?.options?.weekStartsOn ?? 0, h = Te(s, i?.in), g = h.getDay(), _ = (g < u ? -7 : 0) + 6 - (g - u);
  return h.setDate(h.getDate() + _), h.setHours(23, 59, 59, 999), h;
}
function HR(s, i) {
  const l = Te(s, i?.in);
  return l.setSeconds(59, 999), l;
}
function kR(s, i) {
  const l = Te(s, i?.in), u = l.getMonth(), h = u - u % 3 + 3;
  return l.setMonth(h, 0), l.setHours(23, 59, 59, 999), l;
}
function NR(s, i) {
  const l = Te(s, i?.in);
  return l.setMilliseconds(999), l;
}
const UR = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, BR = (s, i, l) => {
  let u;
  const h = UR[s];
  return typeof h == "string" ? u = h : i === 1 ? u = h.one : u = h.other.replace("{{count}}", i.toString()), l?.addSuffix ? l.comparison && l.comparison > 0 ? "in " + u : u + " ago" : u;
};
function a1(s) {
  return (i = {}) => {
    const l = i.width ? String(i.width) : s.defaultWidth;
    return s.formats[l] || s.formats[s.defaultWidth];
  };
}
const YR = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, jR = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, qR = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, ZR = {
  date: a1({
    formats: YR,
    defaultWidth: "full"
  }),
  time: a1({
    formats: jR,
    defaultWidth: "full"
  }),
  dateTime: a1({
    formats: qR,
    defaultWidth: "full"
  })
}, VR = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, PR = (s, i, l, u) => VR[s];
function nv(s) {
  return (i, l) => {
    const u = l?.context ? String(l.context) : "standalone";
    let h;
    if (u === "formatting" && s.formattingValues) {
      const _ = s.defaultFormattingWidth || s.defaultWidth, S = l?.width ? String(l.width) : _;
      h = s.formattingValues[S] || s.formattingValues[_];
    } else {
      const _ = s.defaultWidth, S = l?.width ? String(l.width) : s.defaultWidth;
      h = s.values[S] || s.values[_];
    }
    const g = s.argumentCallback ? s.argumentCallback(i) : i;
    return h[g];
  };
}
const GR = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, XR = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, QR = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, KR = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, WR = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, JR = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, IR = (s, i) => {
  const l = Number(s), u = l % 100;
  if (u > 20 || u < 10)
    switch (u % 10) {
      case 1:
        return l + "st";
      case 2:
        return l + "nd";
      case 3:
        return l + "rd";
    }
  return l + "th";
}, $R = {
  ordinalNumber: IR,
  era: nv({
    values: GR,
    defaultWidth: "wide"
  }),
  quarter: nv({
    values: XR,
    defaultWidth: "wide",
    argumentCallback: (s) => s - 1
  }),
  month: nv({
    values: QR,
    defaultWidth: "wide"
  }),
  day: nv({
    values: KR,
    defaultWidth: "wide"
  }),
  dayPeriod: nv({
    values: WR,
    defaultWidth: "wide",
    formattingValues: JR,
    defaultFormattingWidth: "wide"
  })
};
function iv(s) {
  return (i, l = {}) => {
    const u = l.width, h = u && s.matchPatterns[u] || s.matchPatterns[s.defaultMatchWidth], g = i.match(h);
    if (!g)
      return null;
    const _ = g[0], S = u && s.parsePatterns[u] || s.parsePatterns[s.defaultParseWidth], T = Array.isArray(S) ? tC(S, (C) => C.test(_)) : (
      // [TODO] -- I challenge you to fix the type
      FR(S, (C) => C.test(_))
    );
    let E;
    E = s.valueCallback ? s.valueCallback(T) : T, E = l.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      l.valueCallback(E)
    ) : E;
    const A = i.slice(_.length);
    return { value: E, rest: A };
  };
}
function FR(s, i) {
  for (const l in s)
    if (Object.prototype.hasOwnProperty.call(s, l) && i(s[l]))
      return l;
}
function tC(s, i) {
  for (let l = 0; l < s.length; l++)
    if (i(s[l]))
      return l;
}
function eC(s) {
  return (i, l = {}) => {
    const u = i.match(s.matchPattern);
    if (!u) return null;
    const h = u[0], g = i.match(s.parsePattern);
    if (!g) return null;
    let _ = s.valueCallback ? s.valueCallback(g[0]) : g[0];
    _ = l.valueCallback ? l.valueCallback(_) : _;
    const S = i.slice(h.length);
    return { value: _, rest: S };
  };
}
const nC = /^(\d+)(th|st|nd|rd)?/i, iC = /\d+/i, aC = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, oC = {
  any: [/^b/i, /^(a|c)/i]
}, lC = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, sC = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, rC = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, uC = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, cC = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, fC = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, hC = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, dC = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, mC = {
  ordinalNumber: eC({
    matchPattern: nC,
    parsePattern: iC,
    valueCallback: (s) => parseInt(s, 10)
  }),
  era: iv({
    matchPatterns: aC,
    defaultMatchWidth: "wide",
    parsePatterns: oC,
    defaultParseWidth: "any"
  }),
  quarter: iv({
    matchPatterns: lC,
    defaultMatchWidth: "wide",
    parsePatterns: sC,
    defaultParseWidth: "any",
    valueCallback: (s) => s + 1
  }),
  month: iv({
    matchPatterns: rC,
    defaultMatchWidth: "wide",
    parsePatterns: uC,
    defaultParseWidth: "any"
  }),
  day: iv({
    matchPatterns: cC,
    defaultMatchWidth: "wide",
    parsePatterns: fC,
    defaultParseWidth: "any"
  }),
  dayPeriod: iv({
    matchPatterns: hC,
    defaultMatchWidth: "any",
    parsePatterns: dC,
    defaultParseWidth: "any"
  })
}, vM = {
  code: "en-US",
  formatDistance: BR,
  formatLong: ZR,
  formatRelative: PR,
  localize: $R,
  match: mC,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function pC(s, i) {
  const l = Te(s, i?.in);
  return fM(l, yM(l)) + 1;
}
function _M(s, i) {
  const l = Te(s, i?.in), u = +kp(l) - +dR(l);
  return Math.round(u / uM) + 1;
}
function U1(s, i) {
  const l = Te(s, i?.in), u = l.getFullYear(), h = vd(), g = i?.firstWeekContainsDate ?? i?.locale?.options?.firstWeekContainsDate ?? h.firstWeekContainsDate ?? h.locale?.options?.firstWeekContainsDate ?? 1, _ = Wn(i?.in || s, 0);
  _.setFullYear(u + 1, 0, g), _.setHours(0, 0, 0, 0);
  const S = fu(_, i), T = Wn(i?.in || s, 0);
  T.setFullYear(u, 0, g), T.setHours(0, 0, 0, 0);
  const E = fu(T, i);
  return +l >= +S ? u + 1 : +l >= +E ? u : u - 1;
}
function gC(s, i) {
  const l = vd(), u = i?.firstWeekContainsDate ?? i?.locale?.options?.firstWeekContainsDate ?? l.firstWeekContainsDate ?? l.locale?.options?.firstWeekContainsDate ?? 1, h = U1(s, i), g = Wn(i?.in || s, 0);
  return g.setFullYear(h, 0, u), g.setHours(0, 0, 0, 0), fu(g, i);
}
function bM(s, i) {
  const l = Te(s, i?.in), u = +fu(l, i) - +gC(l, i);
  return Math.round(u / uM) + 1;
}
function rn(s, i) {
  const l = s < 0 ? "-" : "", u = Math.abs(s).toString().padStart(i, "0");
  return l + u;
}
const xf = {
  // Year
  y(s, i) {
    const l = s.getFullYear(), u = l > 0 ? l : 1 - l;
    return rn(i === "yy" ? u % 100 : u, i.length);
  },
  // Month
  M(s, i) {
    const l = s.getMonth();
    return i === "M" ? String(l + 1) : rn(l + 1, 2);
  },
  // Day of the month
  d(s, i) {
    return rn(s.getDate(), i.length);
  },
  // AM or PM
  a(s, i) {
    const l = s.getHours() / 12 >= 1 ? "pm" : "am";
    switch (i) {
      case "a":
      case "aa":
        return l.toUpperCase();
      case "aaa":
        return l;
      case "aaaaa":
        return l[0];
      case "aaaa":
      default:
        return l === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(s, i) {
    return rn(s.getHours() % 12 || 12, i.length);
  },
  // Hour [0-23]
  H(s, i) {
    return rn(s.getHours(), i.length);
  },
  // Minute
  m(s, i) {
    return rn(s.getMinutes(), i.length);
  },
  // Second
  s(s, i) {
    return rn(s.getSeconds(), i.length);
  },
  // Fraction of second
  S(s, i) {
    const l = i.length, u = s.getMilliseconds(), h = Math.trunc(
      u * Math.pow(10, l - 3)
    );
    return rn(h, i.length);
  }
}, Cp = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, gw = {
  // Era
  G: function(s, i, l) {
    const u = s.getFullYear() > 0 ? 1 : 0;
    switch (i) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return l.era(u, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return l.era(u, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return l.era(u, { width: "wide" });
    }
  },
  // Year
  y: function(s, i, l) {
    if (i === "yo") {
      const u = s.getFullYear(), h = u > 0 ? u : 1 - u;
      return l.ordinalNumber(h, { unit: "year" });
    }
    return xf.y(s, i);
  },
  // Local week-numbering year
  Y: function(s, i, l, u) {
    const h = U1(s, u), g = h > 0 ? h : 1 - h;
    if (i === "YY") {
      const _ = g % 100;
      return rn(_, 2);
    }
    return i === "Yo" ? l.ordinalNumber(g, { unit: "year" }) : rn(g, i.length);
  },
  // ISO week-numbering year
  R: function(s, i) {
    const l = cM(s);
    return rn(l, i.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(s, i) {
    const l = s.getFullYear();
    return rn(l, i.length);
  },
  // Quarter
  Q: function(s, i, l) {
    const u = Math.ceil((s.getMonth() + 1) / 3);
    switch (i) {
      // 1, 2, 3, 4
      case "Q":
        return String(u);
      // 01, 02, 03, 04
      case "QQ":
        return rn(u, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return l.ordinalNumber(u, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return l.quarter(u, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return l.quarter(u, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return l.quarter(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(s, i, l) {
    const u = Math.ceil((s.getMonth() + 1) / 3);
    switch (i) {
      // 1, 2, 3, 4
      case "q":
        return String(u);
      // 01, 02, 03, 04
      case "qq":
        return rn(u, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return l.ordinalNumber(u, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return l.quarter(u, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return l.quarter(u, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return l.quarter(u, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(s, i, l) {
    const u = s.getMonth();
    switch (i) {
      case "M":
      case "MM":
        return xf.M(s, i);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return l.ordinalNumber(u + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return l.month(u, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return l.month(u, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return l.month(u, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(s, i, l) {
    const u = s.getMonth();
    switch (i) {
      // 1, 2, ..., 12
      case "L":
        return String(u + 1);
      // 01, 02, ..., 12
      case "LL":
        return rn(u + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return l.ordinalNumber(u + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return l.month(u, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return l.month(u, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return l.month(u, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(s, i, l, u) {
    const h = bM(s, u);
    return i === "wo" ? l.ordinalNumber(h, { unit: "week" }) : rn(h, i.length);
  },
  // ISO week of year
  I: function(s, i, l) {
    const u = _M(s);
    return i === "Io" ? l.ordinalNumber(u, { unit: "week" }) : rn(u, i.length);
  },
  // Day of the month
  d: function(s, i, l) {
    return i === "do" ? l.ordinalNumber(s.getDate(), { unit: "date" }) : xf.d(s, i);
  },
  // Day of year
  D: function(s, i, l) {
    const u = pC(s);
    return i === "Do" ? l.ordinalNumber(u, { unit: "dayOfYear" }) : rn(u, i.length);
  },
  // Day of week
  E: function(s, i, l) {
    const u = s.getDay();
    switch (i) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return l.day(u, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return l.day(u, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return l.day(u, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return l.day(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(s, i, l, u) {
    const h = s.getDay(), g = (h - u.weekStartsOn + 8) % 7 || 7;
    switch (i) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(g);
      // Padded numerical value
      case "ee":
        return rn(g, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return l.ordinalNumber(g, { unit: "day" });
      case "eee":
        return l.day(h, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return l.day(h, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return l.day(h, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return l.day(h, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(s, i, l, u) {
    const h = s.getDay(), g = (h - u.weekStartsOn + 8) % 7 || 7;
    switch (i) {
      // Numerical value (same as in `e`)
      case "c":
        return String(g);
      // Padded numerical value
      case "cc":
        return rn(g, i.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return l.ordinalNumber(g, { unit: "day" });
      case "ccc":
        return l.day(h, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return l.day(h, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return l.day(h, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return l.day(h, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(s, i, l) {
    const u = s.getDay(), h = u === 0 ? 7 : u;
    switch (i) {
      // 2
      case "i":
        return String(h);
      // 02
      case "ii":
        return rn(h, i.length);
      // 2nd
      case "io":
        return l.ordinalNumber(h, { unit: "day" });
      // Tue
      case "iii":
        return l.day(u, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return l.day(u, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return l.day(u, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return l.day(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(s, i, l) {
    const h = s.getHours() / 12 >= 1 ? "pm" : "am";
    switch (i) {
      case "a":
      case "aa":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return l.dayPeriod(h, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return l.dayPeriod(h, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(s, i, l) {
    const u = s.getHours();
    let h;
    switch (u === 12 ? h = Cp.noon : u === 0 ? h = Cp.midnight : h = u / 12 >= 1 ? "pm" : "am", i) {
      case "b":
      case "bb":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return l.dayPeriod(h, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return l.dayPeriod(h, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(s, i, l) {
    const u = s.getHours();
    let h;
    switch (u >= 17 ? h = Cp.evening : u >= 12 ? h = Cp.afternoon : u >= 4 ? h = Cp.morning : h = Cp.night, i) {
      case "B":
      case "BB":
      case "BBB":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return l.dayPeriod(h, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return l.dayPeriod(h, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(s, i, l) {
    if (i === "ho") {
      let u = s.getHours() % 12;
      return u === 0 && (u = 12), l.ordinalNumber(u, { unit: "hour" });
    }
    return xf.h(s, i);
  },
  // Hour [0-23]
  H: function(s, i, l) {
    return i === "Ho" ? l.ordinalNumber(s.getHours(), { unit: "hour" }) : xf.H(s, i);
  },
  // Hour [0-11]
  K: function(s, i, l) {
    const u = s.getHours() % 12;
    return i === "Ko" ? l.ordinalNumber(u, { unit: "hour" }) : rn(u, i.length);
  },
  // Hour [1-24]
  k: function(s, i, l) {
    let u = s.getHours();
    return u === 0 && (u = 24), i === "ko" ? l.ordinalNumber(u, { unit: "hour" }) : rn(u, i.length);
  },
  // Minute
  m: function(s, i, l) {
    return i === "mo" ? l.ordinalNumber(s.getMinutes(), { unit: "minute" }) : xf.m(s, i);
  },
  // Second
  s: function(s, i, l) {
    return i === "so" ? l.ordinalNumber(s.getSeconds(), { unit: "second" }) : xf.s(s, i);
  },
  // Fraction of second
  S: function(s, i) {
    return xf.S(s, i);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(s, i, l) {
    const u = s.getTimezoneOffset();
    if (u === 0)
      return "Z";
    switch (i) {
      // Hours and optional minutes
      case "X":
        return vw(u);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return hd(u);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return hd(u, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(s, i, l) {
    const u = s.getTimezoneOffset();
    switch (i) {
      // Hours and optional minutes
      case "x":
        return vw(u);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return hd(u);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return hd(u, ":");
    }
  },
  // Timezone (GMT)
  O: function(s, i, l) {
    const u = s.getTimezoneOffset();
    switch (i) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + yw(u, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + hd(u, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(s, i, l) {
    const u = s.getTimezoneOffset();
    switch (i) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + yw(u, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + hd(u, ":");
    }
  },
  // Seconds timestamp
  t: function(s, i, l) {
    const u = Math.trunc(+s / 1e3);
    return rn(u, i.length);
  },
  // Milliseconds timestamp
  T: function(s, i, l) {
    return rn(+s, i.length);
  }
};
function yw(s, i = "") {
  const l = s > 0 ? "-" : "+", u = Math.abs(s), h = Math.trunc(u / 60), g = u % 60;
  return g === 0 ? l + String(h) : l + String(h) + i + rn(g, 2);
}
function vw(s, i) {
  return s % 60 === 0 ? (s > 0 ? "-" : "+") + rn(Math.abs(s) / 60, 2) : hd(s, i);
}
function hd(s, i = "") {
  const l = s > 0 ? "-" : "+", u = Math.abs(s), h = rn(Math.trunc(u / 60), 2), g = rn(u % 60, 2);
  return l + h + i + g;
}
const _w = (s, i) => {
  switch (s) {
    case "P":
      return i.date({ width: "short" });
    case "PP":
      return i.date({ width: "medium" });
    case "PPP":
      return i.date({ width: "long" });
    case "PPPP":
    default:
      return i.date({ width: "full" });
  }
}, SM = (s, i) => {
  switch (s) {
    case "p":
      return i.time({ width: "short" });
    case "pp":
      return i.time({ width: "medium" });
    case "ppp":
      return i.time({ width: "long" });
    case "pppp":
    default:
      return i.time({ width: "full" });
  }
}, yC = (s, i) => {
  const l = s.match(/(P+)(p+)?/) || [], u = l[1], h = l[2];
  if (!h)
    return _w(s, i);
  let g;
  switch (u) {
    case "P":
      g = i.dateTime({ width: "short" });
      break;
    case "PP":
      g = i.dateTime({ width: "medium" });
      break;
    case "PPP":
      g = i.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      g = i.dateTime({ width: "full" });
      break;
  }
  return g.replace("{{date}}", _w(u, i)).replace("{{time}}", SM(h, i));
}, y1 = {
  p: SM,
  P: yC
}, vC = /^D+$/, _C = /^Y+$/, bC = ["D", "DD", "YY", "YYYY"];
function TM(s) {
  return vC.test(s);
}
function xM(s) {
  return _C.test(s);
}
function v1(s, i, l) {
  const u = SC(s, i, l);
  if (console.warn(u), bC.includes(s)) throw new RangeError(u);
}
function SC(s, i, l) {
  const u = s[0] === "Y" ? "years" : "days of the month";
  return `Use \`${s.toLowerCase()}\` instead of \`${s}\` (in \`${i}\`) for formatting ${u} to the input \`${l}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const TC = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, xC = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, wC = /^'([^]*?)'?$/, MC = /''/g, EC = /[a-zA-Z]/;
function OC(s, i, l) {
  const u = vd(), h = l?.locale ?? u.locale ?? vM, g = l?.firstWeekContainsDate ?? l?.locale?.options?.firstWeekContainsDate ?? u.firstWeekContainsDate ?? u.locale?.options?.firstWeekContainsDate ?? 1, _ = l?.weekStartsOn ?? l?.locale?.options?.weekStartsOn ?? u.weekStartsOn ?? u.locale?.options?.weekStartsOn ?? 0, S = Te(s, l?.in);
  if (!hM(S))
    throw new RangeError("Invalid time value");
  let T = i.match(xC).map((A) => {
    const C = A[0];
    if (C === "p" || C === "P") {
      const z = y1[C];
      return z(A, h.formatLong);
    }
    return A;
  }).join("").match(TC).map((A) => {
    if (A === "''")
      return { isToken: !1, value: "'" };
    const C = A[0];
    if (C === "'")
      return { isToken: !1, value: AC(A) };
    if (gw[C])
      return { isToken: !0, value: A };
    if (C.match(EC))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + C + "`"
      );
    return { isToken: !1, value: A };
  });
  h.localize.preprocessor && (T = h.localize.preprocessor(S, T));
  const E = {
    firstWeekContainsDate: g,
    weekStartsOn: _,
    locale: h
  };
  return T.map((A) => {
    if (!A.isToken) return A.value;
    const C = A.value;
    (!l?.useAdditionalWeekYearTokens && xM(C) || !l?.useAdditionalDayOfYearTokens && TM(C)) && v1(C, i, String(s));
    const z = gw[C[0]];
    return z(S, C, h.localize, E);
  }).join("");
}
function AC(s) {
  const i = s.match(wC);
  return i ? i[1].replace(MC, "'") : s;
}
function DC() {
  return Object.assign({}, vd());
}
function RC(s, i) {
  const l = Te(s, i?.in).getDay();
  return l === 0 ? 7 : l;
}
function CC(s, i) {
  const l = zC(i) ? new i(0) : Wn(i, 0);
  return l.setFullYear(s.getFullYear(), s.getMonth(), s.getDate()), l.setHours(
    s.getHours(),
    s.getMinutes(),
    s.getSeconds(),
    s.getMilliseconds()
  ), l;
}
function zC(s) {
  return typeof s == "function" && s.prototype?.constructor === s;
}
const LC = 10;
class wM {
  subPriority = 0;
  validate(i, l) {
    return !0;
  }
}
class HC extends wM {
  constructor(i, l, u, h, g) {
    super(), this.value = i, this.validateValue = l, this.setValue = u, this.priority = h, g && (this.subPriority = g);
  }
  validate(i, l) {
    return this.validateValue(i, this.value, l);
  }
  set(i, l, u) {
    return this.setValue(i, l, this.value, u);
  }
}
class kC extends wM {
  priority = LC;
  subPriority = -1;
  constructor(i, l) {
    super(), this.context = i || ((u) => Wn(l, u));
  }
  set(i, l) {
    return l.timestampIsSet ? i : Wn(i, CC(i, this.context));
  }
}
class $e {
  run(i, l, u, h) {
    const g = this.parse(i, l, u, h);
    return g ? {
      setter: new HC(
        g.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: g.rest
    } : null;
  }
  validate(i, l, u) {
    return !0;
  }
}
class NC extends $e {
  priority = 140;
  parse(i, l, u) {
    switch (l) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return u.era(i, { width: "abbreviated" }) || u.era(i, { width: "narrow" });
      // A, B
      case "GGGGG":
        return u.era(i, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return u.era(i, { width: "wide" }) || u.era(i, { width: "abbreviated" }) || u.era(i, { width: "narrow" });
    }
  }
  set(i, l, u) {
    return l.era = u, i.setFullYear(u, 0, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = ["R", "u", "t", "T"];
}
const ri = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, su = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function ui(s, i) {
  return s && {
    value: i(s.value),
    rest: s.rest
  };
}
function qn(s, i) {
  const l = i.match(s);
  return l ? {
    value: parseInt(l[0], 10),
    rest: i.slice(l[0].length)
  } : null;
}
function ru(s, i) {
  const l = i.match(s);
  if (!l)
    return null;
  if (l[0] === "Z")
    return {
      value: 0,
      rest: i.slice(1)
    };
  const u = l[1] === "+" ? 1 : -1, h = l[2] ? parseInt(l[2], 10) : 0, g = l[3] ? parseInt(l[3], 10) : 0, _ = l[5] ? parseInt(l[5], 10) : 0;
  return {
    value: u * (h * wv + g * xv + _ * cR),
    rest: i.slice(l[0].length)
  };
}
function MM(s) {
  return qn(ri.anyDigitsSigned, s);
}
function Jn(s, i) {
  switch (s) {
    case 1:
      return qn(ri.singleDigit, i);
    case 2:
      return qn(ri.twoDigits, i);
    case 3:
      return qn(ri.threeDigits, i);
    case 4:
      return qn(ri.fourDigits, i);
    default:
      return qn(new RegExp("^\\d{1," + s + "}"), i);
  }
}
function E0(s, i) {
  switch (s) {
    case 1:
      return qn(ri.singleDigitSigned, i);
    case 2:
      return qn(ri.twoDigitsSigned, i);
    case 3:
      return qn(ri.threeDigitsSigned, i);
    case 4:
      return qn(ri.fourDigitsSigned, i);
    default:
      return qn(new RegExp("^-?\\d{1," + s + "}"), i);
  }
}
function B1(s) {
  switch (s) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function EM(s, i) {
  const l = i > 0, u = l ? i : 1 - i;
  let h;
  if (u <= 50)
    h = s || 100;
  else {
    const g = u + 50, _ = Math.trunc(g / 100) * 100, S = s >= g % 100;
    h = s + _ - (S ? 100 : 0);
  }
  return l ? h : 1 - h;
}
function OM(s) {
  return s % 400 === 0 || s % 4 === 0 && s % 100 !== 0;
}
class UC extends $e {
  priority = 130;
  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];
  parse(i, l, u) {
    const h = (g) => ({
      year: g,
      isTwoDigitYear: l === "yy"
    });
    switch (l) {
      case "y":
        return ui(Jn(4, i), h);
      case "yo":
        return ui(
          u.ordinalNumber(i, {
            unit: "year"
          }),
          h
        );
      default:
        return ui(Jn(l.length, i), h);
    }
  }
  validate(i, l) {
    return l.isTwoDigitYear || l.year > 0;
  }
  set(i, l, u) {
    const h = i.getFullYear();
    if (u.isTwoDigitYear) {
      const _ = EM(
        u.year,
        h
      );
      return i.setFullYear(_, 0, 1), i.setHours(0, 0, 0, 0), i;
    }
    const g = !("era" in l) || l.era === 1 ? u.year : 1 - u.year;
    return i.setFullYear(g, 0, 1), i.setHours(0, 0, 0, 0), i;
  }
}
class BC extends $e {
  priority = 130;
  parse(i, l, u) {
    const h = (g) => ({
      year: g,
      isTwoDigitYear: l === "YY"
    });
    switch (l) {
      case "Y":
        return ui(Jn(4, i), h);
      case "Yo":
        return ui(
          u.ordinalNumber(i, {
            unit: "year"
          }),
          h
        );
      default:
        return ui(Jn(l.length, i), h);
    }
  }
  validate(i, l) {
    return l.isTwoDigitYear || l.year > 0;
  }
  set(i, l, u, h) {
    const g = U1(i, h);
    if (u.isTwoDigitYear) {
      const S = EM(
        u.year,
        g
      );
      return i.setFullYear(
        S,
        0,
        h.firstWeekContainsDate
      ), i.setHours(0, 0, 0, 0), fu(i, h);
    }
    const _ = !("era" in l) || l.era === 1 ? u.year : 1 - u.year;
    return i.setFullYear(_, 0, h.firstWeekContainsDate), i.setHours(0, 0, 0, 0), fu(i, h);
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T"
  ];
}
class YC extends $e {
  priority = 130;
  parse(i, l) {
    return E0(l === "R" ? 4 : l.length, i);
  }
  set(i, l, u) {
    const h = Wn(i, 0);
    return h.setFullYear(u, 0, 4), h.setHours(0, 0, 0, 0), kp(h);
  }
  incompatibleTokens = [
    "G",
    "y",
    "Y",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T"
  ];
}
class jC extends $e {
  priority = 130;
  parse(i, l) {
    return E0(l === "u" ? 4 : l.length, i);
  }
  set(i, l, u) {
    return i.setFullYear(u, 0, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
}
class qC extends $e {
  priority = 120;
  parse(i, l, u) {
    switch (l) {
      // 1, 2, 3, 4
      case "Q":
      case "QQ":
        return Jn(l.length, i);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return u.ordinalNumber(i, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return u.quarter(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.quarter(i, {
          width: "narrow",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return u.quarter(i, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return u.quarter(i, {
          width: "wide",
          context: "formatting"
        }) || u.quarter(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.quarter(i, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 4;
  }
  set(i, l, u) {
    return i.setMonth((u - 1) * 3, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
class ZC extends $e {
  priority = 120;
  parse(i, l, u) {
    switch (l) {
      // 1, 2, 3, 4
      case "q":
      case "qq":
        return Jn(l.length, i);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return u.ordinalNumber(i, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return u.quarter(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.quarter(i, {
          width: "narrow",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return u.quarter(i, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return u.quarter(i, {
          width: "wide",
          context: "standalone"
        }) || u.quarter(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.quarter(i, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 4;
  }
  set(i, l, u) {
    return i.setMonth((u - 1) * 3, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
class VC extends $e {
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "L",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
  priority = 110;
  parse(i, l, u) {
    const h = (g) => g - 1;
    switch (l) {
      // 1, 2, ..., 12
      case "M":
        return ui(
          qn(ri.month, i),
          h
        );
      // 01, 02, ..., 12
      case "MM":
        return ui(Jn(2, i), h);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return ui(
          u.ordinalNumber(i, {
            unit: "month"
          }),
          h
        );
      // Jan, Feb, ..., Dec
      case "MMM":
        return u.month(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.month(i, { width: "narrow", context: "formatting" });
      // J, F, ..., D
      case "MMMMM":
        return u.month(i, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return u.month(i, { width: "wide", context: "formatting" }) || u.month(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.month(i, { width: "narrow", context: "formatting" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 11;
  }
  set(i, l, u) {
    return i.setMonth(u, 1), i.setHours(0, 0, 0, 0), i;
  }
}
class PC extends $e {
  priority = 110;
  parse(i, l, u) {
    const h = (g) => g - 1;
    switch (l) {
      // 1, 2, ..., 12
      case "L":
        return ui(
          qn(ri.month, i),
          h
        );
      // 01, 02, ..., 12
      case "LL":
        return ui(Jn(2, i), h);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return ui(
          u.ordinalNumber(i, {
            unit: "month"
          }),
          h
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return u.month(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.month(i, { width: "narrow", context: "standalone" });
      // J, F, ..., D
      case "LLLLL":
        return u.month(i, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return u.month(i, { width: "wide", context: "standalone" }) || u.month(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.month(i, { width: "narrow", context: "standalone" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 11;
  }
  set(i, l, u) {
    return i.setMonth(u, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
function GC(s, i, l) {
  const u = Te(s, l?.in), h = bM(u, l) - i;
  return u.setDate(u.getDate() - h * 7), Te(u, l?.in);
}
class XC extends $e {
  priority = 100;
  parse(i, l, u) {
    switch (l) {
      case "w":
        return qn(ri.week, i);
      case "wo":
        return u.ordinalNumber(i, { unit: "week" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 53;
  }
  set(i, l, u, h) {
    return fu(GC(i, u, h), h);
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T"
  ];
}
function QC(s, i, l) {
  const u = Te(s, l?.in), h = _M(u, l) - i;
  return u.setDate(u.getDate() - h * 7), u;
}
class KC extends $e {
  priority = 100;
  parse(i, l, u) {
    switch (l) {
      case "I":
        return qn(ri.week, i);
      case "Io":
        return u.ordinalNumber(i, { unit: "week" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 53;
  }
  set(i, l, u) {
    return kp(QC(i, u));
  }
  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T"
  ];
}
const WC = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], JC = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class IC extends $e {
  priority = 90;
  subPriority = 1;
  parse(i, l, u) {
    switch (l) {
      case "d":
        return qn(ri.date, i);
      case "do":
        return u.ordinalNumber(i, { unit: "date" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    const u = i.getFullYear(), h = OM(u), g = i.getMonth();
    return h ? l >= 1 && l <= JC[g] : l >= 1 && l <= WC[g];
  }
  set(i, l, u) {
    return i.setDate(u), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
class $C extends $e {
  priority = 90;
  subpriority = 1;
  parse(i, l, u) {
    switch (l) {
      case "D":
      case "DD":
        return qn(ri.dayOfYear, i);
      case "Do":
        return u.ordinalNumber(i, { unit: "date" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    const u = i.getFullYear();
    return OM(u) ? l >= 1 && l <= 366 : l >= 1 && l <= 365;
  }
  set(i, l, u) {
    return i.setMonth(0, u), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "E",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
function Y1(s, i, l) {
  const u = vd(), h = l?.weekStartsOn ?? l?.locale?.options?.weekStartsOn ?? u.weekStartsOn ?? u.locale?.options?.weekStartsOn ?? 0, g = Te(s, l?.in), _ = g.getDay(), T = (i % 7 + 7) % 7, E = 7 - h, A = i < 0 || i > 6 ? i - (_ + E) % 7 : (T + E) % 7 - (_ + E) % 7;
  return z0(g, A, l);
}
class FC extends $e {
  priority = 90;
  parse(i, l, u) {
    switch (l) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return u.day(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
      // T
      case "EEEEE":
        return u.day(i, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
      // Tuesday
      case "EEEE":
      default:
        return u.day(i, { width: "wide", context: "formatting" }) || u.day(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 6;
  }
  set(i, l, u, h) {
    return i = Y1(i, u, h), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
}
class tz extends $e {
  priority = 90;
  parse(i, l, u, h) {
    const g = (_) => {
      const S = Math.floor((_ - 1) / 7) * 7;
      return (_ + h.weekStartsOn + 6) % 7 + S;
    };
    switch (l) {
      // 3
      case "e":
      case "ee":
        return ui(Jn(l.length, i), g);
      // 3rd
      case "eo":
        return ui(
          u.ordinalNumber(i, {
            unit: "day"
          }),
          g
        );
      // Tue
      case "eee":
        return u.day(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
      // T
      case "eeeee":
        return u.day(i, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
      // Tuesday
      case "eeee":
      default:
        return u.day(i, { width: "wide", context: "formatting" }) || u.day(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 6;
  }
  set(i, l, u, h) {
    return i = Y1(i, u, h), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "c",
    "t",
    "T"
  ];
}
class ez extends $e {
  priority = 90;
  parse(i, l, u, h) {
    const g = (_) => {
      const S = Math.floor((_ - 1) / 7) * 7;
      return (_ + h.weekStartsOn + 6) % 7 + S;
    };
    switch (l) {
      // 3
      case "c":
      case "cc":
        return ui(Jn(l.length, i), g);
      // 3rd
      case "co":
        return ui(
          u.ordinalNumber(i, {
            unit: "day"
          }),
          g
        );
      // Tue
      case "ccc":
        return u.day(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.day(i, { width: "short", context: "standalone" }) || u.day(i, { width: "narrow", context: "standalone" });
      // T
      case "ccccc":
        return u.day(i, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return u.day(i, { width: "short", context: "standalone" }) || u.day(i, { width: "narrow", context: "standalone" });
      // Tuesday
      case "cccc":
      default:
        return u.day(i, { width: "wide", context: "standalone" }) || u.day(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.day(i, { width: "short", context: "standalone" }) || u.day(i, { width: "narrow", context: "standalone" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 6;
  }
  set(i, l, u, h) {
    return i = Y1(i, u, h), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "e",
    "t",
    "T"
  ];
}
function nz(s, i, l) {
  const u = Te(s, l?.in), h = RC(u, l), g = i - h;
  return z0(u, g, l);
}
class iz extends $e {
  priority = 90;
  parse(i, l, u) {
    const h = (g) => g === 0 ? 7 : g;
    switch (l) {
      // 2
      case "i":
      case "ii":
        return Jn(l.length, i);
      // 2nd
      case "io":
        return u.ordinalNumber(i, { unit: "day" });
      // Tue
      case "iii":
        return ui(
          u.day(i, {
            width: "abbreviated",
            context: "formatting"
          }) || u.day(i, {
            width: "short",
            context: "formatting"
          }) || u.day(i, {
            width: "narrow",
            context: "formatting"
          }),
          h
        );
      // T
      case "iiiii":
        return ui(
          u.day(i, {
            width: "narrow",
            context: "formatting"
          }),
          h
        );
      // Tu
      case "iiiiii":
        return ui(
          u.day(i, {
            width: "short",
            context: "formatting"
          }) || u.day(i, {
            width: "narrow",
            context: "formatting"
          }),
          h
        );
      // Tuesday
      case "iiii":
      default:
        return ui(
          u.day(i, {
            width: "wide",
            context: "formatting"
          }) || u.day(i, {
            width: "abbreviated",
            context: "formatting"
          }) || u.day(i, {
            width: "short",
            context: "formatting"
          }) || u.day(i, {
            width: "narrow",
            context: "formatting"
          }),
          h
        );
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 7;
  }
  set(i, l, u) {
    return i = nz(i, u), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "E",
    "e",
    "c",
    "t",
    "T"
  ];
}
class az extends $e {
  priority = 80;
  parse(i, l, u) {
    switch (l) {
      case "a":
      case "aa":
      case "aaa":
        return u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return u.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(i, l, u) {
    return i.setHours(B1(u), 0, 0, 0), i;
  }
  incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
}
class oz extends $e {
  priority = 80;
  parse(i, l, u) {
    switch (l) {
      case "b":
      case "bb":
      case "bbb":
        return u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return u.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(i, l, u) {
    return i.setHours(B1(u), 0, 0, 0), i;
  }
  incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
}
class lz extends $e {
  priority = 80;
  parse(i, l, u) {
    switch (l) {
      case "B":
      case "BB":
      case "BBB":
        return u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return u.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(i, l, u) {
    return i.setHours(B1(u), 0, 0, 0), i;
  }
  incompatibleTokens = ["a", "b", "t", "T"];
}
class sz extends $e {
  priority = 70;
  parse(i, l, u) {
    switch (l) {
      case "h":
        return qn(ri.hour12h, i);
      case "ho":
        return u.ordinalNumber(i, { unit: "hour" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 12;
  }
  set(i, l, u) {
    const h = i.getHours() >= 12;
    return h && u < 12 ? i.setHours(u + 12, 0, 0, 0) : !h && u === 12 ? i.setHours(0, 0, 0, 0) : i.setHours(u, 0, 0, 0), i;
  }
  incompatibleTokens = ["H", "K", "k", "t", "T"];
}
class rz extends $e {
  priority = 70;
  parse(i, l, u) {
    switch (l) {
      case "H":
        return qn(ri.hour23h, i);
      case "Ho":
        return u.ordinalNumber(i, { unit: "hour" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 23;
  }
  set(i, l, u) {
    return i.setHours(u, 0, 0, 0), i;
  }
  incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
}
class uz extends $e {
  priority = 70;
  parse(i, l, u) {
    switch (l) {
      case "K":
        return qn(ri.hour11h, i);
      case "Ko":
        return u.ordinalNumber(i, { unit: "hour" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 11;
  }
  set(i, l, u) {
    return i.getHours() >= 12 && u < 12 ? i.setHours(u + 12, 0, 0, 0) : i.setHours(u, 0, 0, 0), i;
  }
  incompatibleTokens = ["h", "H", "k", "t", "T"];
}
class cz extends $e {
  priority = 70;
  parse(i, l, u) {
    switch (l) {
      case "k":
        return qn(ri.hour24h, i);
      case "ko":
        return u.ordinalNumber(i, { unit: "hour" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 24;
  }
  set(i, l, u) {
    const h = u <= 24 ? u % 24 : u;
    return i.setHours(h, 0, 0, 0), i;
  }
  incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
}
class fz extends $e {
  priority = 60;
  parse(i, l, u) {
    switch (l) {
      case "m":
        return qn(ri.minute, i);
      case "mo":
        return u.ordinalNumber(i, { unit: "minute" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 59;
  }
  set(i, l, u) {
    return i.setMinutes(u, 0, 0), i;
  }
  incompatibleTokens = ["t", "T"];
}
class hz extends $e {
  priority = 50;
  parse(i, l, u) {
    switch (l) {
      case "s":
        return qn(ri.second, i);
      case "so":
        return u.ordinalNumber(i, { unit: "second" });
      default:
        return Jn(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 59;
  }
  set(i, l, u) {
    return i.setSeconds(u, 0), i;
  }
  incompatibleTokens = ["t", "T"];
}
class dz extends $e {
  priority = 30;
  parse(i, l) {
    const u = (h) => Math.trunc(h * Math.pow(10, -l.length + 3));
    return ui(Jn(l.length, i), u);
  }
  set(i, l, u) {
    return i.setMilliseconds(u), i;
  }
  incompatibleTokens = ["t", "T"];
}
class mz extends $e {
  priority = 10;
  parse(i, l) {
    switch (l) {
      case "X":
        return ru(
          su.basicOptionalMinutes,
          i
        );
      case "XX":
        return ru(su.basic, i);
      case "XXXX":
        return ru(
          su.basicOptionalSeconds,
          i
        );
      case "XXXXX":
        return ru(
          su.extendedOptionalSeconds,
          i
        );
      case "XXX":
      default:
        return ru(su.extended, i);
    }
  }
  set(i, l, u) {
    return l.timestampIsSet ? i : Wn(
      i,
      i.getTime() - M0(i) - u
    );
  }
  incompatibleTokens = ["t", "T", "x"];
}
class pz extends $e {
  priority = 10;
  parse(i, l) {
    switch (l) {
      case "x":
        return ru(
          su.basicOptionalMinutes,
          i
        );
      case "xx":
        return ru(su.basic, i);
      case "xxxx":
        return ru(
          su.basicOptionalSeconds,
          i
        );
      case "xxxxx":
        return ru(
          su.extendedOptionalSeconds,
          i
        );
      case "xxx":
      default:
        return ru(su.extended, i);
    }
  }
  set(i, l, u) {
    return l.timestampIsSet ? i : Wn(
      i,
      i.getTime() - M0(i) - u
    );
  }
  incompatibleTokens = ["t", "T", "X"];
}
class gz extends $e {
  priority = 40;
  parse(i) {
    return MM(i);
  }
  set(i, l, u) {
    return [Wn(i, u * 1e3), { timestampIsSet: !0 }];
  }
  incompatibleTokens = "*";
}
class yz extends $e {
  priority = 20;
  parse(i) {
    return MM(i);
  }
  set(i, l, u) {
    return [Wn(i, u), { timestampIsSet: !0 }];
  }
  incompatibleTokens = "*";
}
const vz = {
  G: new NC(),
  y: new UC(),
  Y: new BC(),
  R: new YC(),
  u: new jC(),
  Q: new qC(),
  q: new ZC(),
  M: new VC(),
  L: new PC(),
  w: new XC(),
  I: new KC(),
  d: new IC(),
  D: new $C(),
  E: new FC(),
  e: new tz(),
  c: new ez(),
  i: new iz(),
  a: new az(),
  b: new oz(),
  B: new lz(),
  h: new sz(),
  H: new rz(),
  K: new uz(),
  k: new cz(),
  m: new fz(),
  s: new hz(),
  S: new dz(),
  X: new mz(),
  x: new pz(),
  t: new gz(),
  T: new yz()
}, _z = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, bz = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Sz = /^'([^]*?)'?$/, Tz = /''/g, xz = /\S/, wz = /[a-zA-Z]/;
function Mz(s, i, l, u) {
  const h = () => Wn(u?.in || l, NaN), g = DC(), _ = u?.locale ?? g.locale ?? vM, S = u?.firstWeekContainsDate ?? u?.locale?.options?.firstWeekContainsDate ?? g.firstWeekContainsDate ?? g.locale?.options?.firstWeekContainsDate ?? 1, T = u?.weekStartsOn ?? u?.locale?.options?.weekStartsOn ?? g.weekStartsOn ?? g.locale?.options?.weekStartsOn ?? 0;
  if (!i)
    return s ? h() : Te(l, u?.in);
  const E = {
    firstWeekContainsDate: S,
    weekStartsOn: T,
    locale: _
  }, A = [new kC(u?.in, l)], C = i.match(bz).map((X) => {
    const et = X[0];
    if (et in y1) {
      const wt = y1[et];
      return wt(X, _.formatLong);
    }
    return X;
  }).join("").match(_z), z = [];
  for (let X of C) {
    !u?.useAdditionalWeekYearTokens && xM(X) && v1(X, i, s), !u?.useAdditionalDayOfYearTokens && TM(X) && v1(X, i, s);
    const et = X[0], wt = vz[et];
    if (wt) {
      const { incompatibleTokens: At } = wt;
      if (Array.isArray(At)) {
        const yt = z.find(
          (Bt) => At.includes(Bt.token) || Bt.token === et
        );
        if (yt)
          throw new RangeError(
            `The format string mustn't contain \`${yt.fullToken}\` and \`${X}\` at the same time`
          );
      } else if (wt.incompatibleTokens === "*" && z.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${X}\` and any other token at the same time`
        );
      z.push({ token: et, fullToken: X });
      const Lt = wt.run(
        s,
        X,
        _.match,
        E
      );
      if (!Lt)
        return h();
      A.push(Lt.setter), s = Lt.rest;
    } else {
      if (et.match(wz))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + et + "`"
        );
      if (X === "''" ? X = "'" : et === "'" && (X = Ez(X)), s.indexOf(X) === 0)
        s = s.slice(X.length);
      else
        return h();
    }
  }
  if (s.length > 0 && xz.test(s))
    return h();
  const j = A.map((X) => X.priority).sort((X, et) => et - X).filter((X, et, wt) => wt.indexOf(X) === et).map(
    (X) => A.filter((et) => et.priority === X).sort((et, wt) => wt.subPriority - et.subPriority)
  ).map((X) => X[0]);
  let J = Te(l, u?.in);
  if (isNaN(+J)) return h();
  const Q = {};
  for (const X of j) {
    if (!X.validate(J, E))
      return h();
    const et = X.set(J, Q, E);
    Array.isArray(et) ? (J = et[0], Object.assign(Q, et[1])) : J = et;
  }
  return J;
}
function Ez(s) {
  return s.match(Sz)[1].replace(Tz, "'");
}
function Oz(s, i) {
  const l = Te(s, i?.in);
  return l.setMinutes(0, 0, 0), l;
}
function Az(s, i) {
  const l = Te(s, i?.in);
  return l.setSeconds(0, 0), l;
}
function Dz(s, i) {
  const l = Te(s, i?.in);
  return l.setMilliseconds(0), l;
}
function Rz(s, i) {
  const l = () => Wn(i?.in, NaN), u = i?.additionalDigits ?? 2, h = Hz(s);
  let g;
  if (h.date) {
    const E = kz(h.date, u);
    g = Nz(E.restDateString, E.year);
  }
  if (!g || isNaN(+g)) return l();
  const _ = +g;
  let S = 0, T;
  if (h.time && (S = Uz(h.time), isNaN(S)))
    return l();
  if (h.timezone) {
    if (T = Bz(h.timezone), isNaN(T)) return l();
  } else {
    const E = new Date(_ + S), A = Te(0, i?.in);
    return A.setFullYear(
      E.getUTCFullYear(),
      E.getUTCMonth(),
      E.getUTCDate()
    ), A.setHours(
      E.getUTCHours(),
      E.getUTCMinutes(),
      E.getUTCSeconds(),
      E.getUTCMilliseconds()
    ), A;
  }
  return Te(_ + S + T, i?.in);
}
const m0 = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, Cz = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, zz = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, Lz = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function Hz(s) {
  const i = {}, l = s.split(m0.dateTimeDelimiter);
  let u;
  if (l.length > 2)
    return i;
  if (/:/.test(l[0]) ? u = l[0] : (i.date = l[0], u = l[1], m0.timeZoneDelimiter.test(i.date) && (i.date = s.split(m0.timeZoneDelimiter)[0], u = s.substr(
    i.date.length,
    s.length
  ))), u) {
    const h = m0.timezone.exec(u);
    h ? (i.time = u.replace(h[1], ""), i.timezone = h[1]) : i.time = u;
  }
  return i;
}
function kz(s, i) {
  const l = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + i) + "})|(\\d{2}|[+-]\\d{" + (2 + i) + "})$)"
  ), u = s.match(l);
  if (!u) return { year: NaN, restDateString: "" };
  const h = u[1] ? parseInt(u[1]) : null, g = u[2] ? parseInt(u[2]) : null;
  return {
    year: g === null ? h : g * 100,
    restDateString: s.slice((u[1] || u[2]).length)
  };
}
function Nz(s, i) {
  if (i === null) return /* @__PURE__ */ new Date(NaN);
  const l = s.match(Cz);
  if (!l) return /* @__PURE__ */ new Date(NaN);
  const u = !!l[4], h = av(l[1]), g = av(l[2]) - 1, _ = av(l[3]), S = av(l[4]), T = av(l[5]) - 1;
  if (u)
    return Vz(i, S, T) ? Yz(i, S, T) : /* @__PURE__ */ new Date(NaN);
  {
    const E = /* @__PURE__ */ new Date(0);
    return !qz(i, g, _) || !Zz(i, h) ? /* @__PURE__ */ new Date(NaN) : (E.setUTCFullYear(i, g, Math.max(h, _)), E);
  }
}
function av(s) {
  return s ? parseInt(s) : 1;
}
function Uz(s) {
  const i = s.match(zz);
  if (!i) return NaN;
  const l = o1(i[1]), u = o1(i[2]), h = o1(i[3]);
  return Pz(l, u, h) ? l * wv + u * xv + h * 1e3 : NaN;
}
function o1(s) {
  return s && parseFloat(s.replace(",", ".")) || 0;
}
function Bz(s) {
  if (s === "Z") return 0;
  const i = s.match(Lz);
  if (!i) return 0;
  const l = i[1] === "+" ? -1 : 1, u = parseInt(i[2]), h = i[3] && parseInt(i[3]) || 0;
  return Gz(u, h) ? l * (u * wv + h * xv) : NaN;
}
function Yz(s, i, l) {
  const u = /* @__PURE__ */ new Date(0);
  u.setUTCFullYear(s, 0, 4);
  const h = u.getUTCDay() || 7, g = (i - 1) * 7 + l + 1 - h;
  return u.setUTCDate(u.getUTCDate() + g), u;
}
const jz = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function AM(s) {
  return s % 400 === 0 || s % 4 === 0 && s % 100 !== 0;
}
function qz(s, i, l) {
  return i >= 0 && i <= 11 && l >= 1 && l <= (jz[i] || (AM(s) ? 29 : 28));
}
function Zz(s, i) {
  return i >= 1 && i <= (AM(s) ? 366 : 365);
}
function Vz(s, i, l) {
  return i >= 1 && i <= 53 && l >= 0 && l <= 6;
}
function Pz(s, i, l) {
  return s === 24 ? i === 0 && l === 0 : l >= 0 && l < 60 && i >= 0 && i < 60 && s >= 0 && s < 25;
}
function Gz(s, i) {
  return i >= 0 && i <= 59;
}
/*!
 * chartjs-adapter-date-fns v3.0.0
 * https://www.chartjs.org
 * (c) 2022 chartjs-adapter-date-fns Contributors
 * Released under the MIT license
 */
const Xz = {
  datetime: "MMM d, yyyy, h:mm:ss aaaa",
  millisecond: "h:mm:ss.SSS aaaa",
  second: "h:mm:ss aaaa",
  minute: "h:mm aaaa",
  hour: "ha",
  day: "MMM d",
  week: "PP",
  month: "MMM yyyy",
  quarter: "qqq - yyyy",
  year: "yyyy"
};
Kw._date.override({
  _id: "date-fns",
  // DEBUG
  formats: function() {
    return Xz;
  },
  parse: function(s, i) {
    if (s === null || typeof s > "u")
      return null;
    const l = typeof s;
    return l === "number" || s instanceof Date ? s = Te(s) : l === "string" && (typeof i == "string" ? s = Mz(s, i, /* @__PURE__ */ new Date(), this.options) : s = Rz(s, this.options)), hM(s) ? s.getTime() : null;
  },
  format: function(s, i) {
    return OC(s, i, this.options);
  },
  add: function(s, i, l) {
    switch (l) {
      case "millisecond":
        return k1(s, i);
      case "second":
        return gR(s, i);
      case "minute":
        return mR(s, i);
      case "hour":
        return fR(s, i);
      case "day":
        return z0(s, i);
      case "week":
        return yR(s, i);
      case "month":
        return H1(s, i);
      case "quarter":
        return pR(s, i);
      case "year":
        return vR(s, i);
      default:
        return s;
    }
  },
  diff: function(s, i, l) {
    switch (l) {
      case "millisecond":
        return N1(s, i);
      case "second":
        return ER(s, i);
      case "minute":
        return xR(s, i);
      case "hour":
        return TR(s, i);
      case "day":
        return dM(s, i);
      case "week":
        return OR(s, i);
      case "month":
        return gM(s, i);
      case "quarter":
        return MR(s, i);
      case "year":
        return AR(s, i);
      default:
        return 0;
    }
  },
  startOf: function(s, i, l) {
    switch (i) {
      case "second":
        return Dz(s);
      case "minute":
        return Az(s);
      case "hour":
        return Oz(s);
      case "day":
        return g1(s);
      case "week":
        return fu(s);
      case "isoWeek":
        return fu(s, { weekStartsOn: +l });
      case "month":
        return RR(s);
      case "quarter":
        return DR(s);
      case "year":
        return yM(s);
      default:
        return s;
    }
  },
  endOf: function(s, i) {
    switch (i) {
      case "second":
        return NR(s);
      case "minute":
        return HR(s);
      case "hour":
        return zR(s);
      case "day":
        return mM(s);
      case "week":
        return LR(s);
      case "month":
        return pM(s);
      case "quarter":
        return kR(s);
      case "year":
        return CR(s);
      default:
        return s;
    }
  }
});
L1.register(cA, D0, AD, oR, p1, nR, KD);
function Qz({ data: s }) {
  const i = $i.useRef(null);
  return $i.useEffect(() => {
    const l = i.current?.getContext("2d");
    if (!l) return;
    const u = s.map((g) => parseFloat(g.price)), h = new L1(l, {
      type: "line",
      data: {
        labels: s.map((g) => g.fetched_at),
        datasets: [
          {
            label: "Cena",
            data: u,
            borderColor: "#0d6efd",
            fill: !1
          }
        ]
      },
      options: {
        scales: {
          x: { type: "time" }
        }
      }
    });
    return () => h.destroy();
  }, [s]), /* @__PURE__ */ ee.jsx("canvas", { ref: i, height: 300 });
}
var uv = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
var Kz = uv.exports, bw;
function Wz() {
  return bw || (bw = 1, function(s, i) {
    (function(l, u) {
      u(i);
    })(Kz, function(l) {
      var u = "1.9.4";
      function h(r) {
        var d, v, w, O;
        for (v = 1, w = arguments.length; v < w; v++) {
          O = arguments[v];
          for (d in O)
            r[d] = O[d];
        }
        return r;
      }
      var g = Object.create || /* @__PURE__ */ function() {
        function r() {
        }
        return function(d) {
          return r.prototype = d, new r();
        };
      }();
      function _(r, d) {
        var v = Array.prototype.slice;
        if (r.bind)
          return r.bind.apply(r, v.call(arguments, 1));
        var w = v.call(arguments, 2);
        return function() {
          return r.apply(d, w.length ? w.concat(v.call(arguments)) : arguments);
        };
      }
      var S = 0;
      function T(r) {
        return "_leaflet_id" in r || (r._leaflet_id = ++S), r._leaflet_id;
      }
      function E(r, d, v) {
        var w, O, H, q;
        return q = function() {
          w = !1, O && (H.apply(v, O), O = !1);
        }, H = function() {
          w ? O = arguments : (r.apply(v, arguments), setTimeout(q, d), w = !0);
        }, H;
      }
      function A(r, d, v) {
        var w = d[1], O = d[0], H = w - O;
        return r === w && v ? r : ((r - O) % H + H) % H + O;
      }
      function C() {
        return !1;
      }
      function z(r, d) {
        if (d === !1)
          return r;
        var v = Math.pow(10, d === void 0 ? 6 : d);
        return Math.round(r * v) / v;
      }
      function j(r) {
        return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, "");
      }
      function J(r) {
        return j(r).split(/\s+/);
      }
      function Q(r, d) {
        Object.prototype.hasOwnProperty.call(r, "options") || (r.options = r.options ? g(r.options) : {});
        for (var v in d)
          r.options[v] = d[v];
        return r.options;
      }
      function X(r, d, v) {
        var w = [];
        for (var O in r)
          w.push(encodeURIComponent(v ? O.toUpperCase() : O) + "=" + encodeURIComponent(r[O]));
        return (!d || d.indexOf("?") === -1 ? "?" : "&") + w.join("&");
      }
      var et = /\{ *([\w_ -]+) *\}/g;
      function wt(r, d) {
        return r.replace(et, function(v, w) {
          var O = d[w];
          if (O === void 0)
            throw new Error("No value provided for variable " + v);
          return typeof O == "function" && (O = O(d)), O;
        });
      }
      var At = Array.isArray || function(r) {
        return Object.prototype.toString.call(r) === "[object Array]";
      };
      function Lt(r, d) {
        for (var v = 0; v < r.length; v++)
          if (r[v] === d)
            return v;
        return -1;
      }
      var yt = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function Bt(r) {
        return window["webkit" + r] || window["moz" + r] || window["ms" + r];
      }
      var Ct = 0;
      function Yt(r) {
        var d = +/* @__PURE__ */ new Date(), v = Math.max(0, 16 - (d - Ct));
        return Ct = d + v, window.setTimeout(r, v);
      }
      var Mt = window.requestAnimationFrame || Bt("RequestAnimationFrame") || Yt, ne = window.cancelAnimationFrame || Bt("CancelAnimationFrame") || Bt("CancelRequestAnimationFrame") || function(r) {
        window.clearTimeout(r);
      };
      function Rt(r, d, v) {
        if (v && Mt === Yt)
          r.call(d);
        else
          return Mt.call(window, _(r, d));
      }
      function kt(r) {
        r && ne.call(window, r);
      }
      var Ee = {
        __proto__: null,
        extend: h,
        create: g,
        bind: _,
        get lastId() {
          return S;
        },
        stamp: T,
        throttle: E,
        wrapNum: A,
        falseFn: C,
        formatNum: z,
        trim: j,
        splitWords: J,
        setOptions: Q,
        getParamString: X,
        template: wt,
        isArray: At,
        indexOf: Lt,
        emptyImageUrl: yt,
        requestFn: Mt,
        cancelFn: ne,
        requestAnimFrame: Rt,
        cancelAnimFrame: kt
      };
      function ge() {
      }
      ge.extend = function(r) {
        var d = function() {
          Q(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
        }, v = d.__super__ = this.prototype, w = g(v);
        w.constructor = d, d.prototype = w;
        for (var O in this)
          Object.prototype.hasOwnProperty.call(this, O) && O !== "prototype" && O !== "__super__" && (d[O] = this[O]);
        return r.statics && h(d, r.statics), r.includes && (It(r.includes), h.apply(null, [w].concat(r.includes))), h(w, r), delete w.statics, delete w.includes, w.options && (w.options = v.options ? g(v.options) : {}, h(w.options, r.options)), w._initHooks = [], w.callInitHooks = function() {
          if (!this._initHooksCalled) {
            v.callInitHooks && v.callInitHooks.call(this), this._initHooksCalled = !0;
            for (var H = 0, q = w._initHooks.length; H < q; H++)
              w._initHooks[H].call(this);
          }
        }, d;
      }, ge.include = function(r) {
        var d = this.prototype.options;
        return h(this.prototype, r), r.options && (this.prototype.options = d, this.mergeOptions(r.options)), this;
      }, ge.mergeOptions = function(r) {
        return h(this.prototype.options, r), this;
      }, ge.addInitHook = function(r) {
        var d = Array.prototype.slice.call(arguments, 1), v = typeof r == "function" ? r : function() {
          this[r].apply(this, d);
        };
        return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(v), this;
      };
      function It(r) {
        if (!(typeof L > "u" || !L || !L.Mixin)) {
          r = At(r) ? r : [r];
          for (var d = 0; d < r.length; d++)
            r[d] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
        }
      }
      var P = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(r, d, v) {
          if (typeof r == "object")
            for (var w in r)
              this._on(w, r[w], d);
          else {
            r = J(r);
            for (var O = 0, H = r.length; O < H; O++)
              this._on(r[O], d, v);
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(r, d, v) {
          if (!arguments.length)
            delete this._events;
          else if (typeof r == "object")
            for (var w in r)
              this._off(w, r[w], d);
          else {
            r = J(r);
            for (var O = arguments.length === 1, H = 0, q = r.length; H < q; H++)
              O ? this._off(r[H]) : this._off(r[H], d, v);
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(r, d, v, w) {
          if (typeof d != "function") {
            console.warn("wrong listener type: " + typeof d);
            return;
          }
          if (this._listens(r, d, v) === !1) {
            v === this && (v = void 0);
            var O = { fn: d, ctx: v };
            w && (O.once = !0), this._events = this._events || {}, this._events[r] = this._events[r] || [], this._events[r].push(O);
          }
        },
        _off: function(r, d, v) {
          var w, O, H;
          if (this._events && (w = this._events[r], !!w)) {
            if (arguments.length === 1) {
              if (this._firingCount)
                for (O = 0, H = w.length; O < H; O++)
                  w[O].fn = C;
              delete this._events[r];
              return;
            }
            if (typeof d != "function") {
              console.warn("wrong listener type: " + typeof d);
              return;
            }
            var q = this._listens(r, d, v);
            if (q !== !1) {
              var I = w[q];
              this._firingCount && (I.fn = C, this._events[r] = w = w.slice()), w.splice(q, 1);
            }
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object  the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(r, d, v) {
          if (!this.listens(r, v))
            return this;
          var w = h({}, d, {
            type: r,
            target: this,
            sourceTarget: d && d.sourceTarget || this
          });
          if (this._events) {
            var O = this._events[r];
            if (O) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var H = 0, q = O.length; H < q; H++) {
                var I = O[H], rt = I.fn;
                I.once && this.off(r, rt, I.ctx), rt.call(I.ctx || this, w);
              }
              this._firingCount--;
            }
          }
          return v && this._propagateEvent(w), this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(r, d, v, w) {
          typeof r != "string" && console.warn('"string" type argument expected');
          var O = d;
          typeof d != "function" && (w = !!d, O = void 0, v = void 0);
          var H = this._events && this._events[r];
          if (H && H.length && this._listens(r, O, v) !== !1)
            return !0;
          if (w) {
            for (var q in this._eventParents)
              if (this._eventParents[q].listens(r, d, v, w))
                return !0;
          }
          return !1;
        },
        // returns the index (number) or false
        _listens: function(r, d, v) {
          if (!this._events)
            return !1;
          var w = this._events[r] || [];
          if (!d)
            return !!w.length;
          v === this && (v = void 0);
          for (var O = 0, H = w.length; O < H; O++)
            if (w[O].fn === d && w[O].ctx === v)
              return O;
          return !1;
        },
        // @method once(): this
        // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
        once: function(r, d, v) {
          if (typeof r == "object")
            for (var w in r)
              this._on(w, r[w], d, !0);
          else {
            r = J(r);
            for (var O = 0, H = r.length; O < H; O++)
              this._on(r[O], d, v, !0);
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(r) {
          return this._eventParents = this._eventParents || {}, this._eventParents[T(r)] = r, this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(r) {
          return this._eventParents && delete this._eventParents[T(r)], this;
        },
        _propagateEvent: function(r) {
          for (var d in this._eventParents)
            this._eventParents[d].fire(r.type, h({
              layer: r.target,
              propagatedFrom: r.target
            }, r), !0);
        }
      };
      P.addEventListener = P.on, P.removeEventListener = P.clearAllEventListeners = P.off, P.addOneTimeEventListener = P.once, P.fireEvent = P.fire, P.hasEventListeners = P.listens;
      var dt = ge.extend(P);
      function ut(r, d, v) {
        this.x = v ? Math.round(r) : r, this.y = v ? Math.round(d) : d;
      }
      var Gt = Math.trunc || function(r) {
        return r > 0 ? Math.floor(r) : Math.ceil(r);
      };
      ut.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new ut(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(r) {
          return this.clone()._add(k(r));
        },
        _add: function(r) {
          return this.x += r.x, this.y += r.y, this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(r) {
          return this.clone()._subtract(k(r));
        },
        _subtract: function(r) {
          return this.x -= r.x, this.y -= r.y, this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(r) {
          return this.clone()._divideBy(r);
        },
        _divideBy: function(r) {
          return this.x /= r, this.y /= r, this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(r) {
          return this.clone()._multiplyBy(r);
        },
        _multiplyBy: function(r) {
          return this.x *= r, this.y *= r, this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(r) {
          return new ut(this.x * r.x, this.y * r.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(r) {
          return new ut(this.x / r.x, this.y / r.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          return this.x = Gt(this.x), this.y = Gt(this.y), this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(r) {
          r = k(r);
          var d = r.x - this.x, v = r.y - this.y;
          return Math.sqrt(d * d + v * v);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(r) {
          return r = k(r), r.x === this.x && r.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(r) {
          return r = k(r), Math.abs(r.x) <= Math.abs(this.x) && Math.abs(r.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + z(this.x) + ", " + z(this.y) + ")";
        }
      };
      function k(r, d, v) {
        return r instanceof ut ? r : At(r) ? new ut(r[0], r[1]) : r == null ? r : typeof r == "object" && "x" in r && "y" in r ? new ut(r.x, r.y) : new ut(r, d, v);
      }
      function F(r, d) {
        if (r)
          for (var v = d ? [r, d] : r, w = 0, O = v.length; w < O; w++)
            this.extend(v[w]);
      }
      F.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(r) {
          var d, v;
          if (!r)
            return this;
          if (r instanceof ut || typeof r[0] == "number" || "x" in r)
            d = v = k(r);
          else if (r = ct(r), d = r.min, v = r.max, !d || !v)
            return this;
          return !this.min && !this.max ? (this.min = d.clone(), this.max = v.clone()) : (this.min.x = Math.min(d.x, this.min.x), this.max.x = Math.max(v.x, this.max.x), this.min.y = Math.min(d.y, this.min.y), this.max.y = Math.max(v.y, this.max.y)), this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(r) {
          return k(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            r
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return k(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return k(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(r) {
          var d, v;
          return typeof r[0] == "number" || r instanceof ut ? r = k(r) : r = ct(r), r instanceof F ? (d = r.min, v = r.max) : d = v = r, d.x >= this.min.x && v.x <= this.max.x && d.y >= this.min.y && v.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(r) {
          r = ct(r);
          var d = this.min, v = this.max, w = r.min, O = r.max, H = O.x >= d.x && w.x <= v.x, q = O.y >= d.y && w.y <= v.y;
          return H && q;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(r) {
          r = ct(r);
          var d = this.min, v = this.max, w = r.min, O = r.max, H = O.x > d.x && w.x < v.x, q = O.y > d.y && w.y < v.y;
          return H && q;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(r) {
          var d = this.min, v = this.max, w = Math.abs(d.x - v.x) * r, O = Math.abs(d.y - v.y) * r;
          return ct(
            k(d.x - w, d.y - O),
            k(v.x + w, v.y + O)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(r) {
          return r ? (r = ct(r), this.min.equals(r.getTopLeft()) && this.max.equals(r.getBottomRight())) : !1;
        }
      };
      function ct(r, d) {
        return !r || r instanceof F ? r : new F(r, d);
      }
      function bt(r, d) {
        if (r)
          for (var v = d ? [r, d] : r, w = 0, O = v.length; w < O; w++)
            this.extend(v[w]);
      }
      bt.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(r) {
          var d = this._southWest, v = this._northEast, w, O;
          if (r instanceof zt)
            w = r, O = r;
          else if (r instanceof bt) {
            if (w = r._southWest, O = r._northEast, !w || !O)
              return this;
          } else
            return r ? this.extend(Tt(r) || Et(r)) : this;
          return !d && !v ? (this._southWest = new zt(w.lat, w.lng), this._northEast = new zt(O.lat, O.lng)) : (d.lat = Math.min(w.lat, d.lat), d.lng = Math.min(w.lng, d.lng), v.lat = Math.max(O.lat, v.lat), v.lng = Math.max(O.lng, v.lng)), this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(r) {
          var d = this._southWest, v = this._northEast, w = Math.abs(d.lat - v.lat) * r, O = Math.abs(d.lng - v.lng) * r;
          return new bt(
            new zt(d.lat - w, d.lng - O),
            new zt(v.lat + w, v.lng + O)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new zt(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new zt(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new zt(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(r) {
          typeof r[0] == "number" || r instanceof zt || "lat" in r ? r = Tt(r) : r = Et(r);
          var d = this._southWest, v = this._northEast, w, O;
          return r instanceof bt ? (w = r.getSouthWest(), O = r.getNorthEast()) : w = O = r, w.lat >= d.lat && O.lat <= v.lat && w.lng >= d.lng && O.lng <= v.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(r) {
          r = Et(r);
          var d = this._southWest, v = this._northEast, w = r.getSouthWest(), O = r.getNorthEast(), H = O.lat >= d.lat && w.lat <= v.lat, q = O.lng >= d.lng && w.lng <= v.lng;
          return H && q;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(r) {
          r = Et(r);
          var d = this._southWest, v = this._northEast, w = r.getSouthWest(), O = r.getNorthEast(), H = O.lat > d.lat && w.lat < v.lat, q = O.lng > d.lng && w.lng < v.lng;
          return H && q;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(r, d) {
          return r ? (r = Et(r), this._southWest.equals(r.getSouthWest(), d) && this._northEast.equals(r.getNorthEast(), d)) : !1;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function Et(r, d) {
        return r instanceof bt ? r : new bt(r, d);
      }
      function zt(r, d, v) {
        if (isNaN(r) || isNaN(d))
          throw new Error("Invalid LatLng object: (" + r + ", " + d + ")");
        this.lat = +r, this.lng = +d, v !== void 0 && (this.alt = +v);
      }
      zt.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(r, d) {
          if (!r)
            return !1;
          r = Tt(r);
          var v = Math.max(
            Math.abs(this.lat - r.lat),
            Math.abs(this.lng - r.lng)
          );
          return v <= (d === void 0 ? 1e-9 : d);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(r) {
          return "LatLng(" + z(this.lat, r) + ", " + z(this.lng, r) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(r) {
          return $t.distance(this, Tt(r));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return $t.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(r) {
          var d = 180 * r / 40075017, v = d / Math.cos(Math.PI / 180 * this.lat);
          return Et(
            [this.lat - d, this.lng - v],
            [this.lat + d, this.lng + v]
          );
        },
        clone: function() {
          return new zt(this.lat, this.lng, this.alt);
        }
      };
      function Tt(r, d, v) {
        return r instanceof zt ? r : At(r) && typeof r[0] != "object" ? r.length === 3 ? new zt(r[0], r[1], r[2]) : r.length === 2 ? new zt(r[0], r[1]) : null : r == null ? r : typeof r == "object" && "lat" in r ? new zt(r.lat, "lng" in r ? r.lng : r.lon, r.alt) : d === void 0 ? null : new zt(r, d, v);
      }
      var We = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(r, d) {
          var v = this.projection.project(r), w = this.scale(d);
          return this.transformation._transform(v, w);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(r, d) {
          var v = this.scale(d), w = this.transformation.untransform(r, v);
          return this.projection.unproject(w);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(r) {
          return this.projection.project(r);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(r) {
          return this.projection.unproject(r);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(r) {
          return 256 * Math.pow(2, r);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(r) {
          return Math.log(r / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(r) {
          if (this.infinite)
            return null;
          var d = this.projection.bounds, v = this.scale(r), w = this.transformation.transform(d.min, v), O = this.transformation.transform(d.max, v);
          return new F(w, O);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: !1,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(r) {
          var d = this.wrapLng ? A(r.lng, this.wrapLng, !0) : r.lng, v = this.wrapLat ? A(r.lat, this.wrapLat, !0) : r.lat, w = r.alt;
          return new zt(v, d, w);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(r) {
          var d = r.getCenter(), v = this.wrapLatLng(d), w = d.lat - v.lat, O = d.lng - v.lng;
          if (w === 0 && O === 0)
            return r;
          var H = r.getSouthWest(), q = r.getNorthEast(), I = new zt(H.lat - w, H.lng - O), rt = new zt(q.lat - w, q.lng - O);
          return new bt(I, rt);
        }
      }, $t = h({}, We, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(r, d) {
          var v = Math.PI / 180, w = r.lat * v, O = d.lat * v, H = Math.sin((d.lat - r.lat) * v / 2), q = Math.sin((d.lng - r.lng) * v / 2), I = H * H + Math.cos(w) * Math.cos(O) * q * q, rt = 2 * Math.atan2(Math.sqrt(I), Math.sqrt(1 - I));
          return this.R * rt;
        }
      }), on = 6378137, ci = {
        R: on,
        MAX_LATITUDE: 85.0511287798,
        project: function(r) {
          var d = Math.PI / 180, v = this.MAX_LATITUDE, w = Math.max(Math.min(v, r.lat), -v), O = Math.sin(w * d);
          return new ut(
            this.R * r.lng * d,
            this.R * Math.log((1 + O) / (1 - O)) / 2
          );
        },
        unproject: function(r) {
          var d = 180 / Math.PI;
          return new zt(
            (2 * Math.atan(Math.exp(r.y / this.R)) - Math.PI / 2) * d,
            r.x * d / this.R
          );
        },
        bounds: function() {
          var r = on * Math.PI;
          return new F([-r, -r], [r, r]);
        }()
      };
      function da(r, d, v, w) {
        if (At(r)) {
          this._a = r[0], this._b = r[1], this._c = r[2], this._d = r[3];
          return;
        }
        this._a = r, this._b = d, this._c = v, this._d = w;
      }
      da.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(r, d) {
          return this._transform(r.clone(), d);
        },
        // destructive transform (faster)
        _transform: function(r, d) {
          return d = d || 1, r.x = d * (this._a * r.x + this._b), r.y = d * (this._c * r.y + this._d), r;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(r, d) {
          return d = d || 1, new ut(
            (r.x / d - this._b) / this._a,
            (r.y / d - this._d) / this._c
          );
        }
      };
      function Za(r, d, v, w) {
        return new da(r, d, v, w);
      }
      var ma = h({}, $t, {
        code: "EPSG:3857",
        projection: ci,
        transformation: function() {
          var r = 0.5 / (Math.PI * ci.R);
          return Za(r, 0.5, -r, 0.5);
        }()
      }), ur = h({}, ma, {
        code: "EPSG:900913"
      });
      function cr(r) {
        return document.createElementNS("http://www.w3.org/2000/svg", r);
      }
      function Tn(r, d) {
        var v = "", w, O, H, q, I, rt;
        for (w = 0, H = r.length; w < H; w++) {
          for (I = r[w], O = 0, q = I.length; O < q; O++)
            rt = I[O], v += (O ? "L" : "M") + rt.x + " " + rt.y;
          v += d ? Wt.svg ? "z" : "x" : "";
        }
        return v || "M0 0";
      }
      var En = document.documentElement.style, Va = "ActiveXObject" in window, dc = Va && !document.addEventListener, pe = "msLaunchUri" in navigator && !("documentMode" in document), pa = ea("webkit"), vs = ea("android"), po = ea("android 2") || ea("android 3"), mc = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), hu = vs && ea("Google") && mc < 537 && !("AudioNode" in window), go = !!window.opera, Zn = !pe && ea("chrome"), ta = ea("gecko") && !pa && !go && !Va, In = !Zn && ea("safari"), _s = ea("phantom"), fr = "OTransition" in En, hr = navigator.platform.indexOf("Win") === 0, ga = Va && "transition" in En, fi = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !po, Vn = "MozPerspective" in En, Pa = !window.L_DISABLE_3D && (ga || fi || Vn) && !fr && !_s, N = typeof orientation < "u" || ea("mobile"), $ = N && pa, Dt = N && fi, Ht = !window.PointerEvent && window.MSPointerEvent, Xt = !!(window.PointerEvent || Ht), se = "ontouchstart" in window || !!window.TouchEvent, he = !window.L_NO_TOUCH && (se || Xt), ze = N && go, fe = N && ta, On = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, Ga = function() {
        var r = !1;
        try {
          var d = Object.defineProperty({}, "passive", {
            get: function() {
              r = !0;
            }
          });
          window.addEventListener("testPassiveEventSupport", C, d), window.removeEventListener("testPassiveEventSupport", C, d);
        } catch {
        }
        return r;
      }(), pc = function() {
        return !!document.createElement("canvas").getContext;
      }(), du = !!(document.createElementNS && cr("svg").createSVGRect), Nn = !!du && function() {
        var r = document.createElement("div");
        return r.innerHTML = "<svg/>", (r.firstChild && r.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }(), Pn = !du && function() {
        try {
          var r = document.createElement("div");
          r.innerHTML = '<v:shape adj="1"/>';
          var d = r.firstChild;
          return d.style.behavior = "url(#default#VML)", d && typeof d.adj == "object";
        } catch {
          return !1;
        }
      }(), Mi = navigator.platform.indexOf("Mac") === 0, dr = navigator.platform.indexOf("Linux") === 0;
      function ea(r) {
        return navigator.userAgent.toLowerCase().indexOf(r) >= 0;
      }
      var Wt = {
        ie: Va,
        ielt9: dc,
        edge: pe,
        webkit: pa,
        android: vs,
        android23: po,
        androidStock: hu,
        opera: go,
        chrome: Zn,
        gecko: ta,
        safari: In,
        phantom: _s,
        opera12: fr,
        win: hr,
        ie3d: ga,
        webkit3d: fi,
        gecko3d: Vn,
        any3d: Pa,
        mobile: N,
        mobileWebkit: $,
        mobileWebkit3d: Dt,
        msPointer: Ht,
        pointer: Xt,
        touch: he,
        touchNative: se,
        mobileOpera: ze,
        mobileGecko: fe,
        retina: On,
        passiveEvents: Ga,
        canvas: pc,
        svg: du,
        vml: Pn,
        inlineSvg: Nn,
        mac: Mi,
        linux: dr
      }, mu = Wt.msPointer ? "MSPointerDown" : "pointerdown", Af = Wt.msPointer ? "MSPointerMove" : "pointermove", Vt = Wt.msPointer ? "MSPointerUp" : "pointerup", mr = Wt.msPointer ? "MSPointerCancel" : "pointercancel", Un = {
        touchstart: mu,
        touchmove: Af,
        touchend: Vt,
        touchcancel: mr
      }, bl = {
        touchstart: Df,
        touchmove: bs,
        touchend: bs,
        touchcancel: bs
      }, yo = {}, vo = !1;
      function Bn(r, d, v) {
        return d === "touchstart" && bd(), bl[d] ? (v = bl[d].bind(this, v), r.addEventListener(Un[d], v, !1), v) : (console.warn("wrong event specified:", d), C);
      }
      function pu(r, d, v) {
        if (!Un[d]) {
          console.warn("wrong event specified:", d);
          return;
        }
        r.removeEventListener(Un[d], v, !1);
      }
      function na(r) {
        yo[r.pointerId] = r;
      }
      function Sl(r) {
        yo[r.pointerId] && (yo[r.pointerId] = r);
      }
      function Wo(r) {
        delete yo[r.pointerId];
      }
      function bd() {
        vo || (document.addEventListener(mu, na, !0), document.addEventListener(Af, Sl, !0), document.addEventListener(Vt, Wo, !0), document.addEventListener(mr, Wo, !0), vo = !0);
      }
      function bs(r, d) {
        if (d.pointerType !== (d.MSPOINTER_TYPE_MOUSE || "mouse")) {
          d.touches = [];
          for (var v in yo)
            d.touches.push(yo[v]);
          d.changedTouches = [d], r(d);
        }
      }
      function Df(r, d) {
        d.MSPOINTER_TYPE_TOUCH && d.pointerType === d.MSPOINTER_TYPE_TOUCH && Ue(d), bs(r, d);
      }
      function Sd(r) {
        var d = {}, v, w;
        for (w in r)
          v = r[w], d[w] = v && v.bind ? v.bind(r) : v;
        return r = d, d.type = "dblclick", d.detail = 2, d.isTrusted = !1, d._simulated = !0, d;
      }
      var Jo = 200;
      function gu(r, d) {
        r.addEventListener("dblclick", d);
        var v = 0, w;
        function O(H) {
          if (H.detail !== 1) {
            w = H.detail;
            return;
          }
          if (!(H.pointerType === "mouse" || H.sourceCapabilities && !H.sourceCapabilities.firesTouchEvents)) {
            var q = vu(H);
            if (!(q.some(function(rt) {
              return rt instanceof HTMLLabelElement && rt.attributes.for;
            }) && !q.some(function(rt) {
              return rt instanceof HTMLInputElement || rt instanceof HTMLSelectElement;
            }))) {
              var I = Date.now();
              I - v <= Jo ? (w++, w === 2 && d(Sd(H))) : w = 1, v = I;
            }
          }
        }
        return r.addEventListener("click", O), {
          dblclick: d,
          simDblclick: O
        };
      }
      function _o(r, d) {
        r.removeEventListener("dblclick", d.dblclick), r.removeEventListener("click", d.simDblclick);
      }
      var pr = wl(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      ), Ss = wl(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      ), Tl = Ss === "webkitTransition" || Ss === "OTransition" ? Ss + "End" : "transitionend";
      function hi(r) {
        return typeof r == "string" ? document.getElementById(r) : r;
      }
      function ya(r, d) {
        var v = r.style[d] || r.currentStyle && r.currentStyle[d];
        if ((!v || v === "auto") && document.defaultView) {
          var w = document.defaultView.getComputedStyle(r, null);
          v = w ? w[d] : null;
        }
        return v === "auto" ? null : v;
      }
      function we(r, d, v) {
        var w = document.createElement(r);
        return w.className = d || "", v && v.appendChild(w), w;
      }
      function ln(r) {
        var d = r.parentNode;
        d && d.removeChild(r);
      }
      function Yn(r) {
        for (; r.firstChild; )
          r.removeChild(r.firstChild);
      }
      function bo(r) {
        var d = r.parentNode;
        d && d.lastChild !== r && d.appendChild(r);
      }
      function xl(r) {
        var d = r.parentNode;
        d && d.firstChild !== r && d.insertBefore(r, d.firstChild);
      }
      function So(r, d) {
        if (r.classList !== void 0)
          return r.classList.contains(d);
        var v = Ei(r);
        return v.length > 0 && new RegExp("(^|\\s)" + d + "(\\s|$)").test(v);
      }
      function le(r, d) {
        if (r.classList !== void 0)
          for (var v = J(d), w = 0, O = v.length; w < O; w++)
            r.classList.add(v[w]);
        else if (!So(r, d)) {
          var H = Ei(r);
          Rf(r, (H ? H + " " : "") + d);
        }
      }
      function Fe(r, d) {
        r.classList !== void 0 ? r.classList.remove(d) : Rf(r, j((" " + Ei(r) + " ").replace(" " + d + " ", " ")));
      }
      function Rf(r, d) {
        r.className.baseVal === void 0 ? r.className = d : r.className.baseVal = d;
      }
      function Ei(r) {
        return r.correspondingElement && (r = r.correspondingElement), r.className.baseVal === void 0 ? r.className : r.className.baseVal;
      }
      function Oi(r, d) {
        "opacity" in r.style ? r.style.opacity = d : "filter" in r.style && gc(r, d);
      }
      function gc(r, d) {
        var v = !1, w = "DXImageTransform.Microsoft.Alpha";
        try {
          v = r.filters.item(w);
        } catch {
          if (d === 1)
            return;
        }
        d = Math.round(d * 100), v ? (v.Enabled = d !== 100, v.Opacity = d) : r.style.filter += " progid:" + w + "(opacity=" + d + ")";
      }
      function wl(r) {
        for (var d = document.documentElement.style, v = 0; v < r.length; v++)
          if (r[v] in d)
            return r[v];
        return !1;
      }
      function ia(r, d, v) {
        var w = d || new ut(0, 0);
        r.style[pr] = (Wt.ie3d ? "translate(" + w.x + "px," + w.y + "px)" : "translate3d(" + w.x + "px," + w.y + "px,0)") + (v ? " scale(" + v + ")" : "");
      }
      function yn(r, d) {
        r._leaflet_pos = d, Wt.any3d ? ia(r, d) : (r.style.left = d.x + "px", r.style.top = d.y + "px");
      }
      function Io(r) {
        return r._leaflet_pos || new ut(0, 0);
      }
      var To, gr, yr;
      if ("onselectstart" in document)
        To = function() {
          ce(window, "selectstart", Ue);
        }, gr = function() {
          Ye(window, "selectstart", Ue);
        };
      else {
        var $o = wl(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        To = function() {
          if ($o) {
            var r = document.documentElement.style;
            yr = r[$o], r[$o] = "none";
          }
        }, gr = function() {
          $o && (document.documentElement.style[$o] = yr, yr = void 0);
        };
      }
      function Fo() {
        ce(window, "dragstart", Ue);
      }
      function Cf() {
        Ye(window, "dragstart", Ue);
      }
      var yu, Ts;
      function tl(r) {
        for (; r.tabIndex === -1; )
          r = r.parentNode;
        r.style && (xs(), yu = r, Ts = r.style.outlineStyle, r.style.outlineStyle = "none", ce(window, "keydown", xs));
      }
      function xs() {
        yu && (yu.style.outlineStyle = Ts, yu = void 0, Ts = void 0, Ye(window, "keydown", xs));
      }
      function ws(r) {
        do
          r = r.parentNode;
        while ((!r.offsetWidth || !r.offsetHeight) && r !== document.body);
        return r;
      }
      function Ml(r) {
        var d = r.getBoundingClientRect();
        return {
          x: d.width / r.offsetWidth || 1,
          y: d.height / r.offsetHeight || 1,
          boundingClientRect: d
        };
      }
      var Td = {
        __proto__: null,
        TRANSFORM: pr,
        TRANSITION: Ss,
        TRANSITION_END: Tl,
        get: hi,
        getStyle: ya,
        create: we,
        remove: ln,
        empty: Yn,
        toFront: bo,
        toBack: xl,
        hasClass: So,
        addClass: le,
        removeClass: Fe,
        setClass: Rf,
        getClass: Ei,
        setOpacity: Oi,
        testProp: wl,
        setTransform: ia,
        setPosition: yn,
        getPosition: Io,
        get disableTextSelection() {
          return To;
        },
        get enableTextSelection() {
          return gr;
        },
        disableImageDrag: Fo,
        enableImageDrag: Cf,
        preventOutline: tl,
        restoreOutline: xs,
        getSizedParentNode: ws,
        getScale: Ml
      };
      function ce(r, d, v, w) {
        if (d && typeof d == "object")
          for (var O in d)
            Qa(r, O, d[O], v);
        else {
          d = J(d);
          for (var H = 0, q = d.length; H < q; H++)
            Qa(r, d[H], v, w);
        }
        return this;
      }
      var Ai = "_leaflet_events";
      function Ye(r, d, v, w) {
        if (arguments.length === 1)
          Xa(r), delete r[Ai];
        else if (d && typeof d == "object")
          for (var O in d)
            Ka(r, O, d[O], v);
        else if (d = J(d), arguments.length === 2)
          Xa(r, function(I) {
            return Lt(d, I) !== -1;
          });
        else
          for (var H = 0, q = d.length; H < q; H++)
            Ka(r, d[H], v, w);
        return this;
      }
      function Xa(r, d) {
        for (var v in r[Ai]) {
          var w = v.split(/\d/)[0];
          (!d || d(w)) && Ka(r, w, null, null, v);
        }
      }
      var vr = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function Qa(r, d, v, w) {
        var O = d + T(v) + (w ? "_" + T(w) : "");
        if (r[Ai] && r[Ai][O])
          return this;
        var H = function(I) {
          return v.call(w || r, I || window.event);
        }, q = H;
        !Wt.touchNative && Wt.pointer && d.indexOf("touch") === 0 ? H = Bn(r, d, H) : Wt.touch && d === "dblclick" ? H = gu(r, H) : "addEventListener" in r ? d === "touchstart" || d === "touchmove" || d === "wheel" || d === "mousewheel" ? r.addEventListener(vr[d] || d, H, Wt.passiveEvents ? { passive: !1 } : !1) : d === "mouseenter" || d === "mouseleave" ? (H = function(I) {
          I = I || window.event, Es(r, I) && q(I);
        }, r.addEventListener(vr[d], H, !1)) : r.addEventListener(d, q, !1) : r.attachEvent("on" + d, H), r[Ai] = r[Ai] || {}, r[Ai][O] = H;
      }
      function Ka(r, d, v, w, O) {
        O = O || d + T(v) + (w ? "_" + T(w) : "");
        var H = r[Ai] && r[Ai][O];
        if (!H)
          return this;
        !Wt.touchNative && Wt.pointer && d.indexOf("touch") === 0 ? pu(r, d, H) : Wt.touch && d === "dblclick" ? _o(r, H) : "removeEventListener" in r ? r.removeEventListener(vr[d] || d, H, !1) : r.detachEvent("on" + d, H), r[Ai][O] = null;
      }
      function va(r) {
        return r.stopPropagation ? r.stopPropagation() : r.originalEvent ? r.originalEvent._stopped = !0 : r.cancelBubble = !0, this;
      }
      function el(r) {
        return Qa(r, "wheel", va), this;
      }
      function Ms(r) {
        return ce(r, "mousedown touchstart dblclick contextmenu", va), r._leaflet_disable_click = !0, this;
      }
      function Ue(r) {
        return r.preventDefault ? r.preventDefault() : r.returnValue = !1, this;
      }
      function xo(r) {
        return Ue(r), va(r), this;
      }
      function vu(r) {
        if (r.composedPath)
          return r.composedPath();
        for (var d = [], v = r.target; v; )
          d.push(v), v = v.parentNode;
        return d;
      }
      function di(r, d) {
        if (!d)
          return new ut(r.clientX, r.clientY);
        var v = Ml(d), w = v.boundingClientRect;
        return new ut(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (r.clientX - w.left) / v.x - d.clientLeft,
          (r.clientY - w.top) / v.y - d.clientTop
        );
      }
      var El = Wt.linux && Wt.chrome ? window.devicePixelRatio : Wt.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function _u(r) {
        return Wt.edge ? r.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          r.deltaY && r.deltaMode === 0 ? -r.deltaY / El : (
            // Pixels
            r.deltaY && r.deltaMode === 1 ? -r.deltaY * 20 : (
              // Lines
              r.deltaY && r.deltaMode === 2 ? -r.deltaY * 60 : (
                // Pages
                r.deltaX || r.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  r.wheelDelta ? (r.wheelDeltaY || r.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    r.detail && Math.abs(r.detail) < 32765 ? -r.detail * 20 : (
                      // Legacy Moz lines
                      r.detail ? r.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function Es(r, d) {
        var v = d.relatedTarget;
        if (!v)
          return !0;
        try {
          for (; v && v !== r; )
            v = v.parentNode;
        } catch {
          return !1;
        }
        return v !== r;
      }
      var xd = {
        __proto__: null,
        on: ce,
        off: Ye,
        stopPropagation: va,
        disableScrollPropagation: el,
        disableClickPropagation: Ms,
        preventDefault: Ue,
        stop: xo,
        getPropagationPath: vu,
        getMousePosition: di,
        getWheelDelta: _u,
        isExternalTarget: Es,
        addListener: ce,
        removeListener: Ye
      }, yc = dt.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(r, d, v, w) {
          this.stop(), this._el = r, this._inProgress = !0, this._duration = v || 0.25, this._easeOutPower = 1 / Math.max(w || 0.5, 0.2), this._startPos = Io(r), this._offset = d.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          this._inProgress && (this._step(!0), this._complete());
        },
        _animate: function() {
          this._animId = Rt(this._animate, this), this._step();
        },
        _step: function(r) {
          var d = +/* @__PURE__ */ new Date() - this._startTime, v = this._duration * 1e3;
          d < v ? this._runFrame(this._easeOut(d / v), r) : (this._runFrame(1), this._complete());
        },
        _runFrame: function(r, d) {
          var v = this._startPos.add(this._offset.multiplyBy(r));
          d && v._round(), yn(this._el, v), this.fire("step");
        },
        _complete: function() {
          kt(this._animId), this._inProgress = !1, this.fire("end");
        },
        _easeOut: function(r) {
          return 1 - Math.pow(1 - r, this._easeOutPower);
        }
      }), Oe = dt.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: ma,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: !0,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: !0,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: !0,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: !0
        },
        initialize: function(r, d) {
          d = Q(this, d), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(r), this._initLayout(), this._onResize = _(this._onResize, this), this._initEvents(), d.maxBounds && this.setMaxBounds(d.maxBounds), d.zoom !== void 0 && (this._zoom = this._limitZoom(d.zoom)), d.center && d.zoom !== void 0 && this.setView(Tt(d.center), d.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = Ss && Wt.any3d && !Wt.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), ce(this._proxy, Tl, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(r, d, v) {
          if (d = d === void 0 ? this._zoom : this._limitZoom(d), r = this._limitCenter(Tt(r), d, this.options.maxBounds), v = v || {}, this._stop(), this._loaded && !v.reset && v !== !0) {
            v.animate !== void 0 && (v.zoom = h({ animate: v.animate }, v.zoom), v.pan = h({ animate: v.animate, duration: v.duration }, v.pan));
            var w = this._zoom !== d ? this._tryAnimatedZoom && this._tryAnimatedZoom(r, d, v.zoom) : this._tryAnimatedPan(r, v.pan);
            if (w)
              return clearTimeout(this._sizeTimer), this;
          }
          return this._resetView(r, d, v.pan && v.pan.noMoveStart), this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(r, d) {
          return this._loaded ? this.setView(this.getCenter(), r, { zoom: d }) : (this._zoom = r, this);
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(r, d) {
          return r = r || (Wt.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + r, d);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(r, d) {
          return r = r || (Wt.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - r, d);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(r, d, v) {
          var w = this.getZoomScale(d), O = this.getSize().divideBy(2), H = r instanceof ut ? r : this.latLngToContainerPoint(r), q = H.subtract(O).multiplyBy(1 - 1 / w), I = this.containerPointToLatLng(O.add(q));
          return this.setView(I, d, { zoom: v });
        },
        _getBoundsCenterZoom: function(r, d) {
          d = d || {}, r = r.getBounds ? r.getBounds() : Et(r);
          var v = k(d.paddingTopLeft || d.padding || [0, 0]), w = k(d.paddingBottomRight || d.padding || [0, 0]), O = this.getBoundsZoom(r, !1, v.add(w));
          if (O = typeof d.maxZoom == "number" ? Math.min(d.maxZoom, O) : O, O === 1 / 0)
            return {
              center: r.getCenter(),
              zoom: O
            };
          var H = w.subtract(v).divideBy(2), q = this.project(r.getSouthWest(), O), I = this.project(r.getNorthEast(), O), rt = this.unproject(q.add(I).divideBy(2).add(H), O);
          return {
            center: rt,
            zoom: O
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(r, d) {
          if (r = Et(r), !r.isValid())
            throw new Error("Bounds are not valid.");
          var v = this._getBoundsCenterZoom(r, d);
          return this.setView(v.center, v.zoom, d);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(r) {
          return this.fitBounds([[-90, -180], [90, 180]], r);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(r, d) {
          return this.setView(r, this._zoom, { pan: d });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(r, d) {
          if (r = k(r).round(), d = d || {}, !r.x && !r.y)
            return this.fire("moveend");
          if (d.animate !== !0 && !this.getSize().contains(r))
            return this._resetView(this.unproject(this.project(this.getCenter()).add(r)), this.getZoom()), this;
          if (this._panAnim || (this._panAnim = new yc(), this._panAnim.on({
            step: this._onPanTransitionStep,
            end: this._onPanTransitionEnd
          }, this)), d.noMoveStart || this.fire("movestart"), d.animate !== !1) {
            le(this._mapPane, "leaflet-pan-anim");
            var v = this._getMapPanePos().subtract(r).round();
            this._panAnim.run(this._mapPane, v, d.duration || 0.25, d.easeLinearity);
          } else
            this._rawPanBy(r), this.fire("move").fire("moveend");
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(r, d, v) {
          if (v = v || {}, v.animate === !1 || !Wt.any3d)
            return this.setView(r, d, v);
          this._stop();
          var w = this.project(this.getCenter()), O = this.project(r), H = this.getSize(), q = this._zoom;
          r = Tt(r), d = d === void 0 ? q : d;
          var I = Math.max(H.x, H.y), rt = I * this.getZoomScale(q, d), xt = O.distanceTo(w) || 1, Nt = 1.42, qt = Nt * Nt;
          function Zt(fn) {
            var Ea = fn ? -1 : 1, eo = fn ? rt : I, cl = rt * rt - I * I + Ea * qt * qt * xt * xt, Ho = 2 * eo * qt * xt, Or = cl / Ho, Mc = Math.sqrt(Or * Or + 1) - Or, Ar = Mc < 1e-9 ? -18 : Math.log(Mc);
            return Ar;
          }
          function oe(fn) {
            return (Math.exp(fn) - Math.exp(-fn)) / 2;
          }
          function Ge(fn) {
            return (Math.exp(fn) + Math.exp(-fn)) / 2;
          }
          function dn(fn) {
            return oe(fn) / Ge(fn);
          }
          var An = Zt(0);
          function Pi(fn) {
            return I * (Ge(An) / Ge(An + Nt * fn));
          }
          function xu(fn) {
            return I * (Ge(An) * dn(An + Nt * fn) - oe(An)) / qt;
          }
          function Pf(fn) {
            return 1 - Math.pow(1 - fn, 1.5);
          }
          var Er = Date.now(), Bs = (Zt(1) - An) / Nt, Gf = v.duration ? 1e3 * v.duration : 1e3 * Bs * 0.8;
          function Ys() {
            var fn = (Date.now() - Er) / Gf, Ea = Pf(fn) * Bs;
            fn <= 1 ? (this._flyToFrame = Rt(Ys, this), this._move(
              this.unproject(w.add(O.subtract(w).multiplyBy(xu(Ea) / xt)), q),
              this.getScaleZoom(I / Pi(Ea), q),
              { flyTo: !0 }
            )) : this._move(r, d)._moveEnd(!0);
          }
          return this._moveStart(!0, v.noMoveStart), Ys.call(this), this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(r, d) {
          var v = this._getBoundsCenterZoom(r, d);
          return this.flyTo(v.center, v.zoom, d);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(r) {
          return r = Et(r), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), r.isValid() ? (this.options.maxBounds = r, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(r) {
          var d = this.options.minZoom;
          return this.options.minZoom = r, this._loaded && d !== r && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(r) : this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(r) {
          var d = this.options.maxZoom;
          return this.options.maxZoom = r, this._loaded && d !== r && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(r) : this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(r, d) {
          this._enforcingBounds = !0;
          var v = this.getCenter(), w = this._limitCenter(v, this._zoom, Et(r));
          return v.equals(w) || this.panTo(w, d), this._enforcingBounds = !1, this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(r, d) {
          d = d || {};
          var v = k(d.paddingTopLeft || d.padding || [0, 0]), w = k(d.paddingBottomRight || d.padding || [0, 0]), O = this.project(this.getCenter()), H = this.project(r), q = this.getPixelBounds(), I = ct([q.min.add(v), q.max.subtract(w)]), rt = I.getSize();
          if (!I.contains(H)) {
            this._enforcingBounds = !0;
            var xt = H.subtract(I.getCenter()), Nt = I.extend(H).getSize().subtract(rt);
            O.x += xt.x < 0 ? -Nt.x : Nt.x, O.y += xt.y < 0 ? -Nt.y : Nt.y, this.panTo(this.unproject(O), d), this._enforcingBounds = !1;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(r) {
          if (!this._loaded)
            return this;
          r = h({
            animate: !1,
            pan: !0
          }, r === !0 ? { animate: !0 } : r);
          var d = this.getSize();
          this._sizeChanged = !0, this._lastCenter = null;
          var v = this.getSize(), w = d.divideBy(2).round(), O = v.divideBy(2).round(), H = w.subtract(O);
          return !H.x && !H.y ? this : (r.animate && r.pan ? this.panBy(H) : (r.pan && this._rawPanBy(H), this.fire("move"), r.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(_(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
            oldSize: d,
            newSize: v
          }));
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(r) {
          if (r = this._locateOptions = h({
            timeout: 1e4,
            watch: !1
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, r), !("geolocation" in navigator))
            return this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            }), this;
          var d = _(this._handleGeolocationResponse, this), v = _(this._handleGeolocationError, this);
          return r.watch ? this._locationWatchId = navigator.geolocation.watchPosition(d, v, r) : navigator.geolocation.getCurrentPosition(d, v, r), this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;
        },
        _handleGeolocationError: function(r) {
          if (this._container._leaflet_id) {
            var d = r.code, v = r.message || (d === 1 ? "permission denied" : d === 2 ? "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
              code: d,
              message: "Geolocation error: " + v + "."
            });
          }
        },
        _handleGeolocationResponse: function(r) {
          if (this._container._leaflet_id) {
            var d = r.coords.latitude, v = r.coords.longitude, w = new zt(d, v), O = w.toBounds(r.coords.accuracy * 2), H = this._locateOptions;
            if (H.setView) {
              var q = this.getBoundsZoom(O);
              this.setView(w, H.maxZoom ? Math.min(q, H.maxZoom) : q);
            }
            var I = {
              latlng: w,
              bounds: O,
              timestamp: r.timestamp
            };
            for (var rt in r.coords)
              typeof r.coords[rt] == "number" && (I[rt] = r.coords[rt]);
            this.fire("locationfound", I);
          }
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(r, d) {
          if (!d)
            return this;
          var v = this[r] = new d(this);
          return this._handlers.push(v), this.options[r] && v.enable(), this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id)
            throw new Error("Map container is being reused by another instance");
          try {
            delete this._container._leaflet_id, delete this._containerId;
          } catch {
            this._container._leaflet_id = void 0, this._containerId = void 0;
          }
          this._locationWatchId !== void 0 && this.stopLocate(), this._stop(), ln(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (kt(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload");
          var r;
          for (r in this._layers)
            this._layers[r].remove();
          for (r in this._panes)
            ln(this._panes[r]);
          return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(r, d) {
          var v = "leaflet-pane" + (r ? " leaflet-" + r.replace("Pane", "") + "-pane" : ""), w = we("div", v, d || this._mapPane);
          return r && (this._panes[r] = w), w;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var r = this.getPixelBounds(), d = this.unproject(r.getBottomLeft()), v = this.unproject(r.getTopRight());
          return new bt(d, v);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(r, d, v) {
          r = Et(r), v = k(v || [0, 0]);
          var w = this.getZoom() || 0, O = this.getMinZoom(), H = this.getMaxZoom(), q = r.getNorthWest(), I = r.getSouthEast(), rt = this.getSize().subtract(v), xt = ct(this.project(I, w), this.project(q, w)).getSize(), Nt = Wt.any3d ? this.options.zoomSnap : 1, qt = rt.x / xt.x, Zt = rt.y / xt.y, oe = d ? Math.max(qt, Zt) : Math.min(qt, Zt);
          return w = this.getScaleZoom(oe, w), Nt && (w = Math.round(w / (Nt / 100)) * (Nt / 100), w = d ? Math.ceil(w / Nt) * Nt : Math.floor(w / Nt) * Nt), Math.max(O, Math.min(H, w));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          return (!this._size || this._sizeChanged) && (this._size = new ut(
            this._container.clientWidth || 0,
            this._container.clientHeight || 0
          ), this._sizeChanged = !1), this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(r, d) {
          var v = this._getTopLeftPoint(r, d);
          return new F(v, v.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          return this._checkIfLoaded(), this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(r) {
          return this.options.crs.getProjectedBounds(r === void 0 ? this.getZoom() : r);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(r) {
          return typeof r == "string" ? this._panes[r] : r;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(r, d) {
          var v = this.options.crs;
          return d = d === void 0 ? this._zoom : d, v.scale(r) / v.scale(d);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(r, d) {
          var v = this.options.crs;
          d = d === void 0 ? this._zoom : d;
          var w = v.zoom(r * v.scale(d));
          return isNaN(w) ? 1 / 0 : w;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(r, d) {
          return d = d === void 0 ? this._zoom : d, this.options.crs.latLngToPoint(Tt(r), d);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(r, d) {
          return d = d === void 0 ? this._zoom : d, this.options.crs.pointToLatLng(k(r), d);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(r) {
          var d = k(r).add(this.getPixelOrigin());
          return this.unproject(d);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(r) {
          var d = this.project(Tt(r))._round();
          return d._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(r) {
          return this.options.crs.wrapLatLng(Tt(r));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(r) {
          return this.options.crs.wrapLatLngBounds(Et(r));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(r, d) {
          return this.options.crs.distance(Tt(r), Tt(d));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(r) {
          return k(r).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(r) {
          return k(r).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(r) {
          var d = this.containerPointToLayerPoint(k(r));
          return this.layerPointToLatLng(d);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(r) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(Tt(r)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(r) {
          return di(r, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(r) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(r));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(r) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(r));
        },
        // map initialization methods
        _initContainer: function(r) {
          var d = this._container = hi(r);
          if (d) {
            if (d._leaflet_id)
              throw new Error("Map container is already initialized.");
          } else throw new Error("Map container not found.");
          ce(d, "scroll", this._onScroll, this), this._containerId = T(d);
        },
        _initLayout: function() {
          var r = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Wt.any3d, le(r, "leaflet-container" + (Wt.touch ? " leaflet-touch" : "") + (Wt.retina ? " leaflet-retina" : "") + (Wt.ielt9 ? " leaflet-oldie" : "") + (Wt.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var d = ya(r, "position");
          d !== "absolute" && d !== "relative" && d !== "fixed" && d !== "sticky" && (r.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
        },
        _initPanes: function() {
          var r = this._panes = {};
          this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), yn(this._mapPane, new ut(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (le(r.markerPane, "leaflet-zoom-hide"), le(r.shadowPane, "leaflet-zoom-hide"));
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(r, d, v) {
          yn(this._mapPane, new ut(0, 0));
          var w = !this._loaded;
          this._loaded = !0, d = this._limitZoom(d), this.fire("viewprereset");
          var O = this._zoom !== d;
          this._moveStart(O, v)._move(r, d)._moveEnd(O), this.fire("viewreset"), w && this.fire("load");
        },
        _moveStart: function(r, d) {
          return r && this.fire("zoomstart"), d || this.fire("movestart"), this;
        },
        _move: function(r, d, v, w) {
          d === void 0 && (d = this._zoom);
          var O = this._zoom !== d;
          return this._zoom = d, this._lastCenter = r, this._pixelOrigin = this._getNewPixelOrigin(r), w ? v && v.pinch && this.fire("zoom", v) : ((O || v && v.pinch) && this.fire("zoom", v), this.fire("move", v)), this;
        },
        _moveEnd: function(r) {
          return r && this.fire("zoomend"), this.fire("moveend");
        },
        _stop: function() {
          return kt(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
        },
        _rawPanBy: function(r) {
          yn(this._mapPane, this._getMapPanePos().subtract(r));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
        },
        _checkIfLoaded: function() {
          if (!this._loaded)
            throw new Error("Set map center and zoom first.");
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(r) {
          this._targets = {}, this._targets[T(this._container)] = this;
          var d = r ? Ye : ce;
          d(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && d(window, "resize", this._onResize, this), Wt.any3d && this.options.transform3DLimit && (r ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
        },
        _onResize: function() {
          kt(this._resizeRequest), this._resizeRequest = Rt(
            function() {
              this.invalidateSize({ debounceMoveend: !0 });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0, this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var r = this._getMapPanePos();
          Math.max(Math.abs(r.x), Math.abs(r.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
        },
        _findEventTargets: function(r, d) {
          for (var v = [], w, O = d === "mouseout" || d === "mouseover", H = r.target || r.srcElement, q = !1; H; ) {
            if (w = this._targets[T(H)], w && (d === "click" || d === "preclick") && this._draggableMoved(w)) {
              q = !0;
              break;
            }
            if (w && w.listens(d, !0) && (O && !Es(H, r) || (v.push(w), O)) || H === this._container)
              break;
            H = H.parentNode;
          }
          return !v.length && !q && !O && this.listens(d, !0) && (v = [this]), v;
        },
        _isClickDisabled: function(r) {
          for (; r && r !== this._container; ) {
            if (r._leaflet_disable_click)
              return !0;
            r = r.parentNode;
          }
        },
        _handleDOMEvent: function(r) {
          var d = r.target || r.srcElement;
          if (!(!this._loaded || d._leaflet_disable_events || r.type === "click" && this._isClickDisabled(d))) {
            var v = r.type;
            v === "mousedown" && tl(d), this._fireDOMEvent(r, v);
          }
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(r, d, v) {
          if (r.type === "click") {
            var w = h({}, r);
            w.type = "preclick", this._fireDOMEvent(w, w.type, v);
          }
          var O = this._findEventTargets(r, d);
          if (v) {
            for (var H = [], q = 0; q < v.length; q++)
              v[q].listens(d, !0) && H.push(v[q]);
            O = H.concat(O);
          }
          if (O.length) {
            d === "contextmenu" && Ue(r);
            var I = O[0], rt = {
              originalEvent: r
            };
            if (r.type !== "keypress" && r.type !== "keydown" && r.type !== "keyup") {
              var xt = I.getLatLng && (!I._radius || I._radius <= 10);
              rt.containerPoint = xt ? this.latLngToContainerPoint(I.getLatLng()) : this.mouseEventToContainerPoint(r), rt.layerPoint = this.containerPointToLayerPoint(rt.containerPoint), rt.latlng = xt ? I.getLatLng() : this.layerPointToLatLng(rt.layerPoint);
            }
            for (q = 0; q < O.length; q++)
              if (O[q].fire(d, rt, !0), rt.originalEvent._stopped || O[q].options.bubblingMouseEvents === !1 && Lt(this._mouseEvents, d) !== -1)
                return;
          }
        },
        _draggableMoved: function(r) {
          return r = r.dragging && r.dragging.enabled() ? r : this, r.dragging && r.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var r = 0, d = this._handlers.length; r < d; r++)
            this._handlers[r].disable();
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(r, d) {
          return this._loaded ? r.call(d || this, { target: this }) : this.on("load", r, d), this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return Io(this._mapPane) || new ut(0, 0);
        },
        _moved: function() {
          var r = this._getMapPanePos();
          return r && !r.equals([0, 0]);
        },
        _getTopLeftPoint: function(r, d) {
          var v = r && d !== void 0 ? this._getNewPixelOrigin(r, d) : this.getPixelOrigin();
          return v.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(r, d) {
          var v = this.getSize()._divideBy(2);
          return this.project(r, d)._subtract(v)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(r, d, v) {
          var w = this._getNewPixelOrigin(v, d);
          return this.project(r, d)._subtract(w);
        },
        _latLngBoundsToNewLayerBounds: function(r, d, v) {
          var w = this._getNewPixelOrigin(v, d);
          return ct([
            this.project(r.getSouthWest(), d)._subtract(w),
            this.project(r.getNorthWest(), d)._subtract(w),
            this.project(r.getSouthEast(), d)._subtract(w),
            this.project(r.getNorthEast(), d)._subtract(w)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(r) {
          return this.latLngToLayerPoint(r).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(r, d, v) {
          if (!v)
            return r;
          var w = this.project(r, d), O = this.getSize().divideBy(2), H = new F(w.subtract(O), w.add(O)), q = this._getBoundsOffset(H, v, d);
          return Math.abs(q.x) <= 1 && Math.abs(q.y) <= 1 ? r : this.unproject(w.add(q), d);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(r, d) {
          if (!d)
            return r;
          var v = this.getPixelBounds(), w = new F(v.min.add(r), v.max.add(r));
          return r.add(this._getBoundsOffset(w, d));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(r, d, v) {
          var w = ct(
            this.project(d.getNorthEast(), v),
            this.project(d.getSouthWest(), v)
          ), O = w.min.subtract(r.min), H = w.max.subtract(r.max), q = this._rebound(O.x, -H.x), I = this._rebound(O.y, -H.y);
          return new ut(q, I);
        },
        _rebound: function(r, d) {
          return r + d > 0 ? Math.round(r - d) / 2 : Math.max(0, Math.ceil(r)) - Math.max(0, Math.floor(d));
        },
        _limitZoom: function(r) {
          var d = this.getMinZoom(), v = this.getMaxZoom(), w = Wt.any3d ? this.options.zoomSnap : 1;
          return w && (r = Math.round(r / w) * w), Math.max(d, Math.min(v, r));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          Fe(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
        },
        _tryAnimatedPan: function(r, d) {
          var v = this._getCenterOffset(r)._trunc();
          return (d && d.animate) !== !0 && !this.getSize().contains(v) ? !1 : (this.panBy(v, d), !0);
        },
        _createAnimProxy: function() {
          var r = this._proxy = we("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(r), this.on("zoomanim", function(d) {
            var v = pr, w = this._proxy.style[v];
            ia(this._proxy, this.project(d.center, d.zoom), this.getZoomScale(d.zoom, 1)), w === this._proxy.style[v] && this._animatingZoom && this._onZoomTransitionEnd();
          }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          ln(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
        },
        _animMoveEnd: function() {
          var r = this.getCenter(), d = this.getZoom();
          ia(this._proxy, this.project(r, d), this.getZoomScale(d, 1));
        },
        _catchTransitionEnd: function(r) {
          this._animatingZoom && r.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(r, d, v) {
          if (this._animatingZoom)
            return !0;
          if (v = v || {}, !this._zoomAnimated || v.animate === !1 || this._nothingToAnimate() || Math.abs(d - this._zoom) > this.options.zoomAnimationThreshold)
            return !1;
          var w = this.getZoomScale(d), O = this._getCenterOffset(r)._divideBy(1 - 1 / w);
          return v.animate !== !0 && !this.getSize().contains(O) ? !1 : (Rt(function() {
            this._moveStart(!0, v.noMoveStart || !1)._animateZoom(r, d, !0);
          }, this), !0);
        },
        _animateZoom: function(r, d, v, w) {
          this._mapPane && (v && (this._animatingZoom = !0, this._animateToCenter = r, this._animateToZoom = d, le(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
            center: r,
            zoom: d,
            noUpdate: w
          }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(_(this._onZoomTransitionEnd, this), 250));
        },
        _onZoomTransitionEnd: function() {
          this._animatingZoom && (this._mapPane && Fe(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0));
        }
      });
      function bu(r, d) {
        return new Oe(r, d);
      }
      var $n = ge.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(r) {
          Q(this, r);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(r) {
          var d = this._map;
          return d && d.removeControl(this), this.options.position = r, d && d.addControl(this), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(r) {
          this.remove(), this._map = r;
          var d = this._container = this.onAdd(r), v = this.getPosition(), w = r._controlCorners[v];
          return le(d, "leaflet-control"), v.indexOf("bottom") !== -1 ? w.insertBefore(d, w.firstChild) : w.appendChild(d), this._map.on("unload", this.remove, this), this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          return this._map ? (ln(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null, this) : this;
        },
        _refocusOnMap: function(r) {
          this._map && r && r.screenX > 0 && r.screenY > 0 && this._map.getContainer().focus();
        }
      }), Os = function(r) {
        return new $n(r);
      };
      Oe.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(r) {
          return r.addTo(this), this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(r) {
          return r.remove(), this;
        },
        _initControlPos: function() {
          var r = this._controlCorners = {}, d = "leaflet-", v = this._controlContainer = we("div", d + "control-container", this._container);
          function w(O, H) {
            var q = d + O + " " + d + H;
            r[O + H] = we("div", q, v);
          }
          w("top", "left"), w("top", "right"), w("bottom", "left"), w("bottom", "right");
        },
        _clearControlPos: function() {
          for (var r in this._controlCorners)
            ln(this._controlCorners[r]);
          ln(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
        }
      });
      var zf = $n.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: !0,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: !0,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: !1,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: !1,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(r, d, v, w) {
            return v < w ? -1 : w < v ? 1 : 0;
          }
        },
        initialize: function(r, d, v) {
          Q(this, v), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1;
          for (var w in r)
            this._addLayer(r[w], w);
          for (w in d)
            this._addLayer(d[w], w, !0);
        },
        onAdd: function(r) {
          this._initLayout(), this._update(), this._map = r, r.on("zoomend", this._checkDisabledLayers, this);
          for (var d = 0; d < this._layers.length; d++)
            this._layers[d].layer.on("add remove", this._onLayerChange, this);
          return this._container;
        },
        addTo: function(r) {
          return $n.prototype.addTo.call(this, r), this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var r = 0; r < this._layers.length; r++)
            this._layers[r].layer.off("add remove", this._onLayerChange, this);
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(r, d) {
          return this._addLayer(r, d), this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(r, d) {
          return this._addLayer(r, d, !0), this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(r) {
          r.off("add remove", this._onLayerChange, this);
          var d = this._getLayer(T(r));
          return d && this._layers.splice(this._layers.indexOf(d), 1), this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          le(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
          var r = this._map.getSize().y - (this._container.offsetTop + 50);
          return r < this._section.clientHeight ? (le(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = r + "px") : Fe(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          return Fe(this._container, "leaflet-control-layers-expanded"), this;
        },
        _initLayout: function() {
          var r = "leaflet-control-layers", d = this._container = we("div", r), v = this.options.collapsed;
          d.setAttribute("aria-haspopup", !0), Ms(d), el(d);
          var w = this._section = we("section", r + "-list");
          v && (this._map.on("click", this.collapse, this), ce(d, {
            mouseenter: this._expandSafely,
            mouseleave: this.collapse
          }, this));
          var O = this._layersLink = we("a", r + "-toggle", d);
          O.href = "#", O.title = "Layers", O.setAttribute("role", "button"), ce(O, {
            keydown: function(H) {
              H.keyCode === 13 && this._expandSafely();
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(H) {
              Ue(H), this._expandSafely();
            }
          }, this), v || this.expand(), this._baseLayersList = we("div", r + "-base", w), this._separator = we("div", r + "-separator", w), this._overlaysList = we("div", r + "-overlays", w), d.appendChild(w);
        },
        _getLayer: function(r) {
          for (var d = 0; d < this._layers.length; d++)
            if (this._layers[d] && T(this._layers[d].layer) === r)
              return this._layers[d];
        },
        _addLayer: function(r, d, v) {
          this._map && r.on("add remove", this._onLayerChange, this), this._layers.push({
            layer: r,
            name: d,
            overlay: v
          }), this.options.sortLayers && this._layers.sort(_(function(w, O) {
            return this.options.sortFunction(w.layer, O.layer, w.name, O.name);
          }, this)), this.options.autoZIndex && r.setZIndex && (this._lastZIndex++, r.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container)
            return this;
          Yn(this._baseLayersList), Yn(this._overlaysList), this._layerControlInputs = [];
          var r, d, v, w, O = 0;
          for (v = 0; v < this._layers.length; v++)
            w = this._layers[v], this._addItem(w), d = d || w.overlay, r = r || !w.overlay, O += w.overlay ? 0 : 1;
          return this.options.hideSingleBase && (r = r && O > 1, this._baseLayersList.style.display = r ? "" : "none"), this._separator.style.display = d && r ? "" : "none", this;
        },
        _onLayerChange: function(r) {
          this._handlingClick || this._update();
          var d = this._getLayer(T(r.target)), v = d.overlay ? r.type === "add" ? "overlayadd" : "overlayremove" : r.type === "add" ? "baselayerchange" : null;
          v && this._map.fire(v, d);
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(r, d) {
          var v = '<input type="radio" class="leaflet-control-layers-selector" name="' + r + '"' + (d ? ' checked="checked"' : "") + "/>", w = document.createElement("div");
          return w.innerHTML = v, w.firstChild;
        },
        _addItem: function(r) {
          var d = document.createElement("label"), v = this._map.hasLayer(r.layer), w;
          r.overlay ? (w = document.createElement("input"), w.type = "checkbox", w.className = "leaflet-control-layers-selector", w.defaultChecked = v) : w = this._createRadioElement("leaflet-base-layers_" + T(this), v), this._layerControlInputs.push(w), w.layerId = T(r.layer), ce(w, "click", this._onInputClick, this);
          var O = document.createElement("span");
          O.innerHTML = " " + r.name;
          var H = document.createElement("span");
          d.appendChild(H), H.appendChild(w), H.appendChild(O);
          var q = r.overlay ? this._overlaysList : this._baseLayersList;
          return q.appendChild(d), this._checkDisabledLayers(), d;
        },
        _onInputClick: function() {
          if (!this._preventClick) {
            var r = this._layerControlInputs, d, v, w = [], O = [];
            this._handlingClick = !0;
            for (var H = r.length - 1; H >= 0; H--)
              d = r[H], v = this._getLayer(d.layerId).layer, d.checked ? w.push(v) : d.checked || O.push(v);
            for (H = 0; H < O.length; H++)
              this._map.hasLayer(O[H]) && this._map.removeLayer(O[H]);
            for (H = 0; H < w.length; H++)
              this._map.hasLayer(w[H]) || this._map.addLayer(w[H]);
            this._handlingClick = !1, this._refocusOnMap();
          }
        },
        _checkDisabledLayers: function() {
          for (var r = this._layerControlInputs, d, v, w = this._map.getZoom(), O = r.length - 1; O >= 0; O--)
            d = r[O], v = this._getLayer(d.layerId).layer, d.disabled = v.options.minZoom !== void 0 && w < v.options.minZoom || v.options.maxZoom !== void 0 && w > v.options.maxZoom;
        },
        _expandIfNotCollapsed: function() {
          return this._map && !this.options.collapsed && this.expand(), this;
        },
        _expandSafely: function() {
          var r = this._section;
          this._preventClick = !0, ce(r, "click", Ue), this.expand();
          var d = this;
          setTimeout(function() {
            Ye(r, "click", Ue), d._preventClick = !1;
          });
        }
      }), wd = function(r, d, v) {
        return new zf(r, d, v);
      }, Lf = $n.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(r) {
          var d = "leaflet-control-zoom", v = we("div", d + " leaflet-bar"), w = this.options;
          return this._zoomInButton = this._createButton(
            w.zoomInText,
            w.zoomInTitle,
            d + "-in",
            v,
            this._zoomIn
          ), this._zoomOutButton = this._createButton(
            w.zoomOutText,
            w.zoomOutTitle,
            d + "-out",
            v,
            this._zoomOut
          ), this._updateDisabled(), r.on("zoomend zoomlevelschange", this._updateDisabled, this), v;
        },
        onRemove: function(r) {
          r.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          return this._disabled = !0, this._updateDisabled(), this;
        },
        enable: function() {
          return this._disabled = !1, this._updateDisabled(), this;
        },
        _zoomIn: function(r) {
          !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (r.shiftKey ? 3 : 1));
        },
        _zoomOut: function(r) {
          !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (r.shiftKey ? 3 : 1));
        },
        _createButton: function(r, d, v, w, O) {
          var H = we("a", v, w);
          return H.innerHTML = r, H.href = "#", H.title = d, H.setAttribute("role", "button"), H.setAttribute("aria-label", d), Ms(H), ce(H, "click", xo), ce(H, "click", O, this), ce(H, "click", this._refocusOnMap, this), H;
        },
        _updateDisabled: function() {
          var r = this._map, d = "leaflet-disabled";
          Fe(this._zoomInButton, d), Fe(this._zoomOutButton, d), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), (this._disabled || r._zoom === r.getMinZoom()) && (le(this._zoomOutButton, d), this._zoomOutButton.setAttribute("aria-disabled", "true")), (this._disabled || r._zoom === r.getMaxZoom()) && (le(this._zoomInButton, d), this._zoomInButton.setAttribute("aria-disabled", "true"));
        }
      });
      Oe.mergeOptions({
        zoomControl: !0
      }), Oe.addInitHook(function() {
        this.options.zoomControl && (this.zoomControl = new Lf(), this.addControl(this.zoomControl));
      });
      var Hf = function(r) {
        return new Lf(r);
      }, Md = $n.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: !0,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: !0
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(r) {
          var d = "leaflet-control-scale", v = we("div", d), w = this.options;
          return this._addScales(w, d + "-line", v), r.on(w.updateWhenIdle ? "moveend" : "move", this._update, this), r.whenReady(this._update, this), v;
        },
        onRemove: function(r) {
          r.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(r, d, v) {
          r.metric && (this._mScale = we("div", d, v)), r.imperial && (this._iScale = we("div", d, v));
        },
        _update: function() {
          var r = this._map, d = r.getSize().y / 2, v = r.distance(
            r.containerPointToLatLng([0, d]),
            r.containerPointToLatLng([this.options.maxWidth, d])
          );
          this._updateScales(v);
        },
        _updateScales: function(r) {
          this.options.metric && r && this._updateMetric(r), this.options.imperial && r && this._updateImperial(r);
        },
        _updateMetric: function(r) {
          var d = this._getRoundNum(r), v = d < 1e3 ? d + " m" : d / 1e3 + " km";
          this._updateScale(this._mScale, v, d / r);
        },
        _updateImperial: function(r) {
          var d = r * 3.2808399, v, w, O;
          d > 5280 ? (v = d / 5280, w = this._getRoundNum(v), this._updateScale(this._iScale, w + " mi", w / v)) : (O = this._getRoundNum(d), this._updateScale(this._iScale, O + " ft", O / d));
        },
        _updateScale: function(r, d, v) {
          r.style.width = Math.round(this.options.maxWidth * v) + "px", r.innerHTML = d;
        },
        _getRoundNum: function(r) {
          var d = Math.pow(10, (Math.floor(r) + "").length - 1), v = r / d;
          return v = v >= 10 ? 10 : v >= 5 ? 5 : v >= 3 ? 3 : v >= 2 ? 2 : 1, d * v;
        }
      }), Up = function(r) {
        return new Md(r);
      }, Bp = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>', As = $n.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Wt.inlineSvg ? Bp + " " : "") + "Leaflet</a>"
        },
        initialize: function(r) {
          Q(this, r), this._attributions = {};
        },
        onAdd: function(r) {
          r.attributionControl = this, this._container = we("div", "leaflet-control-attribution"), Ms(this._container);
          for (var d in r._layers)
            r._layers[d].getAttribution && this.addAttribution(r._layers[d].getAttribution());
          return this._update(), r.on("layeradd", this._addAttribution, this), this._container;
        },
        onRemove: function(r) {
          r.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(r) {
          r.layer.getAttribution && (this.addAttribution(r.layer.getAttribution()), r.layer.once("remove", function() {
            this.removeAttribution(r.layer.getAttribution());
          }, this));
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(r) {
          return this.options.prefix = r, this._update(), this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(r) {
          return r ? (this._attributions[r] || (this._attributions[r] = 0), this._attributions[r]++, this._update(), this) : this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(r) {
          return r ? (this._attributions[r] && (this._attributions[r]--, this._update()), this) : this;
        },
        _update: function() {
          if (this._map) {
            var r = [];
            for (var d in this._attributions)
              this._attributions[d] && r.push(d);
            var v = [];
            this.options.prefix && v.push(this.options.prefix), r.length && v.push(r.join(", ")), this._container.innerHTML = v.join(' <span aria-hidden="true">|</span> ');
          }
        }
      });
      Oe.mergeOptions({
        attributionControl: !0
      }), Oe.addInitHook(function() {
        this.options.attributionControl && new As().addTo(this);
      });
      var Ed = function(r) {
        return new As(r);
      };
      $n.Layers = zf, $n.Zoom = Lf, $n.Scale = Md, $n.Attribution = As, Os.layers = wd, Os.zoom = Hf, Os.scale = Up, Os.attribution = Ed;
      var _a = ge.extend({
        initialize: function(r) {
          this._map = r;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      _a.addTo = function(r, d) {
        return r.addHandler(d, this), this;
      };
      var Od = { Events: P }, kf = Wt.touch ? "touchstart mousedown" : "mousedown", wo = dt.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(r, d, v, w) {
          Q(this, w), this._element = r, this._dragStartTarget = d || r, this._preventOutline = v;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          this._enabled || (ce(this._dragStartTarget, kf, this._onDown, this), this._enabled = !0);
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          this._enabled && (wo._dragging === this && this.finishDrag(!0), Ye(this._dragStartTarget, kf, this._onDown, this), this._enabled = !1, this._moved = !1);
        },
        _onDown: function(r) {
          if (this._enabled && (this._moved = !1, !So(this._element, "leaflet-zoom-anim"))) {
            if (r.touches && r.touches.length !== 1) {
              wo._dragging === this && this.finishDrag();
              return;
            }
            if (!(wo._dragging || r.shiftKey || r.which !== 1 && r.button !== 1 && !r.touches) && (wo._dragging = this, this._preventOutline && tl(this._element), Fo(), To(), !this._moving)) {
              this.fire("down");
              var d = r.touches ? r.touches[0] : r, v = ws(this._element);
              this._startPoint = new ut(d.clientX, d.clientY), this._startPos = Io(this._element), this._parentScale = Ml(v);
              var w = r.type === "mousedown";
              ce(document, w ? "mousemove" : "touchmove", this._onMove, this), ce(document, w ? "mouseup" : "touchend touchcancel", this._onUp, this);
            }
          }
        },
        _onMove: function(r) {
          if (this._enabled) {
            if (r.touches && r.touches.length > 1) {
              this._moved = !0;
              return;
            }
            var d = r.touches && r.touches.length === 1 ? r.touches[0] : r, v = new ut(d.clientX, d.clientY)._subtract(this._startPoint);
            !v.x && !v.y || Math.abs(v.x) + Math.abs(v.y) < this.options.clickTolerance || (v.x /= this._parentScale.x, v.y /= this._parentScale.y, Ue(r), this._moved || (this.fire("dragstart"), this._moved = !0, le(document.body, "leaflet-dragging"), this._lastTarget = r.target || r.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), le(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(v), this._moving = !0, this._lastEvent = r, this._updatePosition());
          }
        },
        _updatePosition: function() {
          var r = { originalEvent: this._lastEvent };
          this.fire("predrag", r), yn(this._element, this._newPos), this.fire("drag", r);
        },
        _onUp: function() {
          this._enabled && this.finishDrag();
        },
        finishDrag: function(r) {
          Fe(document.body, "leaflet-dragging"), this._lastTarget && (Fe(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), Ye(document, "mousemove touchmove", this._onMove, this), Ye(document, "mouseup touchend touchcancel", this._onUp, this), Cf(), gr();
          var d = this._moved && this._moving;
          this._moving = !1, wo._dragging = !1, d && this.fire("dragend", {
            noInertia: r,
            distance: this._newPos.distanceTo(this._startPos)
          });
        }
      });
      function Nf(r, d, v) {
        var w, O = [1, 4, 2, 8], H, q, I, rt, xt, Nt, qt, Zt;
        for (H = 0, Nt = r.length; H < Nt; H++)
          r[H]._code = Al(r[H], d);
        for (I = 0; I < 4; I++) {
          for (qt = O[I], w = [], H = 0, Nt = r.length, q = Nt - 1; H < Nt; q = H++)
            rt = r[H], xt = r[q], rt._code & qt ? xt._code & qt || (Zt = br(xt, rt, qt, d, v), Zt._code = Al(Zt, d), w.push(Zt)) : (xt._code & qt && (Zt = br(xt, rt, qt, d, v), Zt._code = Al(Zt, d), w.push(Zt)), w.push(rt));
          r = w;
        }
        return r;
      }
      function Mo(r, d) {
        var v, w, O, H, q, I, rt, xt, Nt;
        if (!r || r.length === 0)
          throw new Error("latlngs not passed");
        pi(r) || (console.warn("latlngs are not flat! Only the first ring will be used"), r = r[0]);
        var qt = Tt([0, 0]), Zt = Et(r), oe = Zt.getNorthWest().distanceTo(Zt.getSouthWest()) * Zt.getNorthEast().distanceTo(Zt.getNorthWest());
        oe < 1700 && (qt = nl(r));
        var Ge = r.length, dn = [];
        for (v = 0; v < Ge; v++) {
          var An = Tt(r[v]);
          dn.push(d.project(Tt([An.lat - qt.lat, An.lng - qt.lng])));
        }
        for (I = rt = xt = 0, v = 0, w = Ge - 1; v < Ge; w = v++)
          O = dn[v], H = dn[w], q = O.y * H.x - H.y * O.x, rt += (O.x + H.x) * q, xt += (O.y + H.y) * q, I += q * 3;
        I === 0 ? Nt = dn[0] : Nt = [rt / I, xt / I];
        var Pi = d.unproject(k(Nt));
        return Tt([Pi.lat + qt.lat, Pi.lng + qt.lng]);
      }
      function nl(r) {
        for (var d = 0, v = 0, w = 0, O = 0; O < r.length; O++) {
          var H = Tt(r[O]);
          d += H.lat, v += H.lng, w++;
        }
        return Tt([d / w, v / w]);
      }
      var Wa = {
        __proto__: null,
        clipPolygon: Nf,
        polygonCenter: Mo,
        centroid: nl
      };
      function ji(r, d) {
        if (!d || !r.length)
          return r.slice();
        var v = d * d;
        return r = Ad(r, v), r = Uf(r, v), r;
      }
      function _r(r, d, v) {
        return Math.sqrt(il(r, d, v, !0));
      }
      function vc(r, d, v) {
        return il(r, d, v);
      }
      function Uf(r, d) {
        var v = r.length, w = typeof Uint8Array < "u" ? Uint8Array : Array, O = new w(v);
        O[0] = O[v - 1] = 1, mi(r, O, d, 0, v - 1);
        var H, q = [];
        for (H = 0; H < v; H++)
          O[H] && q.push(r[H]);
        return q;
      }
      function mi(r, d, v, w, O) {
        var H = 0, q, I, rt;
        for (I = w + 1; I <= O - 1; I++)
          rt = il(r[I], r[w], r[O], !0), rt > H && (q = I, H = rt);
        H > v && (d[q] = 1, mi(r, d, v, w, q), mi(r, d, v, q, O));
      }
      function Ad(r, d) {
        for (var v = [r[0]], w = 1, O = 0, H = r.length; w < H; w++)
          Dd(r[w], r[O]) > d && (v.push(r[w]), O = w);
        return O < H - 1 && v.push(r[H - 1]), v;
      }
      var Su;
      function Ol(r, d, v, w, O) {
        var H = w ? Su : Al(r, v), q = Al(d, v), I, rt, xt;
        for (Su = q; ; ) {
          if (!(H | q))
            return [r, d];
          if (H & q)
            return !1;
          I = H || q, rt = br(r, d, I, v, O), xt = Al(rt, v), I === H ? (r = rt, H = xt) : (d = rt, q = xt);
        }
      }
      function br(r, d, v, w, O) {
        var H = d.x - r.x, q = d.y - r.y, I = w.min, rt = w.max, xt, Nt;
        return v & 8 ? (xt = r.x + H * (rt.y - r.y) / q, Nt = rt.y) : v & 4 ? (xt = r.x + H * (I.y - r.y) / q, Nt = I.y) : v & 2 ? (xt = rt.x, Nt = r.y + q * (rt.x - r.x) / H) : v & 1 && (xt = I.x, Nt = r.y + q * (I.x - r.x) / H), new ut(xt, Nt, O);
      }
      function Al(r, d) {
        var v = 0;
        return r.x < d.min.x ? v |= 1 : r.x > d.max.x && (v |= 2), r.y < d.min.y ? v |= 4 : r.y > d.max.y && (v |= 8), v;
      }
      function Dd(r, d) {
        var v = d.x - r.x, w = d.y - r.y;
        return v * v + w * w;
      }
      function il(r, d, v, w) {
        var O = d.x, H = d.y, q = v.x - O, I = v.y - H, rt = q * q + I * I, xt;
        return rt > 0 && (xt = ((r.x - O) * q + (r.y - H) * I) / rt, xt > 1 ? (O = v.x, H = v.y) : xt > 0 && (O += q * xt, H += I * xt)), q = r.x - O, I = r.y - H, w ? q * q + I * I : new ut(O, H);
      }
      function pi(r) {
        return !At(r[0]) || typeof r[0][0] != "object" && typeof r[0][0] < "u";
      }
      function _c(r) {
        return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), pi(r);
      }
      function Ja(r, d) {
        var v, w, O, H, q, I, rt, xt;
        if (!r || r.length === 0)
          throw new Error("latlngs not passed");
        pi(r) || (console.warn("latlngs are not flat! Only the first ring will be used"), r = r[0]);
        var Nt = Tt([0, 0]), qt = Et(r), Zt = qt.getNorthWest().distanceTo(qt.getSouthWest()) * qt.getNorthEast().distanceTo(qt.getNorthWest());
        Zt < 1700 && (Nt = nl(r));
        var oe = r.length, Ge = [];
        for (v = 0; v < oe; v++) {
          var dn = Tt(r[v]);
          Ge.push(d.project(Tt([dn.lat - Nt.lat, dn.lng - Nt.lng])));
        }
        for (v = 0, w = 0; v < oe - 1; v++)
          w += Ge[v].distanceTo(Ge[v + 1]) / 2;
        if (w === 0)
          xt = Ge[0];
        else
          for (v = 0, H = 0; v < oe - 1; v++)
            if (q = Ge[v], I = Ge[v + 1], O = q.distanceTo(I), H += O, H > w) {
              rt = (H - w) / O, xt = [
                I.x - rt * (I.x - q.x),
                I.y - rt * (I.y - q.y)
              ];
              break;
            }
        var An = d.unproject(k(xt));
        return Tt([An.lat + Nt.lat, An.lng + Nt.lng]);
      }
      var Bf = {
        __proto__: null,
        simplify: ji,
        pointToSegmentDistance: _r,
        closestPointOnSegment: vc,
        clipSegment: Ol,
        _getEdgeIntersection: br,
        _getBitCode: Al,
        _sqClosestPointOnSegment: il,
        isFlat: pi,
        _flat: _c,
        polylineCenter: Ja
      }, Sr = {
        project: function(r) {
          return new ut(r.lng, r.lat);
        },
        unproject: function(r) {
          return new zt(r.y, r.x);
        },
        bounds: new F([-180, -90], [180, 90])
      }, Ds = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new F([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(r) {
          var d = Math.PI / 180, v = this.R, w = r.lat * d, O = this.R_MINOR / v, H = Math.sqrt(1 - O * O), q = H * Math.sin(w), I = Math.tan(Math.PI / 4 - w / 2) / Math.pow((1 - q) / (1 + q), H / 2);
          return w = -v * Math.log(Math.max(I, 1e-10)), new ut(r.lng * d * v, w);
        },
        unproject: function(r) {
          for (var d = 180 / Math.PI, v = this.R, w = this.R_MINOR / v, O = Math.sqrt(1 - w * w), H = Math.exp(-r.y / v), q = Math.PI / 2 - 2 * Math.atan(H), I = 0, rt = 0.1, xt; I < 15 && Math.abs(rt) > 1e-7; I++)
            xt = O * Math.sin(q), xt = Math.pow((1 - xt) / (1 + xt), O / 2), rt = Math.PI / 2 - 2 * Math.atan(H * xt) - q, q += rt;
          return new zt(q * d, r.x * d / v);
        }
      }, Dl = {
        __proto__: null,
        LonLat: Sr,
        Mercator: Ds,
        SphericalMercator: ci
      }, Rl = h({}, $t, {
        code: "EPSG:3395",
        projection: Ds,
        transformation: function() {
          var r = 0.5 / (Math.PI * Ds.R);
          return Za(r, 0.5, -r, 0.5);
        }()
      }), bc = h({}, $t, {
        code: "EPSG:4326",
        projection: Sr,
        transformation: Za(1 / 180, 1, -1 / 180, 0.5)
      }), Rs = h({}, We, {
        projection: Sr,
        transformation: Za(1, 0, -1, 0),
        scale: function(r) {
          return Math.pow(2, r);
        },
        zoom: function(r) {
          return Math.log(r) / Math.LN2;
        },
        distance: function(r, d) {
          var v = d.lng - r.lng, w = d.lat - r.lat;
          return Math.sqrt(v * v + w * w);
        },
        infinite: !0
      });
      We.Earth = $t, We.EPSG3395 = Rl, We.EPSG3857 = ma, We.EPSG900913 = ur, We.EPSG4326 = bc, We.Simple = Rs;
      var ba = dt.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: !0
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(r) {
          return r.addLayer(this), this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(r) {
          return r && r.removeLayer(this), this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(r) {
          return this._map.getPane(r ? this.options[r] || r : this.options.pane);
        },
        addInteractiveTarget: function(r) {
          return this._map._targets[T(r)] = this, this;
        },
        removeInteractiveTarget: function(r) {
          return delete this._map._targets[T(r)], this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(r) {
          var d = r.target;
          if (d.hasLayer(this)) {
            if (this._map = d, this._zoomAnimated = d._zoomAnimated, this.getEvents) {
              var v = this.getEvents();
              d.on(v, this), this.once("remove", function() {
                d.off(v, this);
              }, this);
            }
            this.onAdd(d), this.fire("add"), d.fire("layeradd", { layer: this });
          }
        }
      });
      Oe.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(r) {
          if (!r._layerAdd)
            throw new Error("The provided object is not a Layer.");
          var d = T(r);
          return this._layers[d] ? this : (this._layers[d] = r, r._mapToAdd = this, r.beforeAdd && r.beforeAdd(this), this.whenReady(r._layerAdd, r), this);
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(r) {
          var d = T(r);
          return this._layers[d] ? (this._loaded && r.onRemove(this), delete this._layers[d], this._loaded && (this.fire("layerremove", { layer: r }), r.fire("remove")), r._map = r._mapToAdd = null, this) : this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(r) {
          return T(r) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(r, d) {
          for (var v in this._layers)
            r.call(d, this._layers[v]);
          return this;
        },
        _addLayers: function(r) {
          r = r ? At(r) ? r : [r] : [];
          for (var d = 0, v = r.length; d < v; d++)
            this.addLayer(r[d]);
        },
        _addZoomLimit: function(r) {
          (!isNaN(r.options.maxZoom) || !isNaN(r.options.minZoom)) && (this._zoomBoundLayers[T(r)] = r, this._updateZoomLevels());
        },
        _removeZoomLimit: function(r) {
          var d = T(r);
          this._zoomBoundLayers[d] && (delete this._zoomBoundLayers[d], this._updateZoomLevels());
        },
        _updateZoomLevels: function() {
          var r = 1 / 0, d = -1 / 0, v = this._getZoomSpan();
          for (var w in this._zoomBoundLayers) {
            var O = this._zoomBoundLayers[w].options;
            r = O.minZoom === void 0 ? r : Math.min(r, O.minZoom), d = O.maxZoom === void 0 ? d : Math.max(d, O.maxZoom);
          }
          this._layersMaxZoom = d === -1 / 0 ? void 0 : d, this._layersMinZoom = r === 1 / 0 ? void 0 : r, v !== this._getZoomSpan() && this.fire("zoomlevelschange"), this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
        }
      });
      var al = ba.extend({
        initialize: function(r, d) {
          Q(this, d), this._layers = {};
          var v, w;
          if (r)
            for (v = 0, w = r.length; v < w; v++)
              this.addLayer(r[v]);
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(r) {
          var d = this.getLayerId(r);
          return this._layers[d] = r, this._map && this._map.addLayer(r), this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(r) {
          var d = r in this._layers ? r : this.getLayerId(r);
          return this._map && this._layers[d] && this._map.removeLayer(this._layers[d]), delete this._layers[d], this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(r) {
          var d = typeof r == "number" ? r : this.getLayerId(r);
          return d in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, ): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(r) {
          var d = Array.prototype.slice.call(arguments, 1), v, w;
          for (v in this._layers)
            w = this._layers[v], w[r] && w[r].apply(w, d);
          return this;
        },
        onAdd: function(r) {
          this.eachLayer(r.addLayer, r);
        },
        onRemove: function(r) {
          this.eachLayer(r.removeLayer, r);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(r, d) {
          for (var v in this._layers)
            r.call(d, this._layers[v]);
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(r) {
          return this._layers[r];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var r = [];
          return this.eachLayer(r.push, r), r;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(r) {
          return this.invoke("setZIndex", r);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(r) {
          return T(r);
        }
      }), Sc = function(r, d) {
        return new al(r, d);
      }, jn = al.extend({
        addLayer: function(r) {
          return this.hasLayer(r) ? this : (r.addEventParent(this), al.prototype.addLayer.call(this, r), this.fire("layeradd", { layer: r }));
        },
        removeLayer: function(r) {
          return this.hasLayer(r) ? (r in this._layers && (r = this._layers[r]), r.removeEventParent(this), al.prototype.removeLayer.call(this, r), this.fire("layerremove", { layer: r })) : this;
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(r) {
          return this.invoke("setStyle", r);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var r = new bt();
          for (var d in this._layers) {
            var v = this._layers[d];
            r.extend(v.getBounds ? v.getBounds() : v.getLatLng());
          }
          return r;
        }
      }), Ia = function(r, d) {
        return new jn(r, d);
      }, Cl = ge.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1
        },
        initialize: function(r) {
          Q(this, r);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(r) {
          return this._createIcon("icon", r);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(r) {
          return this._createIcon("shadow", r);
        },
        _createIcon: function(r, d) {
          var v = this._getIconUrl(r);
          if (!v) {
            if (r === "icon")
              throw new Error("iconUrl not set in Icon options (see the docs).");
            return null;
          }
          var w = this._createImg(v, d && d.tagName === "IMG" ? d : null);
          return this._setIconStyles(w, r), (this.options.crossOrigin || this.options.crossOrigin === "") && (w.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), w;
        },
        _setIconStyles: function(r, d) {
          var v = this.options, w = v[d + "Size"];
          typeof w == "number" && (w = [w, w]);
          var O = k(w), H = k(d === "shadow" && v.shadowAnchor || v.iconAnchor || O && O.divideBy(2, !0));
          r.className = "leaflet-marker-" + d + " " + (v.className || ""), H && (r.style.marginLeft = -H.x + "px", r.style.marginTop = -H.y + "px"), O && (r.style.width = O.x + "px", r.style.height = O.y + "px");
        },
        _createImg: function(r, d) {
          return d = d || document.createElement("img"), d.src = r, d;
        },
        _getIconUrl: function(r) {
          return Wt.retina && this.options[r + "RetinaUrl"] || this.options[r + "Url"];
        }
      });
      function Eo(r) {
        return new Cl(r);
      }
      var Cs = Cl.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(r) {
          return typeof Cs.imagePath != "string" && (Cs.imagePath = this._detectIconPath()), (this.options.imagePath || Cs.imagePath) + Cl.prototype._getIconUrl.call(this, r);
        },
        _stripUrl: function(r) {
          var d = function(v, w, O) {
            var H = w.exec(v);
            return H && H[O];
          };
          return r = d(r, /^url\((['"])?(.+)\1\)$/, 2), r && d(r, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var r = we("div", "leaflet-default-icon-path", document.body), d = ya(r, "background-image") || ya(r, "backgroundImage");
          if (document.body.removeChild(r), d = this._stripUrl(d), d)
            return d;
          var v = document.querySelector('link[href$="leaflet.css"]');
          return v ? v.href.substring(0, v.href.length - 11 - 1) : "";
        }
      }), Tc = _a.extend({
        initialize: function(r) {
          this._marker = r;
        },
        addHooks: function() {
          var r = this._marker._icon;
          this._draggable || (this._draggable = new wo(r, r, !0)), this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable(), le(r, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable(), this._marker._icon && Fe(this._marker._icon, "leaflet-marker-draggable");
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(r) {
          var d = this._marker, v = d._map, w = this._marker.options.autoPanSpeed, O = this._marker.options.autoPanPadding, H = Io(d._icon), q = v.getPixelBounds(), I = v.getPixelOrigin(), rt = ct(
            q.min._subtract(I).add(O),
            q.max._subtract(I).subtract(O)
          );
          if (!rt.contains(H)) {
            var xt = k(
              (Math.max(rt.max.x, H.x) - rt.max.x) / (q.max.x - rt.max.x) - (Math.min(rt.min.x, H.x) - rt.min.x) / (q.min.x - rt.min.x),
              (Math.max(rt.max.y, H.y) - rt.max.y) / (q.max.y - rt.max.y) - (Math.min(rt.min.y, H.y) - rt.min.y) / (q.min.y - rt.min.y)
            ).multiplyBy(w);
            v.panBy(xt, { animate: !1 }), this._draggable._newPos._add(xt), this._draggable._startPos._add(xt), yn(d._icon, this._draggable._newPos), this._onDrag(r), this._panRequest = Rt(this._adjustPan.bind(this, r));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(r) {
          this._marker.options.autoPan && (kt(this._panRequest), this._panRequest = Rt(this._adjustPan.bind(this, r)));
        },
        _onDrag: function(r) {
          var d = this._marker, v = d._shadow, w = Io(d._icon), O = d._map.layerPointToLatLng(w);
          v && yn(v, w), d._latlng = O, r.latlng = O, r.oldLatLng = this._oldLatLng, d.fire("move", r).fire("drag", r);
        },
        _onDragEnd: function(r) {
          kt(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", r);
        }
      }), Oo = ba.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new Cs(),
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: !0,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: !1,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !1,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: !0,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: !1,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: !1,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(r, d) {
          Q(this, d), this._latlng = Tt(r);
        },
        onAdd: function(r) {
          this._zoomAnimated = this._zoomAnimated && r.options.markerZoomAnimation, this._zoomAnimated && r.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
        },
        onRemove: function(r) {
          this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && r.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(r) {
          var d = this._latlng;
          return this._latlng = Tt(r), this.update(), this.fire("move", { oldLatLng: d, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(r) {
          return this.options.zIndexOffset = r, this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(r) {
          return this.options.icon = r, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var r = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(r);
          }
          return this;
        },
        _initIcon: function() {
          var r = this.options, d = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), v = r.icon.createIcon(this._icon), w = !1;
          v !== this._icon && (this._icon && this._removeIcon(), w = !0, r.title && (v.title = r.title), v.tagName === "IMG" && (v.alt = r.alt || "")), le(v, d), r.keyboard && (v.tabIndex = "0", v.setAttribute("role", "button")), this._icon = v, r.riseOnHover && this.on({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && ce(v, "focus", this._panOnFocus, this);
          var O = r.icon.createShadow(this._shadow), H = !1;
          O !== this._shadow && (this._removeShadow(), H = !0), O && (le(O, d), O.alt = ""), this._shadow = O, r.opacity < 1 && this._updateOpacity(), w && this.getPane().appendChild(this._icon), this._initInteraction(), O && H && this.getPane(r.shadowPane).appendChild(this._shadow);
        },
        _removeIcon: function() {
          this.options.riseOnHover && this.off({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && Ye(this._icon, "focus", this._panOnFocus, this), ln(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
        },
        _removeShadow: function() {
          this._shadow && ln(this._shadow), this._shadow = null;
        },
        _setPos: function(r) {
          this._icon && yn(this._icon, r), this._shadow && yn(this._shadow, r), this._zIndex = r.y + this.options.zIndexOffset, this._resetZIndex();
        },
        _updateZIndex: function(r) {
          this._icon && (this._icon.style.zIndex = this._zIndex + r);
        },
        _animateZoom: function(r) {
          var d = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center).round();
          this._setPos(d);
        },
        _initInteraction: function() {
          if (this.options.interactive && (le(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), Tc)) {
            var r = this.options.draggable;
            this.dragging && (r = this.dragging.enabled(), this.dragging.disable()), this.dragging = new Tc(this), r && this.dragging.enable();
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(r) {
          return this.options.opacity = r, this._map && this._updateOpacity(), this;
        },
        _updateOpacity: function() {
          var r = this.options.opacity;
          this._icon && Oi(this._icon, r), this._shadow && Oi(this._shadow, r);
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var r = this._map;
          if (r) {
            var d = this.options.icon.options, v = d.iconSize ? k(d.iconSize) : k(0, 0), w = d.iconAnchor ? k(d.iconAnchor) : k(0, 0);
            r.panInside(this._latlng, {
              paddingTopLeft: w,
              paddingBottomRight: v.subtract(w)
            });
          }
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function zs(r, d) {
        return new Oo(r, d);
      }
      var Ao = ba.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: !0,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: !1,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !0
        },
        beforeAdd: function(r) {
          this._renderer = r.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          return this._map && this._renderer._updatePath(this), this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(r) {
          return Q(this, r), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && r && Object.prototype.hasOwnProperty.call(r, "weight") && this._updateBounds()), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          return this._renderer && this._renderer._bringToFront(this), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          return this._renderer && this._renderer._bringToBack(this), this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project(), this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      }), ol = Ao.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: !0,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(r, d) {
          Q(this, d), this._latlng = Tt(r), this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(r) {
          var d = this._latlng;
          return this._latlng = Tt(r), this.redraw(), this.fire("move", { oldLatLng: d, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(r) {
          return this.options.radius = this._radius = r, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(r) {
          var d = r && r.radius || this._radius;
          return Ao.prototype.setStyle.call(this, r), this.setRadius(d), this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
        },
        _updateBounds: function() {
          var r = this._radius, d = this._radiusY || r, v = this._clickTolerance(), w = [r + v, d + v];
          this._pxBounds = new F(this._point.subtract(w), this._point.add(w));
        },
        _update: function() {
          this._map && this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(r) {
          return r.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function Yf(r, d) {
        return new ol(r, d);
      }
      var Tr = ol.extend({
        initialize: function(r, d, v) {
          if (typeof d == "number" && (d = h({}, v, { radius: d })), Q(this, d), this._latlng = Tt(r), isNaN(this.options.radius))
            throw new Error("Circle radius cannot be NaN");
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(r) {
          return this._mRadius = r, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var r = [this._radius, this._radiusY || this._radius];
          return new bt(
            this._map.layerPointToLatLng(this._point.subtract(r)),
            this._map.layerPointToLatLng(this._point.add(r))
          );
        },
        setStyle: Ao.prototype.setStyle,
        _project: function() {
          var r = this._latlng.lng, d = this._latlng.lat, v = this._map, w = v.options.crs;
          if (w.distance === $t.distance) {
            var O = Math.PI / 180, H = this._mRadius / $t.R / O, q = v.project([d + H, r]), I = v.project([d - H, r]), rt = q.add(I).divideBy(2), xt = v.unproject(rt).lat, Nt = Math.acos((Math.cos(H * O) - Math.sin(d * O) * Math.sin(xt * O)) / (Math.cos(d * O) * Math.cos(xt * O))) / O;
            (isNaN(Nt) || Nt === 0) && (Nt = H / Math.cos(Math.PI / 180 * d)), this._point = rt.subtract(v.getPixelOrigin()), this._radius = isNaN(Nt) ? 0 : rt.x - v.project([xt, r - Nt]).x, this._radiusY = rt.y - q.y;
          } else {
            var qt = w.unproject(w.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = v.latLngToLayerPoint(this._latlng), this._radius = this._point.x - v.latLngToLayerPoint(qt).x;
          }
          this._updateBounds();
        }
      });
      function zl(r, d, v) {
        return new Tr(r, d, v);
      }
      var Fn = Ao.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: !1
        },
        initialize: function(r, d) {
          Q(this, d), this._setLatLngs(r);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(r) {
          return this._setLatLngs(r), this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(r) {
          for (var d = 1 / 0, v = null, w = il, O, H, q = 0, I = this._parts.length; q < I; q++)
            for (var rt = this._parts[q], xt = 1, Nt = rt.length; xt < Nt; xt++) {
              O = rt[xt - 1], H = rt[xt];
              var qt = w(r, O, H, !0);
              qt < d && (d = qt, v = w(r, O, H));
            }
          return v && (v.distance = Math.sqrt(d)), v;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          return Ja(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(r, d) {
          return d = d || this._defaultShape(), r = Tt(r), d.push(r), this._bounds.extend(r), this.redraw();
        },
        _setLatLngs: function(r) {
          this._bounds = new bt(), this._latlngs = this._convertLatLngs(r);
        },
        _defaultShape: function() {
          return pi(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(r) {
          for (var d = [], v = pi(r), w = 0, O = r.length; w < O; w++)
            v ? (d[w] = Tt(r[w]), this._bounds.extend(d[w])) : d[w] = this._convertLatLngs(r[w]);
          return d;
        },
        _project: function() {
          var r = new F();
          this._rings = [], this._projectLatlngs(this._latlngs, this._rings, r), this._bounds.isValid() && r.isValid() && (this._rawPxBounds = r, this._updateBounds());
        },
        _updateBounds: function() {
          var r = this._clickTolerance(), d = new ut(r, r);
          this._rawPxBounds && (this._pxBounds = new F([
            this._rawPxBounds.min.subtract(d),
            this._rawPxBounds.max.add(d)
          ]));
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(r, d, v) {
          var w = r[0] instanceof zt, O = r.length, H, q;
          if (w) {
            for (q = [], H = 0; H < O; H++)
              q[H] = this._map.latLngToLayerPoint(r[H]), v.extend(q[H]);
            d.push(q);
          } else
            for (H = 0; H < O; H++)
              this._projectLatlngs(r[H], d, v);
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var r = this._renderer._bounds;
          if (this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(r))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var d = this._parts, v, w, O, H, q, I, rt;
            for (v = 0, O = 0, H = this._rings.length; v < H; v++)
              for (rt = this._rings[v], w = 0, q = rt.length; w < q - 1; w++)
                I = Ol(rt[w], rt[w + 1], r, w, !0), I && (d[O] = d[O] || [], d[O].push(I[0]), (I[1] !== rt[w + 1] || w === q - 2) && (d[O].push(I[1]), O++));
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          for (var r = this._parts, d = this.options.smoothFactor, v = 0, w = r.length; v < w; v++)
            r[v] = ji(r[v], d);
        },
        _update: function() {
          this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(r, d) {
          var v, w, O, H, q, I, rt = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(r))
            return !1;
          for (v = 0, H = this._parts.length; v < H; v++)
            for (I = this._parts[v], w = 0, q = I.length, O = q - 1; w < q; O = w++)
              if (!(!d && w === 0) && _r(r, I[O], I[w]) <= rt)
                return !0;
          return !1;
        }
      });
      function jf(r, d) {
        return new Fn(r, d);
      }
      Fn._flat = _c;
      var Ll = Fn.extend({
        options: {
          fill: !0
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          return Mo(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(r) {
          var d = Fn.prototype._convertLatLngs.call(this, r), v = d.length;
          return v >= 2 && d[0] instanceof zt && d[0].equals(d[v - 1]) && d.pop(), d;
        },
        _setLatLngs: function(r) {
          Fn.prototype._setLatLngs.call(this, r), pi(this._latlngs) && (this._latlngs = [this._latlngs]);
        },
        _defaultShape: function() {
          return pi(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var r = this._renderer._bounds, d = this.options.weight, v = new ut(d, d);
          if (r = new F(r.min.subtract(v), r.max.add(v)), this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(r))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var w = 0, O = this._rings.length, H; w < O; w++)
              H = Nf(this._rings[w], r, !0), H.length && this._parts.push(H);
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, !0);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(r) {
          var d = !1, v, w, O, H, q, I, rt, xt;
          if (!this._pxBounds || !this._pxBounds.contains(r))
            return !1;
          for (H = 0, rt = this._parts.length; H < rt; H++)
            for (v = this._parts[H], q = 0, xt = v.length, I = xt - 1; q < xt; I = q++)
              w = v[q], O = v[I], w.y > r.y != O.y > r.y && r.x < (O.x - w.x) * (r.y - w.y) / (O.y - w.y) + w.x && (d = !d);
          return d || Fn.prototype._containsPoint.call(this, r, !0);
        }
      });
      function ti(r, d) {
        return new Ll(r, d);
      }
      var gi = jn.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(r, d) {
          Q(this, d), this._layers = {}, r && this.addData(r);
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(r) {
          var d = At(r) ? r : r.features, v, w, O;
          if (d) {
            for (v = 0, w = d.length; v < w; v++)
              O = d[v], (O.geometries || O.geometry || O.features || O.coordinates) && this.addData(O);
            return this;
          }
          var H = this.options;
          if (H.filter && !H.filter(r))
            return this;
          var q = $a(r, H);
          return q ? (q.feature = qi(r), q.defaultOptions = q.options, this.resetStyle(q), H.onEachFeature && H.onEachFeature(r, q), this.addLayer(q)) : this;
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(r) {
          return r === void 0 ? this.eachLayer(this.resetStyle, this) : (r.options = h({}, r.defaultOptions), this._setLayerStyle(r, this.options.style), this);
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(r) {
          return this.eachLayer(function(d) {
            this._setLayerStyle(d, r);
          }, this);
        },
        _setLayerStyle: function(r, d) {
          r.setStyle && (typeof d == "function" && (d = d(r.feature)), r.setStyle(d));
        }
      });
      function $a(r, d) {
        var v = r.type === "Feature" ? r.geometry : r, w = v ? v.coordinates : null, O = [], H = d && d.pointToLayer, q = d && d.coordsToLatLng || Ls, I, rt, xt, Nt;
        if (!w && !v)
          return null;
        switch (v.type) {
          case "Point":
            return I = q(w), tn(H, r, I, d);
          case "MultiPoint":
            for (xt = 0, Nt = w.length; xt < Nt; xt++)
              I = q(w[xt]), O.push(tn(H, r, I, d));
            return new jn(O);
          case "LineString":
          case "MultiLineString":
            return rt = xr(w, v.type === "LineString" ? 0 : 1, q), new Fn(rt, d);
          case "Polygon":
          case "MultiPolygon":
            return rt = xr(w, v.type === "Polygon" ? 1 : 2, q), new Ll(rt, d);
          case "GeometryCollection":
            for (xt = 0, Nt = v.geometries.length; xt < Nt; xt++) {
              var qt = $a({
                geometry: v.geometries[xt],
                type: "Feature",
                properties: r.properties
              }, d);
              qt && O.push(qt);
            }
            return new jn(O);
          case "FeatureCollection":
            for (xt = 0, Nt = v.features.length; xt < Nt; xt++) {
              var Zt = $a(v.features[xt], d);
              Zt && O.push(Zt);
            }
            return new jn(O);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function tn(r, d, v, w) {
        return r ? r(d, v) : new Oo(v, w && w.markersInheritOptions && w);
      }
      function Ls(r) {
        return new zt(r[1], r[0], r[2]);
      }
      function xr(r, d, v) {
        for (var w = [], O = 0, H = r.length, q; O < H; O++)
          q = d ? xr(r[O], d - 1, v) : (v || Ls)(r[O]), w.push(q);
        return w;
      }
      function Hs(r, d) {
        return r = Tt(r), r.alt !== void 0 ? [z(r.lng, d), z(r.lat, d), z(r.alt, d)] : [z(r.lng, d), z(r.lat, d)];
      }
      function Do(r, d, v, w) {
        for (var O = [], H = 0, q = r.length; H < q; H++)
          O.push(d ? Do(r[H], pi(r[H]) ? 0 : d - 1, v, w) : Hs(r[H], w));
        return !d && v && O.length > 0 && O.push(O[0].slice()), O;
      }
      function Di(r, d) {
        return r.feature ? h({}, r.feature, { geometry: d }) : qi(d);
      }
      function qi(r) {
        return r.type === "Feature" || r.type === "FeatureCollection" ? r : {
          type: "Feature",
          properties: {},
          geometry: r
        };
      }
      var Ro = {
        toGeoJSON: function(r) {
          return Di(this, {
            type: "Point",
            coordinates: Hs(this.getLatLng(), r)
          });
        }
      };
      Oo.include(Ro), Tr.include(Ro), ol.include(Ro), Fn.include({
        toGeoJSON: function(r) {
          var d = !pi(this._latlngs), v = Do(this._latlngs, d ? 1 : 0, !1, r);
          return Di(this, {
            type: (d ? "Multi" : "") + "LineString",
            coordinates: v
          });
        }
      }), Ll.include({
        toGeoJSON: function(r) {
          var d = !pi(this._latlngs), v = d && !pi(this._latlngs[0]), w = Do(this._latlngs, v ? 2 : d ? 1 : 0, !0, r);
          return d || (w = [w]), Di(this, {
            type: (v ? "Multi" : "") + "Polygon",
            coordinates: w
          });
        }
      }), al.include({
        toMultiPoint: function(r) {
          var d = [];
          return this.eachLayer(function(v) {
            d.push(v.toGeoJSON(r).geometry.coordinates);
          }), Di(this, {
            type: "MultiPoint",
            coordinates: d
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(r) {
          var d = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (d === "MultiPoint")
            return this.toMultiPoint(r);
          var v = d === "GeometryCollection", w = [];
          return this.eachLayer(function(O) {
            if (O.toGeoJSON) {
              var H = O.toGeoJSON(r);
              if (v)
                w.push(H.geometry);
              else {
                var q = qi(H);
                q.type === "FeatureCollection" ? w.push.apply(w, q.features) : w.push(q);
              }
            }
          }), v ? Di(this, {
            geometries: w,
            type: "GeometryCollection"
          }) : {
            type: "FeatureCollection",
            features: w
          };
        }
      });
      function Hl(r, d) {
        return new gi(r, d);
      }
      var xc = Hl, Sa = ba.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(r, d, v) {
          this._url = r, this._bounds = Et(d), Q(this, v);
        },
        onAdd: function() {
          this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (le(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
        },
        onRemove: function() {
          ln(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(r) {
          return this.options.opacity = r, this._image && this._updateOpacity(), this;
        },
        setStyle: function(r) {
          return r.opacity && this.setOpacity(r.opacity), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          return this._map && bo(this._image), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          return this._map && xl(this._image), this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(r) {
          return this._url = r, this._image && (this._image.src = r), this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(r) {
          return this._bounds = Et(r), this._map && this._reset(), this;
        },
        getEvents: function() {
          var r = {
            zoom: this._reset,
            viewreset: this._reset
          };
          return this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(r) {
          return this.options.zIndex = r, this._updateZIndex(), this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var r = this._url.tagName === "IMG", d = this._image = r ? this._url : we("img");
          if (le(d, "leaflet-image-layer"), this._zoomAnimated && le(d, "leaflet-zoom-animated"), this.options.className && le(d, this.options.className), d.onselectstart = C, d.onmousemove = C, d.onload = _(this.fire, this, "load"), d.onerror = _(this._overlayOnError, this, "error"), (this.options.crossOrigin || this.options.crossOrigin === "") && (d.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), r) {
            this._url = d.src;
            return;
          }
          d.src = this._url, d.alt = this.options.alt;
        },
        _animateZoom: function(r) {
          var d = this._map.getZoomScale(r.zoom), v = this._map._latLngBoundsToNewLayerBounds(this._bounds, r.zoom, r.center).min;
          ia(this._image, v, d);
        },
        _reset: function() {
          var r = this._image, d = new F(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), v = d.getSize();
          yn(r, d.min), r.style.width = v.x + "px", r.style.height = v.y + "px";
        },
        _updateOpacity: function() {
          Oi(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex);
        },
        _overlayOnError: function() {
          this.fire("error");
          var r = this.options.errorOverlayUrl;
          r && this._url !== r && (this._url = r, this._image.src = r);
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      }), ks = function(r, d, v) {
        return new Sa(r, d, v);
      }, aa = Sa.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: !0,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: !0,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: !0,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: !1,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: !0
        },
        _initImage: function() {
          var r = this._url.tagName === "VIDEO", d = this._image = r ? this._url : we("video");
          if (le(d, "leaflet-image-layer"), this._zoomAnimated && le(d, "leaflet-zoom-animated"), this.options.className && le(d, this.options.className), d.onselectstart = C, d.onmousemove = C, d.onloadeddata = _(this.fire, this, "load"), r) {
            for (var v = d.getElementsByTagName("source"), w = [], O = 0; O < v.length; O++)
              w.push(v[O].src);
            this._url = v.length > 0 ? w : [d.src];
            return;
          }
          At(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(d.style, "objectFit") && (d.style.objectFit = "fill"), d.autoplay = !!this.options.autoplay, d.loop = !!this.options.loop, d.muted = !!this.options.muted, d.playsInline = !!this.options.playsInline;
          for (var H = 0; H < this._url.length; H++) {
            var q = we("source");
            q.src = this._url[H], d.appendChild(q);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function Fa(r, d, v) {
        return new aa(r, d, v);
      }
      var to = Sa.extend({
        _initImage: function() {
          var r = this._image = this._url;
          le(r, "leaflet-image-layer"), this._zoomAnimated && le(r, "leaflet-zoom-animated"), this.options.className && le(r, this.options.className), r.onselectstart = C, r.onmousemove = C;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function Rd(r, d, v) {
        return new to(r, d, v);
      }
      var Ta = ba.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: !1,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(r, d) {
          r && (r instanceof zt || At(r)) ? (this._latlng = Tt(r), Q(this, d)) : (Q(this, r), this._source = d), this.options.content && (this._content = this.options.content);
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(r) {
          return r = arguments.length ? r : this._source._map, r.hasLayer(this) || r.addLayer(this), this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          return this._map && this._map.removeLayer(this), this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(r) {
          return this._map ? this.close() : (arguments.length ? this._source = r : r = this._source, this._prepareOpen(), this.openOn(r._map)), this;
        },
        onAdd: function(r) {
          this._zoomAnimated = r._zoomAnimated, this._container || this._initLayout(), r._fadeAnimated && Oi(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), r._fadeAnimated && Oi(this._container, 1), this.bringToFront(), this.options.interactive && (le(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
        },
        onRemove: function(r) {
          r._fadeAnimated ? (Oi(this._container, 0), this._removeTimeout = setTimeout(_(ln, void 0, this._container), 200)) : ln(this._container), this.options.interactive && (Fe(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(r) {
          return this._latlng = Tt(r), this._map && (this._updatePosition(), this._adjustPan()), this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(r) {
          return this._content = r, this.update(), this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
        },
        getEvents: function() {
          var r = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          return this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          return this._map && bo(this._container), this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          return this._map && xl(this._container), this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(r) {
          var d = this._source;
          if (!d._map)
            return !1;
          if (d instanceof jn) {
            d = null;
            var v = this._source._layers;
            for (var w in v)
              if (v[w]._map) {
                d = v[w];
                break;
              }
            if (!d)
              return !1;
            this._source = d;
          }
          if (!r)
            if (d.getCenter)
              r = d.getCenter();
            else if (d.getLatLng)
              r = d.getLatLng();
            else if (d.getBounds)
              r = d.getBounds().getCenter();
            else
              throw new Error("Unable to get source layer LatLng.");
          return this.setLatLng(r), this._map && this.update(), !0;
        },
        _updateContent: function() {
          if (this._content) {
            var r = this._contentNode, d = typeof this._content == "function" ? this._content(this._source || this) : this._content;
            if (typeof d == "string")
              r.innerHTML = d;
            else {
              for (; r.hasChildNodes(); )
                r.removeChild(r.firstChild);
              r.appendChild(d);
            }
            this.fire("contentupdate");
          }
        },
        _updatePosition: function() {
          if (this._map) {
            var r = this._map.latLngToLayerPoint(this._latlng), d = k(this.options.offset), v = this._getAnchor();
            this._zoomAnimated ? yn(this._container, r.add(v)) : d = d.add(r).add(v);
            var w = this._containerBottom = -d.y, O = this._containerLeft = -Math.round(this._containerWidth / 2) + d.x;
            this._container.style.bottom = w + "px", this._container.style.left = O + "px";
          }
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      Oe.include({
        _initOverlay: function(r, d, v, w) {
          var O = d;
          return O instanceof r || (O = new r(w).setContent(d)), v && O.setLatLng(v), O;
        }
      }), ba.include({
        _initOverlay: function(r, d, v, w) {
          var O = v;
          return O instanceof r ? (Q(O, w), O._source = this) : (O = d && !w ? d : new r(w, this), O.setContent(v)), O;
        }
      });
      var Tu = Ta.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: !0,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: !1,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: !0,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: !0,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: !0,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(r) {
          return r = arguments.length ? r : this._source._map, !r.hasLayer(this) && r._popup && r._popup.options.autoClose && r.removeLayer(r._popup), r._popup = this, Ta.prototype.openOn.call(this, r);
        },
        onAdd: function(r) {
          Ta.prototype.onAdd.call(this, r), r.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof Ao || this._source.on("preclick", va));
        },
        onRemove: function(r) {
          Ta.prototype.onRemove.call(this, r), r.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof Ao || this._source.off("preclick", va));
        },
        getEvents: function() {
          var r = Ta.prototype.getEvents.call(this);
          return (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (r.preclick = this.close), this.options.keepInView && (r.moveend = this._adjustPan), r;
        },
        _initLayout: function() {
          var r = "leaflet-popup", d = this._container = we(
            "div",
            r + " " + (this.options.className || "") + " leaflet-zoom-animated"
          ), v = this._wrapper = we("div", r + "-content-wrapper", d);
          if (this._contentNode = we("div", r + "-content", v), Ms(d), el(this._contentNode), ce(d, "contextmenu", va), this._tipContainer = we("div", r + "-tip-container", d), this._tip = we("div", r + "-tip", this._tipContainer), this.options.closeButton) {
            var w = this._closeButton = we("a", r + "-close-button", d);
            w.setAttribute("role", "button"), w.setAttribute("aria-label", "Close popup"), w.href = "#close", w.innerHTML = '<span aria-hidden="true">&#215;</span>', ce(w, "click", function(O) {
              Ue(O), this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var r = this._contentNode, d = r.style;
          d.width = "", d.whiteSpace = "nowrap";
          var v = r.offsetWidth;
          v = Math.min(v, this.options.maxWidth), v = Math.max(v, this.options.minWidth), d.width = v + 1 + "px", d.whiteSpace = "", d.height = "";
          var w = r.offsetHeight, O = this.options.maxHeight, H = "leaflet-popup-scrolled";
          O && w > O ? (d.height = O + "px", le(r, H)) : Fe(r, H), this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(r) {
          var d = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center), v = this._getAnchor();
          yn(this._container, d.add(v));
        },
        _adjustPan: function() {
          if (this.options.autoPan) {
            if (this._map._panAnim && this._map._panAnim.stop(), this._autopanning) {
              this._autopanning = !1;
              return;
            }
            var r = this._map, d = parseInt(ya(this._container, "marginBottom"), 10) || 0, v = this._container.offsetHeight + d, w = this._containerWidth, O = new ut(this._containerLeft, -v - this._containerBottom);
            O._add(Io(this._container));
            var H = r.layerPointToContainerPoint(O), q = k(this.options.autoPanPadding), I = k(this.options.autoPanPaddingTopLeft || q), rt = k(this.options.autoPanPaddingBottomRight || q), xt = r.getSize(), Nt = 0, qt = 0;
            H.x + w + rt.x > xt.x && (Nt = H.x + w - xt.x + rt.x), H.x - Nt - I.x < 0 && (Nt = H.x - I.x), H.y + v + rt.y > xt.y && (qt = H.y + v - xt.y + rt.y), H.y - qt - I.y < 0 && (qt = H.y - I.y), (Nt || qt) && (this.options.keepInView && (this._autopanning = !0), r.fire("autopanstart").panBy([Nt, qt]));
          }
        },
        _getAnchor: function() {
          return k(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      }), qf = function(r, d) {
        return new Tu(r, d);
      };
      Oe.mergeOptions({
        closePopupOnClick: !0
      }), Oe.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(r, d, v) {
          return this._initOverlay(Tu, r, d, v).openOn(this), this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(r) {
          return r = arguments.length ? r : this._popup, r && r.close(), this;
        }
      }), ba.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(r, d) {
          return this._popup = this._initOverlay(Tu, this._popup, r, d), this._popupHandlersAdded || (this.on({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !0), this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          return this._popup && (this.off({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !1, this._popup = null), this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(r) {
          return this._popup && (this instanceof jn || (this._popup._source = this), this._popup._prepareOpen(r || this._latlng) && this._popup.openOn(this._map)), this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          return this._popup && this._popup.close(), this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          return this._popup && this._popup.toggle(this), this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : !1;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(r) {
          return this._popup && this._popup.setContent(r), this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(r) {
          if (!(!this._popup || !this._map)) {
            xo(r);
            var d = r.layer || r.target;
            if (this._popup._source === d && !(d instanceof Ao)) {
              this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(r.latlng);
              return;
            }
            this._popup._source = d, this.openPopup(r.latlng);
          }
        },
        _movePopup: function(r) {
          this._popup.setLatLng(r.latlng);
        },
        _onKeyPress: function(r) {
          r.originalEvent.keyCode === 13 && this._openPopup(r);
        }
      });
      var Ns = Ta.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: !1,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: !1,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(r) {
          Ta.prototype.onAdd.call(this, r), this.setOpacity(this.options.opacity), r.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0));
        },
        onRemove: function(r) {
          Ta.prototype.onRemove.call(this, r), r.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0));
        },
        getEvents: function() {
          var r = Ta.prototype.getEvents.call(this);
          return this.options.permanent || (r.preclick = this.close), r;
        },
        _initLayout: function() {
          var r = "leaflet-tooltip", d = r + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = we("div", d), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + T(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(r) {
          var d, v, w = this._map, O = this._container, H = w.latLngToContainerPoint(w.getCenter()), q = w.layerPointToContainerPoint(r), I = this.options.direction, rt = O.offsetWidth, xt = O.offsetHeight, Nt = k(this.options.offset), qt = this._getAnchor();
          I === "top" ? (d = rt / 2, v = xt) : I === "bottom" ? (d = rt / 2, v = 0) : I === "center" ? (d = rt / 2, v = xt / 2) : I === "right" ? (d = 0, v = xt / 2) : I === "left" ? (d = rt, v = xt / 2) : q.x < H.x ? (I = "right", d = 0, v = xt / 2) : (I = "left", d = rt + (Nt.x + qt.x) * 2, v = xt / 2), r = r.subtract(k(d, v, !0)).add(Nt).add(qt), Fe(O, "leaflet-tooltip-right"), Fe(O, "leaflet-tooltip-left"), Fe(O, "leaflet-tooltip-top"), Fe(O, "leaflet-tooltip-bottom"), le(O, "leaflet-tooltip-" + I), yn(O, r);
        },
        _updatePosition: function() {
          var r = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(r);
        },
        setOpacity: function(r) {
          this.options.opacity = r, this._container && Oi(this._container, r);
        },
        _animateZoom: function(r) {
          var d = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center);
          this._setPosition(d);
        },
        _getAnchor: function() {
          return k(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      }), Cd = function(r, d) {
        return new Ns(r, d);
      };
      Oe.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(r, d, v) {
          return this._initOverlay(Ns, r, d, v).openOn(this), this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(r) {
          return r.close(), this;
        }
      }), ba.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(r, d) {
          return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Ns, this._tooltip, r, d), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this;
        },
        _initTooltipInteractions: function(r) {
          if (!(!r && this._tooltipHandlersAdded)) {
            var d = r ? "off" : "on", v = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            this._tooltip.options.permanent ? v.add = this._openTooltip : (v.mouseover = this._openTooltip, v.mouseout = this.closeTooltip, v.click = this._openTooltip, this._map ? this._addFocusListeners() : v.add = this._addFocusListeners), this._tooltip.options.sticky && (v.mousemove = this._moveTooltip), this[d](v), this._tooltipHandlersAdded = !r;
          }
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(r) {
          return this._tooltip && (this instanceof jn || (this._tooltip._source = this), this._tooltip._prepareOpen(r) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip)
            return this._tooltip.close();
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          return this._tooltip && this._tooltip.toggle(this), this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(r) {
          return this._tooltip && this._tooltip.setContent(r), this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
        },
        _addFocusListenersOnLayer: function(r) {
          var d = typeof r.getElement == "function" && r.getElement();
          d && (ce(d, "focus", function() {
            this._tooltip._source = r, this.openTooltip();
          }, this), ce(d, "blur", this.closeTooltip, this));
        },
        _setAriaDescribedByOnLayer: function(r) {
          var d = typeof r.getElement == "function" && r.getElement();
          d && d.setAttribute("aria-describedby", this._tooltip._container.id);
        },
        _openTooltip: function(r) {
          if (!(!this._tooltip || !this._map)) {
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
              this._openOnceFlag = !0;
              var d = this;
              this._map.once("moveend", function() {
                d._openOnceFlag = !1, d._openTooltip(r);
              });
              return;
            }
            this._tooltip._source = r.layer || r.target, this.openTooltip(this._tooltip.options.sticky ? r.latlng : void 0);
          }
        },
        _moveTooltip: function(r) {
          var d = r.latlng, v, w;
          this._tooltip.options.sticky && r.originalEvent && (v = this._map.mouseEventToContainerPoint(r.originalEvent), w = this._map.containerPointToLayerPoint(v), d = this._map.layerPointToLatLng(w)), this._tooltip.setLatLng(d);
        }
      });
      var wc = Cl.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: !1,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(r) {
          var d = r && r.tagName === "DIV" ? r : document.createElement("div"), v = this.options;
          if (v.html instanceof Element ? (Yn(d), d.appendChild(v.html)) : d.innerHTML = v.html !== !1 ? v.html : "", v.bgPos) {
            var w = k(v.bgPos);
            d.style.backgroundPosition = -w.x + "px " + -w.y + "px";
          }
          return this._setIconStyles(d, "icon"), d;
        },
        createShadow: function() {
          return null;
        }
      });
      function Zf(r) {
        return new wc(r);
      }
      Cl.Default = Cs;
      var Co = ba.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Wt.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: !0,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: !1,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(r) {
          Q(this, r);
        },
        onAdd: function() {
          this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
        },
        beforeAdd: function(r) {
          r._addZoomLimit(this);
        },
        onRemove: function(r) {
          this._removeAllTiles(), ln(this._container), r._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          return this._map && (bo(this._container), this._setAutoZIndex(Math.max)), this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          return this._map && (xl(this._container), this._setAutoZIndex(Math.min)), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(r) {
          return this.options.opacity = r, this._updateOpacity(), this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(r) {
          return this.options.zIndex = r, this._updateZIndex(), this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var r = this._clampZoom(this._map.getZoom());
            r !== this._tileZoom && (this._tileZoom = r, this._updateLevels()), this._update();
          }
          return this;
        },
        getEvents: function() {
          var r = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          return this.options.updateWhenIdle || (this._onMove || (this._onMove = E(this._onMoveEnd, this.options.updateInterval, this)), r.move = this._onMove), this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var r = this.options.tileSize;
          return r instanceof ut ? r : new ut(r, r);
        },
        _updateZIndex: function() {
          this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex);
        },
        _setAutoZIndex: function(r) {
          for (var d = this.getPane().children, v = -r(-1 / 0, 1 / 0), w = 0, O = d.length, H; w < O; w++)
            H = d[w].style.zIndex, d[w] !== this._container && H && (v = r(v, +H));
          isFinite(v) && (this.options.zIndex = v + r(-1, 1), this._updateZIndex());
        },
        _updateOpacity: function() {
          if (this._map && !Wt.ielt9) {
            Oi(this._container, this.options.opacity);
            var r = +/* @__PURE__ */ new Date(), d = !1, v = !1;
            for (var w in this._tiles) {
              var O = this._tiles[w];
              if (!(!O.current || !O.loaded)) {
                var H = Math.min(1, (r - O.loaded) / 200);
                Oi(O.el, H), H < 1 ? d = !0 : (O.active ? v = !0 : this._onOpaqueTile(O), O.active = !0);
              }
            }
            v && !this._noPrune && this._pruneTiles(), d && (kt(this._fadeFrame), this._fadeFrame = Rt(this._updateOpacity, this));
          }
        },
        _onOpaqueTile: C,
        _initContainer: function() {
          this._container || (this._container = we("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
        },
        _updateLevels: function() {
          var r = this._tileZoom, d = this.options.maxZoom;
          if (r !== void 0) {
            for (var v in this._levels)
              v = Number(v), this._levels[v].el.children.length || v === r ? (this._levels[v].el.style.zIndex = d - Math.abs(r - v), this._onUpdateLevel(v)) : (ln(this._levels[v].el), this._removeTilesAtZoom(v), this._onRemoveLevel(v), delete this._levels[v]);
            var w = this._levels[r], O = this._map;
            return w || (w = this._levels[r] = {}, w.el = we("div", "leaflet-tile-container leaflet-zoom-animated", this._container), w.el.style.zIndex = d, w.origin = O.project(O.unproject(O.getPixelOrigin()), r).round(), w.zoom = r, this._setZoomTransform(w, O.getCenter(), O.getZoom()), C(w.el.offsetWidth), this._onCreateLevel(w)), this._level = w, w;
          }
        },
        _onUpdateLevel: C,
        _onRemoveLevel: C,
        _onCreateLevel: C,
        _pruneTiles: function() {
          if (this._map) {
            var r, d, v = this._map.getZoom();
            if (v > this.options.maxZoom || v < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (r in this._tiles)
              d = this._tiles[r], d.retain = d.current;
            for (r in this._tiles)
              if (d = this._tiles[r], d.current && !d.active) {
                var w = d.coords;
                this._retainParent(w.x, w.y, w.z, w.z - 5) || this._retainChildren(w.x, w.y, w.z, w.z + 2);
              }
            for (r in this._tiles)
              this._tiles[r].retain || this._removeTile(r);
          }
        },
        _removeTilesAtZoom: function(r) {
          for (var d in this._tiles)
            this._tiles[d].coords.z === r && this._removeTile(d);
        },
        _removeAllTiles: function() {
          for (var r in this._tiles)
            this._removeTile(r);
        },
        _invalidateAll: function() {
          for (var r in this._levels)
            ln(this._levels[r].el), this._onRemoveLevel(Number(r)), delete this._levels[r];
          this._removeAllTiles(), this._tileZoom = void 0;
        },
        _retainParent: function(r, d, v, w) {
          var O = Math.floor(r / 2), H = Math.floor(d / 2), q = v - 1, I = new ut(+O, +H);
          I.z = +q;
          var rt = this._tileCoordsToKey(I), xt = this._tiles[rt];
          return xt && xt.active ? (xt.retain = !0, !0) : (xt && xt.loaded && (xt.retain = !0), q > w ? this._retainParent(O, H, q, w) : !1);
        },
        _retainChildren: function(r, d, v, w) {
          for (var O = 2 * r; O < 2 * r + 2; O++)
            for (var H = 2 * d; H < 2 * d + 2; H++) {
              var q = new ut(O, H);
              q.z = v + 1;
              var I = this._tileCoordsToKey(q), rt = this._tiles[I];
              if (rt && rt.active) {
                rt.retain = !0;
                continue;
              } else rt && rt.loaded && (rt.retain = !0);
              v + 1 < w && this._retainChildren(O, H, v + 1, w);
            }
        },
        _resetView: function(r) {
          var d = r && (r.pinch || r.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), d, d);
        },
        _animateZoom: function(r) {
          this._setView(r.center, r.zoom, !0, r.noUpdate);
        },
        _clampZoom: function(r) {
          var d = this.options;
          return d.minNativeZoom !== void 0 && r < d.minNativeZoom ? d.minNativeZoom : d.maxNativeZoom !== void 0 && d.maxNativeZoom < r ? d.maxNativeZoom : r;
        },
        _setView: function(r, d, v, w) {
          var O = Math.round(d);
          this.options.maxZoom !== void 0 && O > this.options.maxZoom || this.options.minZoom !== void 0 && O < this.options.minZoom ? O = void 0 : O = this._clampZoom(O);
          var H = this.options.updateWhenZooming && O !== this._tileZoom;
          (!w || H) && (this._tileZoom = O, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), O !== void 0 && this._update(r), v || this._pruneTiles(), this._noPrune = !!v), this._setZoomTransforms(r, d);
        },
        _setZoomTransforms: function(r, d) {
          for (var v in this._levels)
            this._setZoomTransform(this._levels[v], r, d);
        },
        _setZoomTransform: function(r, d, v) {
          var w = this._map.getZoomScale(v, r.zoom), O = r.origin.multiplyBy(w).subtract(this._map._getNewPixelOrigin(d, v)).round();
          Wt.any3d ? ia(r.el, O, w) : yn(r.el, O);
        },
        _resetGrid: function() {
          var r = this._map, d = r.options.crs, v = this._tileSize = this.getTileSize(), w = this._tileZoom, O = this._map.getPixelWorldBounds(this._tileZoom);
          O && (this._globalTileRange = this._pxBoundsToTileRange(O)), this._wrapX = d.wrapLng && !this.options.noWrap && [
            Math.floor(r.project([0, d.wrapLng[0]], w).x / v.x),
            Math.ceil(r.project([0, d.wrapLng[1]], w).x / v.y)
          ], this._wrapY = d.wrapLat && !this.options.noWrap && [
            Math.floor(r.project([d.wrapLat[0], 0], w).y / v.x),
            Math.ceil(r.project([d.wrapLat[1], 0], w).y / v.y)
          ];
        },
        _onMoveEnd: function() {
          !this._map || this._map._animatingZoom || this._update();
        },
        _getTiledPixelBounds: function(r) {
          var d = this._map, v = d._animatingZoom ? Math.max(d._animateToZoom, d.getZoom()) : d.getZoom(), w = d.getZoomScale(v, this._tileZoom), O = d.project(r, this._tileZoom).floor(), H = d.getSize().divideBy(w * 2);
          return new F(O.subtract(H), O.add(H));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(r) {
          var d = this._map;
          if (d) {
            var v = this._clampZoom(d.getZoom());
            if (r === void 0 && (r = d.getCenter()), this._tileZoom !== void 0) {
              var w = this._getTiledPixelBounds(r), O = this._pxBoundsToTileRange(w), H = O.getCenter(), q = [], I = this.options.keepBuffer, rt = new F(
                O.getBottomLeft().subtract([I, -I]),
                O.getTopRight().add([I, -I])
              );
              if (!(isFinite(O.min.x) && isFinite(O.min.y) && isFinite(O.max.x) && isFinite(O.max.y)))
                throw new Error("Attempted to load an infinite number of tiles");
              for (var xt in this._tiles) {
                var Nt = this._tiles[xt].coords;
                (Nt.z !== this._tileZoom || !rt.contains(new ut(Nt.x, Nt.y))) && (this._tiles[xt].current = !1);
              }
              if (Math.abs(v - this._tileZoom) > 1) {
                this._setView(r, v);
                return;
              }
              for (var qt = O.min.y; qt <= O.max.y; qt++)
                for (var Zt = O.min.x; Zt <= O.max.x; Zt++) {
                  var oe = new ut(Zt, qt);
                  if (oe.z = this._tileZoom, !!this._isValidTile(oe)) {
                    var Ge = this._tiles[this._tileCoordsToKey(oe)];
                    Ge ? Ge.current = !0 : q.push(oe);
                  }
                }
              if (q.sort(function(An, Pi) {
                return An.distanceTo(H) - Pi.distanceTo(H);
              }), q.length !== 0) {
                this._loading || (this._loading = !0, this.fire("loading"));
                var dn = document.createDocumentFragment();
                for (Zt = 0; Zt < q.length; Zt++)
                  this._addTile(q[Zt], dn);
                this._level.el.appendChild(dn);
              }
            }
          }
        },
        _isValidTile: function(r) {
          var d = this._map.options.crs;
          if (!d.infinite) {
            var v = this._globalTileRange;
            if (!d.wrapLng && (r.x < v.min.x || r.x > v.max.x) || !d.wrapLat && (r.y < v.min.y || r.y > v.max.y))
              return !1;
          }
          if (!this.options.bounds)
            return !0;
          var w = this._tileCoordsToBounds(r);
          return Et(this.options.bounds).overlaps(w);
        },
        _keyToBounds: function(r) {
          return this._tileCoordsToBounds(this._keyToTileCoords(r));
        },
        _tileCoordsToNwSe: function(r) {
          var d = this._map, v = this.getTileSize(), w = r.scaleBy(v), O = w.add(v), H = d.unproject(w, r.z), q = d.unproject(O, r.z);
          return [H, q];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(r) {
          var d = this._tileCoordsToNwSe(r), v = new bt(d[0], d[1]);
          return this.options.noWrap || (v = this._map.wrapLatLngBounds(v)), v;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(r) {
          return r.x + ":" + r.y + ":" + r.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(r) {
          var d = r.split(":"), v = new ut(+d[0], +d[1]);
          return v.z = +d[2], v;
        },
        _removeTile: function(r) {
          var d = this._tiles[r];
          d && (ln(d.el), delete this._tiles[r], this.fire("tileunload", {
            tile: d.el,
            coords: this._keyToTileCoords(r)
          }));
        },
        _initTile: function(r) {
          le(r, "leaflet-tile");
          var d = this.getTileSize();
          r.style.width = d.x + "px", r.style.height = d.y + "px", r.onselectstart = C, r.onmousemove = C, Wt.ielt9 && this.options.opacity < 1 && Oi(r, this.options.opacity);
        },
        _addTile: function(r, d) {
          var v = this._getTilePos(r), w = this._tileCoordsToKey(r), O = this.createTile(this._wrapCoords(r), _(this._tileReady, this, r));
          this._initTile(O), this.createTile.length < 2 && Rt(_(this._tileReady, this, r, null, O)), yn(O, v), this._tiles[w] = {
            el: O,
            coords: r,
            current: !0
          }, d.appendChild(O), this.fire("tileloadstart", {
            tile: O,
            coords: r
          });
        },
        _tileReady: function(r, d, v) {
          d && this.fire("tileerror", {
            error: d,
            tile: v,
            coords: r
          });
          var w = this._tileCoordsToKey(r);
          v = this._tiles[w], v && (v.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (Oi(v.el, 0), kt(this._fadeFrame), this._fadeFrame = Rt(this._updateOpacity, this)) : (v.active = !0, this._pruneTiles()), d || (le(v.el, "leaflet-tile-loaded"), this.fire("tileload", {
            tile: v.el,
            coords: r
          })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), Wt.ielt9 || !this._map._fadeAnimated ? Rt(this._pruneTiles, this) : setTimeout(_(this._pruneTiles, this), 250)));
        },
        _getTilePos: function(r) {
          return r.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(r) {
          var d = new ut(
            this._wrapX ? A(r.x, this._wrapX) : r.x,
            this._wrapY ? A(r.y, this._wrapY) : r.y
          );
          return d.z = r.z, d;
        },
        _pxBoundsToTileRange: function(r) {
          var d = this.getTileSize();
          return new F(
            r.min.unscaleBy(d).floor(),
            r.max.unscaleBy(d).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var r in this._tiles)
            if (!this._tiles[r].loaded)
              return !1;
          return !0;
        }
      });
      function xa(r) {
        return new Co(r);
      }
      var kl = Co.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: !1,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: !1,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: !1
        },
        initialize: function(r, d) {
          this._url = r, d = Q(this, d), d.detectRetina && Wt.retina && d.maxZoom > 0 ? (d.tileSize = Math.floor(d.tileSize / 2), d.zoomReverse ? (d.zoomOffset--, d.minZoom = Math.min(d.maxZoom, d.minZoom + 1)) : (d.zoomOffset++, d.maxZoom = Math.max(d.minZoom, d.maxZoom - 1)), d.minZoom = Math.max(0, d.minZoom)) : d.zoomReverse ? d.minZoom = Math.min(d.maxZoom, d.minZoom) : d.maxZoom = Math.max(d.minZoom, d.maxZoom), typeof d.subdomains == "string" && (d.subdomains = d.subdomains.split("")), this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(r, d) {
          return this._url === r && d === void 0 && (d = !0), this._url = r, d || this.redraw(), this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(r, d) {
          var v = document.createElement("img");
          return ce(v, "load", _(this._tileOnLoad, this, d, v)), ce(v, "error", _(this._tileOnError, this, d, v)), (this.options.crossOrigin || this.options.crossOrigin === "") && (v.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), typeof this.options.referrerPolicy == "string" && (v.referrerPolicy = this.options.referrerPolicy), v.alt = "", v.src = this.getTileUrl(r), v;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(r) {
          var d = {
            r: Wt.retina ? "@2x" : "",
            s: this._getSubdomain(r),
            x: r.x,
            y: r.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var v = this._globalTileRange.max.y - r.y;
            this.options.tms && (d.y = v), d["-y"] = v;
          }
          return wt(this._url, h(d, this.options));
        },
        _tileOnLoad: function(r, d) {
          Wt.ielt9 ? setTimeout(_(r, this, null, d), 0) : r(null, d);
        },
        _tileOnError: function(r, d, v) {
          var w = this.options.errorTileUrl;
          w && d.getAttribute("src") !== w && (d.src = w), r(v, d);
        },
        _onTileRemove: function(r) {
          r.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var r = this._tileZoom, d = this.options.maxZoom, v = this.options.zoomReverse, w = this.options.zoomOffset;
          return v && (r = d - r), r + w;
        },
        _getSubdomain: function(r) {
          var d = Math.abs(r.x + r.y) % this.options.subdomains.length;
          return this.options.subdomains[d];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var r, d;
          for (r in this._tiles)
            if (this._tiles[r].coords.z !== this._tileZoom && (d = this._tiles[r].el, d.onload = C, d.onerror = C, !d.complete)) {
              d.src = yt;
              var v = this._tiles[r].coords;
              ln(d), delete this._tiles[r], this.fire("tileabort", {
                tile: d,
                coords: v
              });
            }
        },
        _removeTile: function(r) {
          var d = this._tiles[r];
          if (d)
            return d.el.setAttribute("src", yt), Co.prototype._removeTile.call(this, r);
        },
        _tileReady: function(r, d, v) {
          if (!(!this._map || v && v.getAttribute("src") === yt))
            return Co.prototype._tileReady.call(this, r, d, v);
        }
      });
      function Zi(r, d) {
        return new kl(r, d);
      }
      var Ri = kl.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: !1,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: !1
        },
        initialize: function(r, d) {
          this._url = r;
          var v = h({}, this.defaultWmsParams);
          for (var w in d)
            w in this.options || (v[w] = d[w]);
          d = Q(this, d);
          var O = d.detectRetina && Wt.retina ? 2 : 1, H = this.getTileSize();
          v.width = H.x * O, v.height = H.y * O, this.wmsParams = v;
        },
        onAdd: function(r) {
          this._crs = this.options.crs || r.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
          var d = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[d] = this._crs.code, kl.prototype.onAdd.call(this, r);
        },
        getTileUrl: function(r) {
          var d = this._tileCoordsToNwSe(r), v = this._crs, w = ct(v.project(d[0]), v.project(d[1])), O = w.min, H = w.max, q = (this._wmsVersion >= 1.3 && this._crs === bc ? [O.y, O.x, H.y, H.x] : [O.x, O.y, H.x, H.y]).join(","), I = kl.prototype.getTileUrl.call(this, r);
          return I + X(this.wmsParams, I, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + q;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(r, d) {
          return h(this.wmsParams, r), d || this.redraw(), this;
        }
      });
      function Nl(r, d) {
        return new Ri(r, d);
      }
      kl.WMS = Ri, Zi.wms = Nl;
      var Gn = ba.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(r) {
          Q(this, r), T(this), this._layers = this._layers || {};
        },
        onAdd: function() {
          this._container || (this._initContainer(), le(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this), this._destroyContainer();
        },
        getEvents: function() {
          var r = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          return this._zoomAnimated && (r.zoomanim = this._onAnimZoom), r;
        },
        _onAnimZoom: function(r) {
          this._updateTransform(r.center, r.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(r, d) {
          var v = this._map.getZoomScale(d, this._zoom), w = this._map.getSize().multiplyBy(0.5 + this.options.padding), O = this._map.project(this._center, d), H = w.multiplyBy(-v).add(O).subtract(this._map._getNewPixelOrigin(r, d));
          Wt.any3d ? ia(this._container, H, v) : yn(this._container, H);
        },
        _reset: function() {
          this._update(), this._updateTransform(this._center, this._zoom);
          for (var r in this._layers)
            this._layers[r]._reset();
        },
        _onZoomEnd: function() {
          for (var r in this._layers)
            this._layers[r]._project();
        },
        _updatePaths: function() {
          for (var r in this._layers)
            this._layers[r]._update();
        },
        _update: function() {
          var r = this.options.padding, d = this._map.getSize(), v = this._map.containerPointToLayerPoint(d.multiplyBy(-r)).round();
          this._bounds = new F(v, v.add(d.multiplyBy(1 + r * 2)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
        }
      }), wa = Gn.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var r = Gn.prototype.getEvents.call(this);
          return r.viewprereset = this._onViewPreReset, r;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = !0;
        },
        onAdd: function() {
          Gn.prototype.onAdd.call(this), this._draw();
        },
        _initContainer: function() {
          var r = this._container = document.createElement("canvas");
          ce(r, "mousemove", this._onMouseMove, this), ce(r, "click dblclick mousedown mouseup contextmenu", this._onClick, this), ce(r, "mouseout", this._handleMouseOut, this), r._leaflet_disable_events = !0, this._ctx = r.getContext("2d");
        },
        _destroyContainer: function() {
          kt(this._redrawRequest), delete this._ctx, ln(this._container), Ye(this._container), delete this._container;
        },
        _updatePaths: function() {
          if (!this._postponeUpdatePaths) {
            var r;
            this._redrawBounds = null;
            for (var d in this._layers)
              r = this._layers[d], r._update();
            this._redraw();
          }
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            Gn.prototype._update.call(this);
            var r = this._bounds, d = this._container, v = r.getSize(), w = Wt.retina ? 2 : 1;
            yn(d, r.min), d.width = w * v.x, d.height = w * v.y, d.style.width = v.x + "px", d.style.height = v.y + "px", Wt.retina && this._ctx.scale(2, 2), this._ctx.translate(-r.min.x, -r.min.y), this.fire("update");
          }
        },
        _reset: function() {
          Gn.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());
        },
        _initPath: function(r) {
          this._updateDashArray(r), this._layers[T(r)] = r;
          var d = r._order = {
            layer: r,
            prev: this._drawLast,
            next: null
          };
          this._drawLast && (this._drawLast.next = d), this._drawLast = d, this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(r) {
          this._requestRedraw(r);
        },
        _removePath: function(r) {
          var d = r._order, v = d.next, w = d.prev;
          v ? v.prev = w : this._drawLast = w, w ? w.next = v : this._drawFirst = v, delete r._order, delete this._layers[T(r)], this._requestRedraw(r);
        },
        _updatePath: function(r) {
          this._extendRedrawBounds(r), r._project(), r._update(), this._requestRedraw(r);
        },
        _updateStyle: function(r) {
          this._updateDashArray(r), this._requestRedraw(r);
        },
        _updateDashArray: function(r) {
          if (typeof r.options.dashArray == "string") {
            var d = r.options.dashArray.split(/[, ]+/), v = [], w, O;
            for (O = 0; O < d.length; O++) {
              if (w = Number(d[O]), isNaN(w))
                return;
              v.push(w);
            }
            r.options._dashArray = v;
          } else
            r.options._dashArray = r.options.dashArray;
        },
        _requestRedraw: function(r) {
          this._map && (this._extendRedrawBounds(r), this._redrawRequest = this._redrawRequest || Rt(this._redraw, this));
        },
        _extendRedrawBounds: function(r) {
          if (r._pxBounds) {
            var d = (r.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new F(), this._redrawBounds.extend(r._pxBounds.min.subtract([d, d])), this._redrawBounds.extend(r._pxBounds.max.add([d, d]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
        },
        _clear: function() {
          var r = this._redrawBounds;
          if (r) {
            var d = r.getSize();
            this._ctx.clearRect(r.min.x, r.min.y, d.x, d.y);
          } else
            this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore();
        },
        _draw: function() {
          var r, d = this._redrawBounds;
          if (this._ctx.save(), d) {
            var v = d.getSize();
            this._ctx.beginPath(), this._ctx.rect(d.min.x, d.min.y, v.x, v.y), this._ctx.clip();
          }
          this._drawing = !0;
          for (var w = this._drawFirst; w; w = w.next)
            r = w.layer, (!d || r._pxBounds && r._pxBounds.intersects(d)) && r._updatePath();
          this._drawing = !1, this._ctx.restore();
        },
        _updatePoly: function(r, d) {
          if (this._drawing) {
            var v, w, O, H, q = r._parts, I = q.length, rt = this._ctx;
            if (I) {
              for (rt.beginPath(), v = 0; v < I; v++) {
                for (w = 0, O = q[v].length; w < O; w++)
                  H = q[v][w], rt[w ? "lineTo" : "moveTo"](H.x, H.y);
                d && rt.closePath();
              }
              this._fillStroke(rt, r);
            }
          }
        },
        _updateCircle: function(r) {
          if (!(!this._drawing || r._empty())) {
            var d = r._point, v = this._ctx, w = Math.max(Math.round(r._radius), 1), O = (Math.max(Math.round(r._radiusY), 1) || w) / w;
            O !== 1 && (v.save(), v.scale(1, O)), v.beginPath(), v.arc(d.x, d.y / O, w, 0, Math.PI * 2, !1), O !== 1 && v.restore(), this._fillStroke(v, r);
          }
        },
        _fillStroke: function(r, d) {
          var v = d.options;
          v.fill && (r.globalAlpha = v.fillOpacity, r.fillStyle = v.fillColor || v.color, r.fill(v.fillRule || "evenodd")), v.stroke && v.weight !== 0 && (r.setLineDash && r.setLineDash(d.options && d.options._dashArray || []), r.globalAlpha = v.opacity, r.lineWidth = v.weight, r.strokeStyle = v.color, r.lineCap = v.lineCap, r.lineJoin = v.lineJoin, r.stroke());
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(r) {
          for (var d = this._map.mouseEventToLayerPoint(r), v, w, O = this._drawFirst; O; O = O.next)
            v = O.layer, v.options.interactive && v._containsPoint(d) && (!(r.type === "click" || r.type === "preclick") || !this._map._draggableMoved(v)) && (w = v);
          this._fireEvent(w ? [w] : !1, r);
        },
        _onMouseMove: function(r) {
          if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
            var d = this._map.mouseEventToLayerPoint(r);
            this._handleMouseHover(r, d);
          }
        },
        _handleMouseOut: function(r) {
          var d = this._hoveredLayer;
          d && (Fe(this._container, "leaflet-interactive"), this._fireEvent([d], r, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1);
        },
        _handleMouseHover: function(r, d) {
          if (!this._mouseHoverThrottled) {
            for (var v, w, O = this._drawFirst; O; O = O.next)
              v = O.layer, v.options.interactive && v._containsPoint(d) && (w = v);
            w !== this._hoveredLayer && (this._handleMouseOut(r), w && (le(this._container, "leaflet-interactive"), this._fireEvent([w], r, "mouseover"), this._hoveredLayer = w)), this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, r), this._mouseHoverThrottled = !0, setTimeout(_(function() {
              this._mouseHoverThrottled = !1;
            }, this), 32);
          }
        },
        _fireEvent: function(r, d, v) {
          this._map._fireDOMEvent(d, v || d.type, r);
        },
        _bringToFront: function(r) {
          var d = r._order;
          if (d) {
            var v = d.next, w = d.prev;
            if (v)
              v.prev = w;
            else
              return;
            w ? w.next = v : v && (this._drawFirst = v), d.prev = this._drawLast, this._drawLast.next = d, d.next = null, this._drawLast = d, this._requestRedraw(r);
          }
        },
        _bringToBack: function(r) {
          var d = r._order;
          if (d) {
            var v = d.next, w = d.prev;
            if (w)
              w.next = v;
            else
              return;
            v ? v.prev = w : w && (this._drawLast = w), d.prev = null, d.next = this._drawFirst, this._drawFirst.prev = d, this._drawFirst = d, this._requestRedraw(r);
          }
        }
      });
      function ll(r) {
        return Wt.canvas ? new wa(r) : null;
      }
      var zo = function() {
        try {
          return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(r) {
            return document.createElement("<lvml:" + r + ' class="lvml">');
          };
        } catch {
        }
        return function(r) {
          return document.createElement("<" + r + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }(), Lo = {
        _initContainer: function() {
          this._container = we("div", "leaflet-vml-container");
        },
        _update: function() {
          this._map._animatingZoom || (Gn.prototype._update.call(this), this.fire("update"));
        },
        _initPath: function(r) {
          var d = r._container = zo("shape");
          le(d, "leaflet-vml-shape " + (this.options.className || "")), d.coordsize = "1 1", r._path = zo("path"), d.appendChild(r._path), this._updateStyle(r), this._layers[T(r)] = r;
        },
        _addPath: function(r) {
          var d = r._container;
          this._container.appendChild(d), r.options.interactive && r.addInteractiveTarget(d);
        },
        _removePath: function(r) {
          var d = r._container;
          ln(d), r.removeInteractiveTarget(d), delete this._layers[T(r)];
        },
        _updateStyle: function(r) {
          var d = r._stroke, v = r._fill, w = r.options, O = r._container;
          O.stroked = !!w.stroke, O.filled = !!w.fill, w.stroke ? (d || (d = r._stroke = zo("stroke")), O.appendChild(d), d.weight = w.weight + "px", d.color = w.color, d.opacity = w.opacity, w.dashArray ? d.dashStyle = At(w.dashArray) ? w.dashArray.join(" ") : w.dashArray.replace(/( *, *)/g, " ") : d.dashStyle = "", d.endcap = w.lineCap.replace("butt", "flat"), d.joinstyle = w.lineJoin) : d && (O.removeChild(d), r._stroke = null), w.fill ? (v || (v = r._fill = zo("fill")), O.appendChild(v), v.color = w.fillColor || w.color, v.opacity = w.fillOpacity) : v && (O.removeChild(v), r._fill = null);
        },
        _updateCircle: function(r) {
          var d = r._point.round(), v = Math.round(r._radius), w = Math.round(r._radiusY || v);
          this._setPath(r, r._empty() ? "M0 0" : "AL " + d.x + "," + d.y + " " + v + "," + w + " 0," + 65535 * 360);
        },
        _setPath: function(r, d) {
          r._path.v = d;
        },
        _bringToFront: function(r) {
          bo(r._container);
        },
        _bringToBack: function(r) {
          xl(r._container);
        }
      }, sl = Wt.vml ? zo : cr, rl = Gn.extend({
        _initContainer: function() {
          this._container = sl("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = sl("g"), this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          ln(this._container), Ye(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            Gn.prototype._update.call(this);
            var r = this._bounds, d = r.getSize(), v = this._container;
            (!this._svgSize || !this._svgSize.equals(d)) && (this._svgSize = d, v.setAttribute("width", d.x), v.setAttribute("height", d.y)), yn(v, r.min), v.setAttribute("viewBox", [r.min.x, r.min.y, d.x, d.y].join(" ")), this.fire("update");
          }
        },
        // methods below are called by vector layers implementations
        _initPath: function(r) {
          var d = r._path = sl("path");
          r.options.className && le(d, r.options.className), r.options.interactive && le(d, "leaflet-interactive"), this._updateStyle(r), this._layers[T(r)] = r;
        },
        _addPath: function(r) {
          this._rootGroup || this._initContainer(), this._rootGroup.appendChild(r._path), r.addInteractiveTarget(r._path);
        },
        _removePath: function(r) {
          ln(r._path), r.removeInteractiveTarget(r._path), delete this._layers[T(r)];
        },
        _updatePath: function(r) {
          r._project(), r._update();
        },
        _updateStyle: function(r) {
          var d = r._path, v = r.options;
          d && (v.stroke ? (d.setAttribute("stroke", v.color), d.setAttribute("stroke-opacity", v.opacity), d.setAttribute("stroke-width", v.weight), d.setAttribute("stroke-linecap", v.lineCap), d.setAttribute("stroke-linejoin", v.lineJoin), v.dashArray ? d.setAttribute("stroke-dasharray", v.dashArray) : d.removeAttribute("stroke-dasharray"), v.dashOffset ? d.setAttribute("stroke-dashoffset", v.dashOffset) : d.removeAttribute("stroke-dashoffset")) : d.setAttribute("stroke", "none"), v.fill ? (d.setAttribute("fill", v.fillColor || v.color), d.setAttribute("fill-opacity", v.fillOpacity), d.setAttribute("fill-rule", v.fillRule || "evenodd")) : d.setAttribute("fill", "none"));
        },
        _updatePoly: function(r, d) {
          this._setPath(r, Tn(r._parts, d));
        },
        _updateCircle: function(r) {
          var d = r._point, v = Math.max(Math.round(r._radius), 1), w = Math.max(Math.round(r._radiusY), 1) || v, O = "a" + v + "," + w + " 0 1,0 ", H = r._empty() ? "M0 0" : "M" + (d.x - v) + "," + d.y + O + v * 2 + ",0 " + O + -v * 2 + ",0 ";
          this._setPath(r, H);
        },
        _setPath: function(r, d) {
          r._path.setAttribute("d", d);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(r) {
          bo(r._path);
        },
        _bringToBack: function(r) {
          xl(r._path);
        }
      });
      Wt.vml && rl.include(Lo);
      function Us(r) {
        return Wt.svg || Wt.vml ? new rl(r) : null;
      }
      Oe.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(r) {
          var d = r.options.renderer || this._getPaneRenderer(r.options.pane) || this.options.renderer || this._renderer;
          return d || (d = this._renderer = this._createRenderer()), this.hasLayer(d) || this.addLayer(d), d;
        },
        _getPaneRenderer: function(r) {
          if (r === "overlayPane" || r === void 0)
            return !1;
          var d = this._paneRenderers[r];
          return d === void 0 && (d = this._createRenderer({ pane: r }), this._paneRenderers[r] = d), d;
        },
        _createRenderer: function(r) {
          return this.options.preferCanvas && ll(r) || Us(r);
        }
      });
      var Vf = Ll.extend({
        initialize: function(r, d) {
          Ll.prototype.initialize.call(this, this._boundsToLatLngs(r), d);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(r) {
          return this.setLatLngs(this._boundsToLatLngs(r));
        },
        _boundsToLatLngs: function(r) {
          return r = Et(r), [
            r.getSouthWest(),
            r.getNorthWest(),
            r.getNorthEast(),
            r.getSouthEast()
          ];
        }
      });
      function Vi(r, d) {
        return new Vf(r, d);
      }
      rl.create = sl, rl.pointsToPath = Tn, gi.geometryToLayer = $a, gi.coordsToLatLng = Ls, gi.coordsToLatLngs = xr, gi.latLngToCoords = Hs, gi.latLngsToCoords = Do, gi.getFeature = Di, gi.asFeature = qi, Oe.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: !0
      });
      var wr = _a.extend({
        initialize: function(r) {
          this._map = r, this._container = r._container, this._pane = r._panes.overlayPane, this._resetStateTimeout = 0, r.on("unload", this._destroy, this);
        },
        addHooks: function() {
          ce(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          Ye(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          ln(this._pane), delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0, this._moved = !1;
        },
        _clearDeferredResetState: function() {
          this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
        },
        _onMouseDown: function(r) {
          if (!r.shiftKey || r.which !== 1 && r.button !== 1)
            return !1;
          this._clearDeferredResetState(), this._resetState(), To(), Fo(), this._startPoint = this._map.mouseEventToContainerPoint(r), ce(document, {
            contextmenu: xo,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(r) {
          this._moved || (this._moved = !0, this._box = we("div", "leaflet-zoom-box", this._container), le(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(r);
          var d = new F(this._point, this._startPoint), v = d.getSize();
          yn(this._box, d.min), this._box.style.width = v.x + "px", this._box.style.height = v.y + "px";
        },
        _finish: function() {
          this._moved && (ln(this._box), Fe(this._container, "leaflet-crosshair")), gr(), Cf(), Ye(document, {
            contextmenu: xo,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(r) {
          if (!(r.which !== 1 && r.button !== 1) && (this._finish(), !!this._moved)) {
            this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(_(this._resetState, this), 0);
            var d = new bt(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(d).fire("boxzoomend", { boxZoomBounds: d });
          }
        },
        _onKeyDown: function(r) {
          r.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
        }
      });
      Oe.addInitHook("addHandler", "boxZoom", wr), Oe.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: !0
      });
      var Ma = _a.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(r) {
          var d = this._map, v = d.getZoom(), w = d.options.zoomDelta, O = r.originalEvent.shiftKey ? v - w : v + w;
          d.options.doubleClickZoom === "center" ? d.setZoom(O) : d.setZoomAround(r.containerPoint, O);
        }
      });
      Oe.addInitHook("addHandler", "doubleClickZoom", Ma), Oe.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: !0,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: !0,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second.
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: 1 / 0,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: !1,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var ye = _a.extend({
        addHooks: function() {
          if (!this._draggable) {
            var r = this._map;
            this._draggable = new wo(r._mapPane, r._container), this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this), this._draggable.on("predrag", this._onPreDragLimit, this), r.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), r.on("zoomend", this._onZoomEnd, this), r.whenReady(this._onZoomEnd, this));
          }
          le(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
        },
        removeHooks: function() {
          Fe(this._map._container, "leaflet-grab"), Fe(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var r = this._map;
          if (r._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var d = Et(this._map.options.maxBounds);
            this._offsetLimit = ct(
              this._map.latLngToContainerPoint(d.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(d.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            ), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else
            this._offsetLimit = null;
          r.fire("movestart").fire("dragstart"), r.options.inertia && (this._positions = [], this._times = []);
        },
        _onDrag: function(r) {
          if (this._map.options.inertia) {
            var d = this._lastTime = +/* @__PURE__ */ new Date(), v = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(v), this._times.push(d), this._prunePositions(d);
          }
          this._map.fire("move", r).fire("drag", r);
        },
        _prunePositions: function(r) {
          for (; this._positions.length > 1 && r - this._times[0] > 50; )
            this._positions.shift(), this._times.shift();
        },
        _onZoomEnd: function() {
          var r = this._map.getSize().divideBy(2), d = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = d.subtract(r).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(r, d) {
          return r - (r - d) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!(!this._viscosity || !this._offsetLimit)) {
            var r = this._draggable._newPos.subtract(this._draggable._startPos), d = this._offsetLimit;
            r.x < d.min.x && (r.x = this._viscousLimit(r.x, d.min.x)), r.y < d.min.y && (r.y = this._viscousLimit(r.y, d.min.y)), r.x > d.max.x && (r.x = this._viscousLimit(r.x, d.max.x)), r.y > d.max.y && (r.y = this._viscousLimit(r.y, d.max.y)), this._draggable._newPos = this._draggable._startPos.add(r);
          }
        },
        _onPreDragWrap: function() {
          var r = this._worldWidth, d = Math.round(r / 2), v = this._initialWorldOffset, w = this._draggable._newPos.x, O = (w - d + v) % r + d - v, H = (w + d + v) % r - d - v, q = Math.abs(O + v) < Math.abs(H + v) ? O : H;
          this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = q;
        },
        _onDragEnd: function(r) {
          var d = this._map, v = d.options, w = !v.inertia || r.noInertia || this._times.length < 2;
          if (d.fire("dragend", r), w)
            d.fire("moveend");
          else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var O = this._lastPos.subtract(this._positions[0]), H = (this._lastTime - this._times[0]) / 1e3, q = v.easeLinearity, I = O.multiplyBy(q / H), rt = I.distanceTo([0, 0]), xt = Math.min(v.inertiaMaxSpeed, rt), Nt = I.multiplyBy(xt / rt), qt = xt / (v.inertiaDeceleration * q), Zt = Nt.multiplyBy(-qt / 2).round();
            !Zt.x && !Zt.y ? d.fire("moveend") : (Zt = d._limitOffset(Zt, d.options.maxBounds), Rt(function() {
              d.panBy(Zt, {
                duration: qt,
                easeLinearity: q,
                noMoveStart: !0,
                animate: !0
              });
            }));
          }
        }
      });
      Oe.addInitHook("addHandler", "dragging", ye), Oe.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: !0,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Ot = _a.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(r) {
          this._map = r, this._setPanDelta(r.options.keyboardPanDelta), this._setZoomDelta(r.options.zoomDelta);
        },
        addHooks: function() {
          var r = this._map._container;
          r.tabIndex <= 0 && (r.tabIndex = "0"), ce(r, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks(), Ye(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (!this._focused) {
            var r = document.body, d = document.documentElement, v = r.scrollTop || d.scrollTop, w = r.scrollLeft || d.scrollLeft;
            this._map._container.focus(), window.scrollTo(w, v);
          }
        },
        _onFocus: function() {
          this._focused = !0, this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = !1, this._map.fire("blur");
        },
        _setPanDelta: function(r) {
          var d = this._panKeys = {}, v = this.keyCodes, w, O;
          for (w = 0, O = v.left.length; w < O; w++)
            d[v.left[w]] = [-1 * r, 0];
          for (w = 0, O = v.right.length; w < O; w++)
            d[v.right[w]] = [r, 0];
          for (w = 0, O = v.down.length; w < O; w++)
            d[v.down[w]] = [0, r];
          for (w = 0, O = v.up.length; w < O; w++)
            d[v.up[w]] = [0, -1 * r];
        },
        _setZoomDelta: function(r) {
          var d = this._zoomKeys = {}, v = this.keyCodes, w, O;
          for (w = 0, O = v.zoomIn.length; w < O; w++)
            d[v.zoomIn[w]] = r;
          for (w = 0, O = v.zoomOut.length; w < O; w++)
            d[v.zoomOut[w]] = -r;
        },
        _addHooks: function() {
          ce(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          Ye(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(r) {
          if (!(r.altKey || r.ctrlKey || r.metaKey)) {
            var d = r.keyCode, v = this._map, w;
            if (d in this._panKeys) {
              if (!v._panAnim || !v._panAnim._inProgress)
                if (w = this._panKeys[d], r.shiftKey && (w = k(w).multiplyBy(3)), v.options.maxBounds && (w = v._limitOffset(k(w), v.options.maxBounds)), v.options.worldCopyJump) {
                  var O = v.wrapLatLng(v.unproject(v.project(v.getCenter()).add(w)));
                  v.panTo(O);
                } else
                  v.panBy(w);
            } else if (d in this._zoomKeys)
              v.setZoom(v.getZoom() + (r.shiftKey ? 3 : 1) * this._zoomKeys[d]);
            else if (d === 27 && v._popup && v._popup.options.closeOnEscapeKey)
              v.closePopup();
            else
              return;
            xo(r);
          }
        }
      });
      Oe.addInitHook("addHandler", "keyboard", Ot), Oe.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: !0,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var oa = _a.extend({
        addHooks: function() {
          ce(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
        },
        removeHooks: function() {
          Ye(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(r) {
          var d = _u(r), v = this._map.options.wheelDebounceTime;
          this._delta += d, this._lastMousePos = this._map.mouseEventToContainerPoint(r), this._startTime || (this._startTime = +/* @__PURE__ */ new Date());
          var w = Math.max(v - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer), this._timer = setTimeout(_(this._performZoom, this), w), xo(r);
        },
        _performZoom: function() {
          var r = this._map, d = r.getZoom(), v = this._map.options.zoomSnap || 0;
          r._stop();
          var w = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), O = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(w)))) / Math.LN2, H = v ? Math.ceil(O / v) * v : O, q = r._limitZoom(d + (this._delta > 0 ? H : -H)) - d;
          this._delta = 0, this._startTime = null, q && (r.options.scrollWheelZoom === "center" ? r.setZoom(d + q) : r.setZoomAround(this._lastMousePos, d + q));
        }
      });
      Oe.addInitHook("addHandler", "scrollWheelZoom", oa);
      var Mr = 600;
      Oe.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Wt.touchNative && Wt.safari && Wt.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var cn = _a.extend({
        addHooks: function() {
          ce(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          Ye(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(r) {
          if (clearTimeout(this._holdTimeout), r.touches.length === 1) {
            var d = r.touches[0];
            this._startPos = this._newPos = new ut(d.clientX, d.clientY), this._holdTimeout = setTimeout(_(function() {
              this._cancel(), this._isTapValid() && (ce(document, "touchend", Ue), ce(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", d));
            }, this), Mr), ce(document, "touchend touchcancel contextmenu", this._cancel, this), ce(document, "touchmove", this._onMove, this);
          }
        },
        _cancelClickPrevent: function r() {
          Ye(document, "touchend", Ue), Ye(document, "touchend touchcancel", r);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout), Ye(document, "touchend touchcancel contextmenu", this._cancel, this), Ye(document, "touchmove", this._onMove, this);
        },
        _onMove: function(r) {
          var d = r.touches[0];
          this._newPos = new ut(d.clientX, d.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(r, d) {
          var v = new MouseEvent(r, {
            bubbles: !0,
            cancelable: !0,
            view: window,
            // detail: 1,
            screenX: d.screenX,
            screenY: d.screenY,
            clientX: d.clientX,
            clientY: d.clientY
            // button: 2,
            // buttons: 2
          });
          v._simulated = !0, d.target.dispatchEvent(v);
        }
      });
      Oe.addInitHook("addHandler", "tapHold", cn), Oe.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Wt.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: !0
      });
      var ul = _a.extend({
        addHooks: function() {
          le(this._map._container, "leaflet-touch-zoom"), ce(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          Fe(this._map._container, "leaflet-touch-zoom"), Ye(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(r) {
          var d = this._map;
          if (!(!r.touches || r.touches.length !== 2 || d._animatingZoom || this._zooming)) {
            var v = d.mouseEventToContainerPoint(r.touches[0]), w = d.mouseEventToContainerPoint(r.touches[1]);
            this._centerPoint = d.getSize()._divideBy(2), this._startLatLng = d.containerPointToLatLng(this._centerPoint), d.options.touchZoom !== "center" && (this._pinchStartLatLng = d.containerPointToLatLng(v.add(w)._divideBy(2))), this._startDist = v.distanceTo(w), this._startZoom = d.getZoom(), this._moved = !1, this._zooming = !0, d._stop(), ce(document, "touchmove", this._onTouchMove, this), ce(document, "touchend touchcancel", this._onTouchEnd, this), Ue(r);
          }
        },
        _onTouchMove: function(r) {
          if (!(!r.touches || r.touches.length !== 2 || !this._zooming)) {
            var d = this._map, v = d.mouseEventToContainerPoint(r.touches[0]), w = d.mouseEventToContainerPoint(r.touches[1]), O = v.distanceTo(w) / this._startDist;
            if (this._zoom = d.getScaleZoom(O, this._startZoom), !d.options.bounceAtZoomLimits && (this._zoom < d.getMinZoom() && O < 1 || this._zoom > d.getMaxZoom() && O > 1) && (this._zoom = d._limitZoom(this._zoom)), d.options.touchZoom === "center") {
              if (this._center = this._startLatLng, O === 1)
                return;
            } else {
              var H = v._add(w)._divideBy(2)._subtract(this._centerPoint);
              if (O === 1 && H.x === 0 && H.y === 0)
                return;
              this._center = d.unproject(d.project(this._pinchStartLatLng, this._zoom).subtract(H), this._zoom);
            }
            this._moved || (d._moveStart(!0, !1), this._moved = !0), kt(this._animRequest);
            var q = _(d._move, d, this._center, this._zoom, { pinch: !0, round: !1 }, void 0);
            this._animRequest = Rt(q, this, !0), Ue(r);
          }
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = !1;
            return;
          }
          this._zooming = !1, kt(this._animRequest), Ye(document, "touchmove", this._onTouchMove, this), Ye(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom));
        }
      });
      Oe.addInitHook("addHandler", "touchZoom", ul), Oe.BoxZoom = wr, Oe.DoubleClickZoom = Ma, Oe.Drag = ye, Oe.Keyboard = Ot, Oe.ScrollWheelZoom = oa, Oe.TapHold = cn, Oe.TouchZoom = ul, l.Bounds = F, l.Browser = Wt, l.CRS = We, l.Canvas = wa, l.Circle = Tr, l.CircleMarker = ol, l.Class = ge, l.Control = $n, l.DivIcon = wc, l.DivOverlay = Ta, l.DomEvent = xd, l.DomUtil = Td, l.Draggable = wo, l.Evented = dt, l.FeatureGroup = jn, l.GeoJSON = gi, l.GridLayer = Co, l.Handler = _a, l.Icon = Cl, l.ImageOverlay = Sa, l.LatLng = zt, l.LatLngBounds = bt, l.Layer = ba, l.LayerGroup = al, l.LineUtil = Bf, l.Map = Oe, l.Marker = Oo, l.Mixin = Od, l.Path = Ao, l.Point = ut, l.PolyUtil = Wa, l.Polygon = Ll, l.Polyline = Fn, l.Popup = Tu, l.PosAnimation = yc, l.Projection = Dl, l.Rectangle = Vf, l.Renderer = Gn, l.SVG = rl, l.SVGOverlay = to, l.TileLayer = kl, l.Tooltip = Ns, l.Transformation = da, l.Util = Ee, l.VideoOverlay = aa, l.bind = _, l.bounds = ct, l.canvas = ll, l.circle = zl, l.circleMarker = Yf, l.control = Os, l.divIcon = Zf, l.extend = h, l.featureGroup = Ia, l.geoJSON = Hl, l.geoJson = xc, l.gridLayer = xa, l.icon = Eo, l.imageOverlay = ks, l.latLng = Tt, l.latLngBounds = Et, l.layerGroup = Sc, l.map = bu, l.marker = zs, l.point = k, l.polygon = ti, l.polyline = jf, l.popup = qf, l.rectangle = Vi, l.setOptions = Q, l.stamp = T, l.svg = Us, l.svgOverlay = Rd, l.tileLayer = Zi, l.tooltip = Cd, l.transformation = Za, l.version = u, l.videoOverlay = Fa;
      var Ul = window.L;
      l.noConflict = function() {
        return window.L = Ul, this;
      }, window.L = l;
    });
  }(uv, uv.exports)), uv.exports;
}
var Jz = Wz();
const l1 = /* @__PURE__ */ HE(Jz);
function Iz({ offers: s, center: i }) {
  const l = $i.useRef(null);
  return $i.useEffect(() => {
    if (!l.current) return;
    const u = l1.map(l.current).setView(i || [52.2297, 21.0122], i ? 13 : 6);
    return l1.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(u), s.forEach((h) => {
      h.pharmacy_lat && h.pharmacy_lon && l1.marker([h.pharmacy_lat, h.pharmacy_lon]).addTo(u);
    }), () => {
      u.remove();
    };
  }, [s, i]), /* @__PURE__ */ ee.jsx("div", { id: "map", ref: l, style: { height: "300px" } });
}
function $z() {
  const [s, i] = $i.useState(""), [l, u] = $i.useState(""), [h, g] = $i.useState([]), [_, S] = $i.useState([]), [T, E] = $i.useState("price"), [A, C] = $i.useState("asc"), [z, j] = $i.useState(0), [J, Q] = $i.useState(0), X = 50;
  return $i.useEffect(() => {
    if (!s) return;
    const et = new URLSearchParams({
      limit: String(X),
      offset: String(J),
      sort: T,
      order: A
    });
    l && et.append("city", l), fetch(`/api/product/${encodeURIComponent(s)}?${et}`).then((wt) => wt.json()).then((wt) => {
      g(wt.offers || []), S(wt.trend || []), j(wt.total || 0);
    }).catch((wt) => console.error("product error", wt));
  }, [s, l, T, A, J]), /* @__PURE__ */ ee.jsxs("div", { className: "container py-4", children: [
    /* @__PURE__ */ ee.jsx("h1", { className: "text-center mb-4", children: " Dashboard cen medycznej marihuany" }),
    /* @__PURE__ */ ee.jsxs("div", { className: "row mb-3", children: [
      /* @__PURE__ */ ee.jsxs("div", { className: "col-md-6 mb-2 mb-md-0", children: [
        /* @__PURE__ */ ee.jsx("label", { className: "form-label", children: "Wybierz produkt:" }),
        /* @__PURE__ */ ee.jsx(
          KE,
          {
            value: s,
            onChange: (et) => {
              i(et), Q(0);
            }
          }
        )
      ] }),
      /* @__PURE__ */ ee.jsxs("div", { className: "col-md-6", children: [
        /* @__PURE__ */ ee.jsx("label", { className: "form-label", children: "Miasto:" }),
        /* @__PURE__ */ ee.jsx(
          WE,
          {
            value: l,
            onChange: (et) => {
              u(et), Q(0);
            }
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ ee.jsx(
      JE,
      {
        sort: T,
        order: A,
        onSortChange: (et) => {
          E(et), Q(0);
        },
        onOrderChange: (et) => {
          C(et), Q(0);
        }
      }
    ),
    /* @__PURE__ */ ee.jsxs("div", { className: "card p-3 mb-4", children: [
      /* @__PURE__ */ ee.jsx("h2", { className: "card-title", children: " Najblisza apteka" }),
      /* @__PURE__ */ ee.jsx(
        Iz,
        {
          offers: h,
          center: h.length && h[0].pharmacy_lat && h[0].pharmacy_lon ? [h[0].pharmacy_lat, h[0].pharmacy_lon] : void 0
        }
      )
    ] }),
    /* @__PURE__ */ ee.jsxs("div", { className: "card p-3 mb-4", children: [
      /* @__PURE__ */ ee.jsx("h2", { className: "card-title", children: " Najtasze oferty" }),
      /* @__PURE__ */ ee.jsx(IE, { offers: h }),
      /* @__PURE__ */ ee.jsx($E, { total: z, limit: X, offset: J, onChange: Q }),
      /* @__PURE__ */ ee.jsxs("div", { id: "countInfo", className: "mb-2 text-muted", children: [
        "Wywietlasz ",
        J + 1,
        "",
        Math.min(J + X, z),
        " z ",
        z,
        " ofert"
      ] })
    ] }),
    /* @__PURE__ */ ee.jsxs("div", { className: "card p-3 mb-4", children: [
      /* @__PURE__ */ ee.jsx("h2", { className: "card-title", children: " Trend cen wg daty" }),
      /* @__PURE__ */ ee.jsx(Qz, { data: _ })
    ] })
  ] });
}
QE.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ ee.jsx($i.StrictMode, { children: /* @__PURE__ */ ee.jsx($z, {}) })
);
