function HE(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var W_ = { exports: {} }, Qy = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BT;
function kE() {
  if (BT) return Qy;
  BT = 1;
  var s = Symbol.for("react.transitional.element"), i = Symbol.for("react.fragment");
  function l(u, h, g) {
    var _ = null;
    if (g !== void 0 && (_ = "" + g), h.key !== void 0 && (_ = "" + h.key), "key" in h) {
      g = {};
      for (var S in h)
        S !== "key" && (g[S] = h[S]);
    } else g = h;
    return h = g.ref, {
      $$typeof: s,
      type: u,
      key: _,
      ref: h !== void 0 ? h : null,
      props: g
    };
  }
  return Qy.Fragment = i, Qy.jsx = l, Qy.jsxs = l, Qy;
}
var Ky = {}, I_ = { exports: {} }, Re = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var YT;
function NE() {
  if (YT) return Re;
  YT = 1;
  var s = Symbol.for("react.transitional.element"), i = Symbol.for("react.portal"), l = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), h = Symbol.for("react.profiler"), g = Symbol.for("react.consumer"), _ = Symbol.for("react.context"), S = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), E = Symbol.for("react.memo"), D = Symbol.for("react.lazy"), C = Symbol.iterator;
  function z(k) {
    return k === null || typeof k != "object" ? null : (k = C && k[C] || k["@@iterator"], typeof k == "function" ? k : null);
  }
  var j = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, I = Object.assign, Q = {};
  function X(k, F, ct) {
    this.props = k, this.context = F, this.refs = Q, this.updater = ct || j;
  }
  X.prototype.isReactComponent = {}, X.prototype.setState = function(k, F) {
    if (typeof k != "object" && typeof k != "function" && k != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, k, F, "setState");
  }, X.prototype.forceUpdate = function(k) {
    this.updater.enqueueForceUpdate(this, k, "forceUpdate");
  };
  function nt() {
  }
  nt.prototype = X.prototype;
  function Dt(k, F, ct) {
    this.props = k, this.context = F, this.refs = Q, this.updater = ct || j;
  }
  var Et = Dt.prototype = new nt();
  Et.constructor = Dt, I(Et, X.prototype), Et.isPureReactComponent = !0;
  var zt = Array.isArray, dt = { H: null, A: null, T: null, S: null, V: null }, Lt = Object.prototype.hasOwnProperty;
  function Ct(k, F, ct, bt, Mt, Ht) {
    return ct = Ht.ref, {
      $$typeof: s,
      type: k,
      key: F,
      ref: ct !== void 0 ? ct : null,
      props: Ht
    };
  }
  function Yt(k, F) {
    return Ct(
      k.type,
      F,
      void 0,
      void 0,
      void 0,
      k.props
    );
  }
  function wt(k) {
    return typeof k == "object" && k !== null && k.$$typeof === s;
  }
  function ne(k) {
    var F = { "=": "=0", ":": "=2" };
    return "$" + k.replace(/[=:]/g, function(ct) {
      return F[ct];
    });
  }
  var Rt = /\/+/g;
  function Nt(k, F) {
    return typeof k == "object" && k !== null && k.key != null ? ne("" + k.key) : F.toString(36);
  }
  function Ee() {
  }
  function ge(k) {
    switch (k.status) {
      case "fulfilled":
        return k.value;
      case "rejected":
        throw k.reason;
      default:
        switch (typeof k.status == "string" ? k.then(Ee, Ee) : (k.status = "pending", k.then(
          function(F) {
            k.status === "pending" && (k.status = "fulfilled", k.value = F);
          },
          function(F) {
            k.status === "pending" && (k.status = "rejected", k.reason = F);
          }
        )), k.status) {
          case "fulfilled":
            return k.value;
          case "rejected":
            throw k.reason;
        }
    }
    throw k;
  }
  function Jt(k, F, ct, bt, Mt) {
    var Ht = typeof k;
    (Ht === "undefined" || Ht === "boolean") && (k = null);
    var Tt = !1;
    if (k === null) Tt = !0;
    else
      switch (Ht) {
        case "bigint":
        case "string":
        case "number":
          Tt = !0;
          break;
        case "object":
          switch (k.$$typeof) {
            case s:
            case i:
              Tt = !0;
              break;
            case D:
              return Tt = k._init, Jt(
                Tt(k._payload),
                F,
                ct,
                bt,
                Mt
              );
          }
      }
    if (Tt)
      return Mt = Mt(k), Tt = bt === "" ? "." + Nt(k, 0) : bt, zt(Mt) ? (ct = "", Tt != null && (ct = Tt.replace(Rt, "$&/") + "/"), Jt(Mt, F, ct, "", function(on) {
        return on;
      })) : Mt != null && (wt(Mt) && (Mt = Yt(
        Mt,
        ct + (Mt.key == null || k && k.key === Mt.key ? "" : ("" + Mt.key).replace(
          Rt,
          "$&/"
        ) + "/") + Tt
      )), F.push(Mt)), 1;
    Tt = 0;
    var We = bt === "" ? "." : bt + ":";
    if (zt(k))
      for (var Ft = 0; Ft < k.length; Ft++)
        bt = k[Ft], Ht = We + Nt(bt, Ft), Tt += Jt(
          bt,
          F,
          ct,
          Ht,
          Mt
        );
    else if (Ft = z(k), typeof Ft == "function")
      for (k = Ft.call(k), Ft = 0; !(bt = k.next()).done; )
        bt = bt.value, Ht = We + Nt(bt, Ft++), Tt += Jt(
          bt,
          F,
          ct,
          Ht,
          Mt
        );
    else if (Ht === "object") {
      if (typeof k.then == "function")
        return Jt(
          ge(k),
          F,
          ct,
          bt,
          Mt
        );
      throw F = String(k), Error(
        "Objects are not valid as a React child (found: " + (F === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : F) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return Tt;
  }
  function V(k, F, ct) {
    if (k == null) return k;
    var bt = [], Mt = 0;
    return Jt(k, bt, "", "", function(Ht) {
      return F.call(ct, Ht, Mt++);
    }), bt;
  }
  function mt(k) {
    if (k._status === -1) {
      var F = k._result;
      F = F(), F.then(
        function(ct) {
          (k._status === 0 || k._status === -1) && (k._status = 1, k._result = ct);
        },
        function(ct) {
          (k._status === 0 || k._status === -1) && (k._status = 2, k._result = ct);
        }
      ), k._status === -1 && (k._status = 0, k._result = F);
    }
    if (k._status === 1) return k._result.default;
    throw k._result;
  }
  var ut = typeof reportError == "function" ? reportError : function(k) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var F = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof k == "object" && k !== null && typeof k.message == "string" ? String(k.message) : String(k),
        error: k
      });
      if (!window.dispatchEvent(F)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", k);
      return;
    }
    console.error(k);
  };
  function Gt() {
  }
  return Re.Children = {
    map: V,
    forEach: function(k, F, ct) {
      V(
        k,
        function() {
          F.apply(this, arguments);
        },
        ct
      );
    },
    count: function(k) {
      var F = 0;
      return V(k, function() {
        F++;
      }), F;
    },
    toArray: function(k) {
      return V(k, function(F) {
        return F;
      }) || [];
    },
    only: function(k) {
      if (!wt(k))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return k;
    }
  }, Re.Component = X, Re.Fragment = l, Re.Profiler = h, Re.PureComponent = Dt, Re.StrictMode = u, Re.Suspense = T, Re.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = dt, Re.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(k) {
      return dt.H.useMemoCache(k);
    }
  }, Re.cache = function(k) {
    return function() {
      return k.apply(null, arguments);
    };
  }, Re.cloneElement = function(k, F, ct) {
    if (k == null)
      throw Error(
        "The argument must be a React element, but you passed " + k + "."
      );
    var bt = I({}, k.props), Mt = k.key, Ht = void 0;
    if (F != null)
      for (Tt in F.ref !== void 0 && (Ht = void 0), F.key !== void 0 && (Mt = "" + F.key), F)
        !Lt.call(F, Tt) || Tt === "key" || Tt === "__self" || Tt === "__source" || Tt === "ref" && F.ref === void 0 || (bt[Tt] = F[Tt]);
    var Tt = arguments.length - 2;
    if (Tt === 1) bt.children = ct;
    else if (1 < Tt) {
      for (var We = Array(Tt), Ft = 0; Ft < Tt; Ft++)
        We[Ft] = arguments[Ft + 2];
      bt.children = We;
    }
    return Ct(k.type, Mt, void 0, void 0, Ht, bt);
  }, Re.createContext = function(k) {
    return k = {
      $$typeof: _,
      _currentValue: k,
      _currentValue2: k,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, k.Provider = k, k.Consumer = {
      $$typeof: g,
      _context: k
    }, k;
  }, Re.createElement = function(k, F, ct) {
    var bt, Mt = {}, Ht = null;
    if (F != null)
      for (bt in F.key !== void 0 && (Ht = "" + F.key), F)
        Lt.call(F, bt) && bt !== "key" && bt !== "__self" && bt !== "__source" && (Mt[bt] = F[bt]);
    var Tt = arguments.length - 2;
    if (Tt === 1) Mt.children = ct;
    else if (1 < Tt) {
      for (var We = Array(Tt), Ft = 0; Ft < Tt; Ft++)
        We[Ft] = arguments[Ft + 2];
      Mt.children = We;
    }
    if (k && k.defaultProps)
      for (bt in Tt = k.defaultProps, Tt)
        Mt[bt] === void 0 && (Mt[bt] = Tt[bt]);
    return Ct(k, Ht, void 0, void 0, null, Mt);
  }, Re.createRef = function() {
    return { current: null };
  }, Re.forwardRef = function(k) {
    return { $$typeof: S, render: k };
  }, Re.isValidElement = wt, Re.lazy = function(k) {
    return {
      $$typeof: D,
      _payload: { _status: -1, _result: k },
      _init: mt
    };
  }, Re.memo = function(k, F) {
    return {
      $$typeof: E,
      type: k,
      compare: F === void 0 ? null : F
    };
  }, Re.startTransition = function(k) {
    var F = dt.T, ct = {};
    dt.T = ct;
    try {
      var bt = k(), Mt = dt.S;
      Mt !== null && Mt(ct, bt), typeof bt == "object" && bt !== null && typeof bt.then == "function" && bt.then(Gt, ut);
    } catch (Ht) {
      ut(Ht);
    } finally {
      dt.T = F;
    }
  }, Re.unstable_useCacheRefresh = function() {
    return dt.H.useCacheRefresh();
  }, Re.use = function(k) {
    return dt.H.use(k);
  }, Re.useActionState = function(k, F, ct) {
    return dt.H.useActionState(k, F, ct);
  }, Re.useCallback = function(k, F) {
    return dt.H.useCallback(k, F);
  }, Re.useContext = function(k) {
    return dt.H.useContext(k);
  }, Re.useDebugValue = function() {
  }, Re.useDeferredValue = function(k, F) {
    return dt.H.useDeferredValue(k, F);
  }, Re.useEffect = function(k, F, ct) {
    var bt = dt.H;
    if (typeof ct == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return bt.useEffect(k, F);
  }, Re.useId = function() {
    return dt.H.useId();
  }, Re.useImperativeHandle = function(k, F, ct) {
    return dt.H.useImperativeHandle(k, F, ct);
  }, Re.useInsertionEffect = function(k, F) {
    return dt.H.useInsertionEffect(k, F);
  }, Re.useLayoutEffect = function(k, F) {
    return dt.H.useLayoutEffect(k, F);
  }, Re.useMemo = function(k, F) {
    return dt.H.useMemo(k, F);
  }, Re.useOptimistic = function(k, F) {
    return dt.H.useOptimistic(k, F);
  }, Re.useReducer = function(k, F, ct) {
    return dt.H.useReducer(k, F, ct);
  }, Re.useRef = function(k) {
    return dt.H.useRef(k);
  }, Re.useState = function(k) {
    return dt.H.useState(k);
  }, Re.useSyncExternalStore = function(k, F, ct) {
    return dt.H.useSyncExternalStore(
      k,
      F,
      ct
    );
  }, Re.useTransition = function() {
    return dt.H.useTransition();
  }, Re.version = "19.1.1", Re;
}
var ov = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
ov.exports;
var jT;
function UE() {
  return jT || (jT = 1, function(s, i) {
    process.env.NODE_ENV !== "production" && function() {
      function l(N, J) {
        Object.defineProperty(g.prototype, N, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              J[0],
              J[1]
            );
          }
        });
      }
      function u(N) {
        return N === null || typeof N != "object" ? null : (N = da && N[da] || N["@@iterator"], typeof N == "function" ? N : null);
      }
      function h(N, J) {
        N = (N = N.constructor) && (N.displayName || N.name) || "ReactClass";
        var At = N + "." + J;
        Za[At] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          J,
          N
        ), Za[At] = !0);
      }
      function g(N, J, At) {
        this.props = N, this.context = J, this.refs = cr, this.updater = At || ma;
      }
      function _() {
      }
      function S(N, J, At) {
        this.props = N, this.context = J, this.refs = cr, this.updater = At || ma;
      }
      function T(N) {
        return "" + N;
      }
      function E(N) {
        try {
          T(N);
          var J = !1;
        } catch {
          J = !0;
        }
        if (J) {
          J = console;
          var At = J.error, kt = typeof Symbol == "function" && Symbol.toStringTag && N[Symbol.toStringTag] || N.constructor.name || "Object";
          return At.call(
            J,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            kt
          ), T(N);
        }
      }
      function D(N) {
        if (N == null) return null;
        if (typeof N == "function")
          return N.$$typeof === dc ? null : N.displayName || N.name || null;
        if (typeof N == "string") return N;
        switch (N) {
          case k:
            return "Fragment";
          case ct:
            return "Profiler";
          case F:
            return "StrictMode";
          case Tt:
            return "Suspense";
          case We:
            return "SuspenseList";
          case fi:
            return "Activity";
        }
        if (typeof N == "object")
          switch (typeof N.tag == "number" && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), N.$$typeof) {
            case Gt:
              return "Portal";
            case Mt:
              return (N.displayName || "Context") + ".Provider";
            case bt:
              return (N._context.displayName || "Context") + ".Consumer";
            case Ht:
              var J = N.render;
              return N = N.displayName, N || (N = J.displayName || J.name || "", N = N !== "" ? "ForwardRef(" + N + ")" : "ForwardRef"), N;
            case Ft:
              return J = N.displayName || null, J !== null ? J : D(N.type) || "Memo";
            case on:
              J = N._payload, N = N._init;
              try {
                return D(N(J));
              } catch {
              }
          }
        return null;
      }
      function C(N) {
        if (N === k) return "<>";
        if (typeof N == "object" && N !== null && N.$$typeof === on)
          return "<...>";
        try {
          var J = D(N);
          return J ? "<" + J + ">" : "<...>";
        } catch {
          return "<...>";
        }
      }
      function z() {
        var N = pe.A;
        return N === null ? null : N.getOwner();
      }
      function j() {
        return Error("react-stack-top-frame");
      }
      function I(N) {
        if (pa.call(N, "key")) {
          var J = Object.getOwnPropertyDescriptor(N, "key").get;
          if (J && J.isReactWarning) return !1;
        }
        return N.key !== void 0;
      }
      function Q(N, J) {
        function At() {
          po || (po = !0, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            J
          ));
        }
        At.isReactWarning = !0, Object.defineProperty(N, "key", {
          get: At,
          configurable: !0
        });
      }
      function X() {
        var N = D(this.type);
        return hu[N] || (hu[N] = !0, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        )), N = this.props.ref, N !== void 0 ? N : null;
      }
      function nt(N, J, At, kt, Xt, se, he, ze) {
        return At = se.ref, N = {
          $$typeof: ut,
          type: N,
          key: J,
          props: se,
          _owner: Xt
        }, (At !== void 0 ? At : null) !== null ? Object.defineProperty(N, "ref", {
          enumerable: !1,
          get: X
        }) : Object.defineProperty(N, "ref", { enumerable: !1, value: null }), N._store = {}, Object.defineProperty(N._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: 0
        }), Object.defineProperty(N, "_debugInfo", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: null
        }), Object.defineProperty(N, "_debugStack", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: he
        }), Object.defineProperty(N, "_debugTask", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: ze
        }), Object.freeze && (Object.freeze(N.props), Object.freeze(N)), N;
      }
      function Dt(N, J) {
        return J = nt(
          N.type,
          J,
          void 0,
          void 0,
          N._owner,
          N.props,
          N._debugStack,
          N._debugTask
        ), N._store && (J._store.validated = N._store.validated), J;
      }
      function Et(N) {
        return typeof N == "object" && N !== null && N.$$typeof === ut;
      }
      function zt(N) {
        var J = { "=": "=0", ":": "=2" };
        return "$" + N.replace(/[=:]/g, function(At) {
          return J[At];
        });
      }
      function dt(N, J) {
        return typeof N == "object" && N !== null && N.key != null ? (E(N.key), zt("" + N.key)) : J.toString(36);
      }
      function Lt() {
      }
      function Ct(N) {
        switch (N.status) {
          case "fulfilled":
            return N.value;
          case "rejected":
            throw N.reason;
          default:
            switch (typeof N.status == "string" ? N.then(Lt, Lt) : (N.status = "pending", N.then(
              function(J) {
                N.status === "pending" && (N.status = "fulfilled", N.value = J);
              },
              function(J) {
                N.status === "pending" && (N.status = "rejected", N.reason = J);
              }
            )), N.status) {
              case "fulfilled":
                return N.value;
              case "rejected":
                throw N.reason;
            }
        }
        throw N;
      }
      function Yt(N, J, At, kt, Xt) {
        var se = typeof N;
        (se === "undefined" || se === "boolean") && (N = null);
        var he = !1;
        if (N === null) he = !0;
        else
          switch (se) {
            case "bigint":
            case "string":
            case "number":
              he = !0;
              break;
            case "object":
              switch (N.$$typeof) {
                case ut:
                case Gt:
                  he = !0;
                  break;
                case on:
                  return he = N._init, Yt(
                    he(N._payload),
                    J,
                    At,
                    kt,
                    Xt
                  );
              }
          }
        if (he) {
          he = N, Xt = Xt(he);
          var ze = kt === "" ? "." + dt(he, 0) : kt;
          return Pa(Xt) ? (At = "", ze != null && (At = ze.replace($n, "$&/") + "/"), Yt(Xt, J, At, "", function(On) {
            return On;
          })) : Xt != null && (Et(Xt) && (Xt.key != null && (he && he.key === Xt.key || E(Xt.key)), At = Dt(
            Xt,
            At + (Xt.key == null || he && he.key === Xt.key ? "" : ("" + Xt.key).replace(
              $n,
              "$&/"
            ) + "/") + ze
          ), kt !== "" && he != null && Et(he) && he.key == null && he._store && !he._store.validated && (At._store.validated = 2), Xt = At), J.push(Xt)), 1;
        }
        if (he = 0, ze = kt === "" ? "." : kt + ":", Pa(N))
          for (var fe = 0; fe < N.length; fe++)
            kt = N[fe], se = ze + dt(kt, fe), he += Yt(
              kt,
              J,
              At,
              se,
              Xt
            );
        else if (fe = u(N), typeof fe == "function")
          for (fe === N.entries && (ta || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), ta = !0), N = fe.call(N), fe = 0; !(kt = N.next()).done; )
            kt = kt.value, se = ze + dt(kt, fe++), he += Yt(
              kt,
              J,
              At,
              se,
              Xt
            );
        else if (se === "object") {
          if (typeof N.then == "function")
            return Yt(
              Ct(N),
              J,
              At,
              kt,
              Xt
            );
          throw J = String(N), Error(
            "Objects are not valid as a React child (found: " + (J === "[object Object]" ? "object with keys {" + Object.keys(N).join(", ") + "}" : J) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return he;
      }
      function wt(N, J, At) {
        if (N == null) return N;
        var kt = [], Xt = 0;
        return Yt(N, kt, "", "", function(se) {
          return J.call(At, se, Xt++);
        }), kt;
      }
      function ne(N) {
        if (N._status === -1) {
          var J = N._result;
          J = J(), J.then(
            function(At) {
              (N._status === 0 || N._status === -1) && (N._status = 1, N._result = At);
            },
            function(At) {
              (N._status === 0 || N._status === -1) && (N._status = 2, N._result = At);
            }
          ), N._status === -1 && (N._status = 0, N._result = J);
        }
        if (N._status === 1)
          return J = N._result, J === void 0 && console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,
            J
          ), "default" in J || console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,
            J
          ), J.default;
        throw N._result;
      }
      function Rt() {
        var N = pe.H;
        return N === null && console.error(
          `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
        ), N;
      }
      function Nt() {
      }
      function Ee(N) {
        if (hr === null)
          try {
            var J = ("require" + Math.random()).slice(0, 7);
            hr = (s && s[J]).call(
              s,
              "timers"
            ).setImmediate;
          } catch {
            hr = function(kt) {
              fr === !1 && (fr = !0, typeof MessageChannel > "u" && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var Xt = new MessageChannel();
              Xt.port1.onmessage = kt, Xt.port2.postMessage(void 0);
            };
          }
        return hr(N);
      }
      function ge(N) {
        return 1 < N.length && typeof AggregateError == "function" ? new AggregateError(N) : N[0];
      }
      function Jt(N, J) {
        J !== ga - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        ), ga = J;
      }
      function V(N, J, At) {
        var kt = pe.actQueue;
        if (kt !== null)
          if (kt.length !== 0)
            try {
              mt(kt), Ee(function() {
                return V(N, J, At);
              });
              return;
            } catch (Xt) {
              pe.thrownErrors.push(Xt);
            }
          else pe.actQueue = null;
        0 < pe.thrownErrors.length ? (kt = ge(pe.thrownErrors), pe.thrownErrors.length = 0, At(kt)) : J(N);
      }
      function mt(N) {
        if (!Pn) {
          Pn = !0;
          var J = 0;
          try {
            for (; J < N.length; J++) {
              var At = N[J];
              do {
                pe.didUsePromise = !1;
                var kt = At(!1);
                if (kt !== null) {
                  if (pe.didUsePromise) {
                    N[J] = At, N.splice(0, J);
                    return;
                  }
                  At = kt;
                } else break;
              } while (!0);
            }
            N.length = 0;
          } catch (Xt) {
            N.splice(0, J + 1), pe.thrownErrors.push(Xt);
          } finally {
            Pn = !1;
          }
        }
      }
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var ut = Symbol.for("react.transitional.element"), Gt = Symbol.for("react.portal"), k = Symbol.for("react.fragment"), F = Symbol.for("react.strict_mode"), ct = Symbol.for("react.profiler"), bt = Symbol.for("react.consumer"), Mt = Symbol.for("react.context"), Ht = Symbol.for("react.forward_ref"), Tt = Symbol.for("react.suspense"), We = Symbol.for("react.suspense_list"), Ft = Symbol.for("react.memo"), on = Symbol.for("react.lazy"), fi = Symbol.for("react.activity"), da = Symbol.iterator, Za = {}, ma = {
        isMounted: function() {
          return !1;
        },
        enqueueForceUpdate: function(N) {
          h(N, "forceUpdate");
        },
        enqueueReplaceState: function(N) {
          h(N, "replaceState");
        },
        enqueueSetState: function(N) {
          h(N, "setState");
        }
      }, ur = Object.assign, cr = {};
      Object.freeze(cr), g.prototype.isReactComponent = {}, g.prototype.setState = function(N, J) {
        if (typeof N != "object" && typeof N != "function" && N != null)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, N, J, "setState");
      }, g.prototype.forceUpdate = function(N) {
        this.updater.enqueueForceUpdate(this, N, "forceUpdate");
      };
      var Tn = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, En;
      for (En in Tn)
        Tn.hasOwnProperty(En) && l(En, Tn[En]);
      _.prototype = g.prototype, Tn = S.prototype = new _(), Tn.constructor = S, ur(Tn, g.prototype), Tn.isPureReactComponent = !0;
      var Pa = Array.isArray, dc = Symbol.for("react.client.reference"), pe = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, pa = Object.prototype.hasOwnProperty, vs = console.createTask ? console.createTask : function() {
        return null;
      };
      Tn = {
        react_stack_bottom_frame: function(N) {
          return N();
        }
      };
      var po, mc, hu = {}, go = Tn.react_stack_bottom_frame.bind(
        Tn,
        j
      )(), Zn = vs(C(j)), ta = !1, $n = /\/+/g, _s = typeof reportError == "function" ? reportError : function(N) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var J = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof N == "object" && N !== null && typeof N.message == "string" ? String(N.message) : String(N),
            error: N
          });
          if (!window.dispatchEvent(J)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", N);
          return;
        }
        console.error(N);
      }, fr = !1, hr = null, ga = 0, hi = !1, Pn = !1, Va = typeof queueMicrotask == "function" ? function(N) {
        queueMicrotask(function() {
          return queueMicrotask(N);
        });
      } : Ee;
      Tn = Object.freeze({
        __proto__: null,
        c: function(N) {
          return Rt().useMemoCache(N);
        }
      }), i.Children = {
        map: wt,
        forEach: function(N, J, At) {
          wt(
            N,
            function() {
              J.apply(this, arguments);
            },
            At
          );
        },
        count: function(N) {
          var J = 0;
          return wt(N, function() {
            J++;
          }), J;
        },
        toArray: function(N) {
          return wt(N, function(J) {
            return J;
          }) || [];
        },
        only: function(N) {
          if (!Et(N))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return N;
        }
      }, i.Component = g, i.Fragment = k, i.Profiler = ct, i.PureComponent = S, i.StrictMode = F, i.Suspense = Tt, i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = pe, i.__COMPILER_RUNTIME = Tn, i.act = function(N) {
        var J = pe.actQueue, At = ga;
        ga++;
        var kt = pe.actQueue = J !== null ? J : [], Xt = !1;
        try {
          var se = N();
        } catch (fe) {
          pe.thrownErrors.push(fe);
        }
        if (0 < pe.thrownErrors.length)
          throw Jt(J, At), N = ge(pe.thrownErrors), pe.thrownErrors.length = 0, N;
        if (se !== null && typeof se == "object" && typeof se.then == "function") {
          var he = se;
          return Va(function() {
            Xt || hi || (hi = !0, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          }), {
            then: function(fe, On) {
              Xt = !0, he.then(
                function(Ga) {
                  if (Jt(J, At), At === 0) {
                    try {
                      mt(kt), Ee(function() {
                        return V(
                          Ga,
                          fe,
                          On
                        );
                      });
                    } catch (du) {
                      pe.thrownErrors.push(du);
                    }
                    if (0 < pe.thrownErrors.length) {
                      var pc = ge(
                        pe.thrownErrors
                      );
                      pe.thrownErrors.length = 0, On(pc);
                    }
                  } else fe(Ga);
                },
                function(Ga) {
                  Jt(J, At), 0 < pe.thrownErrors.length && (Ga = ge(
                    pe.thrownErrors
                  ), pe.thrownErrors.length = 0), On(Ga);
                }
              );
            }
          };
        }
        var ze = se;
        if (Jt(J, At), At === 0 && (mt(kt), kt.length !== 0 && Va(function() {
          Xt || hi || (hi = !0, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), pe.actQueue = null), 0 < pe.thrownErrors.length)
          throw N = ge(pe.thrownErrors), pe.thrownErrors.length = 0, N;
        return {
          then: function(fe, On) {
            Xt = !0, At === 0 ? (pe.actQueue = kt, Ee(function() {
              return V(
                ze,
                fe,
                On
              );
            })) : fe(ze);
          }
        };
      }, i.cache = function(N) {
        return function() {
          return N.apply(null, arguments);
        };
      }, i.captureOwnerStack = function() {
        var N = pe.getCurrentStack;
        return N === null ? null : N();
      }, i.cloneElement = function(N, J, At) {
        if (N == null)
          throw Error(
            "The argument must be a React element, but you passed " + N + "."
          );
        var kt = ur({}, N.props), Xt = N.key, se = N._owner;
        if (J != null) {
          var he;
          t: {
            if (pa.call(J, "ref") && (he = Object.getOwnPropertyDescriptor(
              J,
              "ref"
            ).get) && he.isReactWarning) {
              he = !1;
              break t;
            }
            he = J.ref !== void 0;
          }
          he && (se = z()), I(J) && (E(J.key), Xt = "" + J.key);
          for (ze in J)
            !pa.call(J, ze) || ze === "key" || ze === "__self" || ze === "__source" || ze === "ref" && J.ref === void 0 || (kt[ze] = J[ze]);
        }
        var ze = arguments.length - 2;
        if (ze === 1) kt.children = At;
        else if (1 < ze) {
          he = Array(ze);
          for (var fe = 0; fe < ze; fe++)
            he[fe] = arguments[fe + 2];
          kt.children = he;
        }
        for (kt = nt(
          N.type,
          Xt,
          void 0,
          void 0,
          se,
          kt,
          N._debugStack,
          N._debugTask
        ), Xt = 2; Xt < arguments.length; Xt++)
          se = arguments[Xt], Et(se) && se._store && (se._store.validated = 1);
        return kt;
      }, i.createContext = function(N) {
        return N = {
          $$typeof: Mt,
          _currentValue: N,
          _currentValue2: N,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }, N.Provider = N, N.Consumer = {
          $$typeof: bt,
          _context: N
        }, N._currentRenderer = null, N._currentRenderer2 = null, N;
      }, i.createElement = function(N, J, At) {
        for (var kt = 2; kt < arguments.length; kt++) {
          var Xt = arguments[kt];
          Et(Xt) && Xt._store && (Xt._store.validated = 1);
        }
        if (kt = {}, Xt = null, J != null)
          for (fe in mc || !("__self" in J) || "key" in J || (mc = !0, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), I(J) && (E(J.key), Xt = "" + J.key), J)
            pa.call(J, fe) && fe !== "key" && fe !== "__self" && fe !== "__source" && (kt[fe] = J[fe]);
        var se = arguments.length - 2;
        if (se === 1) kt.children = At;
        else if (1 < se) {
          for (var he = Array(se), ze = 0; ze < se; ze++)
            he[ze] = arguments[ze + 2];
          Object.freeze && Object.freeze(he), kt.children = he;
        }
        if (N && N.defaultProps)
          for (fe in se = N.defaultProps, se)
            kt[fe] === void 0 && (kt[fe] = se[fe]);
        Xt && Q(
          kt,
          typeof N == "function" ? N.displayName || N.name || "Unknown" : N
        );
        var fe = 1e4 > pe.recentlyCreatedOwnerStacks++;
        return nt(
          N,
          Xt,
          void 0,
          void 0,
          z(),
          kt,
          fe ? Error("react-stack-top-frame") : go,
          fe ? vs(C(N)) : Zn
        );
      }, i.createRef = function() {
        var N = { current: null };
        return Object.seal(N), N;
      }, i.forwardRef = function(N) {
        N != null && N.$$typeof === Ft ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : typeof N != "function" ? console.error(
          "forwardRef requires a render function but was given %s.",
          N === null ? "null" : typeof N
        ) : N.length !== 0 && N.length !== 2 && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          N.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        ), N != null && N.defaultProps != null && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var J = { $$typeof: Ht, render: N }, At;
        return Object.defineProperty(J, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return At;
          },
          set: function(kt) {
            At = kt, N.name || N.displayName || (Object.defineProperty(N, "name", { value: kt }), N.displayName = kt);
          }
        }), J;
      }, i.isValidElement = Et, i.lazy = function(N) {
        return {
          $$typeof: on,
          _payload: { _status: -1, _result: N },
          _init: ne
        };
      }, i.memo = function(N, J) {
        N == null && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          N === null ? "null" : typeof N
        ), J = {
          $$typeof: Ft,
          type: N,
          compare: J === void 0 ? null : J
        };
        var At;
        return Object.defineProperty(J, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return At;
          },
          set: function(kt) {
            At = kt, N.name || N.displayName || (Object.defineProperty(N, "name", { value: kt }), N.displayName = kt);
          }
        }), J;
      }, i.startTransition = function(N) {
        var J = pe.T, At = {};
        pe.T = At, At._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var kt = N(), Xt = pe.S;
          Xt !== null && Xt(At, kt), typeof kt == "object" && kt !== null && typeof kt.then == "function" && kt.then(Nt, _s);
        } catch (se) {
          _s(se);
        } finally {
          J === null && At._updatedFibers && (N = At._updatedFibers.size, At._updatedFibers.clear(), 10 < N && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), pe.T = J;
        }
      }, i.unstable_useCacheRefresh = function() {
        return Rt().useCacheRefresh();
      }, i.use = function(N) {
        return Rt().use(N);
      }, i.useActionState = function(N, J, At) {
        return Rt().useActionState(
          N,
          J,
          At
        );
      }, i.useCallback = function(N, J) {
        return Rt().useCallback(N, J);
      }, i.useContext = function(N) {
        var J = Rt();
        return N.$$typeof === bt && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        ), J.useContext(N);
      }, i.useDebugValue = function(N, J) {
        return Rt().useDebugValue(N, J);
      }, i.useDeferredValue = function(N, J) {
        return Rt().useDeferredValue(N, J);
      }, i.useEffect = function(N, J, At) {
        N == null && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var kt = Rt();
        if (typeof At == "function")
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return kt.useEffect(N, J);
      }, i.useId = function() {
        return Rt().useId();
      }, i.useImperativeHandle = function(N, J, At) {
        return Rt().useImperativeHandle(N, J, At);
      }, i.useInsertionEffect = function(N, J) {
        return N == null && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        ), Rt().useInsertionEffect(N, J);
      }, i.useLayoutEffect = function(N, J) {
        return N == null && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        ), Rt().useLayoutEffect(N, J);
      }, i.useMemo = function(N, J) {
        return Rt().useMemo(N, J);
      }, i.useOptimistic = function(N, J) {
        return Rt().useOptimistic(N, J);
      }, i.useReducer = function(N, J, At) {
        return Rt().useReducer(N, J, At);
      }, i.useRef = function(N) {
        return Rt().useRef(N);
      }, i.useState = function(N) {
        return Rt().useState(N);
      }, i.useSyncExternalStore = function(N, J, At) {
        return Rt().useSyncExternalStore(
          N,
          J,
          At
        );
      }, i.useTransition = function() {
        return Rt().useTransition();
      }, i.version = "19.1.1", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(ov, ov.exports)), ov.exports;
}
var qT;
function Np() {
  return qT || (qT = 1, process.env.NODE_ENV === "production" ? I_.exports = NE() : I_.exports = UE()), I_.exports;
}
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZT;
function BE() {
  return ZT || (ZT = 1, process.env.NODE_ENV !== "production" && function() {
    function s(k) {
      if (k == null) return null;
      if (typeof k == "function")
        return k.$$typeof === ne ? null : k.displayName || k.name || null;
      if (typeof k == "string") return k;
      switch (k) {
        case Q:
          return "Fragment";
        case nt:
          return "Profiler";
        case X:
          return "StrictMode";
        case dt:
          return "Suspense";
        case Lt:
          return "SuspenseList";
        case wt:
          return "Activity";
      }
      if (typeof k == "object")
        switch (typeof k.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), k.$$typeof) {
          case I:
            return "Portal";
          case Et:
            return (k.displayName || "Context") + ".Provider";
          case Dt:
            return (k._context.displayName || "Context") + ".Consumer";
          case zt:
            var F = k.render;
            return k = k.displayName, k || (k = F.displayName || F.name || "", k = k !== "" ? "ForwardRef(" + k + ")" : "ForwardRef"), k;
          case Ct:
            return F = k.displayName || null, F !== null ? F : s(k.type) || "Memo";
          case Yt:
            F = k._payload, k = k._init;
            try {
              return s(k(F));
            } catch {
            }
        }
      return null;
    }
    function i(k) {
      return "" + k;
    }
    function l(k) {
      try {
        i(k);
        var F = !1;
      } catch {
        F = !0;
      }
      if (F) {
        F = console;
        var ct = F.error, bt = typeof Symbol == "function" && Symbol.toStringTag && k[Symbol.toStringTag] || k.constructor.name || "Object";
        return ct.call(
          F,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          bt
        ), i(k);
      }
    }
    function u(k) {
      if (k === Q) return "<>";
      if (typeof k == "object" && k !== null && k.$$typeof === Yt)
        return "<...>";
      try {
        var F = s(k);
        return F ? "<" + F + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function h() {
      var k = Rt.A;
      return k === null ? null : k.getOwner();
    }
    function g() {
      return Error("react-stack-top-frame");
    }
    function _(k) {
      if (Nt.call(k, "key")) {
        var F = Object.getOwnPropertyDescriptor(k, "key").get;
        if (F && F.isReactWarning) return !1;
      }
      return k.key !== void 0;
    }
    function S(k, F) {
      function ct() {
        Jt || (Jt = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          F
        ));
      }
      ct.isReactWarning = !0, Object.defineProperty(k, "key", {
        get: ct,
        configurable: !0
      });
    }
    function T() {
      var k = s(this.type);
      return V[k] || (V[k] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), k = this.props.ref, k !== void 0 ? k : null;
    }
    function E(k, F, ct, bt, Mt, Ht, Tt, We) {
      return ct = Ht.ref, k = {
        $$typeof: j,
        type: k,
        key: F,
        props: Ht,
        _owner: Mt
      }, (ct !== void 0 ? ct : null) !== null ? Object.defineProperty(k, "ref", {
        enumerable: !1,
        get: T
      }) : Object.defineProperty(k, "ref", { enumerable: !1, value: null }), k._store = {}, Object.defineProperty(k._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(k, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(k, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: Tt
      }), Object.defineProperty(k, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: We
      }), Object.freeze && (Object.freeze(k.props), Object.freeze(k)), k;
    }
    function D(k, F, ct, bt, Mt, Ht, Tt, We) {
      var Ft = F.children;
      if (Ft !== void 0)
        if (bt)
          if (Ee(Ft)) {
            for (bt = 0; bt < Ft.length; bt++)
              C(Ft[bt]);
            Object.freeze && Object.freeze(Ft);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else C(Ft);
      if (Nt.call(F, "key")) {
        Ft = s(k);
        var on = Object.keys(F).filter(function(da) {
          return da !== "key";
        });
        bt = 0 < on.length ? "{key: someKey, " + on.join(": ..., ") + ": ...}" : "{key: someKey}", Gt[Ft + bt] || (on = 0 < on.length ? "{" + on.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          bt,
          Ft,
          on,
          Ft
        ), Gt[Ft + bt] = !0);
      }
      if (Ft = null, ct !== void 0 && (l(ct), Ft = "" + ct), _(F) && (l(F.key), Ft = "" + F.key), "key" in F) {
        ct = {};
        for (var fi in F)
          fi !== "key" && (ct[fi] = F[fi]);
      } else ct = F;
      return Ft && S(
        ct,
        typeof k == "function" ? k.displayName || k.name || "Unknown" : k
      ), E(
        k,
        Ft,
        Ht,
        Mt,
        h(),
        ct,
        Tt,
        We
      );
    }
    function C(k) {
      typeof k == "object" && k !== null && k.$$typeof === j && k._store && (k._store.validated = 1);
    }
    var z = Np(), j = Symbol.for("react.transitional.element"), I = Symbol.for("react.portal"), Q = Symbol.for("react.fragment"), X = Symbol.for("react.strict_mode"), nt = Symbol.for("react.profiler"), Dt = Symbol.for("react.consumer"), Et = Symbol.for("react.context"), zt = Symbol.for("react.forward_ref"), dt = Symbol.for("react.suspense"), Lt = Symbol.for("react.suspense_list"), Ct = Symbol.for("react.memo"), Yt = Symbol.for("react.lazy"), wt = Symbol.for("react.activity"), ne = Symbol.for("react.client.reference"), Rt = z.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Nt = Object.prototype.hasOwnProperty, Ee = Array.isArray, ge = console.createTask ? console.createTask : function() {
      return null;
    };
    z = {
      react_stack_bottom_frame: function(k) {
        return k();
      }
    };
    var Jt, V = {}, mt = z.react_stack_bottom_frame.bind(
      z,
      g
    )(), ut = ge(u(g)), Gt = {};
    Ky.Fragment = Q, Ky.jsx = function(k, F, ct, bt, Mt) {
      var Ht = 1e4 > Rt.recentlyCreatedOwnerStacks++;
      return D(
        k,
        F,
        ct,
        !1,
        bt,
        Mt,
        Ht ? Error("react-stack-top-frame") : mt,
        Ht ? ge(u(k)) : ut
      );
    }, Ky.jsxs = function(k, F, ct, bt, Mt) {
      var Ht = 1e4 > Rt.recentlyCreatedOwnerStacks++;
      return D(
        k,
        F,
        ct,
        !0,
        bt,
        Mt,
        Ht ? Error("react-stack-top-frame") : mt,
        Ht ? ge(u(k)) : ut
      );
    };
  }()), Ky;
}
var PT;
function YE() {
  return PT || (PT = 1, process.env.NODE_ENV === "production" ? W_.exports = kE() : W_.exports = BE()), W_.exports;
}
var Qt = YE(), si = Np(), $_ = { exports: {} }, Wy = {}, J_ = { exports: {} }, Gb = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VT;
function jE() {
  return VT || (VT = 1, function(s) {
    function i(V, mt) {
      var ut = V.length;
      V.push(mt);
      t: for (; 0 < ut; ) {
        var Gt = ut - 1 >>> 1, k = V[Gt];
        if (0 < h(k, mt))
          V[Gt] = mt, V[ut] = k, ut = Gt;
        else break t;
      }
    }
    function l(V) {
      return V.length === 0 ? null : V[0];
    }
    function u(V) {
      if (V.length === 0) return null;
      var mt = V[0], ut = V.pop();
      if (ut !== mt) {
        V[0] = ut;
        t: for (var Gt = 0, k = V.length, F = k >>> 1; Gt < F; ) {
          var ct = 2 * (Gt + 1) - 1, bt = V[ct], Mt = ct + 1, Ht = V[Mt];
          if (0 > h(bt, ut))
            Mt < k && 0 > h(Ht, bt) ? (V[Gt] = Ht, V[Mt] = ut, Gt = Mt) : (V[Gt] = bt, V[ct] = ut, Gt = ct);
          else if (Mt < k && 0 > h(Ht, ut))
            V[Gt] = Ht, V[Mt] = ut, Gt = Mt;
          else break t;
        }
      }
      return mt;
    }
    function h(V, mt) {
      var ut = V.sortIndex - mt.sortIndex;
      return ut !== 0 ? ut : V.id - mt.id;
    }
    if (s.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var g = performance;
      s.unstable_now = function() {
        return g.now();
      };
    } else {
      var _ = Date, S = _.now();
      s.unstable_now = function() {
        return _.now() - S;
      };
    }
    var T = [], E = [], D = 1, C = null, z = 3, j = !1, I = !1, Q = !1, X = !1, nt = typeof setTimeout == "function" ? setTimeout : null, Dt = typeof clearTimeout == "function" ? clearTimeout : null, Et = typeof setImmediate < "u" ? setImmediate : null;
    function zt(V) {
      for (var mt = l(E); mt !== null; ) {
        if (mt.callback === null) u(E);
        else if (mt.startTime <= V)
          u(E), mt.sortIndex = mt.expirationTime, i(T, mt);
        else break;
        mt = l(E);
      }
    }
    function dt(V) {
      if (Q = !1, zt(V), !I)
        if (l(T) !== null)
          I = !0, Lt || (Lt = !0, Nt());
        else {
          var mt = l(E);
          mt !== null && Jt(dt, mt.startTime - V);
        }
    }
    var Lt = !1, Ct = -1, Yt = 5, wt = -1;
    function ne() {
      return X ? !0 : !(s.unstable_now() - wt < Yt);
    }
    function Rt() {
      if (X = !1, Lt) {
        var V = s.unstable_now();
        wt = V;
        var mt = !0;
        try {
          t: {
            I = !1, Q && (Q = !1, Dt(Ct), Ct = -1), j = !0;
            var ut = z;
            try {
              e: {
                for (zt(V), C = l(T); C !== null && !(C.expirationTime > V && ne()); ) {
                  var Gt = C.callback;
                  if (typeof Gt == "function") {
                    C.callback = null, z = C.priorityLevel;
                    var k = Gt(
                      C.expirationTime <= V
                    );
                    if (V = s.unstable_now(), typeof k == "function") {
                      C.callback = k, zt(V), mt = !0;
                      break e;
                    }
                    C === l(T) && u(T), zt(V);
                  } else u(T);
                  C = l(T);
                }
                if (C !== null) mt = !0;
                else {
                  var F = l(E);
                  F !== null && Jt(
                    dt,
                    F.startTime - V
                  ), mt = !1;
                }
              }
              break t;
            } finally {
              C = null, z = ut, j = !1;
            }
            mt = void 0;
          }
        } finally {
          mt ? Nt() : Lt = !1;
        }
      }
    }
    var Nt;
    if (typeof Et == "function")
      Nt = function() {
        Et(Rt);
      };
    else if (typeof MessageChannel < "u") {
      var Ee = new MessageChannel(), ge = Ee.port2;
      Ee.port1.onmessage = Rt, Nt = function() {
        ge.postMessage(null);
      };
    } else
      Nt = function() {
        nt(Rt, 0);
      };
    function Jt(V, mt) {
      Ct = nt(function() {
        V(s.unstable_now());
      }, mt);
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(V) {
      V.callback = null;
    }, s.unstable_forceFrameRate = function(V) {
      0 > V || 125 < V ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : Yt = 0 < V ? Math.floor(1e3 / V) : 5;
    }, s.unstable_getCurrentPriorityLevel = function() {
      return z;
    }, s.unstable_next = function(V) {
      switch (z) {
        case 1:
        case 2:
        case 3:
          var mt = 3;
          break;
        default:
          mt = z;
      }
      var ut = z;
      z = mt;
      try {
        return V();
      } finally {
        z = ut;
      }
    }, s.unstable_requestPaint = function() {
      X = !0;
    }, s.unstable_runWithPriority = function(V, mt) {
      switch (V) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          V = 3;
      }
      var ut = z;
      z = V;
      try {
        return mt();
      } finally {
        z = ut;
      }
    }, s.unstable_scheduleCallback = function(V, mt, ut) {
      var Gt = s.unstable_now();
      switch (typeof ut == "object" && ut !== null ? (ut = ut.delay, ut = typeof ut == "number" && 0 < ut ? Gt + ut : Gt) : ut = Gt, V) {
        case 1:
          var k = -1;
          break;
        case 2:
          k = 250;
          break;
        case 5:
          k = 1073741823;
          break;
        case 4:
          k = 1e4;
          break;
        default:
          k = 5e3;
      }
      return k = ut + k, V = {
        id: D++,
        callback: mt,
        priorityLevel: V,
        startTime: ut,
        expirationTime: k,
        sortIndex: -1
      }, ut > Gt ? (V.sortIndex = ut, i(E, V), l(T) === null && V === l(E) && (Q ? (Dt(Ct), Ct = -1) : Q = !0, Jt(dt, ut - Gt))) : (V.sortIndex = k, i(T, V), I || j || (I = !0, Lt || (Lt = !0, Nt()))), V;
    }, s.unstable_shouldYield = ne, s.unstable_wrapCallback = function(V) {
      var mt = z;
      return function() {
        var ut = z;
        z = mt;
        try {
          return V.apply(this, arguments);
        } finally {
          z = ut;
        }
      };
    };
  }(Gb)), Gb;
}
var Xb = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var GT;
function qE() {
  return GT || (GT = 1, function(s) {
    process.env.NODE_ENV !== "production" && function() {
      function i() {
        if (dt = !1, wt) {
          var V = s.unstable_now();
          Nt = V;
          var mt = !0;
          try {
            t: {
              Et = !1, zt && (zt = !1, Ct(ne), ne = -1), Dt = !0;
              var ut = nt;
              try {
                e: {
                  for (_(V), X = u(j); X !== null && !(X.expirationTime > V && T()); ) {
                    var Gt = X.callback;
                    if (typeof Gt == "function") {
                      X.callback = null, nt = X.priorityLevel;
                      var k = Gt(
                        X.expirationTime <= V
                      );
                      if (V = s.unstable_now(), typeof k == "function") {
                        X.callback = k, _(V), mt = !0;
                        break e;
                      }
                      X === u(j) && h(j), _(V);
                    } else h(j);
                    X = u(j);
                  }
                  if (X !== null) mt = !0;
                  else {
                    var F = u(I);
                    F !== null && E(
                      S,
                      F.startTime - V
                    ), mt = !1;
                  }
                }
                break t;
              } finally {
                X = null, nt = ut, Dt = !1;
              }
              mt = void 0;
            }
          } finally {
            mt ? Ee() : wt = !1;
          }
        }
      }
      function l(V, mt) {
        var ut = V.length;
        V.push(mt);
        t: for (; 0 < ut; ) {
          var Gt = ut - 1 >>> 1, k = V[Gt];
          if (0 < g(k, mt))
            V[Gt] = mt, V[ut] = k, ut = Gt;
          else break t;
        }
      }
      function u(V) {
        return V.length === 0 ? null : V[0];
      }
      function h(V) {
        if (V.length === 0) return null;
        var mt = V[0], ut = V.pop();
        if (ut !== mt) {
          V[0] = ut;
          t: for (var Gt = 0, k = V.length, F = k >>> 1; Gt < F; ) {
            var ct = 2 * (Gt + 1) - 1, bt = V[ct], Mt = ct + 1, Ht = V[Mt];
            if (0 > g(bt, ut))
              Mt < k && 0 > g(Ht, bt) ? (V[Gt] = Ht, V[Mt] = ut, Gt = Mt) : (V[Gt] = bt, V[ct] = ut, Gt = ct);
            else if (Mt < k && 0 > g(Ht, ut))
              V[Gt] = Ht, V[Mt] = ut, Gt = Mt;
            else break t;
          }
        }
        return mt;
      }
      function g(V, mt) {
        var ut = V.sortIndex - mt.sortIndex;
        return ut !== 0 ? ut : V.id - mt.id;
      }
      function _(V) {
        for (var mt = u(I); mt !== null; ) {
          if (mt.callback === null) h(I);
          else if (mt.startTime <= V)
            h(I), mt.sortIndex = mt.expirationTime, l(j, mt);
          else break;
          mt = u(I);
        }
      }
      function S(V) {
        if (zt = !1, _(V), !Et)
          if (u(j) !== null)
            Et = !0, wt || (wt = !0, Ee());
          else {
            var mt = u(I);
            mt !== null && E(
              S,
              mt.startTime - V
            );
          }
      }
      function T() {
        return dt ? !0 : !(s.unstable_now() - Nt < Rt);
      }
      function E(V, mt) {
        ne = Lt(function() {
          V(s.unstable_now());
        }, mt);
      }
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()), s.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var D = performance;
        s.unstable_now = function() {
          return D.now();
        };
      } else {
        var C = Date, z = C.now();
        s.unstable_now = function() {
          return C.now() - z;
        };
      }
      var j = [], I = [], Q = 1, X = null, nt = 3, Dt = !1, Et = !1, zt = !1, dt = !1, Lt = typeof setTimeout == "function" ? setTimeout : null, Ct = typeof clearTimeout == "function" ? clearTimeout : null, Yt = typeof setImmediate < "u" ? setImmediate : null, wt = !1, ne = -1, Rt = 5, Nt = -1;
      if (typeof Yt == "function")
        var Ee = function() {
          Yt(i);
        };
      else if (typeof MessageChannel < "u") {
        var ge = new MessageChannel(), Jt = ge.port2;
        ge.port1.onmessage = i, Ee = function() {
          Jt.postMessage(null);
        };
      } else
        Ee = function() {
          Lt(i, 0);
        };
      s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(V) {
        V.callback = null;
      }, s.unstable_forceFrameRate = function(V) {
        0 > V || 125 < V ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : Rt = 0 < V ? Math.floor(1e3 / V) : 5;
      }, s.unstable_getCurrentPriorityLevel = function() {
        return nt;
      }, s.unstable_next = function(V) {
        switch (nt) {
          case 1:
          case 2:
          case 3:
            var mt = 3;
            break;
          default:
            mt = nt;
        }
        var ut = nt;
        nt = mt;
        try {
          return V();
        } finally {
          nt = ut;
        }
      }, s.unstable_requestPaint = function() {
        dt = !0;
      }, s.unstable_runWithPriority = function(V, mt) {
        switch (V) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            V = 3;
        }
        var ut = nt;
        nt = V;
        try {
          return mt();
        } finally {
          nt = ut;
        }
      }, s.unstable_scheduleCallback = function(V, mt, ut) {
        var Gt = s.unstable_now();
        switch (typeof ut == "object" && ut !== null ? (ut = ut.delay, ut = typeof ut == "number" && 0 < ut ? Gt + ut : Gt) : ut = Gt, V) {
          case 1:
            var k = -1;
            break;
          case 2:
            k = 250;
            break;
          case 5:
            k = 1073741823;
            break;
          case 4:
            k = 1e4;
            break;
          default:
            k = 5e3;
        }
        return k = ut + k, V = {
          id: Q++,
          callback: mt,
          priorityLevel: V,
          startTime: ut,
          expirationTime: k,
          sortIndex: -1
        }, ut > Gt ? (V.sortIndex = ut, l(I, V), u(j) === null && V === u(I) && (zt ? (Ct(ne), ne = -1) : zt = !0, E(S, ut - Gt))) : (V.sortIndex = k, l(j, V), Et || Dt || (Et = !0, wt || (wt = !0, Ee()))), V;
      }, s.unstable_shouldYield = T, s.unstable_wrapCallback = function(V) {
        var mt = nt;
        return function() {
          var ut = nt;
          nt = mt;
          try {
            return V.apply(this, arguments);
          } finally {
            nt = ut;
          }
        };
      }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(Xb)), Xb;
}
var XT;
function Sw() {
  return XT || (XT = 1, process.env.NODE_ENV === "production" ? J_.exports = jE() : J_.exports = qE()), J_.exports;
}
var F_ = { exports: {} }, Ba = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QT;
function ZE() {
  if (QT) return Ba;
  QT = 1;
  var s = Np();
  function i(T) {
    var E = "https://react.dev/errors/" + T;
    if (1 < arguments.length) {
      E += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var D = 2; D < arguments.length; D++)
        E += "&args[]=" + encodeURIComponent(arguments[D]);
    }
    return "Minified React error #" + T + "; visit " + E + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function l() {
  }
  var u = {
    d: {
      f: l,
      r: function() {
        throw Error(i(522));
      },
      D: l,
      C: l,
      L: l,
      m: l,
      X: l,
      S: l,
      M: l
    },
    p: 0,
    findDOMNode: null
  }, h = Symbol.for("react.portal");
  function g(T, E, D) {
    var C = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: h,
      key: C == null ? null : "" + C,
      children: T,
      containerInfo: E,
      implementation: D
    };
  }
  var _ = s.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function S(T, E) {
    if (T === "font") return "";
    if (typeof E == "string")
      return E === "use-credentials" ? E : "";
  }
  return Ba.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = u, Ba.createPortal = function(T, E) {
    var D = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!E || E.nodeType !== 1 && E.nodeType !== 9 && E.nodeType !== 11)
      throw Error(i(299));
    return g(T, E, null, D);
  }, Ba.flushSync = function(T) {
    var E = _.T, D = u.p;
    try {
      if (_.T = null, u.p = 2, T) return T();
    } finally {
      _.T = E, u.p = D, u.d.f();
    }
  }, Ba.preconnect = function(T, E) {
    typeof T == "string" && (E ? (E = E.crossOrigin, E = typeof E == "string" ? E === "use-credentials" ? E : "" : void 0) : E = null, u.d.C(T, E));
  }, Ba.prefetchDNS = function(T) {
    typeof T == "string" && u.d.D(T);
  }, Ba.preinit = function(T, E) {
    if (typeof T == "string" && E && typeof E.as == "string") {
      var D = E.as, C = S(D, E.crossOrigin), z = typeof E.integrity == "string" ? E.integrity : void 0, j = typeof E.fetchPriority == "string" ? E.fetchPriority : void 0;
      D === "style" ? u.d.S(
        T,
        typeof E.precedence == "string" ? E.precedence : void 0,
        {
          crossOrigin: C,
          integrity: z,
          fetchPriority: j
        }
      ) : D === "script" && u.d.X(T, {
        crossOrigin: C,
        integrity: z,
        fetchPriority: j,
        nonce: typeof E.nonce == "string" ? E.nonce : void 0
      });
    }
  }, Ba.preinitModule = function(T, E) {
    if (typeof T == "string")
      if (typeof E == "object" && E !== null) {
        if (E.as == null || E.as === "script") {
          var D = S(
            E.as,
            E.crossOrigin
          );
          u.d.M(T, {
            crossOrigin: D,
            integrity: typeof E.integrity == "string" ? E.integrity : void 0,
            nonce: typeof E.nonce == "string" ? E.nonce : void 0
          });
        }
      } else E == null && u.d.M(T);
  }, Ba.preload = function(T, E) {
    if (typeof T == "string" && typeof E == "object" && E !== null && typeof E.as == "string") {
      var D = E.as, C = S(D, E.crossOrigin);
      u.d.L(T, D, {
        crossOrigin: C,
        integrity: typeof E.integrity == "string" ? E.integrity : void 0,
        nonce: typeof E.nonce == "string" ? E.nonce : void 0,
        type: typeof E.type == "string" ? E.type : void 0,
        fetchPriority: typeof E.fetchPriority == "string" ? E.fetchPriority : void 0,
        referrerPolicy: typeof E.referrerPolicy == "string" ? E.referrerPolicy : void 0,
        imageSrcSet: typeof E.imageSrcSet == "string" ? E.imageSrcSet : void 0,
        imageSizes: typeof E.imageSizes == "string" ? E.imageSizes : void 0,
        media: typeof E.media == "string" ? E.media : void 0
      });
    }
  }, Ba.preloadModule = function(T, E) {
    if (typeof T == "string")
      if (E) {
        var D = S(E.as, E.crossOrigin);
        u.d.m(T, {
          as: typeof E.as == "string" && E.as !== "script" ? E.as : void 0,
          crossOrigin: D,
          integrity: typeof E.integrity == "string" ? E.integrity : void 0
        });
      } else u.d.m(T);
  }, Ba.requestFormReset = function(T) {
    u.d.r(T);
  }, Ba.unstable_batchedUpdates = function(T, E) {
    return T(E);
  }, Ba.useFormState = function(T, E, D) {
    return _.H.useFormState(T, E, D);
  }, Ba.useFormStatus = function() {
    return _.H.useHostTransitionStatus();
  }, Ba.version = "19.1.1", Ba;
}
var Ya = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KT;
function PE() {
  return KT || (KT = 1, process.env.NODE_ENV !== "production" && function() {
    function s() {
    }
    function i(C) {
      return "" + C;
    }
    function l(C, z, j) {
      var I = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      try {
        i(I);
        var Q = !1;
      } catch {
        Q = !0;
      }
      return Q && (console.error(
        "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
        typeof Symbol == "function" && Symbol.toStringTag && I[Symbol.toStringTag] || I.constructor.name || "Object"
      ), i(I)), {
        $$typeof: E,
        key: I == null ? null : "" + I,
        children: C,
        containerInfo: z,
        implementation: j
      };
    }
    function u(C, z) {
      if (C === "font") return "";
      if (typeof z == "string")
        return z === "use-credentials" ? z : "";
    }
    function h(C) {
      return C === null ? "`null`" : C === void 0 ? "`undefined`" : C === "" ? "an empty string" : 'something with type "' + typeof C + '"';
    }
    function g(C) {
      return C === null ? "`null`" : C === void 0 ? "`undefined`" : C === "" ? "an empty string" : typeof C == "string" ? JSON.stringify(C) : typeof C == "number" ? "`" + C + "`" : 'something with type "' + typeof C + '"';
    }
    function _() {
      var C = D.H;
      return C === null && console.error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      ), C;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var S = Np(), T = {
      d: {
        f: s,
        r: function() {
          throw Error(
            "Invalid form element. requestFormReset must be passed a form that was rendered by React."
          );
        },
        D: s,
        C: s,
        L: s,
        m: s,
        X: s,
        S: s,
        M: s
      },
      p: 0,
      findDOMNode: null
    }, E = Symbol.for("react.portal"), D = S.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
    ), Ya.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = T, Ya.createPortal = function(C, z) {
      var j = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!z || z.nodeType !== 1 && z.nodeType !== 9 && z.nodeType !== 11)
        throw Error("Target container is not a DOM element.");
      return l(C, z, null, j);
    }, Ya.flushSync = function(C) {
      var z = D.T, j = T.p;
      try {
        if (D.T = null, T.p = 2, C)
          return C();
      } finally {
        D.T = z, T.p = j, T.d.f() && console.error(
          "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
        );
      }
    }, Ya.preconnect = function(C, z) {
      typeof C == "string" && C ? z != null && typeof z != "object" ? console.error(
        "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
        g(z)
      ) : z != null && typeof z.crossOrigin != "string" && console.error(
        "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
        h(z.crossOrigin)
      ) : console.error(
        "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        h(C)
      ), typeof C == "string" && (z ? (z = z.crossOrigin, z = typeof z == "string" ? z === "use-credentials" ? z : "" : void 0) : z = null, T.d.C(C, z));
    }, Ya.prefetchDNS = function(C) {
      if (typeof C != "string" || !C)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          h(C)
        );
      else if (1 < arguments.length) {
        var z = arguments[1];
        typeof z == "object" && z.hasOwnProperty("crossOrigin") ? console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          g(z)
        ) : console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          g(z)
        );
      }
      typeof C == "string" && T.d.D(C);
    }, Ya.preinit = function(C, z) {
      if (typeof C == "string" && C ? z == null || typeof z != "object" ? console.error(
        "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
        g(z)
      ) : z.as !== "style" && z.as !== "script" && console.error(
        'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
        g(z.as)
      ) : console.error(
        "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        h(C)
      ), typeof C == "string" && z && typeof z.as == "string") {
        var j = z.as, I = u(j, z.crossOrigin), Q = typeof z.integrity == "string" ? z.integrity : void 0, X = typeof z.fetchPriority == "string" ? z.fetchPriority : void 0;
        j === "style" ? T.d.S(
          C,
          typeof z.precedence == "string" ? z.precedence : void 0,
          {
            crossOrigin: I,
            integrity: Q,
            fetchPriority: X
          }
        ) : j === "script" && T.d.X(C, {
          crossOrigin: I,
          integrity: Q,
          fetchPriority: X,
          nonce: typeof z.nonce == "string" ? z.nonce : void 0
        });
      }
    }, Ya.preinitModule = function(C, z) {
      var j = "";
      if (typeof C == "string" && C || (j += " The `href` argument encountered was " + h(C) + "."), z !== void 0 && typeof z != "object" ? j += " The `options` argument encountered was " + h(z) + "." : z && "as" in z && z.as !== "script" && (j += " The `as` option encountered was " + g(z.as) + "."), j)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          j
        );
      else
        switch (j = z && typeof z.as == "string" ? z.as : "script", j) {
          case "script":
            break;
          default:
            j = g(j), console.error(
              'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
              j,
              C
            );
        }
      typeof C == "string" && (typeof z == "object" && z !== null ? (z.as == null || z.as === "script") && (j = u(
        z.as,
        z.crossOrigin
      ), T.d.M(C, {
        crossOrigin: j,
        integrity: typeof z.integrity == "string" ? z.integrity : void 0,
        nonce: typeof z.nonce == "string" ? z.nonce : void 0
      })) : z == null && T.d.M(C));
    }, Ya.preload = function(C, z) {
      var j = "";
      if (typeof C == "string" && C || (j += " The `href` argument encountered was " + h(C) + "."), z == null || typeof z != "object" ? j += " The `options` argument encountered was " + h(z) + "." : typeof z.as == "string" && z.as || (j += " The `as` option encountered was " + h(z.as) + "."), j && console.error(
        'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
        j
      ), typeof C == "string" && typeof z == "object" && z !== null && typeof z.as == "string") {
        j = z.as;
        var I = u(
          j,
          z.crossOrigin
        );
        T.d.L(C, j, {
          crossOrigin: I,
          integrity: typeof z.integrity == "string" ? z.integrity : void 0,
          nonce: typeof z.nonce == "string" ? z.nonce : void 0,
          type: typeof z.type == "string" ? z.type : void 0,
          fetchPriority: typeof z.fetchPriority == "string" ? z.fetchPriority : void 0,
          referrerPolicy: typeof z.referrerPolicy == "string" ? z.referrerPolicy : void 0,
          imageSrcSet: typeof z.imageSrcSet == "string" ? z.imageSrcSet : void 0,
          imageSizes: typeof z.imageSizes == "string" ? z.imageSizes : void 0,
          media: typeof z.media == "string" ? z.media : void 0
        });
      }
    }, Ya.preloadModule = function(C, z) {
      var j = "";
      typeof C == "string" && C || (j += " The `href` argument encountered was " + h(C) + "."), z !== void 0 && typeof z != "object" ? j += " The `options` argument encountered was " + h(z) + "." : z && "as" in z && typeof z.as != "string" && (j += " The `as` option encountered was " + h(z.as) + "."), j && console.error(
        'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
        j
      ), typeof C == "string" && (z ? (j = u(
        z.as,
        z.crossOrigin
      ), T.d.m(C, {
        as: typeof z.as == "string" && z.as !== "script" ? z.as : void 0,
        crossOrigin: j,
        integrity: typeof z.integrity == "string" ? z.integrity : void 0
      })) : T.d.m(C));
    }, Ya.requestFormReset = function(C) {
      T.d.r(C);
    }, Ya.unstable_batchedUpdates = function(C, z) {
      return C(z);
    }, Ya.useFormState = function(C, z, j) {
      return _().useFormState(C, z, j);
    }, Ya.useFormStatus = function() {
      return _().useHostTransitionStatus();
    }, Ya.version = "19.1.1", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Ya;
}
var WT;
function Tw() {
  if (WT) return F_.exports;
  WT = 1;
  function s() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s);
      } catch (i) {
        console.error(i);
      }
    }
  }
  return process.env.NODE_ENV === "production" ? (s(), F_.exports = ZE()) : F_.exports = PE(), F_.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var IT;
function VE() {
  if (IT) return Wy;
  IT = 1;
  var s = Sw(), i = Np(), l = Tw();
  function u(n) {
    var o = "https://react.dev/errors/" + n;
    if (1 < arguments.length) {
      o += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var c = 2; c < arguments.length; c++)
        o += "&args[]=" + encodeURIComponent(arguments[c]);
    }
    return "Minified React error #" + n + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function h(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11);
  }
  function g(n) {
    var o = n, c = n;
    if (n.alternate) for (; o.return; ) o = o.return;
    else {
      n = o;
      do
        o = n, (o.flags & 4098) !== 0 && (c = o.return), n = o.return;
      while (n);
    }
    return o.tag === 3 ? c : null;
  }
  function _(n) {
    if (n.tag === 13) {
      var o = n.memoizedState;
      if (o === null && (n = n.alternate, n !== null && (o = n.memoizedState)), o !== null) return o.dehydrated;
    }
    return null;
  }
  function S(n) {
    if (g(n) !== n)
      throw Error(u(188));
  }
  function T(n) {
    var o = n.alternate;
    if (!o) {
      if (o = g(n), o === null) throw Error(u(188));
      return o !== n ? null : n;
    }
    for (var c = n, m = o; ; ) {
      var b = c.return;
      if (b === null) break;
      var x = b.alternate;
      if (x === null) {
        if (m = b.return, m !== null) {
          c = m;
          continue;
        }
        break;
      }
      if (b.child === x.child) {
        for (x = b.child; x; ) {
          if (x === c) return S(b), n;
          if (x === m) return S(b), o;
          x = x.sibling;
        }
        throw Error(u(188));
      }
      if (c.return !== m.return) c = b, m = x;
      else {
        for (var R = !1, U = b.child; U; ) {
          if (U === c) {
            R = !0, c = b, m = x;
            break;
          }
          if (U === m) {
            R = !0, m = b, c = x;
            break;
          }
          U = U.sibling;
        }
        if (!R) {
          for (U = x.child; U; ) {
            if (U === c) {
              R = !0, c = x, m = b;
              break;
            }
            if (U === m) {
              R = !0, m = x, c = b;
              break;
            }
            U = U.sibling;
          }
          if (!R) throw Error(u(189));
        }
      }
      if (c.alternate !== m) throw Error(u(190));
    }
    if (c.tag !== 3) throw Error(u(188));
    return c.stateNode.current === c ? n : o;
  }
  function E(n) {
    var o = n.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return n;
    for (n = n.child; n !== null; ) {
      if (o = E(n), o !== null) return o;
      n = n.sibling;
    }
    return null;
  }
  var D = Object.assign, C = Symbol.for("react.element"), z = Symbol.for("react.transitional.element"), j = Symbol.for("react.portal"), I = Symbol.for("react.fragment"), Q = Symbol.for("react.strict_mode"), X = Symbol.for("react.profiler"), nt = Symbol.for("react.provider"), Dt = Symbol.for("react.consumer"), Et = Symbol.for("react.context"), zt = Symbol.for("react.forward_ref"), dt = Symbol.for("react.suspense"), Lt = Symbol.for("react.suspense_list"), Ct = Symbol.for("react.memo"), Yt = Symbol.for("react.lazy"), wt = Symbol.for("react.activity"), ne = Symbol.for("react.memo_cache_sentinel"), Rt = Symbol.iterator;
  function Nt(n) {
    return n === null || typeof n != "object" ? null : (n = Rt && n[Rt] || n["@@iterator"], typeof n == "function" ? n : null);
  }
  var Ee = Symbol.for("react.client.reference");
  function ge(n) {
    if (n == null) return null;
    if (typeof n == "function")
      return n.$$typeof === Ee ? null : n.displayName || n.name || null;
    if (typeof n == "string") return n;
    switch (n) {
      case I:
        return "Fragment";
      case X:
        return "Profiler";
      case Q:
        return "StrictMode";
      case dt:
        return "Suspense";
      case Lt:
        return "SuspenseList";
      case wt:
        return "Activity";
    }
    if (typeof n == "object")
      switch (n.$$typeof) {
        case j:
          return "Portal";
        case Et:
          return (n.displayName || "Context") + ".Provider";
        case Dt:
          return (n._context.displayName || "Context") + ".Consumer";
        case zt:
          var o = n.render;
          return n = n.displayName, n || (n = o.displayName || o.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n;
        case Ct:
          return o = n.displayName || null, o !== null ? o : ge(n.type) || "Memo";
        case Yt:
          o = n._payload, n = n._init;
          try {
            return ge(n(o));
          } catch {
          }
      }
    return null;
  }
  var Jt = Array.isArray, V = i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, mt = l.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ut = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Gt = [], k = -1;
  function F(n) {
    return { current: n };
  }
  function ct(n) {
    0 > k || (n.current = Gt[k], Gt[k] = null, k--);
  }
  function bt(n, o) {
    k++, Gt[k] = n.current, n.current = o;
  }
  var Mt = F(null), Ht = F(null), Tt = F(null), We = F(null);
  function Ft(n, o) {
    switch (bt(Tt, o), bt(Ht, n), bt(Mt, null), o.nodeType) {
      case 9:
      case 11:
        n = (n = o.documentElement) && (n = n.namespaceURI) ? Is(n) : 0;
        break;
      default:
        if (n = o.tagName, o = o.namespaceURI)
          o = Is(o), n = Jc(o, n);
        else
          switch (n) {
            case "svg":
              n = 1;
              break;
            case "math":
              n = 2;
              break;
            default:
              n = 0;
          }
    }
    ct(Mt), bt(Mt, n);
  }
  function on() {
    ct(Mt), ct(Ht), ct(Tt);
  }
  function fi(n) {
    n.memoizedState !== null && bt(We, n);
    var o = Mt.current, c = Jc(o, n.type);
    o !== c && (bt(Ht, n), bt(Mt, c));
  }
  function da(n) {
    Ht.current === n && (ct(Mt), ct(Ht)), We.current === n && (ct(We), Na._currentValue = ut);
  }
  var Za = Object.prototype.hasOwnProperty, ma = s.unstable_scheduleCallback, ur = s.unstable_cancelCallback, cr = s.unstable_shouldYield, Tn = s.unstable_requestPaint, En = s.unstable_now, Pa = s.unstable_getCurrentPriorityLevel, dc = s.unstable_ImmediatePriority, pe = s.unstable_UserBlockingPriority, pa = s.unstable_NormalPriority, vs = s.unstable_LowPriority, po = s.unstable_IdlePriority, mc = s.log, hu = s.unstable_setDisableYieldValue, go = null, Zn = null;
  function ta(n) {
    if (typeof mc == "function" && hu(n), Zn && typeof Zn.setStrictMode == "function")
      try {
        Zn.setStrictMode(go, n);
      } catch {
      }
  }
  var $n = Math.clz32 ? Math.clz32 : hr, _s = Math.log, fr = Math.LN2;
  function hr(n) {
    return n >>>= 0, n === 0 ? 32 : 31 - (_s(n) / fr | 0) | 0;
  }
  var ga = 256, hi = 4194304;
  function Pn(n) {
    var o = n & 42;
    if (o !== 0) return o;
    switch (n & -n) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return n & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return n;
    }
  }
  function Va(n, o, c) {
    var m = n.pendingLanes;
    if (m === 0) return 0;
    var b = 0, x = n.suspendedLanes, R = n.pingedLanes;
    n = n.warmLanes;
    var U = m & 134217727;
    return U !== 0 ? (m = U & ~x, m !== 0 ? b = Pn(m) : (R &= U, R !== 0 ? b = Pn(R) : c || (c = U & ~n, c !== 0 && (b = Pn(c))))) : (U = m & ~x, U !== 0 ? b = Pn(U) : R !== 0 ? b = Pn(R) : c || (c = m & ~n, c !== 0 && (b = Pn(c)))), b === 0 ? 0 : o !== 0 && o !== b && (o & x) === 0 && (x = b & -b, c = o & -o, x >= c || x === 32 && (c & 4194048) !== 0) ? o : b;
  }
  function N(n, o) {
    return (n.pendingLanes & ~(n.suspendedLanes & ~n.pingedLanes) & o) === 0;
  }
  function J(n, o) {
    switch (n) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return o + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function At() {
    var n = ga;
    return ga <<= 1, (ga & 4194048) === 0 && (ga = 256), n;
  }
  function kt() {
    var n = hi;
    return hi <<= 1, (hi & 62914560) === 0 && (hi = 4194304), n;
  }
  function Xt(n) {
    for (var o = [], c = 0; 31 > c; c++) o.push(n);
    return o;
  }
  function se(n, o) {
    n.pendingLanes |= o, o !== 268435456 && (n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0);
  }
  function he(n, o, c, m, b, x) {
    var R = n.pendingLanes;
    n.pendingLanes = c, n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0, n.expiredLanes &= c, n.entangledLanes &= c, n.errorRecoveryDisabledLanes &= c, n.shellSuspendCounter = 0;
    var U = n.entanglements, Z = n.expirationTimes, it = n.hiddenUpdates;
    for (c = R & ~c; 0 < c; ) {
      var vt = 31 - $n(c), St = 1 << vt;
      U[vt] = 0, Z[vt] = -1;
      var ot = it[vt];
      if (ot !== null)
        for (it[vt] = null, vt = 0; vt < ot.length; vt++) {
          var st = ot[vt];
          st !== null && (st.lane &= -536870913);
        }
      c &= ~St;
    }
    m !== 0 && ze(n, m, 0), x !== 0 && b === 0 && n.tag !== 0 && (n.suspendedLanes |= x & ~(R & ~o));
  }
  function ze(n, o, c) {
    n.pendingLanes |= o, n.suspendedLanes &= ~o;
    var m = 31 - $n(o);
    n.entangledLanes |= o, n.entanglements[m] = n.entanglements[m] | 1073741824 | c & 4194090;
  }
  function fe(n, o) {
    var c = n.entangledLanes |= o;
    for (n = n.entanglements; c; ) {
      var m = 31 - $n(c), b = 1 << m;
      b & o | n[m] & o && (n[m] |= o), c &= ~b;
    }
  }
  function On(n) {
    switch (n) {
      case 2:
        n = 1;
        break;
      case 8:
        n = 4;
        break;
      case 32:
        n = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        n = 128;
        break;
      case 268435456:
        n = 134217728;
        break;
      default:
        n = 0;
    }
    return n;
  }
  function Ga(n) {
    return n &= -n, 2 < n ? 8 < n ? (n & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function pc() {
    var n = mt.p;
    return n !== 0 ? n : (n = window.event, n === void 0 ? 32 : ry(n.type));
  }
  function du(n, o) {
    var c = mt.p;
    try {
      return mt.p = n, o();
    } finally {
      mt.p = c;
    }
  }
  var Nn = Math.random().toString(36).slice(2), Vn = "__reactFiber$" + Nn, Ei = "__reactProps$" + Nn, dr = "__reactContainer$" + Nn, ea = "__reactEvents$" + Nn, It = "__reactListeners$" + Nn, mu = "__reactHandles$" + Nn, Df = "__reactResources$" + Nn, Pt = "__reactMarker$" + Nn;
  function mr(n) {
    delete n[Vn], delete n[Ei], delete n[ea], delete n[It], delete n[mu];
  }
  function Un(n) {
    var o = n[Vn];
    if (o) return o;
    for (var c = n.parentNode; c; ) {
      if (o = c[dr] || c[Vn]) {
        if (c = o.alternate, o.child !== null || c !== null && c.child !== null)
          for (n = Ni(n); n !== null; ) {
            if (c = n[Vn]) return c;
            n = Ni(n);
          }
        return o;
      }
      n = c, c = n.parentNode;
    }
    return null;
  }
  function bl(n) {
    if (n = n[Vn] || n[dr]) {
      var o = n.tag;
      if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3)
        return n;
    }
    return null;
  }
  function yo(n) {
    var o = n.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return n.stateNode;
    throw Error(u(33));
  }
  function vo(n) {
    var o = n[Df];
    return o || (o = n[Df] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), o;
  }
  function Bn(n) {
    n[Pt] = !0;
  }
  var pu = /* @__PURE__ */ new Set(), na = {};
  function Sl(n, o) {
    Wo(n, o), Wo(n + "Capture", o);
  }
  function Wo(n, o) {
    for (na[n] = o, n = 0; n < o.length; n++)
      pu.add(o[n]);
  }
  var bd = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), bs = {}, Af = {};
  function Sd(n) {
    return Za.call(Af, n) ? !0 : Za.call(bs, n) ? !1 : bd.test(n) ? Af[n] = !0 : (bs[n] = !0, !1);
  }
  function Io(n, o, c) {
    if (Sd(o))
      if (c === null) n.removeAttribute(o);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
            n.removeAttribute(o);
            return;
          case "boolean":
            var m = o.toLowerCase().slice(0, 5);
            if (m !== "data-" && m !== "aria-") {
              n.removeAttribute(o);
              return;
            }
        }
        n.setAttribute(o, "" + c);
      }
  }
  function gu(n, o, c) {
    if (c === null) n.removeAttribute(o);
    else {
      switch (typeof c) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          n.removeAttribute(o);
          return;
      }
      n.setAttribute(o, "" + c);
    }
  }
  function _o(n, o, c, m) {
    if (m === null) n.removeAttribute(c);
    else {
      switch (typeof m) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          n.removeAttribute(c);
          return;
      }
      n.setAttributeNS(o, c, "" + m);
    }
  }
  var pr, Ss;
  function Tl(n) {
    if (pr === void 0)
      try {
        throw Error();
      } catch (c) {
        var o = c.stack.trim().match(/\n( *(at )?)/);
        pr = o && o[1] || "", Ss = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + pr + n + Ss;
  }
  var di = !1;
  function ya(n, o) {
    if (!n || di) return "";
    di = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var m = {
        DetermineComponentFrameRoot: function() {
          try {
            if (o) {
              var St = function() {
                throw Error();
              };
              if (Object.defineProperty(St.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(St, []);
                } catch (st) {
                  var ot = st;
                }
                Reflect.construct(n, [], St);
              } else {
                try {
                  St.call();
                } catch (st) {
                  ot = st;
                }
                n.call(St.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (st) {
                ot = st;
              }
              (St = n()) && typeof St.catch == "function" && St.catch(function() {
              });
            }
          } catch (st) {
            if (st && ot && typeof st.stack == "string")
              return [st.stack, ot.stack];
          }
          return [null, null];
        }
      };
      m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var b = Object.getOwnPropertyDescriptor(
        m.DetermineComponentFrameRoot,
        "name"
      );
      b && b.configurable && Object.defineProperty(
        m.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var x = m.DetermineComponentFrameRoot(), R = x[0], U = x[1];
      if (R && U) {
        var Z = R.split(`
`), it = U.split(`
`);
        for (b = m = 0; m < Z.length && !Z[m].includes("DetermineComponentFrameRoot"); )
          m++;
        for (; b < it.length && !it[b].includes(
          "DetermineComponentFrameRoot"
        ); )
          b++;
        if (m === Z.length || b === it.length)
          for (m = Z.length - 1, b = it.length - 1; 1 <= m && 0 <= b && Z[m] !== it[b]; )
            b--;
        for (; 1 <= m && 0 <= b; m--, b--)
          if (Z[m] !== it[b]) {
            if (m !== 1 || b !== 1)
              do
                if (m--, b--, 0 > b || Z[m] !== it[b]) {
                  var vt = `
` + Z[m].replace(" at new ", " at ");
                  return n.displayName && vt.includes("<anonymous>") && (vt = vt.replace("<anonymous>", n.displayName)), vt;
                }
              while (1 <= m && 0 <= b);
            break;
          }
      }
    } finally {
      di = !1, Error.prepareStackTrace = c;
    }
    return (c = n ? n.displayName || n.name : "") ? Tl(c) : "";
  }
  function we(n) {
    switch (n.tag) {
      case 26:
      case 27:
      case 5:
        return Tl(n.type);
      case 16:
        return Tl("Lazy");
      case 13:
        return Tl("Suspense");
      case 19:
        return Tl("SuspenseList");
      case 0:
      case 15:
        return ya(n.type, !1);
      case 11:
        return ya(n.type.render, !1);
      case 1:
        return ya(n.type, !0);
      case 31:
        return Tl("Activity");
      default:
        return "";
    }
  }
  function ln(n) {
    try {
      var o = "";
      do
        o += we(n), n = n.return;
      while (n);
      return o;
    } catch (c) {
      return `
Error generating stack: ` + c.message + `
` + c.stack;
    }
  }
  function Yn(n) {
    switch (typeof n) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return n;
      case "object":
        return n;
      default:
        return "";
    }
  }
  function bo(n) {
    var o = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
  }
  function xl(n) {
    var o = bo(n) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(
      n.constructor.prototype,
      o
    ), m = "" + n[o];
    if (!n.hasOwnProperty(o) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var b = c.get, x = c.set;
      return Object.defineProperty(n, o, {
        configurable: !0,
        get: function() {
          return b.call(this);
        },
        set: function(R) {
          m = "" + R, x.call(this, R);
        }
      }), Object.defineProperty(n, o, {
        enumerable: c.enumerable
      }), {
        getValue: function() {
          return m;
        },
        setValue: function(R) {
          m = "" + R;
        },
        stopTracking: function() {
          n._valueTracker = null, delete n[o];
        }
      };
    }
  }
  function So(n) {
    n._valueTracker || (n._valueTracker = xl(n));
  }
  function le(n) {
    if (!n) return !1;
    var o = n._valueTracker;
    if (!o) return !0;
    var c = o.getValue(), m = "";
    return n && (m = bo(n) ? n.checked ? "true" : "false" : n.value), n = m, n !== c ? (o.setValue(n), !0) : !1;
  }
  function Fe(n) {
    if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null;
    try {
      return n.activeElement || n.body;
    } catch {
      return n.body;
    }
  }
  var Rf = /[\n"\\]/g;
  function Oi(n) {
    return n.replace(
      Rf,
      function(o) {
        return "\\" + o.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Di(n, o, c, m, b, x, R, U) {
    n.name = "", R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" ? n.type = R : n.removeAttribute("type"), o != null ? R === "number" ? (o === 0 && n.value === "" || n.value != o) && (n.value = "" + Yn(o)) : n.value !== "" + Yn(o) && (n.value = "" + Yn(o)) : R !== "submit" && R !== "reset" || n.removeAttribute("value"), o != null ? wl(n, R, Yn(o)) : c != null ? wl(n, R, Yn(c)) : m != null && n.removeAttribute("value"), b == null && x != null && (n.defaultChecked = !!x), b != null && (n.checked = b && typeof b != "function" && typeof b != "symbol"), U != null && typeof U != "function" && typeof U != "symbol" && typeof U != "boolean" ? n.name = "" + Yn(U) : n.removeAttribute("name");
  }
  function gc(n, o, c, m, b, x, R, U) {
    if (x != null && typeof x != "function" && typeof x != "symbol" && typeof x != "boolean" && (n.type = x), o != null || c != null) {
      if (!(x !== "submit" && x !== "reset" || o != null))
        return;
      c = c != null ? "" + Yn(c) : "", o = o != null ? "" + Yn(o) : c, U || o === n.value || (n.value = o), n.defaultValue = o;
    }
    m = m ?? b, m = typeof m != "function" && typeof m != "symbol" && !!m, n.checked = U ? n.checked : !!m, n.defaultChecked = !!m, R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" && (n.name = R);
  }
  function wl(n, o, c) {
    o === "number" && Fe(n.ownerDocument) === n || n.defaultValue === "" + c || (n.defaultValue = "" + c);
  }
  function ia(n, o, c, m) {
    if (n = n.options, o) {
      o = {};
      for (var b = 0; b < c.length; b++)
        o["$" + c[b]] = !0;
      for (c = 0; c < n.length; c++)
        b = o.hasOwnProperty("$" + n[c].value), n[c].selected !== b && (n[c].selected = b), b && m && (n[c].defaultSelected = !0);
    } else {
      for (c = "" + Yn(c), o = null, b = 0; b < n.length; b++) {
        if (n[b].value === c) {
          n[b].selected = !0, m && (n[b].defaultSelected = !0);
          return;
        }
        o !== null || n[b].disabled || (o = n[b]);
      }
      o !== null && (o.selected = !0);
    }
  }
  function yn(n, o, c) {
    if (o != null && (o = "" + Yn(o), o !== n.value && (n.value = o), c == null)) {
      n.defaultValue !== o && (n.defaultValue = o);
      return;
    }
    n.defaultValue = c != null ? "" + Yn(c) : "";
  }
  function $o(n, o, c, m) {
    if (o == null) {
      if (m != null) {
        if (c != null) throw Error(u(92));
        if (Jt(m)) {
          if (1 < m.length) throw Error(u(93));
          m = m[0];
        }
        c = m;
      }
      c == null && (c = ""), o = c;
    }
    c = Yn(o), n.defaultValue = c, m = n.textContent, m === c && m !== "" && m !== null && (n.value = m);
  }
  function To(n, o) {
    if (o) {
      var c = n.firstChild;
      if (c && c === n.lastChild && c.nodeType === 3) {
        c.nodeValue = o;
        return;
      }
    }
    n.textContent = o;
  }
  var gr = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function yr(n, o, c) {
    var m = o.indexOf("--") === 0;
    c == null || typeof c == "boolean" || c === "" ? m ? n.setProperty(o, "") : o === "float" ? n.cssFloat = "" : n[o] = "" : m ? n.setProperty(o, c) : typeof c != "number" || c === 0 || gr.has(o) ? o === "float" ? n.cssFloat = c : n[o] = ("" + c).trim() : n[o] = c + "px";
  }
  function Jo(n, o, c) {
    if (o != null && typeof o != "object")
      throw Error(u(62));
    if (n = n.style, c != null) {
      for (var m in c)
        !c.hasOwnProperty(m) || o != null && o.hasOwnProperty(m) || (m.indexOf("--") === 0 ? n.setProperty(m, "") : m === "float" ? n.cssFloat = "" : n[m] = "");
      for (var b in o)
        m = o[b], o.hasOwnProperty(b) && c[b] !== m && yr(n, b, m);
    } else
      for (var x in o)
        o.hasOwnProperty(x) && yr(n, x, o[x]);
  }
  function Fo(n) {
    if (n.indexOf("-") === -1) return !1;
    switch (n) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Cf = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), yu = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Ts(n) {
    return yu.test("" + n) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : n;
  }
  var tl = null;
  function xs(n) {
    return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n;
  }
  var ws = null, Ml = null;
  function Td(n) {
    var o = bl(n);
    if (o && (n = o.stateNode)) {
      var c = n[Ei] || null;
      t: switch (n = o.stateNode, o.type) {
        case "input":
          if (Di(
            n,
            c.value,
            c.defaultValue,
            c.defaultValue,
            c.checked,
            c.defaultChecked,
            c.type,
            c.name
          ), o = c.name, c.type === "radio" && o != null) {
            for (c = n; c.parentNode; ) c = c.parentNode;
            for (c = c.querySelectorAll(
              'input[name="' + Oi(
                "" + o
              ) + '"][type="radio"]'
            ), o = 0; o < c.length; o++) {
              var m = c[o];
              if (m !== n && m.form === n.form) {
                var b = m[Ei] || null;
                if (!b) throw Error(u(90));
                Di(
                  m,
                  b.value,
                  b.defaultValue,
                  b.defaultValue,
                  b.checked,
                  b.defaultChecked,
                  b.type,
                  b.name
                );
              }
            }
            for (o = 0; o < c.length; o++)
              m = c[o], m.form === n.form && le(m);
          }
          break t;
        case "textarea":
          yn(n, c.value, c.defaultValue);
          break t;
        case "select":
          o = c.value, o != null && ia(n, !!c.multiple, o, !1);
      }
    }
  }
  var ce = !1;
  function Ai(n, o, c) {
    if (ce) return n(o, c);
    ce = !0;
    try {
      var m = n(o);
      return m;
    } finally {
      if (ce = !1, (ws !== null || Ml !== null) && (Zu(), ws && (o = ws, n = Ml, Ml = ws = null, Td(o), n)))
        for (o = 0; o < n.length; o++) Td(n[o]);
    }
  }
  function Ye(n, o) {
    var c = n.stateNode;
    if (c === null) return null;
    var m = c[Ei] || null;
    if (m === null) return null;
    c = m[o];
    t: switch (o) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (m = !m.disabled) || (n = n.type, m = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !m;
        break t;
      default:
        n = !1;
    }
    if (n) return null;
    if (c && typeof c != "function")
      throw Error(
        u(231, o, typeof c)
      );
    return c;
  }
  var Xa = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), vr = !1;
  if (Xa)
    try {
      var Qa = {};
      Object.defineProperty(Qa, "passive", {
        get: function() {
          vr = !0;
        }
      }), window.addEventListener("test", Qa, Qa), window.removeEventListener("test", Qa, Qa);
    } catch {
      vr = !1;
    }
  var Ka = null, va = null, el = null;
  function Ms() {
    if (el) return el;
    var n, o = va, c = o.length, m, b = "value" in Ka ? Ka.value : Ka.textContent, x = b.length;
    for (n = 0; n < c && o[n] === b[n]; n++) ;
    var R = c - n;
    for (m = 1; m <= R && o[c - m] === b[x - m]; m++) ;
    return el = b.slice(n, 1 < m ? 1 - m : void 0);
  }
  function Ue(n) {
    var o = n.keyCode;
    return "charCode" in n ? (n = n.charCode, n === 0 && o === 13 && (n = 13)) : n = o, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0;
  }
  function xo() {
    return !0;
  }
  function vu() {
    return !1;
  }
  function mi(n) {
    function o(c, m, b, x, R) {
      this._reactName = c, this._targetInst = b, this.type = m, this.nativeEvent = x, this.target = R, this.currentTarget = null;
      for (var U in n)
        n.hasOwnProperty(U) && (c = n[U], this[U] = c ? c(x) : x[U]);
      return this.isDefaultPrevented = (x.defaultPrevented != null ? x.defaultPrevented : x.returnValue === !1) ? xo : vu, this.isPropagationStopped = vu, this;
    }
    return D(o.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var c = this.nativeEvent;
        c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = xo);
      },
      stopPropagation: function() {
        var c = this.nativeEvent;
        c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = xo);
      },
      persist: function() {
      },
      isPersistent: xo
    }), o;
  }
  var El = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, _u = mi(El), Es = D({}, El, { view: 0, detail: 0 }), xd = mi(Es), yc, Oe, bu, Jn = D({}, Es, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Mo,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
      return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
    },
    movementX: function(n) {
      return "movementX" in n ? n.movementX : (n !== bu && (bu && n.type === "mousemove" ? (yc = n.screenX - bu.screenX, Oe = n.screenY - bu.screenY) : Oe = yc = 0, bu = n), yc);
    },
    movementY: function(n) {
      return "movementY" in n ? n.movementY : Oe;
    }
  }), Os = mi(Jn), zf = D({}, Jn, { dataTransfer: 0 }), wd = mi(zf), Lf = D({}, Es, { relatedTarget: 0 }), Hf = mi(Lf), Md = D({}, El, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Up = mi(Md), Bp = D({}, El, {
    clipboardData: function(n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    }
  }), Ds = mi(Bp), Ed = D({}, El, { data: 0 }), _a = mi(Ed), Od = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, kf = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, wo = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function Nf(n) {
    var o = this.nativeEvent;
    return o.getModifierState ? o.getModifierState(n) : (n = wo[n]) ? !!o[n] : !1;
  }
  function Mo() {
    return Nf;
  }
  var nl = D({}, Es, {
    key: function(n) {
      if (n.key) {
        var o = Od[n.key] || n.key;
        if (o !== "Unidentified") return o;
      }
      return n.type === "keypress" ? (n = Ue(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? kf[n.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Mo,
    charCode: function(n) {
      return n.type === "keypress" ? Ue(n) : 0;
    },
    keyCode: function(n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function(n) {
      return n.type === "keypress" ? Ue(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    }
  }), Wa = mi(nl), qi = D({}, Jn, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), _r = mi(qi), vc = D({}, Es, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Mo
  }), Uf = mi(vc), pi = D({}, El, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Dd = mi(pi), Su = D({}, Jn, {
    deltaX: function(n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function(n) {
      return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Ol = mi(Su), br = D({}, El, {
    newState: 0,
    oldState: 0
  }), Dl = mi(br), Ad = [9, 13, 27, 32], il = Xa && "CompositionEvent" in window, gi = null;
  Xa && "documentMode" in document && (gi = document.documentMode);
  var _c = Xa && "TextEvent" in window && !gi, Ia = Xa && (!il || gi && 8 < gi && 11 >= gi), Bf = " ", Sr = !1;
  function As(n, o) {
    switch (n) {
      case "keyup":
        return Ad.indexOf(o.keyCode) !== -1;
      case "keydown":
        return o.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Al(n) {
    return n = n.detail, typeof n == "object" && "data" in n ? n.data : null;
  }
  var Rl = !1;
  function bc(n, o) {
    switch (n) {
      case "compositionend":
        return Al(o);
      case "keypress":
        return o.which !== 32 ? null : (Sr = !0, Bf);
      case "textInput":
        return n = o.data, n === Bf && Sr ? null : n;
      default:
        return null;
    }
  }
  function Rs(n, o) {
    if (Rl)
      return n === "compositionend" || !il && As(n, o) ? (n = Ms(), el = va = Ka = null, Rl = !1, n) : null;
    switch (n) {
      case "paste":
        return null;
      case "keypress":
        if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) {
          if (o.char && 1 < o.char.length)
            return o.char;
          if (o.which) return String.fromCharCode(o.which);
        }
        return null;
      case "compositionend":
        return Ia && o.locale !== "ko" ? null : o.data;
      default:
        return null;
    }
  }
  var ba = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function al(n) {
    var o = n && n.nodeName && n.nodeName.toLowerCase();
    return o === "input" ? !!ba[n.type] : o === "textarea";
  }
  function Sc(n, o, c, m) {
    ws ? Ml ? Ml.push(m) : Ml = [m] : ws = m, o = $c(o, "onChange"), 0 < o.length && (c = new _u(
      "onChange",
      "change",
      null,
      c,
      m
    ), n.push({ event: c, listeners: o }));
  }
  var jn = null, $a = null;
  function Cl(n) {
    Xu(n, 0);
  }
  function Eo(n) {
    var o = yo(n);
    if (le(o)) return n;
  }
  function Cs(n, o) {
    if (n === "change") return o;
  }
  var Tc = !1;
  if (Xa) {
    var Oo;
    if (Xa) {
      var zs = "oninput" in document;
      if (!zs) {
        var Do = document.createElement("div");
        Do.setAttribute("oninput", "return;"), zs = typeof Do.oninput == "function";
      }
      Oo = zs;
    } else Oo = !1;
    Tc = Oo && (!document.documentMode || 9 < document.documentMode);
  }
  function ol() {
    jn && (jn.detachEvent("onpropertychange", Yf), $a = jn = null);
  }
  function Yf(n) {
    if (n.propertyName === "value" && Eo($a)) {
      var o = [];
      Sc(
        o,
        $a,
        n,
        xs(n)
      ), Ai(Cl, o);
    }
  }
  function Tr(n, o, c) {
    n === "focusin" ? (ol(), jn = o, $a = c, jn.attachEvent("onpropertychange", Yf)) : n === "focusout" && ol();
  }
  function zl(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
      return Eo($a);
  }
  function Fn(n, o) {
    if (n === "click") return Eo(o);
  }
  function jf(n, o) {
    if (n === "input" || n === "change")
      return Eo(o);
  }
  function Ll(n, o) {
    return n === o && (n !== 0 || 1 / n === 1 / o) || n !== n && o !== o;
  }
  var ti = typeof Object.is == "function" ? Object.is : Ll;
  function yi(n, o) {
    if (ti(n, o)) return !0;
    if (typeof n != "object" || n === null || typeof o != "object" || o === null)
      return !1;
    var c = Object.keys(n), m = Object.keys(o);
    if (c.length !== m.length) return !1;
    for (m = 0; m < c.length; m++) {
      var b = c[m];
      if (!Za.call(o, b) || !ti(n[b], o[b]))
        return !1;
    }
    return !0;
  }
  function Ja(n) {
    for (; n && n.firstChild; ) n = n.firstChild;
    return n;
  }
  function tn(n, o) {
    var c = Ja(n);
    n = 0;
    for (var m; c; ) {
      if (c.nodeType === 3) {
        if (m = n + c.textContent.length, n <= o && m >= o)
          return { node: c, offset: o - n };
        n = m;
      }
      t: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break t;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Ja(c);
    }
  }
  function Ls(n, o) {
    return n && o ? n === o ? !0 : n && n.nodeType === 3 ? !1 : o && o.nodeType === 3 ? Ls(n, o.parentNode) : "contains" in n ? n.contains(o) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(o) & 16) : !1 : !1;
  }
  function xr(n) {
    n = n != null && n.ownerDocument != null && n.ownerDocument.defaultView != null ? n.ownerDocument.defaultView : window;
    for (var o = Fe(n.document); o instanceof n.HTMLIFrameElement; ) {
      try {
        var c = typeof o.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) n = o.contentWindow;
      else break;
      o = Fe(n.document);
    }
    return o;
  }
  function Hs(n) {
    var o = n && n.nodeName && n.nodeName.toLowerCase();
    return o && (o === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || o === "textarea" || n.contentEditable === "true");
  }
  var Ao = Xa && "documentMode" in document && 11 >= document.documentMode, Ri = null, Zi = null, Ro = null, Hl = !1;
  function xc(n, o, c) {
    var m = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    Hl || Ri == null || Ri !== Fe(m) || (m = Ri, "selectionStart" in m && Hs(m) ? m = { start: m.selectionStart, end: m.selectionEnd } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = {
      anchorNode: m.anchorNode,
      anchorOffset: m.anchorOffset,
      focusNode: m.focusNode,
      focusOffset: m.focusOffset
    }), Ro && yi(Ro, m) || (Ro = m, m = $c(Zi, "onSelect"), 0 < m.length && (o = new _u(
      "onSelect",
      "select",
      null,
      o,
      c
    ), n.push({ event: o, listeners: m }), o.target = Ri)));
  }
  function Sa(n, o) {
    var c = {};
    return c[n.toLowerCase()] = o.toLowerCase(), c["Webkit" + n] = "webkit" + o, c["Moz" + n] = "moz" + o, c;
  }
  var ks = {
    animationend: Sa("Animation", "AnimationEnd"),
    animationiteration: Sa("Animation", "AnimationIteration"),
    animationstart: Sa("Animation", "AnimationStart"),
    transitionrun: Sa("Transition", "TransitionRun"),
    transitionstart: Sa("Transition", "TransitionStart"),
    transitioncancel: Sa("Transition", "TransitionCancel"),
    transitionend: Sa("Transition", "TransitionEnd")
  }, aa = {}, Fa = {};
  Xa && (Fa = document.createElement("div").style, "AnimationEvent" in window || (delete ks.animationend.animation, delete ks.animationiteration.animation, delete ks.animationstart.animation), "TransitionEvent" in window || delete ks.transitionend.transition);
  function to(n) {
    if (aa[n]) return aa[n];
    if (!ks[n]) return n;
    var o = ks[n], c;
    for (c in o)
      if (o.hasOwnProperty(c) && c in Fa)
        return aa[n] = o[c];
    return n;
  }
  var Rd = to("animationend"), Ta = to("animationiteration"), Tu = to("animationstart"), qf = to("transitionrun"), Ns = to("transitionstart"), Cd = to("transitioncancel"), wc = to("transitionend"), Zf = /* @__PURE__ */ new Map(), Co = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Co.push("scrollEnd");
  function xa(n, o) {
    Zf.set(n, o), Sl(o, [n]);
  }
  var kl = /* @__PURE__ */ new WeakMap();
  function Pi(n, o) {
    if (typeof n == "object" && n !== null) {
      var c = kl.get(n);
      return c !== void 0 ? c : (o = {
        value: n,
        source: o,
        stack: ln(o)
      }, kl.set(n, o), o);
    }
    return {
      value: n,
      source: o,
      stack: ln(o)
    };
  }
  var Ci = [], Nl = 0, Gn = 0;
  function wa() {
    for (var n = Nl, o = Gn = Nl = 0; o < n; ) {
      var c = Ci[o];
      Ci[o++] = null;
      var m = Ci[o];
      Ci[o++] = null;
      var b = Ci[o];
      Ci[o++] = null;
      var x = Ci[o];
      if (Ci[o++] = null, m !== null && b !== null) {
        var R = m.pending;
        R === null ? b.next = b : (b.next = R.next, R.next = b), m.pending = b;
      }
      x !== 0 && sl(c, b, x);
    }
  }
  function ll(n, o, c, m) {
    Ci[Nl++] = n, Ci[Nl++] = o, Ci[Nl++] = c, Ci[Nl++] = m, Gn |= m, n.lanes |= m, n = n.alternate, n !== null && (n.lanes |= m);
  }
  function zo(n, o, c, m) {
    return ll(n, o, c, m), rl(n);
  }
  function Lo(n, o) {
    return ll(n, null, null, o), rl(n);
  }
  function sl(n, o, c) {
    n.lanes |= c;
    var m = n.alternate;
    m !== null && (m.lanes |= c);
    for (var b = !1, x = n.return; x !== null; )
      x.childLanes |= c, m = x.alternate, m !== null && (m.childLanes |= c), x.tag === 22 && (n = x.stateNode, n === null || n._visibility & 1 || (b = !0)), n = x, x = x.return;
    return n.tag === 3 ? (x = n.stateNode, b && o !== null && (b = 31 - $n(c), n = x.hiddenUpdates, m = n[b], m === null ? n[b] = [o] : m.push(o), o.lane = c | 536870912), x) : null;
  }
  function rl(n) {
    if (50 < Gc)
      throw Gc = 0, kg = null, Error(u(185));
    for (var o = n.return; o !== null; )
      n = o, o = n.return;
    return n.tag === 3 ? n.stateNode : null;
  }
  var Us = {};
  function Pf(n, o, c, m) {
    this.tag = n, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = o, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Vi(n, o, c, m) {
    return new Pf(n, o, c, m);
  }
  function wr(n) {
    return n = n.prototype, !(!n || !n.isReactComponent);
  }
  function Ma(n, o) {
    var c = n.alternate;
    return c === null ? (c = Vi(
      n.tag,
      o,
      n.key,
      n.mode
    ), c.elementType = n.elementType, c.type = n.type, c.stateNode = n.stateNode, c.alternate = n, n.alternate = c) : (c.pendingProps = o, c.type = n.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = n.flags & 65011712, c.childLanes = n.childLanes, c.lanes = n.lanes, c.child = n.child, c.memoizedProps = n.memoizedProps, c.memoizedState = n.memoizedState, c.updateQueue = n.updateQueue, o = n.dependencies, c.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }, c.sibling = n.sibling, c.index = n.index, c.ref = n.ref, c.refCleanup = n.refCleanup, c;
  }
  function ye(n, o) {
    n.flags &= 65011714;
    var c = n.alternate;
    return c === null ? (n.childLanes = 0, n.lanes = o, n.child = null, n.subtreeFlags = 0, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null) : (n.childLanes = c.childLanes, n.lanes = c.lanes, n.child = c.child, n.subtreeFlags = 0, n.deletions = null, n.memoizedProps = c.memoizedProps, n.memoizedState = c.memoizedState, n.updateQueue = c.updateQueue, n.type = c.type, o = c.dependencies, n.dependencies = o === null ? null : {
      lanes: o.lanes,
      firstContext: o.firstContext
    }), n;
  }
  function Ot(n, o, c, m, b, x) {
    var R = 0;
    if (m = n, typeof n == "function") wr(n) && (R = 1);
    else if (typeof n == "string")
      R = l_(
        n,
        c,
        Mt.current
      ) ? 26 : n === "html" || n === "head" || n === "body" ? 27 : 5;
    else
      t: switch (n) {
        case wt:
          return n = Vi(31, c, o, b), n.elementType = wt, n.lanes = x, n;
        case I:
          return oa(c.children, b, x, o);
        case Q:
          R = 8, b |= 24;
          break;
        case X:
          return n = Vi(12, c, o, b | 2), n.elementType = X, n.lanes = x, n;
        case dt:
          return n = Vi(13, c, o, b), n.elementType = dt, n.lanes = x, n;
        case Lt:
          return n = Vi(19, c, o, b), n.elementType = Lt, n.lanes = x, n;
        default:
          if (typeof n == "object" && n !== null)
            switch (n.$$typeof) {
              case nt:
              case Et:
                R = 10;
                break t;
              case Dt:
                R = 9;
                break t;
              case zt:
                R = 11;
                break t;
              case Ct:
                R = 14;
                break t;
              case Yt:
                R = 16, m = null;
                break t;
            }
          R = 29, c = Error(
            u(130, n === null ? "null" : typeof n, "")
          ), m = null;
      }
    return o = Vi(R, c, o, b), o.elementType = n, o.type = m, o.lanes = x, o;
  }
  function oa(n, o, c, m) {
    return n = Vi(7, n, m, o), n.lanes = c, n;
  }
  function Mr(n, o, c) {
    return n = Vi(6, n, null, o), n.lanes = c, n;
  }
  function cn(n, o, c) {
    return o = Vi(
      4,
      n.children !== null ? n.children : [],
      n.key,
      o
    ), o.lanes = c, o.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation
    }, o;
  }
  var ul = [], Ul = 0, r = null, d = 0, v = [], w = 0, O = null, H = 1, q = "";
  function $(n, o) {
    ul[Ul++] = d, ul[Ul++] = r, r = n, d = o;
  }
  function rt(n, o, c) {
    v[w++] = H, v[w++] = q, v[w++] = O, O = n;
    var m = H;
    n = q;
    var b = 32 - $n(m) - 1;
    m &= ~(1 << b), c += 1;
    var x = 32 - $n(o) + b;
    if (30 < x) {
      var R = b - b % 5;
      x = (m & (1 << R) - 1).toString(32), m >>= R, b -= R, H = 1 << 32 - $n(o) + b | c << b | m, q = x + n;
    } else
      H = 1 << x | c << b | m, q = n;
  }
  function xt(n) {
    n.return !== null && ($(n, 1), rt(n, 1, 0));
  }
  function Ut(n) {
    for (; n === r; )
      r = ul[--Ul], ul[Ul] = null, d = ul[--Ul], ul[Ul] = null;
    for (; n === O; )
      O = v[--w], v[w] = null, q = v[--w], v[w] = null, H = v[--w], v[w] = null;
  }
  var qt = null, Zt = null, oe = !1, Ge = null, dn = !1, Dn = Error(u(519));
  function Gi(n) {
    var o = Error(u(418, ""));
    throw Ys(Pi(o, n)), Dn;
  }
  function xu(n) {
    var o = n.stateNode, c = n.type, m = n.memoizedProps;
    switch (o[Vn] = n, o[Ei] = m, c) {
      case "dialog":
        _e("cancel", o), _e("close", o);
        break;
      case "iframe":
      case "object":
      case "embed":
        _e("load", o);
        break;
      case "video":
      case "audio":
        for (c = 0; c < Ah.length; c++)
          _e(Ah[c], o);
        break;
      case "source":
        _e("error", o);
        break;
      case "img":
      case "image":
      case "link":
        _e("error", o), _e("load", o);
        break;
      case "details":
        _e("toggle", o);
        break;
      case "input":
        _e("invalid", o), gc(
          o,
          m.value,
          m.defaultValue,
          m.checked,
          m.defaultChecked,
          m.type,
          m.name,
          !0
        ), So(o);
        break;
      case "select":
        _e("invalid", o);
        break;
      case "textarea":
        _e("invalid", o), $o(o, m.value, m.defaultValue, m.children), So(o);
    }
    c = m.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || o.textContent === "" + c || m.suppressHydrationWarning === !0 || Wg(o.textContent, c) ? (m.popover != null && (_e("beforetoggle", o), _e("toggle", o)), m.onScroll != null && _e("scroll", o), m.onScrollEnd != null && _e("scrollend", o), m.onClick != null && (o.onclick = jm), o = !0) : o = !1, o || Gi(n);
  }
  function Vf(n) {
    for (qt = n.return; qt; )
      switch (qt.tag) {
        case 5:
        case 13:
          dn = !1;
          return;
        case 27:
        case 3:
          dn = !0;
          return;
        default:
          qt = qt.return;
      }
  }
  function Er(n) {
    if (n !== qt) return !1;
    if (!oe) return Vf(n), oe = !0, !1;
    var o = n.tag, c;
    if ((c = o !== 3 && o !== 27) && ((c = o === 5) && (c = n.type, c = !(c !== "form" && c !== "button") || ns(n.type, n.memoizedProps)), c = !c), c && Zt && Gi(n), Vf(n), o === 13) {
      if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(u(317));
      t: {
        for (n = n.nextSibling, o = 0; n; ) {
          if (n.nodeType === 8)
            if (c = n.data, c === "/$") {
              if (o === 0) {
                Zt = pl(n.nextSibling);
                break t;
              }
              o--;
            } else
              c !== "$" && c !== "$!" && c !== "$?" || o++;
          n = n.nextSibling;
        }
        Zt = null;
      }
    } else
      o === 27 ? (o = Zt, Xr(n.type) ? (n = Qr, Qr = null, Zt = n) : Zt = o) : Zt = qt ? pl(n.stateNode.nextSibling) : null;
    return !0;
  }
  function Bs() {
    Zt = qt = null, oe = !1;
  }
  function Gf() {
    var n = Ge;
    return n !== null && (za === null ? za = n : za.push.apply(
      za,
      n
    ), Ge = null), n;
  }
  function Ys(n) {
    Ge === null ? Ge = [n] : Ge.push(n);
  }
  var fn = F(null), Ea = null, eo = null;
  function cl(n, o, c) {
    bt(fn, o._currentValue), o._currentValue = c;
  }
  function Ho(n) {
    n._currentValue = fn.current, ct(fn);
  }
  function Or(n, o, c) {
    for (; n !== null; ) {
      var m = n.alternate;
      if ((n.childLanes & o) !== o ? (n.childLanes |= o, m !== null && (m.childLanes |= o)) : m !== null && (m.childLanes & o) !== o && (m.childLanes |= o), n === c) break;
      n = n.return;
    }
  }
  function Mc(n, o, c, m) {
    var b = n.child;
    for (b !== null && (b.return = n); b !== null; ) {
      var x = b.dependencies;
      if (x !== null) {
        var R = b.child;
        x = x.firstContext;
        t: for (; x !== null; ) {
          var U = x;
          x = b;
          for (var Z = 0; Z < o.length; Z++)
            if (U.context === o[Z]) {
              x.lanes |= c, U = x.alternate, U !== null && (U.lanes |= c), Or(
                x.return,
                c,
                n
              ), m || (R = null);
              break t;
            }
          x = U.next;
        }
      } else if (b.tag === 18) {
        if (R = b.return, R === null) throw Error(u(341));
        R.lanes |= c, x = R.alternate, x !== null && (x.lanes |= c), Or(R, c, n), R = null;
      } else R = b.child;
      if (R !== null) R.return = b;
      else
        for (R = b; R !== null; ) {
          if (R === n) {
            R = null;
            break;
          }
          if (b = R.sibling, b !== null) {
            b.return = R.return, R = b;
            break;
          }
          R = R.return;
        }
      b = R;
    }
  }
  function Dr(n, o, c, m) {
    n = null;
    for (var b = o, x = !1; b !== null; ) {
      if (!x) {
        if ((b.flags & 524288) !== 0) x = !0;
        else if ((b.flags & 262144) !== 0) break;
      }
      if (b.tag === 10) {
        var R = b.alternate;
        if (R === null) throw Error(u(387));
        if (R = R.memoizedProps, R !== null) {
          var U = b.type;
          ti(b.pendingProps.value, R.value) || (n !== null ? n.push(U) : n = [U]);
        }
      } else if (b === We.current) {
        if (R = b.alternate, R === null) throw Error(u(387));
        R.memoizedState.memoizedState !== b.memoizedState.memoizedState && (n !== null ? n.push(Na) : n = [Na]);
      }
      b = b.return;
    }
    n !== null && Mc(
      o,
      n,
      c,
      m
    ), o.flags |= 262144;
  }
  function Xf(n) {
    for (n = n.firstContext; n !== null; ) {
      if (!ti(
        n.context._currentValue,
        n.memoizedValue
      ))
        return !0;
      n = n.next;
    }
    return !1;
  }
  function Ar(n) {
    Ea = n, eo = null, n = n.dependencies, n !== null && (n.firstContext = null);
  }
  function vi(n) {
    return Yp(Ea, n);
  }
  function Qf(n, o) {
    return Ea === null && Ar(n), Yp(n, o);
  }
  function Yp(n, o) {
    var c = o._currentValue;
    if (o = { context: o, memoizedValue: c, next: null }, eo === null) {
      if (n === null) throw Error(u(308));
      eo = o, n.dependencies = { lanes: 0, firstContext: o }, n.flags |= 524288;
    } else eo = eo.next = o;
    return c;
  }
  var Ec = typeof AbortController < "u" ? AbortController : function() {
    var n = [], o = this.signal = {
      aborted: !1,
      addEventListener: function(c, m) {
        n.push(m);
      }
    };
    this.abort = function() {
      o.aborted = !0, n.forEach(function(c) {
        return c();
      });
    };
  }, zd = s.unstable_scheduleCallback, Ov = s.unstable_NormalPriority, ei = {
    $$typeof: Et,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Oc() {
    return {
      controller: new Ec(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Bl(n) {
    n.refCount--, n.refCount === 0 && zd(Ov, function() {
      n.controller.abort();
    });
  }
  var Rr = null, Kf = 0, ko = 0, ni = null;
  function Ld(n, o) {
    if (Rr === null) {
      var c = Rr = [];
      Kf = 0, ko = Gu(), ni = {
        status: "pending",
        value: void 0,
        then: function(m) {
          c.push(m);
        }
      };
    }
    return Kf++, o.then(Hd, Hd), o;
  }
  function Hd() {
    if (--Kf === 0 && Rr !== null) {
      ni !== null && (ni.status = "fulfilled");
      var n = Rr;
      Rr = null, ko = 0, ni = null;
      for (var o = 0; o < n.length; o++) (0, n[o])();
    }
  }
  function Dv(n, o) {
    var c = [], m = {
      status: "pending",
      value: null,
      reason: null,
      then: function(b) {
        c.push(b);
      }
    };
    return n.then(
      function() {
        m.status = "fulfilled", m.value = o;
        for (var b = 0; b < c.length; b++) (0, c[b])(o);
      },
      function(b) {
        for (m.status = "rejected", m.reason = b, b = 0; b < c.length; b++)
          (0, c[b])(void 0);
      }
    ), m;
  }
  var kd = V.S;
  V.S = function(n, o) {
    typeof o == "object" && o !== null && typeof o.then == "function" && Ld(n, o), kd !== null && kd(n, o);
  };
  var Yl = F(null);
  function Wf() {
    var n = Yl.current;
    return n !== null ? n : sn.pooledCache;
  }
  function wu(n, o) {
    o === null ? bt(Yl, Yl.current) : bt(Yl, o.pool);
  }
  function Nd() {
    var n = Wf();
    return n === null ? null : { parent: ei._currentValue, pool: n };
  }
  var Cr = Error(u(460)), Ud = Error(u(474)), If = Error(u(542)), Bd = { then: function() {
  } };
  function Yd(n) {
    return n = n.status, n === "fulfilled" || n === "rejected";
  }
  function $f() {
  }
  function jp(n, o, c) {
    switch (c = n[c], c === void 0 ? n.push(o) : c !== o && (o.then($f, $f), o = c), o.status) {
      case "fulfilled":
        return o.value;
      case "rejected":
        throw n = o.reason, Zp(n), n;
      default:
        if (typeof o.status == "string") o.then($f, $f);
        else {
          if (n = sn, n !== null && 100 < n.shellSuspendCounter)
            throw Error(u(482));
          n = o, n.status = "pending", n.then(
            function(m) {
              if (o.status === "pending") {
                var b = o;
                b.status = "fulfilled", b.value = m;
              }
            },
            function(m) {
              if (o.status === "pending") {
                var b = o;
                b.status = "rejected", b.reason = m;
              }
            }
          );
        }
        switch (o.status) {
          case "fulfilled":
            return o.value;
          case "rejected":
            throw n = o.reason, Zp(n), n;
        }
        throw Mu = o, Cr;
    }
  }
  var Mu = null;
  function qp() {
    if (Mu === null) throw Error(u(459));
    var n = Mu;
    return Mu = null, n;
  }
  function Zp(n) {
    if (n === Cr || n === If)
      throw Error(u(483));
  }
  var jl = !1;
  function jd(n) {
    n.updateQueue = {
      baseState: n.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function qd(n, o) {
    n = n.updateQueue, o.updateQueue === n && (o.updateQueue = {
      baseState: n.baseState,
      firstBaseUpdate: n.firstBaseUpdate,
      lastBaseUpdate: n.lastBaseUpdate,
      shared: n.shared,
      callbacks: null
    });
  }
  function Oa(n) {
    return { lane: n, tag: 0, payload: null, callback: null, next: null };
  }
  function ql(n, o, c) {
    var m = n.updateQueue;
    if (m === null) return null;
    if (m = m.shared, (Qe & 2) !== 0) {
      var b = m.pending;
      return b === null ? o.next = o : (o.next = b.next, b.next = o), m.pending = o, o = rl(n), sl(n, null, c), o;
    }
    return ll(n, m, o, c), rl(n);
  }
  function Eu(n, o, c) {
    if (o = o.updateQueue, o !== null && (o = o.shared, (c & 4194048) !== 0)) {
      var m = o.lanes;
      m &= n.pendingLanes, c |= m, o.lanes = c, fe(n, c);
    }
  }
  function Pp(n, o) {
    var c = n.updateQueue, m = n.alternate;
    if (m !== null && (m = m.updateQueue, c === m)) {
      var b = null, x = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var R = {
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: null,
            next: null
          };
          x === null ? b = x = R : x = x.next = R, c = c.next;
        } while (c !== null);
        x === null ? b = x = o : x = x.next = o;
      } else b = x = o;
      c = {
        baseState: m.baseState,
        firstBaseUpdate: b,
        lastBaseUpdate: x,
        shared: m.shared,
        callbacks: m.callbacks
      }, n.updateQueue = c;
      return;
    }
    n = c.lastBaseUpdate, n === null ? c.firstBaseUpdate = o : n.next = o, c.lastBaseUpdate = o;
  }
  var Vp = !1;
  function Dc() {
    if (Vp) {
      var n = ni;
      if (n !== null) throw n;
    }
  }
  function js(n, o, c, m) {
    Vp = !1;
    var b = n.updateQueue;
    jl = !1;
    var x = b.firstBaseUpdate, R = b.lastBaseUpdate, U = b.shared.pending;
    if (U !== null) {
      b.shared.pending = null;
      var Z = U, it = Z.next;
      Z.next = null, R === null ? x = it : R.next = it, R = Z;
      var vt = n.alternate;
      vt !== null && (vt = vt.updateQueue, U = vt.lastBaseUpdate, U !== R && (U === null ? vt.firstBaseUpdate = it : U.next = it, vt.lastBaseUpdate = Z));
    }
    if (x !== null) {
      var St = b.baseState;
      R = 0, vt = it = Z = null, U = x;
      do {
        var ot = U.lane & -536870913, st = ot !== U.lane;
        if (st ? (He & ot) === ot : (m & ot) === ot) {
          ot !== 0 && ot === ko && (Vp = !0), vt !== null && (vt = vt.next = {
            lane: 0,
            tag: U.tag,
            payload: U.payload,
            callback: null,
            next: null
          });
          t: {
            var te = n, ee = U;
            ot = o;
            var Ze = c;
            switch (ee.tag) {
              case 1:
                if (te = ee.payload, typeof te == "function") {
                  St = te.call(Ze, St, ot);
                  break t;
                }
                St = te;
                break t;
              case 3:
                te.flags = te.flags & -65537 | 128;
              case 0:
                if (te = ee.payload, ot = typeof te == "function" ? te.call(Ze, St, ot) : te, ot == null) break t;
                St = D({}, St, ot);
                break t;
              case 2:
                jl = !0;
            }
          }
          ot = U.callback, ot !== null && (n.flags |= 64, st && (n.flags |= 8192), st = b.callbacks, st === null ? b.callbacks = [ot] : st.push(ot));
        } else
          st = {
            lane: ot,
            tag: U.tag,
            payload: U.payload,
            callback: U.callback,
            next: null
          }, vt === null ? (it = vt = st, Z = St) : vt = vt.next = st, R |= ot;
        if (U = U.next, U === null) {
          if (U = b.shared.pending, U === null)
            break;
          st = U, U = st.next, st.next = null, b.lastBaseUpdate = st, b.shared.pending = null;
        }
      } while (!0);
      vt === null && (Z = St), b.baseState = Z, b.firstBaseUpdate = it, b.lastBaseUpdate = vt, x === null && (b.shared.lanes = 0), Qs |= R, n.lanes = R, n.memoizedState = St;
    }
  }
  function Zd(n, o) {
    if (typeof n != "function")
      throw Error(u(191, n));
    n.call(o);
  }
  function Jf(n, o) {
    var c = n.callbacks;
    if (c !== null)
      for (n.callbacks = null, n = 0; n < c.length; n++)
        Zd(c[n], o);
  }
  var Ou = F(null), Ff = F(0);
  function _i(n, o) {
    n = Xs, bt(Ff, n), bt(Ou, o), Xs = n | o.baseLanes;
  }
  function Ac() {
    bt(Ff, Xs), bt(Ou, Ou.current);
  }
  function Rc() {
    Xs = Ff.current, ct(Ou), ct(Ff);
  }
  var No = 0, ve = null, Xe = null, xn = null, th = !1, no = !1, zr = !1, fl = 0, io = 0, qs = null, Gp = 0;
  function wn() {
    throw Error(u(321));
  }
  function Pd(n, o) {
    if (o === null) return !1;
    for (var c = 0; c < o.length && c < n.length; c++)
      if (!ti(n[c], o[c])) return !1;
    return !0;
  }
  function Vd(n, o, c, m, b, x) {
    return No = x, ve = o, o.memoizedState = null, o.updateQueue = null, o.lanes = 0, V.H = n === null || n.memoizedState === null ? lg : sg, zr = !1, x = c(m, b), zr = !1, no && (x = Xp(
      o,
      c,
      m,
      b
    )), Lr(n), x;
  }
  function Lr(n) {
    V.H = sm;
    var o = Xe !== null && Xe.next !== null;
    if (No = 0, xn = Xe = ve = null, th = !1, io = 0, qs = null, o) throw Error(u(300));
    n === null || ii || (n = n.dependencies, n !== null && Xf(n) && (ii = !0));
  }
  function Xp(n, o, c, m) {
    ve = n;
    var b = 0;
    do {
      if (no && (qs = null), io = 0, no = !1, 25 <= b) throw Error(u(301));
      if (b += 1, xn = Xe = null, n.updateQueue != null) {
        var x = n.updateQueue;
        x.lastEffect = null, x.events = null, x.stores = null, x.memoCache != null && (x.memoCache.index = 0);
      }
      V.H = Zs, x = o(c, m);
    } while (no);
    return x;
  }
  function Av() {
    var n = V.H, o = n.useState()[0];
    return o = typeof o.then == "function" ? nh(o) : o, n = n.useState()[0], (Xe !== null ? Xe.memoizedState : null) !== n && (ve.flags |= 1024), o;
  }
  function Gd() {
    var n = fl !== 0;
    return fl = 0, n;
  }
  function Cc(n, o, c) {
    o.updateQueue = n.updateQueue, o.flags &= -2053, n.lanes &= ~c;
  }
  function Xd(n) {
    if (th) {
      for (n = n.memoizedState; n !== null; ) {
        var o = n.queue;
        o !== null && (o.pending = null), n = n.next;
      }
      th = !1;
    }
    No = 0, xn = Xe = ve = null, no = !1, io = fl = 0, qs = null;
  }
  function Xi() {
    var n = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return xn === null ? ve.memoizedState = xn = n : xn = xn.next = n, xn;
  }
  function An() {
    if (Xe === null) {
      var n = ve.alternate;
      n = n !== null ? n.memoizedState : null;
    } else n = Xe.next;
    var o = xn === null ? ve.memoizedState : xn.next;
    if (o !== null)
      xn = o, Xe = n;
    else {
      if (n === null)
        throw ve.alternate === null ? Error(u(467)) : Error(u(310));
      Xe = n, n = {
        memoizedState: Xe.memoizedState,
        baseState: Xe.baseState,
        baseQueue: Xe.baseQueue,
        queue: Xe.queue,
        next: null
      }, xn === null ? ve.memoizedState = xn = n : xn = xn.next = n;
    }
    return xn;
  }
  function eh() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function nh(n) {
    var o = io;
    return io += 1, qs === null && (qs = []), n = jp(qs, n, o), o = ve, (xn === null ? o.memoizedState : xn.next) === null && (o = o.alternate, V.H = o === null || o.memoizedState === null ? lg : sg), n;
  }
  function Xn(n) {
    if (n !== null && typeof n == "object") {
      if (typeof n.then == "function") return nh(n);
      if (n.$$typeof === Et) return vi(n);
    }
    throw Error(u(438, String(n)));
  }
  function Qd(n) {
    var o = null, c = ve.updateQueue;
    if (c !== null && (o = c.memoCache), o == null) {
      var m = ve.alternate;
      m !== null && (m = m.updateQueue, m !== null && (m = m.memoCache, m != null && (o = {
        data: m.data.map(function(b) {
          return b.slice();
        }),
        index: 0
      })));
    }
    if (o == null && (o = { data: [], index: 0 }), c === null && (c = eh(), ve.updateQueue = c), c.memoCache = o, c = o.data[o.index], c === void 0)
      for (c = o.data[o.index] = Array(n), m = 0; m < n; m++)
        c[m] = ne;
    return o.index++, c;
  }
  function Zl(n, o) {
    return typeof o == "function" ? o(n) : o;
  }
  function ih(n) {
    var o = An();
    return Kd(o, Xe, n);
  }
  function Kd(n, o, c) {
    var m = n.queue;
    if (m === null) throw Error(u(311));
    m.lastRenderedReducer = c;
    var b = n.baseQueue, x = m.pending;
    if (x !== null) {
      if (b !== null) {
        var R = b.next;
        b.next = x.next, x.next = R;
      }
      o.baseQueue = b = x, m.pending = null;
    }
    if (x = n.baseState, b === null) n.memoizedState = x;
    else {
      o = b.next;
      var U = R = null, Z = null, it = o, vt = !1;
      do {
        var St = it.lane & -536870913;
        if (St !== it.lane ? (He & St) === St : (No & St) === St) {
          var ot = it.revertLane;
          if (ot === 0)
            Z !== null && (Z = Z.next = {
              lane: 0,
              revertLane: 0,
              action: it.action,
              hasEagerState: it.hasEagerState,
              eagerState: it.eagerState,
              next: null
            }), St === ko && (vt = !0);
          else if ((No & ot) === ot) {
            it = it.next, ot === ko && (vt = !0);
            continue;
          } else
            St = {
              lane: 0,
              revertLane: it.revertLane,
              action: it.action,
              hasEagerState: it.hasEagerState,
              eagerState: it.eagerState,
              next: null
            }, Z === null ? (U = Z = St, R = x) : Z = Z.next = St, ve.lanes |= ot, Qs |= ot;
          St = it.action, zr && c(x, St), x = it.hasEagerState ? it.eagerState : c(x, St);
        } else
          ot = {
            lane: St,
            revertLane: it.revertLane,
            action: it.action,
            hasEagerState: it.hasEagerState,
            eagerState: it.eagerState,
            next: null
          }, Z === null ? (U = Z = ot, R = x) : Z = Z.next = ot, ve.lanes |= St, Qs |= St;
        it = it.next;
      } while (it !== null && it !== o);
      if (Z === null ? R = x : Z.next = U, !ti(x, n.memoizedState) && (ii = !0, vt && (c = ni, c !== null)))
        throw c;
      n.memoizedState = x, n.baseState = R, n.baseQueue = Z, m.lastRenderedState = x;
    }
    return b === null && (m.lanes = 0), [n.memoizedState, m.dispatch];
  }
  function Wd(n) {
    var o = An(), c = o.queue;
    if (c === null) throw Error(u(311));
    c.lastRenderedReducer = n;
    var m = c.dispatch, b = c.pending, x = o.memoizedState;
    if (b !== null) {
      c.pending = null;
      var R = b = b.next;
      do
        x = n(x, R.action), R = R.next;
      while (R !== b);
      ti(x, o.memoizedState) || (ii = !0), o.memoizedState = x, o.baseQueue === null && (o.baseState = x), c.lastRenderedState = x;
    }
    return [x, m];
  }
  function ah(n, o, c) {
    var m = ve, b = An(), x = oe;
    if (x) {
      if (c === void 0) throw Error(u(407));
      c = c();
    } else c = o();
    var R = !ti(
      (Xe || b).memoizedState,
      c
    );
    R && (b.memoizedState = c, ii = !0), b = b.queue;
    var U = Kp.bind(null, m, b, n);
    if (en(2048, 8, U, [n]), b.getSnapshot !== o || R || xn !== null && xn.memoizedState.tag & 1) {
      if (m.flags |= 2048, Da(
        9,
        sh(),
        Qp.bind(
          null,
          m,
          b,
          c,
          o
        ),
        null
      ), sn === null) throw Error(u(349));
      x || (No & 124) !== 0 || Id(m, o, c);
    }
    return c;
  }
  function Id(n, o, c) {
    n.flags |= 16384, n = { getSnapshot: o, value: c }, o = ve.updateQueue, o === null ? (o = eh(), ve.updateQueue = o, o.stores = [n]) : (c = o.stores, c === null ? o.stores = [n] : c.push(n));
  }
  function Qp(n, o, c, m) {
    o.value = c, o.getSnapshot = m, Wp(o) && $d(n);
  }
  function Kp(n, o, c) {
    return c(function() {
      Wp(o) && $d(n);
    });
  }
  function Wp(n) {
    var o = n.getSnapshot;
    n = n.value;
    try {
      var c = o();
      return !ti(n, c);
    } catch {
      return !0;
    }
  }
  function $d(n) {
    var o = Lo(n, 2);
    o !== null && lo(o, n, 2);
  }
  function oh(n) {
    var o = Xi();
    if (typeof n == "function") {
      var c = n;
      if (n = c(), zr) {
        ta(!0);
        try {
          c();
        } finally {
          ta(!1);
        }
      }
    }
    return o.memoizedState = o.baseState = n, o.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Zl,
      lastRenderedState: n
    }, o;
  }
  function Jd(n, o, c, m) {
    return n.baseState = c, Kd(
      n,
      Xe,
      typeof m == "function" ? m : Zl
    );
  }
  function Rv(n, o, c, m, b) {
    if (Cu(n)) throw Error(u(485));
    if (n = o.action, n !== null) {
      var x = {
        payload: b,
        action: n,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(R) {
          x.listeners.push(R);
        }
      };
      V.T !== null ? c(!0) : x.isTransition = !1, m(x), c = o.pending, c === null ? (x.next = o.pending = x, Fd(o, x)) : (x.next = c.next, o.pending = c.next = x);
    }
  }
  function Fd(n, o) {
    var c = o.action, m = o.payload, b = n.state;
    if (o.isTransition) {
      var x = V.T, R = {};
      V.T = R;
      try {
        var U = c(b, m), Z = V.S;
        Z !== null && Z(R, U), lh(n, o, U);
      } catch (it) {
        em(n, o, it);
      } finally {
        V.T = x;
      }
    } else
      try {
        x = c(b, m), lh(n, o, x);
      } catch (it) {
        em(n, o, it);
      }
  }
  function lh(n, o, c) {
    c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(
      function(m) {
        tm(n, o, m);
      },
      function(m) {
        return em(n, o, m);
      }
    ) : tm(n, o, c);
  }
  function tm(n, o, c) {
    o.status = "fulfilled", o.value = c, Ip(o), n.state = c, o = n.pending, o !== null && (c = o.next, c === o ? n.pending = null : (c = c.next, o.next = c, Fd(n, c)));
  }
  function em(n, o, c) {
    var m = n.pending;
    if (n.pending = null, m !== null) {
      m = m.next;
      do
        o.status = "rejected", o.reason = c, Ip(o), o = o.next;
      while (o !== m);
    }
    n.action = null;
  }
  function Ip(n) {
    n = n.listeners;
    for (var o = 0; o < n.length; o++) (0, n[o])();
  }
  function nm(n, o) {
    return o;
  }
  function $p(n, o) {
    if (oe) {
      var c = sn.formState;
      if (c !== null) {
        t: {
          var m = ve;
          if (oe) {
            if (Zt) {
              e: {
                for (var b = Zt, x = dn; b.nodeType !== 8; ) {
                  if (!x) {
                    b = null;
                    break e;
                  }
                  if (b = pl(
                    b.nextSibling
                  ), b === null) {
                    b = null;
                    break e;
                  }
                }
                x = b.data, b = x === "F!" || x === "F" ? b : null;
              }
              if (b) {
                Zt = pl(
                  b.nextSibling
                ), m = b.data === "F!";
                break t;
              }
            }
            Gi(m);
          }
          m = !1;
        }
        m && (o = c[0]);
      }
    }
    return c = Xi(), c.memoizedState = c.baseState = o, m = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: nm,
      lastRenderedState: o
    }, c.queue = m, c = ag.bind(
      null,
      ve,
      m
    ), m.dispatch = c, m = oh(!1), x = ch.bind(
      null,
      ve,
      !1,
      m.queue
    ), m = Xi(), b = {
      state: o,
      dispatch: null,
      action: n,
      pending: null
    }, m.queue = b, c = Rv.bind(
      null,
      ve,
      b,
      x,
      c
    ), b.dispatch = c, m.memoizedState = n, [o, c, !1];
  }
  function Pl(n) {
    var o = An();
    return im(o, Xe, n);
  }
  function im(n, o, c) {
    if (o = Kd(
      n,
      o,
      nm
    )[0], n = ih(Zl)[0], typeof o == "object" && o !== null && typeof o.then == "function")
      try {
        var m = nh(o);
      } catch (R) {
        throw R === Cr ? If : R;
      }
    else m = o;
    o = An();
    var b = o.queue, x = b.dispatch;
    return c !== o.memoizedState && (ve.flags |= 2048, Da(
      9,
      sh(),
      H0.bind(null, b, c),
      null
    )), [m, x, n];
  }
  function H0(n, o) {
    n.action = o;
  }
  function am(n) {
    var o = An(), c = Xe;
    if (c !== null)
      return im(o, c, n);
    An(), o = o.memoizedState, c = An();
    var m = c.queue.dispatch;
    return c.memoizedState = n, [o, m, !1];
  }
  function Da(n, o, c, m) {
    return n = { tag: n, create: c, deps: m, inst: o, next: null }, o = ve.updateQueue, o === null && (o = eh(), ve.updateQueue = o), c = o.lastEffect, c === null ? o.lastEffect = n.next = n : (m = c.next, c.next = n, n.next = m, o.lastEffect = n), n;
  }
  function sh() {
    return { destroy: void 0, resource: void 0 };
  }
  function rh() {
    return An().memoizedState;
  }
  function Hr(n, o, c, m) {
    var b = Xi();
    m = m === void 0 ? null : m, ve.flags |= n, b.memoizedState = Da(
      1 | o,
      sh(),
      c,
      m
    );
  }
  function en(n, o, c, m) {
    var b = An();
    m = m === void 0 ? null : m;
    var x = b.memoizedState.inst;
    Xe !== null && m !== null && Pd(m, Xe.memoizedState.deps) ? b.memoizedState = Da(o, x, c, m) : (ve.flags |= n, b.memoizedState = Da(
      1 | o,
      x,
      c,
      m
    ));
  }
  function Cv(n, o) {
    Hr(8390656, 8, n, o);
  }
  function zv(n, o) {
    en(2048, 8, n, o);
  }
  function Jp(n, o) {
    return en(4, 2, n, o);
  }
  function hl(n, o) {
    return en(4, 4, n, o);
  }
  function Fp(n, o) {
    if (typeof o == "function") {
      n = n();
      var c = o(n);
      return function() {
        typeof c == "function" ? c() : o(null);
      };
    }
    if (o != null)
      return n = n(), o.current = n, function() {
        o.current = null;
      };
  }
  function om(n, o, c) {
    c = c != null ? c.concat([n]) : null, en(4, 4, Fp.bind(null, o, n), c);
  }
  function Du() {
  }
  function Au(n, o) {
    var c = An();
    o = o === void 0 ? null : o;
    var m = c.memoizedState;
    return o !== null && Pd(o, m[1]) ? m[0] : (c.memoizedState = [n, o], n);
  }
  function tg(n, o) {
    var c = An();
    o = o === void 0 ? null : o;
    var m = c.memoizedState;
    if (o !== null && Pd(o, m[1]))
      return m[0];
    if (m = n(), zr) {
      ta(!0);
      try {
        n();
      } finally {
        ta(!1);
      }
    }
    return c.memoizedState = [m, o], m;
  }
  function uh(n, o, c) {
    return c === void 0 || (No & 1073741824) !== 0 ? n.memoizedState = o : (n.memoizedState = c, n = Ng(), ve.lanes |= n, Qs |= n, c);
  }
  function eg(n, o, c, m) {
    return ti(c, o) ? c : Ou.current !== null ? (n = uh(n, c, m), ti(n, o) || (ii = !0), n) : (No & 42) === 0 ? (ii = !0, n.memoizedState = c) : (n = Ng(), ve.lanes |= n, Qs |= n, o);
  }
  function Lv(n, o, c, m, b) {
    var x = mt.p;
    mt.p = x !== 0 && 8 > x ? x : 8;
    var R = V.T, U = {};
    V.T = U, ch(n, !1, o, c);
    try {
      var Z = b(), it = V.S;
      if (it !== null && it(U, Z), Z !== null && typeof Z == "object" && typeof Z.then == "function") {
        var vt = Dv(
          Z,
          m
        );
        Ru(
          n,
          o,
          vt,
          oo(n)
        );
      } else
        Ru(
          n,
          o,
          m,
          oo(n)
        );
    } catch (St) {
      Ru(
        n,
        o,
        { then: function() {
        }, status: "rejected", reason: St },
        oo()
      );
    } finally {
      mt.p = x, V.T = R;
    }
  }
  function k0() {
  }
  function lm(n, o, c, m) {
    if (n.tag !== 5) throw Error(u(476));
    var b = Hv(n).queue;
    Lv(
      n,
      b,
      o,
      ut,
      c === null ? k0 : function() {
        return zc(n), c(m);
      }
    );
  }
  function Hv(n) {
    var o = n.memoizedState;
    if (o !== null) return o;
    o = {
      memoizedState: ut,
      baseState: ut,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Zl,
        lastRenderedState: ut
      },
      next: null
    };
    var c = {};
    return o.next = {
      memoizedState: c,
      baseState: c,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Zl,
        lastRenderedState: c
      },
      next: null
    }, n.memoizedState = o, n = n.alternate, n !== null && (n.memoizedState = o), o;
  }
  function zc(n) {
    var o = Hv(n).next.queue;
    Ru(n, o, {}, oo());
  }
  function Uo() {
    return vi(Na);
  }
  function ng() {
    return An().memoizedState;
  }
  function kv() {
    return An().memoizedState;
  }
  function Nv(n) {
    for (var o = n.return; o !== null; ) {
      switch (o.tag) {
        case 24:
        case 3:
          var c = oo();
          n = Oa(c);
          var m = ql(o, n, c);
          m !== null && (lo(m, o, c), Eu(m, o, c)), o = { cache: Oc() }, n.payload = o;
          return;
      }
      o = o.return;
    }
  }
  function ig(n, o, c) {
    var m = oo();
    c = {
      lane: m,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Cu(n) ? Uv(o, c) : (c = zo(n, o, c, m), c !== null && (lo(c, n, m), og(c, o, m)));
  }
  function ag(n, o, c) {
    var m = oo();
    Ru(n, o, c, m);
  }
  function Ru(n, o, c, m) {
    var b = {
      lane: m,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Cu(n)) Uv(o, b);
    else {
      var x = n.alternate;
      if (n.lanes === 0 && (x === null || x.lanes === 0) && (x = o.lastRenderedReducer, x !== null))
        try {
          var R = o.lastRenderedState, U = x(R, c);
          if (b.hasEagerState = !0, b.eagerState = U, ti(U, R))
            return ll(n, o, b, 0), sn === null && wa(), !1;
        } catch {
        } finally {
        }
      if (c = zo(n, o, b, m), c !== null)
        return lo(c, n, m), og(c, o, m), !0;
    }
    return !1;
  }
  function ch(n, o, c, m) {
    if (m = {
      lane: 2,
      revertLane: Gu(),
      action: m,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Cu(n)) {
      if (o) throw Error(u(479));
    } else
      o = zo(
        n,
        c,
        m,
        2
      ), o !== null && lo(o, n, 2);
  }
  function Cu(n) {
    var o = n.alternate;
    return n === ve || o !== null && o === ve;
  }
  function Uv(n, o) {
    no = th = !0;
    var c = n.pending;
    c === null ? o.next = o : (o.next = c.next, c.next = o), n.pending = o;
  }
  function og(n, o, c) {
    if ((c & 4194048) !== 0) {
      var m = o.lanes;
      m &= n.pendingLanes, c |= m, o.lanes = c, fe(n, c);
    }
  }
  var sm = {
    readContext: vi,
    use: Xn,
    useCallback: wn,
    useContext: wn,
    useEffect: wn,
    useImperativeHandle: wn,
    useLayoutEffect: wn,
    useInsertionEffect: wn,
    useMemo: wn,
    useReducer: wn,
    useRef: wn,
    useState: wn,
    useDebugValue: wn,
    useDeferredValue: wn,
    useTransition: wn,
    useSyncExternalStore: wn,
    useId: wn,
    useHostTransitionStatus: wn,
    useFormState: wn,
    useActionState: wn,
    useOptimistic: wn,
    useMemoCache: wn,
    useCacheRefresh: wn
  }, lg = {
    readContext: vi,
    use: Xn,
    useCallback: function(n, o) {
      return Xi().memoizedState = [
        n,
        o === void 0 ? null : o
      ], n;
    },
    useContext: vi,
    useEffect: Cv,
    useImperativeHandle: function(n, o, c) {
      c = c != null ? c.concat([n]) : null, Hr(
        4194308,
        4,
        Fp.bind(null, o, n),
        c
      );
    },
    useLayoutEffect: function(n, o) {
      return Hr(4194308, 4, n, o);
    },
    useInsertionEffect: function(n, o) {
      Hr(4, 2, n, o);
    },
    useMemo: function(n, o) {
      var c = Xi();
      o = o === void 0 ? null : o;
      var m = n();
      if (zr) {
        ta(!0);
        try {
          n();
        } finally {
          ta(!1);
        }
      }
      return c.memoizedState = [m, o], m;
    },
    useReducer: function(n, o, c) {
      var m = Xi();
      if (c !== void 0) {
        var b = c(o);
        if (zr) {
          ta(!0);
          try {
            c(o);
          } finally {
            ta(!1);
          }
        }
      } else b = o;
      return m.memoizedState = m.baseState = b, n = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: n,
        lastRenderedState: b
      }, m.queue = n, n = n.dispatch = ig.bind(
        null,
        ve,
        n
      ), [m.memoizedState, n];
    },
    useRef: function(n) {
      var o = Xi();
      return n = { current: n }, o.memoizedState = n;
    },
    useState: function(n) {
      n = oh(n);
      var o = n.queue, c = ag.bind(null, ve, o);
      return o.dispatch = c, [n.memoizedState, c];
    },
    useDebugValue: Du,
    useDeferredValue: function(n, o) {
      var c = Xi();
      return uh(c, n, o);
    },
    useTransition: function() {
      var n = oh(!1);
      return n = Lv.bind(
        null,
        ve,
        n.queue,
        !0,
        !1
      ), Xi().memoizedState = n, [!1, n];
    },
    useSyncExternalStore: function(n, o, c) {
      var m = ve, b = Xi();
      if (oe) {
        if (c === void 0)
          throw Error(u(407));
        c = c();
      } else {
        if (c = o(), sn === null)
          throw Error(u(349));
        (He & 124) !== 0 || Id(m, o, c);
      }
      b.memoizedState = c;
      var x = { value: c, getSnapshot: o };
      return b.queue = x, Cv(Kp.bind(null, m, x, n), [
        n
      ]), m.flags |= 2048, Da(
        9,
        sh(),
        Qp.bind(
          null,
          m,
          x,
          c,
          o
        ),
        null
      ), c;
    },
    useId: function() {
      var n = Xi(), o = sn.identifierPrefix;
      if (oe) {
        var c = q, m = H;
        c = (m & ~(1 << 32 - $n(m) - 1)).toString(32) + c, o = "«" + o + "R" + c, c = fl++, 0 < c && (o += "H" + c.toString(32)), o += "»";
      } else
        c = Gp++, o = "«" + o + "r" + c.toString(32) + "»";
      return n.memoizedState = o;
    },
    useHostTransitionStatus: Uo,
    useFormState: $p,
    useActionState: $p,
    useOptimistic: function(n) {
      var o = Xi();
      o.memoizedState = o.baseState = n;
      var c = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return o.queue = c, o = ch.bind(
        null,
        ve,
        !0,
        c
      ), c.dispatch = o, [n, o];
    },
    useMemoCache: Qd,
    useCacheRefresh: function() {
      return Xi().memoizedState = Nv.bind(
        null,
        ve
      );
    }
  }, sg = {
    readContext: vi,
    use: Xn,
    useCallback: Au,
    useContext: vi,
    useEffect: zv,
    useImperativeHandle: om,
    useInsertionEffect: Jp,
    useLayoutEffect: hl,
    useMemo: tg,
    useReducer: ih,
    useRef: rh,
    useState: function() {
      return ih(Zl);
    },
    useDebugValue: Du,
    useDeferredValue: function(n, o) {
      var c = An();
      return eg(
        c,
        Xe.memoizedState,
        n,
        o
      );
    },
    useTransition: function() {
      var n = ih(Zl)[0], o = An().memoizedState;
      return [
        typeof n == "boolean" ? n : nh(n),
        o
      ];
    },
    useSyncExternalStore: ah,
    useId: ng,
    useHostTransitionStatus: Uo,
    useFormState: Pl,
    useActionState: Pl,
    useOptimistic: function(n, o) {
      var c = An();
      return Jd(c, Xe, n, o);
    },
    useMemoCache: Qd,
    useCacheRefresh: kv
  }, Zs = {
    readContext: vi,
    use: Xn,
    useCallback: Au,
    useContext: vi,
    useEffect: zv,
    useImperativeHandle: om,
    useInsertionEffect: Jp,
    useLayoutEffect: hl,
    useMemo: tg,
    useReducer: Wd,
    useRef: rh,
    useState: function() {
      return Wd(Zl);
    },
    useDebugValue: Du,
    useDeferredValue: function(n, o) {
      var c = An();
      return Xe === null ? uh(c, n, o) : eg(
        c,
        Xe.memoizedState,
        n,
        o
      );
    },
    useTransition: function() {
      var n = Wd(Zl)[0], o = An().memoizedState;
      return [
        typeof n == "boolean" ? n : nh(n),
        o
      ];
    },
    useSyncExternalStore: ah,
    useId: ng,
    useHostTransitionStatus: Uo,
    useFormState: am,
    useActionState: am,
    useOptimistic: function(n, o) {
      var c = An();
      return Xe !== null ? Jd(c, Xe, n, o) : (c.baseState = n, [n, c.queue.dispatch]);
    },
    useMemoCache: Qd,
    useCacheRefresh: kv
  }, zu = null, Lc = 0;
  function rm(n) {
    var o = Lc;
    return Lc += 1, zu === null && (zu = []), jp(zu, n, o);
  }
  function Lu(n, o) {
    o = o.props.ref, n.ref = o !== void 0 ? o : null;
  }
  function Qi(n, o) {
    throw o.$$typeof === C ? Error(u(525)) : (n = Object.prototype.toString.call(o), Error(
      u(
        31,
        n === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : n
      )
    ));
  }
  function rg(n) {
    var o = n._init;
    return o(n._payload);
  }
  function Aa(n) {
    function o(tt, W) {
      if (n) {
        var et = tt.deletions;
        et === null ? (tt.deletions = [W], tt.flags |= 16) : et.push(W);
      }
    }
    function c(tt, W) {
      if (!n) return null;
      for (; W !== null; )
        o(tt, W), W = W.sibling;
      return null;
    }
    function m(tt) {
      for (var W = /* @__PURE__ */ new Map(); tt !== null; )
        tt.key !== null ? W.set(tt.key, tt) : W.set(tt.index, tt), tt = tt.sibling;
      return W;
    }
    function b(tt, W) {
      return tt = Ma(tt, W), tt.index = 0, tt.sibling = null, tt;
    }
    function x(tt, W, et) {
      return tt.index = et, n ? (et = tt.alternate, et !== null ? (et = et.index, et < W ? (tt.flags |= 67108866, W) : et) : (tt.flags |= 67108866, W)) : (tt.flags |= 1048576, W);
    }
    function R(tt) {
      return n && tt.alternate === null && (tt.flags |= 67108866), tt;
    }
    function U(tt, W, et, _t) {
      return W === null || W.tag !== 6 ? (W = Mr(et, tt.mode, _t), W.return = tt, W) : (W = b(W, et), W.return = tt, W);
    }
    function Z(tt, W, et, _t) {
      var Vt = et.type;
      return Vt === I ? vt(
        tt,
        W,
        et.props.children,
        _t,
        et.key
      ) : W !== null && (W.elementType === Vt || typeof Vt == "object" && Vt !== null && Vt.$$typeof === Yt && rg(Vt) === W.type) ? (W = b(W, et.props), Lu(W, et), W.return = tt, W) : (W = Ot(
        et.type,
        et.key,
        et.props,
        null,
        tt.mode,
        _t
      ), Lu(W, et), W.return = tt, W);
    }
    function it(tt, W, et, _t) {
      return W === null || W.tag !== 4 || W.stateNode.containerInfo !== et.containerInfo || W.stateNode.implementation !== et.implementation ? (W = cn(et, tt.mode, _t), W.return = tt, W) : (W = b(W, et.children || []), W.return = tt, W);
    }
    function vt(tt, W, et, _t, Vt) {
      return W === null || W.tag !== 7 ? (W = oa(
        et,
        tt.mode,
        _t,
        Vt
      ), W.return = tt, W) : (W = b(W, et), W.return = tt, W);
    }
    function St(tt, W, et) {
      if (typeof W == "string" && W !== "" || typeof W == "number" || typeof W == "bigint")
        return W = Mr(
          "" + W,
          tt.mode,
          et
        ), W.return = tt, W;
      if (typeof W == "object" && W !== null) {
        switch (W.$$typeof) {
          case z:
            return et = Ot(
              W.type,
              W.key,
              W.props,
              null,
              tt.mode,
              et
            ), Lu(et, W), et.return = tt, et;
          case j:
            return W = cn(
              W,
              tt.mode,
              et
            ), W.return = tt, W;
          case Yt:
            var _t = W._init;
            return W = _t(W._payload), St(tt, W, et);
        }
        if (Jt(W) || Nt(W))
          return W = oa(
            W,
            tt.mode,
            et,
            null
          ), W.return = tt, W;
        if (typeof W.then == "function")
          return St(tt, rm(W), et);
        if (W.$$typeof === Et)
          return St(
            tt,
            Qf(tt, W),
            et
          );
        Qi(tt, W);
      }
      return null;
    }
    function ot(tt, W, et, _t) {
      var Vt = W !== null ? W.key : null;
      if (typeof et == "string" && et !== "" || typeof et == "number" || typeof et == "bigint")
        return Vt !== null ? null : U(tt, W, "" + et, _t);
      if (typeof et == "object" && et !== null) {
        switch (et.$$typeof) {
          case z:
            return et.key === Vt ? Z(tt, W, et, _t) : null;
          case j:
            return et.key === Vt ? it(tt, W, et, _t) : null;
          case Yt:
            return Vt = et._init, et = Vt(et._payload), ot(tt, W, et, _t);
        }
        if (Jt(et) || Nt(et))
          return Vt !== null ? null : vt(tt, W, et, _t, null);
        if (typeof et.then == "function")
          return ot(
            tt,
            W,
            rm(et),
            _t
          );
        if (et.$$typeof === Et)
          return ot(
            tt,
            W,
            Qf(tt, et),
            _t
          );
        Qi(tt, et);
      }
      return null;
    }
    function st(tt, W, et, _t, Vt) {
      if (typeof _t == "string" && _t !== "" || typeof _t == "number" || typeof _t == "bigint")
        return tt = tt.get(et) || null, U(W, tt, "" + _t, Vt);
      if (typeof _t == "object" && _t !== null) {
        switch (_t.$$typeof) {
          case z:
            return tt = tt.get(
              _t.key === null ? et : _t.key
            ) || null, Z(W, tt, _t, Vt);
          case j:
            return tt = tt.get(
              _t.key === null ? et : _t.key
            ) || null, it(W, tt, _t, Vt);
          case Yt:
            var De = _t._init;
            return _t = De(_t._payload), st(
              tt,
              W,
              et,
              _t,
              Vt
            );
        }
        if (Jt(_t) || Nt(_t))
          return tt = tt.get(et) || null, vt(W, tt, _t, Vt, null);
        if (typeof _t.then == "function")
          return st(
            tt,
            W,
            et,
            rm(_t),
            Vt
          );
        if (_t.$$typeof === Et)
          return st(
            tt,
            W,
            et,
            Qf(W, _t),
            Vt
          );
        Qi(W, _t);
      }
      return null;
    }
    function te(tt, W, et, _t) {
      for (var Vt = null, De = null, $t = W, ae = W = 0, Ti = null; $t !== null && ae < et.length; ae++) {
        $t.index > ae ? (Ti = $t, $t = null) : Ti = $t.sibling;
        var je = ot(
          tt,
          $t,
          et[ae],
          _t
        );
        if (je === null) {
          $t === null && ($t = Ti);
          break;
        }
        n && $t && je.alternate === null && o(tt, $t), W = x(je, W, ae), De === null ? Vt = je : De.sibling = je, De = je, $t = Ti;
      }
      if (ae === et.length)
        return c(tt, $t), oe && $(tt, ae), Vt;
      if ($t === null) {
        for (; ae < et.length; ae++)
          $t = St(tt, et[ae], _t), $t !== null && (W = x(
            $t,
            W,
            ae
          ), De === null ? Vt = $t : De.sibling = $t, De = $t);
        return oe && $(tt, ae), Vt;
      }
      for ($t = m($t); ae < et.length; ae++)
        Ti = st(
          $t,
          tt,
          ae,
          et[ae],
          _t
        ), Ti !== null && (n && Ti.alternate !== null && $t.delete(
          Ti.key === null ? ae : Ti.key
        ), W = x(
          Ti,
          W,
          ae
        ), De === null ? Vt = Ti : De.sibling = Ti, De = Ti);
      return n && $t.forEach(function(Jr) {
        return o(tt, Jr);
      }), oe && $(tt, ae), Vt;
    }
    function ee(tt, W, et, _t) {
      if (et == null) throw Error(u(151));
      for (var Vt = null, De = null, $t = W, ae = W = 0, Ti = null, je = et.next(); $t !== null && !je.done; ae++, je = et.next()) {
        $t.index > ae ? (Ti = $t, $t = null) : Ti = $t.sibling;
        var Jr = ot(tt, $t, je.value, _t);
        if (Jr === null) {
          $t === null && ($t = Ti);
          break;
        }
        n && $t && Jr.alternate === null && o(tt, $t), W = x(Jr, W, ae), De === null ? Vt = Jr : De.sibling = Jr, De = Jr, $t = Ti;
      }
      if (je.done)
        return c(tt, $t), oe && $(tt, ae), Vt;
      if ($t === null) {
        for (; !je.done; ae++, je = et.next())
          je = St(tt, je.value, _t), je !== null && (W = x(je, W, ae), De === null ? Vt = je : De.sibling = je, De = je);
        return oe && $(tt, ae), Vt;
      }
      for ($t = m($t); !je.done; ae++, je = et.next())
        je = st($t, tt, ae, je.value, _t), je !== null && (n && je.alternate !== null && $t.delete(je.key === null ? ae : je.key), W = x(je, W, ae), De === null ? Vt = je : De.sibling = je, De = je);
      return n && $t.forEach(function(Q0) {
        return o(tt, Q0);
      }), oe && $(tt, ae), Vt;
    }
    function Ze(tt, W, et, _t) {
      if (typeof et == "object" && et !== null && et.type === I && et.key === null && (et = et.props.children), typeof et == "object" && et !== null) {
        switch (et.$$typeof) {
          case z:
            t: {
              for (var Vt = et.key; W !== null; ) {
                if (W.key === Vt) {
                  if (Vt = et.type, Vt === I) {
                    if (W.tag === 7) {
                      c(
                        tt,
                        W.sibling
                      ), _t = b(
                        W,
                        et.props.children
                      ), _t.return = tt, tt = _t;
                      break t;
                    }
                  } else if (W.elementType === Vt || typeof Vt == "object" && Vt !== null && Vt.$$typeof === Yt && rg(Vt) === W.type) {
                    c(
                      tt,
                      W.sibling
                    ), _t = b(W, et.props), Lu(_t, et), _t.return = tt, tt = _t;
                    break t;
                  }
                  c(tt, W);
                  break;
                } else o(tt, W);
                W = W.sibling;
              }
              et.type === I ? (_t = oa(
                et.props.children,
                tt.mode,
                _t,
                et.key
              ), _t.return = tt, tt = _t) : (_t = Ot(
                et.type,
                et.key,
                et.props,
                null,
                tt.mode,
                _t
              ), Lu(_t, et), _t.return = tt, tt = _t);
            }
            return R(tt);
          case j:
            t: {
              for (Vt = et.key; W !== null; ) {
                if (W.key === Vt)
                  if (W.tag === 4 && W.stateNode.containerInfo === et.containerInfo && W.stateNode.implementation === et.implementation) {
                    c(
                      tt,
                      W.sibling
                    ), _t = b(W, et.children || []), _t.return = tt, tt = _t;
                    break t;
                  } else {
                    c(tt, W);
                    break;
                  }
                else o(tt, W);
                W = W.sibling;
              }
              _t = cn(et, tt.mode, _t), _t.return = tt, tt = _t;
            }
            return R(tt);
          case Yt:
            return Vt = et._init, et = Vt(et._payload), Ze(
              tt,
              W,
              et,
              _t
            );
        }
        if (Jt(et))
          return te(
            tt,
            W,
            et,
            _t
          );
        if (Nt(et)) {
          if (Vt = Nt(et), typeof Vt != "function") throw Error(u(150));
          return et = Vt.call(et), ee(
            tt,
            W,
            et,
            _t
          );
        }
        if (typeof et.then == "function")
          return Ze(
            tt,
            W,
            rm(et),
            _t
          );
        if (et.$$typeof === Et)
          return Ze(
            tt,
            W,
            Qf(tt, et),
            _t
          );
        Qi(tt, et);
      }
      return typeof et == "string" && et !== "" || typeof et == "number" || typeof et == "bigint" ? (et = "" + et, W !== null && W.tag === 6 ? (c(tt, W.sibling), _t = b(W, et), _t.return = tt, tt = _t) : (c(tt, W), _t = Mr(et, tt.mode, _t), _t.return = tt, tt = _t), R(tt)) : c(tt, W);
    }
    return function(tt, W, et, _t) {
      try {
        Lc = 0;
        var Vt = Ze(
          tt,
          W,
          et,
          _t
        );
        return zu = null, Vt;
      } catch ($t) {
        if ($t === Cr || $t === If) throw $t;
        var De = Vi(29, $t, null, tt.mode);
        return De.lanes = _t, De.return = tt, De;
      } finally {
      }
    };
  }
  var Hu = Aa(!0), Vl = Aa(!1), ao = F(null), Ki = null;
  function Ps(n) {
    var o = n.alternate;
    bt(nn, nn.current & 1), bt(ao, n), Ki === null && (o === null || Ou.current !== null || o.memoizedState !== null) && (Ki = n);
  }
  function Gl(n) {
    if (n.tag === 22) {
      if (bt(nn, nn.current), bt(ao, n), Ki === null) {
        var o = n.alternate;
        o !== null && o.memoizedState !== null && (Ki = n);
      }
    } else Xl();
  }
  function Xl() {
    bt(nn, nn.current), bt(ao, ao.current);
  }
  function dl(n) {
    ct(ao), Ki === n && (Ki = null), ct(nn);
  }
  var nn = F(0);
  function fh(n) {
    for (var o = n; o !== null; ) {
      if (o.tag === 13) {
        var c = o.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || Hh(c)))
          return o;
      } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
        if ((o.flags & 128) !== 0) return o;
      } else if (o.child !== null) {
        o.child.return = o, o = o.child;
        continue;
      }
      if (o === n) break;
      for (; o.sibling === null; ) {
        if (o.return === null || o.return === n) return null;
        o = o.return;
      }
      o.sibling.return = o.return, o = o.sibling;
    }
    return null;
  }
  function kr(n, o, c, m) {
    o = n.memoizedState, c = c(m, o), c = c == null ? o : D({}, o, c), n.memoizedState = c, n.lanes === 0 && (n.updateQueue.baseState = c);
  }
  var um = {
    enqueueSetState: function(n, o, c) {
      n = n._reactInternals;
      var m = oo(), b = Oa(m);
      b.payload = o, c != null && (b.callback = c), o = ql(n, b, m), o !== null && (lo(o, n, m), Eu(o, n, m));
    },
    enqueueReplaceState: function(n, o, c) {
      n = n._reactInternals;
      var m = oo(), b = Oa(m);
      b.tag = 1, b.payload = o, c != null && (b.callback = c), o = ql(n, b, m), o !== null && (lo(o, n, m), Eu(o, n, m));
    },
    enqueueForceUpdate: function(n, o) {
      n = n._reactInternals;
      var c = oo(), m = Oa(c);
      m.tag = 2, o != null && (m.callback = o), o = ql(n, m, c), o !== null && (lo(o, n, c), Eu(o, n, c));
    }
  };
  function Hc(n, o, c, m, b, x, R) {
    return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(m, x, R) : o.prototype && o.prototype.isPureReactComponent ? !yi(c, m) || !yi(b, x) : !0;
  }
  function ku(n, o, c, m) {
    n = o.state, typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(c, m), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(c, m), o.state !== n && um.enqueueReplaceState(o, o.state, null);
  }
  function Nr(n, o) {
    var c = o;
    if ("ref" in o) {
      c = {};
      for (var m in o)
        m !== "ref" && (c[m] = o[m]);
    }
    if (n = n.defaultProps) {
      c === o && (c = D({}, c));
      for (var b in n)
        c[b] === void 0 && (c[b] = n[b]);
    }
    return c;
  }
  var hh = typeof reportError == "function" ? reportError : function(n) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var o = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof n == "object" && n !== null && typeof n.message == "string" ? String(n.message) : String(n),
        error: n
      });
      if (!window.dispatchEvent(o)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", n);
      return;
    }
    console.error(n);
  };
  function kc(n) {
    hh(n);
  }
  function ug(n) {
    console.error(n);
  }
  function dh(n) {
    hh(n);
  }
  function mh(n, o) {
    try {
      var c = n.onUncaughtError;
      c(o.value, { componentStack: o.stack });
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  function cg(n, o, c) {
    try {
      var m = n.onCaughtError;
      m(c.value, {
        componentStack: c.stack,
        errorBoundary: o.tag === 1 ? o.stateNode : null
      });
    } catch (b) {
      setTimeout(function() {
        throw b;
      });
    }
  }
  function fg(n, o, c) {
    return c = Oa(c), c.tag = 3, c.payload = { element: null }, c.callback = function() {
      mh(n, o);
    }, c;
  }
  function hg(n) {
    return n = Oa(n), n.tag = 3, n;
  }
  function Ra(n, o, c, m) {
    var b = c.type.getDerivedStateFromError;
    if (typeof b == "function") {
      var x = m.value;
      n.payload = function() {
        return b(x);
      }, n.callback = function() {
        cg(o, c, m);
      };
    }
    var R = c.stateNode;
    R !== null && typeof R.componentDidCatch == "function" && (n.callback = function() {
      cg(o, c, m), typeof b != "function" && (jr === null ? jr = /* @__PURE__ */ new Set([this]) : jr.add(this));
      var U = m.stack;
      this.componentDidCatch(m.value, {
        componentStack: U !== null ? U : ""
      });
    });
  }
  function Bv(n, o, c, m, b) {
    if (c.flags |= 32768, m !== null && typeof m == "object" && typeof m.then == "function") {
      if (o = c.alternate, o !== null && Dr(
        o,
        c,
        b,
        !0
      ), c = ao.current, c !== null) {
        switch (c.tag) {
          case 13:
            return Ki === null ? Vu() : c.alternate === null && Ln === 0 && (Ln = 3), c.flags &= -257, c.flags |= 65536, c.lanes = b, m === Bd ? c.flags |= 16384 : (o = c.updateQueue, o === null ? c.updateQueue = /* @__PURE__ */ new Set([m]) : o.add(m), km(n, m, b)), !1;
          case 22:
            return c.flags |= 65536, m === Bd ? c.flags |= 16384 : (o = c.updateQueue, o === null ? (o = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([m])
            }, c.updateQueue = o) : (c = o.retryQueue, c === null ? o.retryQueue = /* @__PURE__ */ new Set([m]) : c.add(m)), km(n, m, b)), !1;
        }
        throw Error(u(435, c.tag));
      }
      return km(n, m, b), Vu(), !1;
    }
    if (oe)
      return o = ao.current, o !== null ? ((o.flags & 65536) === 0 && (o.flags |= 256), o.flags |= 65536, o.lanes = b, m !== Dn && (n = Error(u(422), { cause: m }), Ys(Pi(n, c)))) : (m !== Dn && (o = Error(u(423), {
        cause: m
      }), Ys(
        Pi(o, c)
      )), n = n.current.alternate, n.flags |= 65536, b &= -b, n.lanes |= b, m = Pi(m, c), b = fg(
        n.stateNode,
        m,
        b
      ), Pp(n, b), Ln !== 4 && (Ln = 2)), !1;
    var x = Error(u(520), { cause: m });
    if (x = Pi(x, c), Zc === null ? Zc = [x] : Zc.push(x), Ln !== 4 && (Ln = 2), o === null) return !0;
    m = Pi(m, c), c = o;
    do {
      switch (c.tag) {
        case 3:
          return c.flags |= 65536, n = b & -b, c.lanes |= n, n = fg(c.stateNode, m, n), Pp(c, n), !1;
        case 1:
          if (o = c.type, x = c.stateNode, (c.flags & 128) === 0 && (typeof o.getDerivedStateFromError == "function" || x !== null && typeof x.componentDidCatch == "function" && (jr === null || !jr.has(x))))
            return c.flags |= 65536, b &= -b, c.lanes |= b, b = hg(b), Ra(
              b,
              n,
              c,
              m
            ), Pp(c, b), !1;
      }
      c = c.return;
    } while (c !== null);
    return !1;
  }
  var Rn = Error(u(461)), ii = !1;
  function bi(n, o, c, m) {
    o.child = n === null ? Vl(o, null, c, m) : Hu(
      o,
      n.child,
      c,
      m
    );
  }
  function Yv(n, o, c, m, b) {
    c = c.render;
    var x = o.ref;
    if ("ref" in m) {
      var R = {};
      for (var U in m)
        U !== "ref" && (R[U] = m[U]);
    } else R = m;
    return Ar(o), m = Vd(
      n,
      o,
      c,
      R,
      x,
      b
    ), U = Gd(), n !== null && !ii ? (Cc(n, o, b), Ql(n, o, b)) : (oe && U && xt(o), o.flags |= 1, bi(n, o, m, b), o.child);
  }
  function Vs(n, o, c, m, b) {
    if (n === null) {
      var x = c.type;
      return typeof x == "function" && !wr(x) && x.defaultProps === void 0 && c.compare === null ? (o.tag = 15, o.type = x, Nu(
        n,
        o,
        x,
        m,
        b
      )) : (n = Ot(
        c.type,
        null,
        m,
        o,
        o.mode,
        b
      ), n.ref = o.ref, n.return = o, o.child = n);
    }
    if (x = n.child, !_m(n, b)) {
      var R = x.memoizedProps;
      if (c = c.compare, c = c !== null ? c : yi, c(R, m) && n.ref === o.ref)
        return Ql(n, o, b);
    }
    return o.flags |= 1, n = Ma(x, m), n.ref = o.ref, n.return = o, o.child = n;
  }
  function Nu(n, o, c, m, b) {
    if (n !== null) {
      var x = n.memoizedProps;
      if (yi(x, m) && n.ref === o.ref)
        if (ii = !1, o.pendingProps = m = x, _m(n, b))
          (n.flags & 131072) !== 0 && (ii = !0);
        else
          return o.lanes = n.lanes, Ql(n, o, b);
    }
    return fm(
      n,
      o,
      c,
      m,
      b
    );
  }
  function cm(n, o, c) {
    var m = o.pendingProps, b = m.children, x = n !== null ? n.memoizedState : null;
    if (m.mode === "hidden") {
      if ((o.flags & 128) !== 0) {
        if (m = x !== null ? x.baseLanes | c : c, n !== null) {
          for (b = o.child = n.child, x = 0; b !== null; )
            x = x | b.lanes | b.childLanes, b = b.sibling;
          o.childLanes = x & ~m;
        } else o.childLanes = 0, o.child = null;
        return Uu(
          n,
          o,
          m,
          c
        );
      }
      if ((c & 536870912) !== 0)
        o.memoizedState = { baseLanes: 0, cachePool: null }, n !== null && wu(
          o,
          x !== null ? x.cachePool : null
        ), x !== null ? _i(o, x) : Ac(), Gl(o);
      else
        return o.lanes = o.childLanes = 536870912, Uu(
          n,
          o,
          x !== null ? x.baseLanes | c : c,
          c
        );
    } else
      x !== null ? (wu(o, x.cachePool), _i(o, x), Xl(), o.memoizedState = null) : (n !== null && wu(o, null), Ac(), Xl());
    return bi(n, o, b, c), o.child;
  }
  function Uu(n, o, c, m) {
    var b = Wf();
    return b = b === null ? null : { parent: ei._currentValue, pool: b }, o.memoizedState = {
      baseLanes: c,
      cachePool: b
    }, n !== null && wu(o, null), Ac(), Gl(o), n !== null && Dr(n, o, m, !0), null;
  }
  function ph(n, o) {
    var c = o.ref;
    if (c === null)
      n !== null && n.ref !== null && (o.flags |= 4194816);
    else {
      if (typeof c != "function" && typeof c != "object")
        throw Error(u(284));
      (n === null || n.ref !== c) && (o.flags |= 4194816);
    }
  }
  function fm(n, o, c, m, b) {
    return Ar(o), c = Vd(
      n,
      o,
      c,
      m,
      void 0,
      b
    ), m = Gd(), n !== null && !ii ? (Cc(n, o, b), Ql(n, o, b)) : (oe && m && xt(o), o.flags |= 1, bi(n, o, c, b), o.child);
  }
  function dg(n, o, c, m, b, x) {
    return Ar(o), o.updateQueue = null, c = Xp(
      o,
      m,
      c,
      b
    ), Lr(n), m = Gd(), n !== null && !ii ? (Cc(n, o, x), Ql(n, o, x)) : (oe && m && xt(o), o.flags |= 1, bi(n, o, c, x), o.child);
  }
  function hm(n, o, c, m, b) {
    if (Ar(o), o.stateNode === null) {
      var x = Us, R = c.contextType;
      typeof R == "object" && R !== null && (x = vi(R)), x = new c(m, x), o.memoizedState = x.state !== null && x.state !== void 0 ? x.state : null, x.updater = um, o.stateNode = x, x._reactInternals = o, x = o.stateNode, x.props = m, x.state = o.memoizedState, x.refs = {}, jd(o), R = c.contextType, x.context = typeof R == "object" && R !== null ? vi(R) : Us, x.state = o.memoizedState, R = c.getDerivedStateFromProps, typeof R == "function" && (kr(
        o,
        c,
        R,
        m
      ), x.state = o.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof x.getSnapshotBeforeUpdate == "function" || typeof x.UNSAFE_componentWillMount != "function" && typeof x.componentWillMount != "function" || (R = x.state, typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount(), R !== x.state && um.enqueueReplaceState(x, x.state, null), js(o, m, x, b), Dc(), x.state = o.memoizedState), typeof x.componentDidMount == "function" && (o.flags |= 4194308), m = !0;
    } else if (n === null) {
      x = o.stateNode;
      var U = o.memoizedProps, Z = Nr(c, U);
      x.props = Z;
      var it = x.context, vt = c.contextType;
      R = Us, typeof vt == "object" && vt !== null && (R = vi(vt));
      var St = c.getDerivedStateFromProps;
      vt = typeof St == "function" || typeof x.getSnapshotBeforeUpdate == "function", U = o.pendingProps !== U, vt || typeof x.UNSAFE_componentWillReceiveProps != "function" && typeof x.componentWillReceiveProps != "function" || (U || it !== R) && ku(
        o,
        x,
        m,
        R
      ), jl = !1;
      var ot = o.memoizedState;
      x.state = ot, js(o, m, x, b), Dc(), it = o.memoizedState, U || ot !== it || jl ? (typeof St == "function" && (kr(
        o,
        c,
        St,
        m
      ), it = o.memoizedState), (Z = jl || Hc(
        o,
        c,
        Z,
        m,
        ot,
        it,
        R
      )) ? (vt || typeof x.UNSAFE_componentWillMount != "function" && typeof x.componentWillMount != "function" || (typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount()), typeof x.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof x.componentDidMount == "function" && (o.flags |= 4194308), o.memoizedProps = m, o.memoizedState = it), x.props = m, x.state = it, x.context = R, m = Z) : (typeof x.componentDidMount == "function" && (o.flags |= 4194308), m = !1);
    } else {
      x = o.stateNode, qd(n, o), R = o.memoizedProps, vt = Nr(c, R), x.props = vt, St = o.pendingProps, ot = x.context, it = c.contextType, Z = Us, typeof it == "object" && it !== null && (Z = vi(it)), U = c.getDerivedStateFromProps, (it = typeof U == "function" || typeof x.getSnapshotBeforeUpdate == "function") || typeof x.UNSAFE_componentWillReceiveProps != "function" && typeof x.componentWillReceiveProps != "function" || (R !== St || ot !== Z) && ku(
        o,
        x,
        m,
        Z
      ), jl = !1, ot = o.memoizedState, x.state = ot, js(o, m, x, b), Dc();
      var st = o.memoizedState;
      R !== St || ot !== st || jl || n !== null && n.dependencies !== null && Xf(n.dependencies) ? (typeof U == "function" && (kr(
        o,
        c,
        U,
        m
      ), st = o.memoizedState), (vt = jl || Hc(
        o,
        c,
        vt,
        m,
        ot,
        st,
        Z
      ) || n !== null && n.dependencies !== null && Xf(n.dependencies)) ? (it || typeof x.UNSAFE_componentWillUpdate != "function" && typeof x.componentWillUpdate != "function" || (typeof x.componentWillUpdate == "function" && x.componentWillUpdate(m, st, Z), typeof x.UNSAFE_componentWillUpdate == "function" && x.UNSAFE_componentWillUpdate(
        m,
        st,
        Z
      )), typeof x.componentDidUpdate == "function" && (o.flags |= 4), typeof x.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof x.componentDidUpdate != "function" || R === n.memoizedProps && ot === n.memoizedState || (o.flags |= 4), typeof x.getSnapshotBeforeUpdate != "function" || R === n.memoizedProps && ot === n.memoizedState || (o.flags |= 1024), o.memoizedProps = m, o.memoizedState = st), x.props = m, x.state = st, x.context = Z, m = vt) : (typeof x.componentDidUpdate != "function" || R === n.memoizedProps && ot === n.memoizedState || (o.flags |= 4), typeof x.getSnapshotBeforeUpdate != "function" || R === n.memoizedProps && ot === n.memoizedState || (o.flags |= 1024), m = !1);
    }
    return x = m, ph(n, o), m = (o.flags & 128) !== 0, x || m ? (x = o.stateNode, c = m && typeof c.getDerivedStateFromError != "function" ? null : x.render(), o.flags |= 1, n !== null && m ? (o.child = Hu(
      o,
      n.child,
      null,
      b
    ), o.child = Hu(
      o,
      null,
      c,
      b
    )) : bi(n, o, c, b), o.memoizedState = x.state, n = o.child) : n = Ql(
      n,
      o,
      b
    ), n;
  }
  function dm(n, o, c, m) {
    return Bs(), o.flags |= 256, bi(n, o, c, m), o.child;
  }
  var mm = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function mg(n) {
    return { baseLanes: n, cachePool: Nd() };
  }
  function pg(n, o, c) {
    return n = n !== null ? n.childLanes & ~c : 0, o && (n |= jo), n;
  }
  function gg(n, o, c) {
    var m = o.pendingProps, b = !1, x = (o.flags & 128) !== 0, R;
    if ((R = x) || (R = n !== null && n.memoizedState === null ? !1 : (nn.current & 2) !== 0), R && (b = !0, o.flags &= -129), R = (o.flags & 32) !== 0, o.flags &= -33, n === null) {
      if (oe) {
        if (b ? Ps(o) : Xl(), oe) {
          var U = Zt, Z;
          if (Z = U) {
            t: {
              for (Z = U, U = dn; Z.nodeType !== 8; ) {
                if (!U) {
                  U = null;
                  break t;
                }
                if (Z = pl(
                  Z.nextSibling
                ), Z === null) {
                  U = null;
                  break t;
                }
              }
              U = Z;
            }
            U !== null ? (o.memoizedState = {
              dehydrated: U,
              treeContext: O !== null ? { id: H, overflow: q } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, Z = Vi(
              18,
              null,
              null,
              0
            ), Z.stateNode = U, Z.return = o, o.child = Z, qt = o, Zt = null, Z = !0) : Z = !1;
          }
          Z || Gi(o);
        }
        if (U = o.memoizedState, U !== null && (U = U.dehydrated, U !== null))
          return Hh(U) ? o.lanes = 32 : o.lanes = 536870912, null;
        dl(o);
      }
      return U = m.children, m = m.fallback, b ? (Xl(), b = o.mode, U = gm(
        { mode: "hidden", children: U },
        b
      ), m = oa(
        m,
        b,
        c,
        null
      ), U.return = o, m.return = o, U.sibling = m, o.child = U, b = o.child, b.memoizedState = mg(c), b.childLanes = pg(
        n,
        R,
        c
      ), o.memoizedState = mm, m) : (Ps(o), pm(o, U));
    }
    if (Z = n.memoizedState, Z !== null && (U = Z.dehydrated, U !== null)) {
      if (x)
        o.flags & 256 ? (Ps(o), o.flags &= -257, o = Ur(
          n,
          o,
          c
        )) : o.memoizedState !== null ? (Xl(), o.child = n.child, o.flags |= 128, o = null) : (Xl(), b = m.fallback, U = o.mode, m = gm(
          { mode: "visible", children: m.children },
          U
        ), b = oa(
          b,
          U,
          c,
          null
        ), b.flags |= 2, m.return = o, b.return = o, m.sibling = b, o.child = m, Hu(
          o,
          n.child,
          null,
          c
        ), m = o.child, m.memoizedState = mg(c), m.childLanes = pg(
          n,
          R,
          c
        ), o.memoizedState = mm, o = b);
      else if (Ps(o), Hh(U)) {
        if (R = U.nextSibling && U.nextSibling.dataset, R) var it = R.dgst;
        R = it, m = Error(u(419)), m.stack = "", m.digest = R, Ys({ value: m, source: null, stack: null }), o = Ur(
          n,
          o,
          c
        );
      } else if (ii || Dr(n, o, c, !1), R = (c & n.childLanes) !== 0, ii || R) {
        if (R = sn, R !== null && (m = c & -c, m = (m & 42) !== 0 ? 1 : On(m), m = (m & (R.suspendedLanes | c)) !== 0 ? 0 : m, m !== 0 && m !== Z.retryLane))
          throw Z.retryLane = m, Lo(n, m), lo(R, n, m), Rn;
        U.data === "$?" || Vu(), o = Ur(
          n,
          o,
          c
        );
      } else
        U.data === "$?" ? (o.flags |= 192, o.child = n.child, o = null) : (n = Z.treeContext, Zt = pl(
          U.nextSibling
        ), qt = o, oe = !0, Ge = null, dn = !1, n !== null && (v[w++] = H, v[w++] = q, v[w++] = O, H = n.id, q = n.overflow, O = o), o = pm(
          o,
          m.children
        ), o.flags |= 4096);
      return o;
    }
    return b ? (Xl(), b = m.fallback, U = o.mode, Z = n.child, it = Z.sibling, m = Ma(Z, {
      mode: "hidden",
      children: m.children
    }), m.subtreeFlags = Z.subtreeFlags & 65011712, it !== null ? b = Ma(it, b) : (b = oa(
      b,
      U,
      c,
      null
    ), b.flags |= 2), b.return = o, m.return = o, m.sibling = b, o.child = m, m = b, b = o.child, U = n.child.memoizedState, U === null ? U = mg(c) : (Z = U.cachePool, Z !== null ? (it = ei._currentValue, Z = Z.parent !== it ? { parent: it, pool: it } : Z) : Z = Nd(), U = {
      baseLanes: U.baseLanes | c,
      cachePool: Z
    }), b.memoizedState = U, b.childLanes = pg(
      n,
      R,
      c
    ), o.memoizedState = mm, m) : (Ps(o), c = n.child, n = c.sibling, c = Ma(c, {
      mode: "visible",
      children: m.children
    }), c.return = o, c.sibling = null, n !== null && (R = o.deletions, R === null ? (o.deletions = [n], o.flags |= 16) : R.push(n)), o.child = c, o.memoizedState = null, c);
  }
  function pm(n, o) {
    return o = gm(
      { mode: "visible", children: o },
      n.mode
    ), o.return = n, n.child = o;
  }
  function gm(n, o) {
    return n = Vi(22, n, null, o), n.lanes = 0, n.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, n;
  }
  function Ur(n, o, c) {
    return Hu(o, n.child, null, c), n = pm(
      o,
      o.pendingProps.children
    ), n.flags |= 2, o.memoizedState = null, n;
  }
  function gh(n, o, c) {
    n.lanes |= o;
    var m = n.alternate;
    m !== null && (m.lanes |= o), Or(n.return, o, c);
  }
  function ym(n, o, c, m, b) {
    var x = n.memoizedState;
    x === null ? n.memoizedState = {
      isBackwards: o,
      rendering: null,
      renderingStartTime: 0,
      last: m,
      tail: c,
      tailMode: b
    } : (x.isBackwards = o, x.rendering = null, x.renderingStartTime = 0, x.last = m, x.tail = c, x.tailMode = b);
  }
  function vm(n, o, c) {
    var m = o.pendingProps, b = m.revealOrder, x = m.tail;
    if (bi(n, o, m.children, c), m = nn.current, (m & 2) !== 0)
      m = m & 1 | 2, o.flags |= 128;
    else {
      if (n !== null && (n.flags & 128) !== 0)
        t: for (n = o.child; n !== null; ) {
          if (n.tag === 13)
            n.memoizedState !== null && gh(n, c, o);
          else if (n.tag === 19)
            gh(n, c, o);
          else if (n.child !== null) {
            n.child.return = n, n = n.child;
            continue;
          }
          if (n === o) break t;
          for (; n.sibling === null; ) {
            if (n.return === null || n.return === o)
              break t;
            n = n.return;
          }
          n.sibling.return = n.return, n = n.sibling;
        }
      m &= 1;
    }
    switch (bt(nn, m), b) {
      case "forwards":
        for (c = o.child, b = null; c !== null; )
          n = c.alternate, n !== null && fh(n) === null && (b = c), c = c.sibling;
        c = b, c === null ? (b = o.child, o.child = null) : (b = c.sibling, c.sibling = null), ym(
          o,
          !1,
          b,
          c,
          x
        );
        break;
      case "backwards":
        for (c = null, b = o.child, o.child = null; b !== null; ) {
          if (n = b.alternate, n !== null && fh(n) === null) {
            o.child = b;
            break;
          }
          n = b.sibling, b.sibling = c, c = b, b = n;
        }
        ym(
          o,
          !0,
          c,
          null,
          x
        );
        break;
      case "together":
        ym(o, !1, null, null, void 0);
        break;
      default:
        o.memoizedState = null;
    }
    return o.child;
  }
  function Ql(n, o, c) {
    if (n !== null && (o.dependencies = n.dependencies), Qs |= o.lanes, (c & o.childLanes) === 0)
      if (n !== null) {
        if (Dr(
          n,
          o,
          c,
          !1
        ), (c & o.childLanes) === 0)
          return null;
      } else return null;
    if (n !== null && o.child !== n.child)
      throw Error(u(153));
    if (o.child !== null) {
      for (n = o.child, c = Ma(n, n.pendingProps), o.child = c, c.return = o; n.sibling !== null; )
        n = n.sibling, c = c.sibling = Ma(n, n.pendingProps), c.return = o;
      c.sibling = null;
    }
    return o.child;
  }
  function _m(n, o) {
    return (n.lanes & o) !== 0 ? !0 : (n = n.dependencies, !!(n !== null && Xf(n)));
  }
  function jv(n, o, c) {
    switch (o.tag) {
      case 3:
        Ft(o, o.stateNode.containerInfo), cl(o, ei, n.memoizedState.cache), Bs();
        break;
      case 27:
      case 5:
        fi(o);
        break;
      case 4:
        Ft(o, o.stateNode.containerInfo);
        break;
      case 10:
        cl(
          o,
          o.type,
          o.memoizedProps.value
        );
        break;
      case 13:
        var m = o.memoizedState;
        if (m !== null)
          return m.dehydrated !== null ? (Ps(o), o.flags |= 128, null) : (c & o.child.childLanes) !== 0 ? gg(n, o, c) : (Ps(o), n = Ql(
            n,
            o,
            c
          ), n !== null ? n.sibling : null);
        Ps(o);
        break;
      case 19:
        var b = (n.flags & 128) !== 0;
        if (m = (c & o.childLanes) !== 0, m || (Dr(
          n,
          o,
          c,
          !1
        ), m = (c & o.childLanes) !== 0), b) {
          if (m)
            return vm(
              n,
              o,
              c
            );
          o.flags |= 128;
        }
        if (b = o.memoizedState, b !== null && (b.rendering = null, b.tail = null, b.lastEffect = null), bt(nn, nn.current), m) break;
        return null;
      case 22:
      case 23:
        return o.lanes = 0, cm(n, o, c);
      case 24:
        cl(o, ei, n.memoizedState.cache);
    }
    return Ql(n, o, c);
  }
  function qv(n, o, c) {
    if (n !== null)
      if (n.memoizedProps !== o.pendingProps)
        ii = !0;
      else {
        if (!_m(n, c) && (o.flags & 128) === 0)
          return ii = !1, jv(
            n,
            o,
            c
          );
        ii = (n.flags & 131072) !== 0;
      }
    else
      ii = !1, oe && (o.flags & 1048576) !== 0 && rt(o, d, o.index);
    switch (o.lanes = 0, o.tag) {
      case 16:
        t: {
          n = o.pendingProps;
          var m = o.elementType, b = m._init;
          if (m = b(m._payload), o.type = m, typeof m == "function")
            wr(m) ? (n = Nr(m, n), o.tag = 1, o = hm(
              null,
              o,
              m,
              n,
              c
            )) : (o.tag = 0, o = fm(
              null,
              o,
              m,
              n,
              c
            ));
          else {
            if (m != null) {
              if (b = m.$$typeof, b === zt) {
                o.tag = 11, o = Yv(
                  null,
                  o,
                  m,
                  n,
                  c
                );
                break t;
              } else if (b === Ct) {
                o.tag = 14, o = Vs(
                  null,
                  o,
                  m,
                  n,
                  c
                );
                break t;
              }
            }
            throw o = ge(m) || m, Error(u(306, o, ""));
          }
        }
        return o;
      case 0:
        return fm(
          n,
          o,
          o.type,
          o.pendingProps,
          c
        );
      case 1:
        return m = o.type, b = Nr(
          m,
          o.pendingProps
        ), hm(
          n,
          o,
          m,
          b,
          c
        );
      case 3:
        t: {
          if (Ft(
            o,
            o.stateNode.containerInfo
          ), n === null) throw Error(u(387));
          m = o.pendingProps;
          var x = o.memoizedState;
          b = x.element, qd(n, o), js(o, m, null, c);
          var R = o.memoizedState;
          if (m = R.cache, cl(o, ei, m), m !== x.cache && Mc(
            o,
            [ei],
            c,
            !0
          ), Dc(), m = R.element, x.isDehydrated)
            if (x = {
              element: m,
              isDehydrated: !1,
              cache: R.cache
            }, o.updateQueue.baseState = x, o.memoizedState = x, o.flags & 256) {
              o = dm(
                n,
                o,
                m,
                c
              );
              break t;
            } else if (m !== b) {
              b = Pi(
                Error(u(424)),
                o
              ), Ys(b), o = dm(
                n,
                o,
                m,
                c
              );
              break t;
            } else {
              switch (n = o.stateNode.containerInfo, n.nodeType) {
                case 9:
                  n = n.body;
                  break;
                default:
                  n = n.nodeName === "HTML" ? n.ownerDocument.body : n;
              }
              for (Zt = pl(n.firstChild), qt = o, oe = !0, Ge = null, dn = !0, c = Vl(
                o,
                null,
                m,
                c
              ), o.child = c; c; )
                c.flags = c.flags & -3 | 4096, c = c.sibling;
            }
          else {
            if (Bs(), m === b) {
              o = Ql(
                n,
                o,
                c
              );
              break t;
            }
            bi(
              n,
              o,
              m,
              c
            );
          }
          o = o.child;
        }
        return o;
      case 26:
        return ph(n, o), n === null ? (c = i_(
          o.type,
          null,
          o.pendingProps,
          null
        )) ? o.memoizedState = c : oe || (c = o.type, n = o.pendingProps, m = Zo(
          Tt.current
        ).createElement(c), m[Vn] = o, m[Ei] = n, re(m, c, n), Bn(m), o.stateNode = m) : o.memoizedState = i_(
          o.type,
          n.memoizedProps,
          o.pendingProps,
          n.memoizedState
        ), null;
      case 27:
        return fi(o), n === null && oe && (m = o.stateNode = jt(
          o.type,
          o.pendingProps,
          Tt.current
        ), qt = o, dn = !0, b = Zt, Xr(o.type) ? (Qr = b, Zt = pl(
          m.firstChild
        )) : Zt = b), bi(
          n,
          o,
          o.pendingProps.children,
          c
        ), ph(n, o), n === null && (o.flags |= 4194304), o.child;
      case 5:
        return n === null && oe && ((b = m = Zt) && (m = tf(
          m,
          o.type,
          o.pendingProps,
          dn
        ), m !== null ? (o.stateNode = m, qt = o, Zt = pl(
          m.firstChild
        ), dn = !1, b = !0) : b = !1), b || Gi(o)), fi(o), b = o.type, x = o.pendingProps, R = n !== null ? n.memoizedProps : null, m = x.children, ns(b, x) ? m = null : R !== null && ns(b, R) && (o.flags |= 32), o.memoizedState !== null && (b = Vd(
          n,
          o,
          Av,
          null,
          null,
          c
        ), Na._currentValue = b), ph(n, o), bi(n, o, m, c), o.child;
      case 6:
        return n === null && oe && ((n = c = Zt) && (c = V0(
          c,
          o.pendingProps,
          dn
        ), c !== null ? (o.stateNode = c, qt = o, Zt = null, n = !0) : n = !1), n || Gi(o)), null;
      case 13:
        return gg(n, o, c);
      case 4:
        return Ft(
          o,
          o.stateNode.containerInfo
        ), m = o.pendingProps, n === null ? o.child = Hu(
          o,
          null,
          m,
          c
        ) : bi(
          n,
          o,
          m,
          c
        ), o.child;
      case 11:
        return Yv(
          n,
          o,
          o.type,
          o.pendingProps,
          c
        );
      case 7:
        return bi(
          n,
          o,
          o.pendingProps,
          c
        ), o.child;
      case 8:
        return bi(
          n,
          o,
          o.pendingProps.children,
          c
        ), o.child;
      case 12:
        return bi(
          n,
          o,
          o.pendingProps.children,
          c
        ), o.child;
      case 10:
        return m = o.pendingProps, cl(o, o.type, m.value), bi(
          n,
          o,
          m.children,
          c
        ), o.child;
      case 9:
        return b = o.type._context, m = o.pendingProps.children, Ar(o), b = vi(b), m = m(b), o.flags |= 1, bi(n, o, m, c), o.child;
      case 14:
        return Vs(
          n,
          o,
          o.type,
          o.pendingProps,
          c
        );
      case 15:
        return Nu(
          n,
          o,
          o.type,
          o.pendingProps,
          c
        );
      case 19:
        return vm(n, o, c);
      case 31:
        return m = o.pendingProps, c = o.mode, m = {
          mode: m.mode,
          children: m.children
        }, n === null ? (c = gm(
          m,
          c
        ), c.ref = o.ref, o.child = c, c.return = o, o = c) : (c = Ma(n.child, m), c.ref = o.ref, o.child = c, c.return = o, o = c), o;
      case 22:
        return cm(n, o, c);
      case 24:
        return Ar(o), m = vi(ei), n === null ? (b = Wf(), b === null && (b = sn, x = Oc(), b.pooledCache = x, x.refCount++, x !== null && (b.pooledCacheLanes |= c), b = x), o.memoizedState = {
          parent: m,
          cache: b
        }, jd(o), cl(o, ei, b)) : ((n.lanes & c) !== 0 && (qd(n, o), js(o, null, null, c), Dc()), b = n.memoizedState, x = o.memoizedState, b.parent !== m ? (b = { parent: m, cache: m }, o.memoizedState = b, o.lanes === 0 && (o.memoizedState = o.updateQueue.baseState = b), cl(o, ei, m)) : (m = x.cache, cl(o, ei, m), m !== b.cache && Mc(
          o,
          [ei],
          c,
          !0
        ))), bi(
          n,
          o,
          o.pendingProps.children,
          c
        ), o.child;
      case 29:
        throw o.pendingProps;
    }
    throw Error(u(156, o.tag));
  }
  function Kl(n) {
    n.flags |= 4;
  }
  function Nc(n, o) {
    if (o.type !== "stylesheet" || (o.state.loading & 4) !== 0)
      n.flags &= -16777217;
    else if (n.flags |= 16777216, !Fg(o)) {
      if (o = ao.current, o !== null && ((He & 4194048) === He ? Ki !== null : (He & 62914560) !== He && (He & 536870912) === 0 || o !== Ki))
        throw Mu = Bd, Ud;
      n.flags |= 8192;
    }
  }
  function yh(n, o) {
    o !== null && (n.flags |= 4), n.flags & 16384 && (o = n.tag !== 22 ? kt() : 536870912, n.lanes |= o, qc |= o);
  }
  function Uc(n, o) {
    if (!oe)
      switch (n.tailMode) {
        case "hidden":
          o = n.tail;
          for (var c = null; o !== null; )
            o.alternate !== null && (c = o), o = o.sibling;
          c === null ? n.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = n.tail;
          for (var m = null; c !== null; )
            c.alternate !== null && (m = c), c = c.sibling;
          m === null ? o || n.tail === null ? n.tail = null : n.tail.sibling = null : m.sibling = null;
      }
  }
  function ie(n) {
    var o = n.alternate !== null && n.alternate.child === n.child, c = 0, m = 0;
    if (o)
      for (var b = n.child; b !== null; )
        c |= b.lanes | b.childLanes, m |= b.subtreeFlags & 65011712, m |= b.flags & 65011712, b.return = n, b = b.sibling;
    else
      for (b = n.child; b !== null; )
        c |= b.lanes | b.childLanes, m |= b.subtreeFlags, m |= b.flags, b.return = n, b = b.sibling;
    return n.subtreeFlags |= m, n.childLanes = c, o;
  }
  function yg(n, o, c) {
    var m = o.pendingProps;
    switch (Ut(o), o.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ie(o), null;
      case 1:
        return ie(o), null;
      case 3:
        return c = o.stateNode, m = null, n !== null && (m = n.memoizedState.cache), o.memoizedState.cache !== m && (o.flags |= 2048), Ho(ei), on(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (n === null || n.child === null) && (Er(o) ? Kl(o) : n === null || n.memoizedState.isDehydrated && (o.flags & 256) === 0 || (o.flags |= 1024, Gf())), ie(o), null;
      case 26:
        return c = o.memoizedState, n === null ? (Kl(o), c !== null ? (ie(o), Nc(o, c)) : (ie(o), o.flags &= -16777217)) : c ? c !== n.memoizedState ? (Kl(o), ie(o), Nc(o, c)) : (ie(o), o.flags &= -16777217) : (n.memoizedProps !== m && Kl(o), ie(o), o.flags &= -16777217), null;
      case 27:
        da(o), c = Tt.current;
        var b = o.type;
        if (n !== null && o.stateNode != null)
          n.memoizedProps !== m && Kl(o);
        else {
          if (!m) {
            if (o.stateNode === null)
              throw Error(u(166));
            return ie(o), null;
          }
          n = Mt.current, Er(o) ? xu(o) : (n = jt(b, m, c), o.stateNode = n, Kl(o));
        }
        return ie(o), null;
      case 5:
        if (da(o), c = o.type, n !== null && o.stateNode != null)
          n.memoizedProps !== m && Kl(o);
        else {
          if (!m) {
            if (o.stateNode === null)
              throw Error(u(166));
            return ie(o), null;
          }
          if (n = Mt.current, Er(o))
            xu(o);
          else {
            switch (b = Zo(
              Tt.current
            ), n) {
              case 1:
                n = b.createElementNS(
                  "http://www.w3.org/2000/svg",
                  c
                );
                break;
              case 2:
                n = b.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  c
                );
                break;
              default:
                switch (c) {
                  case "svg":
                    n = b.createElementNS(
                      "http://www.w3.org/2000/svg",
                      c
                    );
                    break;
                  case "math":
                    n = b.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      c
                    );
                    break;
                  case "script":
                    n = b.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild);
                    break;
                  case "select":
                    n = typeof m.is == "string" ? b.createElement("select", { is: m.is }) : b.createElement("select"), m.multiple ? n.multiple = !0 : m.size && (n.size = m.size);
                    break;
                  default:
                    n = typeof m.is == "string" ? b.createElement(c, { is: m.is }) : b.createElement(c);
                }
            }
            n[Vn] = o, n[Ei] = m;
            t: for (b = o.child; b !== null; ) {
              if (b.tag === 5 || b.tag === 6)
                n.appendChild(b.stateNode);
              else if (b.tag !== 4 && b.tag !== 27 && b.child !== null) {
                b.child.return = b, b = b.child;
                continue;
              }
              if (b === o) break t;
              for (; b.sibling === null; ) {
                if (b.return === null || b.return === o)
                  break t;
                b = b.return;
              }
              b.sibling.return = b.return, b = b.sibling;
            }
            o.stateNode = n;
            t: switch (re(n, c, m), c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                n = !!m.autoFocus;
                break t;
              case "img":
                n = !0;
                break t;
              default:
                n = !1;
            }
            n && Kl(o);
          }
        }
        return ie(o), o.flags &= -16777217, null;
      case 6:
        if (n && o.stateNode != null)
          n.memoizedProps !== m && Kl(o);
        else {
          if (typeof m != "string" && o.stateNode === null)
            throw Error(u(166));
          if (n = Tt.current, Er(o)) {
            if (n = o.stateNode, c = o.memoizedProps, m = null, b = qt, b !== null)
              switch (b.tag) {
                case 27:
                case 5:
                  m = b.memoizedProps;
              }
            n[Vn] = o, n = !!(n.nodeValue === c || m !== null && m.suppressHydrationWarning === !0 || Wg(n.nodeValue, c)), n || Gi(o);
          } else
            n = Zo(n).createTextNode(
              m
            ), n[Vn] = o, o.stateNode = n;
        }
        return ie(o), null;
      case 13:
        if (m = o.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
          if (b = Er(o), m !== null && m.dehydrated !== null) {
            if (n === null) {
              if (!b) throw Error(u(318));
              if (b = o.memoizedState, b = b !== null ? b.dehydrated : null, !b) throw Error(u(317));
              b[Vn] = o;
            } else
              Bs(), (o.flags & 128) === 0 && (o.memoizedState = null), o.flags |= 4;
            ie(o), b = !1;
          } else
            b = Gf(), n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = b), b = !0;
          if (!b)
            return o.flags & 256 ? (dl(o), o) : (dl(o), null);
        }
        if (dl(o), (o.flags & 128) !== 0)
          return o.lanes = c, o;
        if (c = m !== null, n = n !== null && n.memoizedState !== null, c) {
          m = o.child, b = null, m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (b = m.alternate.memoizedState.cachePool.pool);
          var x = null;
          m.memoizedState !== null && m.memoizedState.cachePool !== null && (x = m.memoizedState.cachePool.pool), x !== b && (m.flags |= 2048);
        }
        return c !== n && c && (o.child.flags |= 8192), yh(o, o.updateQueue), ie(o), null;
      case 4:
        return on(), n === null && Qg(o.stateNode.containerInfo), ie(o), null;
      case 10:
        return Ho(o.type), ie(o), null;
      case 19:
        if (ct(nn), b = o.memoizedState, b === null) return ie(o), null;
        if (m = (o.flags & 128) !== 0, x = b.rendering, x === null)
          if (m) Uc(b, !1);
          else {
            if (Ln !== 0 || n !== null && (n.flags & 128) !== 0)
              for (n = o.child; n !== null; ) {
                if (x = fh(n), x !== null) {
                  for (o.flags |= 128, Uc(b, !1), n = x.updateQueue, o.updateQueue = n, yh(o, n), o.subtreeFlags = 0, n = c, c = o.child; c !== null; )
                    ye(c, n), c = c.sibling;
                  return bt(
                    nn,
                    nn.current & 1 | 2
                  ), o.child;
                }
                n = n.sibling;
              }
            b.tail !== null && En() > Dm && (o.flags |= 128, m = !0, Uc(b, !1), o.lanes = 4194304);
          }
        else {
          if (!m)
            if (n = fh(x), n !== null) {
              if (o.flags |= 128, m = !0, n = n.updateQueue, o.updateQueue = n, yh(o, n), Uc(b, !0), b.tail === null && b.tailMode === "hidden" && !x.alternate && !oe)
                return ie(o), null;
            } else
              2 * En() - b.renderingStartTime > Dm && c !== 536870912 && (o.flags |= 128, m = !0, Uc(b, !1), o.lanes = 4194304);
          b.isBackwards ? (x.sibling = o.child, o.child = x) : (n = b.last, n !== null ? n.sibling = x : o.child = x, b.last = x);
        }
        return b.tail !== null ? (o = b.tail, b.rendering = o, b.tail = o.sibling, b.renderingStartTime = En(), o.sibling = null, n = nn.current, bt(nn, m ? n & 1 | 2 : n & 1), o) : (ie(o), null);
      case 22:
      case 23:
        return dl(o), Rc(), m = o.memoizedState !== null, n !== null ? n.memoizedState !== null !== m && (o.flags |= 8192) : m && (o.flags |= 8192), m ? (c & 536870912) !== 0 && (o.flags & 128) === 0 && (ie(o), o.subtreeFlags & 6 && (o.flags |= 8192)) : ie(o), c = o.updateQueue, c !== null && yh(o, c.retryQueue), c = null, n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (c = n.memoizedState.cachePool.pool), m = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (m = o.memoizedState.cachePool.pool), m !== c && (o.flags |= 2048), n !== null && ct(Yl), null;
      case 24:
        return c = null, n !== null && (c = n.memoizedState.cache), o.memoizedState.cache !== c && (o.flags |= 2048), Ho(ei), ie(o), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(u(156, o.tag));
  }
  function N0(n, o) {
    switch (Ut(o), o.tag) {
      case 1:
        return n = o.flags, n & 65536 ? (o.flags = n & -65537 | 128, o) : null;
      case 3:
        return Ho(ei), on(), n = o.flags, (n & 65536) !== 0 && (n & 128) === 0 ? (o.flags = n & -65537 | 128, o) : null;
      case 26:
      case 27:
      case 5:
        return da(o), null;
      case 13:
        if (dl(o), n = o.memoizedState, n !== null && n.dehydrated !== null) {
          if (o.alternate === null)
            throw Error(u(340));
          Bs();
        }
        return n = o.flags, n & 65536 ? (o.flags = n & -65537 | 128, o) : null;
      case 19:
        return ct(nn), null;
      case 4:
        return on(), null;
      case 10:
        return Ho(o.type), null;
      case 22:
      case 23:
        return dl(o), Rc(), n !== null && ct(Yl), n = o.flags, n & 65536 ? (o.flags = n & -65537 | 128, o) : null;
      case 24:
        return Ho(ei), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function vg(n, o) {
    switch (Ut(o), o.tag) {
      case 3:
        Ho(ei), on();
        break;
      case 26:
      case 27:
      case 5:
        da(o);
        break;
      case 4:
        on();
        break;
      case 13:
        dl(o);
        break;
      case 19:
        ct(nn);
        break;
      case 10:
        Ho(o.type);
        break;
      case 22:
      case 23:
        dl(o), Rc(), n !== null && ct(Yl);
        break;
      case 24:
        Ho(ei);
    }
  }
  function vh(n, o) {
    try {
      var c = o.updateQueue, m = c !== null ? c.lastEffect : null;
      if (m !== null) {
        var b = m.next;
        c = b;
        do {
          if ((c.tag & n) === n) {
            m = void 0;
            var x = c.create, R = c.inst;
            m = x(), R.destroy = m;
          }
          c = c.next;
        } while (c !== b);
      }
    } catch (U) {
      Ie(o, o.return, U);
    }
  }
  function Br(n, o, c) {
    try {
      var m = o.updateQueue, b = m !== null ? m.lastEffect : null;
      if (b !== null) {
        var x = b.next;
        m = x;
        do {
          if ((m.tag & n) === n) {
            var R = m.inst, U = R.destroy;
            if (U !== void 0) {
              R.destroy = void 0, b = o;
              var Z = c, it = U;
              try {
                it();
              } catch (vt) {
                Ie(
                  b,
                  Z,
                  vt
                );
              }
            }
          }
          m = m.next;
        } while (m !== x);
      }
    } catch (vt) {
      Ie(o, o.return, vt);
    }
  }
  function bm(n) {
    var o = n.updateQueue;
    if (o !== null) {
      var c = n.stateNode;
      try {
        Jf(o, c);
      } catch (m) {
        Ie(n, n.return, m);
      }
    }
  }
  function _g(n, o, c) {
    c.props = Nr(
      n.type,
      n.memoizedProps
    ), c.state = n.memoizedState;
    try {
      c.componentWillUnmount();
    } catch (m) {
      Ie(n, o, m);
    }
  }
  function Bc(n, o) {
    try {
      var c = n.ref;
      if (c !== null) {
        switch (n.tag) {
          case 26:
          case 27:
          case 5:
            var m = n.stateNode;
            break;
          case 30:
            m = n.stateNode;
            break;
          default:
            m = n.stateNode;
        }
        typeof c == "function" ? n.refCleanup = c(m) : c.current = m;
      }
    } catch (b) {
      Ie(n, o, b);
    }
  }
  function ml(n, o) {
    var c = n.ref, m = n.refCleanup;
    if (c !== null)
      if (typeof m == "function")
        try {
          m();
        } catch (b) {
          Ie(n, o, b);
        } finally {
          n.refCleanup = null, n = n.alternate, n != null && (n.refCleanup = null);
        }
      else if (typeof c == "function")
        try {
          c(null);
        } catch (b) {
          Ie(n, o, b);
        }
      else c.current = null;
  }
  function Yc(n) {
    var o = n.type, c = n.memoizedProps, m = n.stateNode;
    try {
      t: switch (o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && m.focus();
          break t;
        case "img":
          c.src ? m.src = c.src : c.srcSet && (m.srcset = c.srcSet);
      }
    } catch (b) {
      Ie(n, n.return, b);
    }
  }
  function bg(n, o, c) {
    try {
      var m = n.stateNode;
      q0(m, n.type, c, o), m[Ei] = o;
    } catch (b) {
      Ie(n, n.return, b);
    }
  }
  function Zv(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 26 || n.tag === 27 && Xr(n.type) || n.tag === 4;
  }
  function Bo(n) {
    t: for (; ; ) {
      for (; n.sibling === null; ) {
        if (n.return === null || Zv(n.return)) return null;
        n = n.return;
      }
      for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
        if (n.tag === 27 && Xr(n.type) || n.flags & 2 || n.child === null || n.tag === 4) continue t;
        n.child.return = n, n = n.child;
      }
      if (!(n.flags & 2)) return n.stateNode;
    }
  }
  function Bu(n, o, c) {
    var m = n.tag;
    if (m === 5 || m === 6)
      n = n.stateNode, o ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(n, o) : (o = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, o.appendChild(n), c = c._reactRootContainer, c != null || o.onclick !== null || (o.onclick = jm));
    else if (m !== 4 && (m === 27 && Xr(n.type) && (c = n.stateNode, o = null), n = n.child, n !== null))
      for (Bu(n, o, c), n = n.sibling; n !== null; )
        Bu(n, o, c), n = n.sibling;
  }
  function Sm(n, o, c) {
    var m = n.tag;
    if (m === 5 || m === 6)
      n = n.stateNode, o ? c.insertBefore(n, o) : c.appendChild(n);
    else if (m !== 4 && (m === 27 && Xr(n.type) && (c = n.stateNode), n = n.child, n !== null))
      for (Sm(n, o, c), n = n.sibling; n !== null; )
        Sm(n, o, c), n = n.sibling;
  }
  function Tm(n) {
    var o = n.stateNode, c = n.memoizedProps;
    try {
      for (var m = n.type, b = o.attributes; b.length; )
        o.removeAttributeNode(b[0]);
      re(o, m, c), o[Vn] = n, o[Ei] = c;
    } catch (x) {
      Ie(n, n.return, x);
    }
  }
  var Wl = !1, Cn = !1, xm = !1, wm = typeof WeakSet == "function" ? WeakSet : Set, ai = null;
  function Sg(n, o) {
    if (n = n.containerInfo, Ch = Uh, n = xr(n), Hs(n)) {
      if ("selectionStart" in n)
        var c = {
          start: n.selectionStart,
          end: n.selectionEnd
        };
      else
        t: {
          c = (c = n.ownerDocument) && c.defaultView || window;
          var m = c.getSelection && c.getSelection();
          if (m && m.rangeCount !== 0) {
            c = m.anchorNode;
            var b = m.anchorOffset, x = m.focusNode;
            m = m.focusOffset;
            try {
              c.nodeType, x.nodeType;
            } catch {
              c = null;
              break t;
            }
            var R = 0, U = -1, Z = -1, it = 0, vt = 0, St = n, ot = null;
            e: for (; ; ) {
              for (var st; St !== c || b !== 0 && St.nodeType !== 3 || (U = R + b), St !== x || m !== 0 && St.nodeType !== 3 || (Z = R + m), St.nodeType === 3 && (R += St.nodeValue.length), (st = St.firstChild) !== null; )
                ot = St, St = st;
              for (; ; ) {
                if (St === n) break e;
                if (ot === c && ++it === b && (U = R), ot === x && ++vt === m && (Z = R), (st = St.nextSibling) !== null) break;
                St = ot, ot = St.parentNode;
              }
              St = st;
            }
            c = U === -1 || Z === -1 ? null : { start: U, end: Z };
          } else c = null;
        }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (zh = { focusedElem: n, selectionRange: c }, Uh = !1, ai = o; ai !== null; )
      if (o = ai, n = o.child, (o.subtreeFlags & 1024) !== 0 && n !== null)
        n.return = o, ai = n;
      else
        for (; ai !== null; ) {
          switch (o = ai, x = o.alternate, n = o.flags, o.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((n & 1024) !== 0 && x !== null) {
                n = void 0, c = o, b = x.memoizedProps, x = x.memoizedState, m = c.stateNode;
                try {
                  var te = Nr(
                    c.type,
                    b,
                    c.elementType === c.type
                  );
                  n = m.getSnapshotBeforeUpdate(
                    te,
                    x
                  ), m.__reactInternalSnapshotBeforeUpdate = n;
                } catch (ee) {
                  Ie(
                    c,
                    c.return,
                    ee
                  );
                }
              }
              break;
            case 3:
              if ((n & 1024) !== 0) {
                if (n = o.stateNode.containerInfo, c = n.nodeType, c === 9)
                  Lh(n);
                else if (c === 1)
                  switch (n.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Lh(n);
                      break;
                    default:
                      n.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((n & 1024) !== 0) throw Error(u(163));
          }
          if (n = o.sibling, n !== null) {
            n.return = o.return, ai = n;
            break;
          }
          ai = o.return;
        }
  }
  function Tg(n, o, c) {
    var m = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 15:
        $l(n, c), m & 4 && vh(5, c);
        break;
      case 1:
        if ($l(n, c), m & 4)
          if (n = c.stateNode, o === null)
            try {
              n.componentDidMount();
            } catch (R) {
              Ie(c, c.return, R);
            }
          else {
            var b = Nr(
              c.type,
              o.memoizedProps
            );
            o = o.memoizedState;
            try {
              n.componentDidUpdate(
                b,
                o,
                n.__reactInternalSnapshotBeforeUpdate
              );
            } catch (R) {
              Ie(
                c,
                c.return,
                R
              );
            }
          }
        m & 64 && bm(c), m & 512 && Bc(c, c.return);
        break;
      case 3:
        if ($l(n, c), m & 64 && (n = c.updateQueue, n !== null)) {
          if (o = null, c.child !== null)
            switch (c.child.tag) {
              case 27:
              case 5:
                o = c.child.stateNode;
                break;
              case 1:
                o = c.child.stateNode;
            }
          try {
            Jf(n, o);
          } catch (R) {
            Ie(c, c.return, R);
          }
        }
        break;
      case 27:
        o === null && m & 4 && Tm(c);
      case 26:
      case 5:
        $l(n, c), o === null && m & 4 && Yc(c), m & 512 && Bc(c, c.return);
        break;
      case 12:
        $l(n, c);
        break;
      case 13:
        $l(n, c), m & 4 && Mm(n, c), m & 64 && (n = c.memoizedState, n !== null && (n = n.dehydrated, n !== null && (c = U0.bind(
          null,
          c
        ), G0(n, c))));
        break;
      case 22:
        if (m = c.memoizedState !== null || Wl, !m) {
          o = o !== null && o.memoizedState !== null || Cn, b = Wl;
          var x = Cn;
          Wl = m, (Cn = o) && !x ? Yr(
            n,
            c,
            (c.subtreeFlags & 8772) !== 0
          ) : $l(n, c), Wl = b, Cn = x;
        }
        break;
      case 30:
        break;
      default:
        $l(n, c);
    }
  }
  function xg(n) {
    var o = n.alternate;
    o !== null && (n.alternate = null, xg(o)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (o = n.stateNode, o !== null && mr(o)), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
  }
  var vn = null, zi = !1;
  function Il(n, o, c) {
    for (c = c.child; c !== null; )
      Ce(n, o, c), c = c.sibling;
  }
  function Ce(n, o, c) {
    if (Zn && typeof Zn.onCommitFiberUnmount == "function")
      try {
        Zn.onCommitFiberUnmount(go, c);
      } catch {
      }
    switch (c.tag) {
      case 26:
        Cn || ml(c, o), Il(
          n,
          o,
          c
        ), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
        break;
      case 27:
        Cn || ml(c, o);
        var m = vn, b = zi;
        Xr(c.type) && (vn = c.stateNode, zi = !1), Il(
          n,
          o,
          c
        ), Ha(c.stateNode), vn = m, zi = b;
        break;
      case 5:
        Cn || ml(c, o);
      case 6:
        if (m = vn, b = zi, vn = null, Il(
          n,
          o,
          c
        ), vn = m, zi = b, vn !== null)
          if (zi)
            try {
              (vn.nodeType === 9 ? vn.body : vn.nodeName === "HTML" ? vn.ownerDocument.body : vn).removeChild(c.stateNode);
            } catch (x) {
              Ie(
                c,
                o,
                x
              );
            }
          else
            try {
              vn.removeChild(c.stateNode);
            } catch (x) {
              Ie(
                c,
                o,
                x
              );
            }
        break;
      case 18:
        vn !== null && (zi ? (n = vn, Zm(
          n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n,
          c.stateNode
        ), os(n)) : Zm(vn, c.stateNode));
        break;
      case 4:
        m = vn, b = zi, vn = c.stateNode.containerInfo, zi = !0, Il(
          n,
          o,
          c
        ), vn = m, zi = b;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Cn || Br(2, c, o), Cn || Br(4, c, o), Il(
          n,
          o,
          c
        );
        break;
      case 1:
        Cn || (ml(c, o), m = c.stateNode, typeof m.componentWillUnmount == "function" && _g(
          c,
          o,
          m
        )), Il(
          n,
          o,
          c
        );
        break;
      case 21:
        Il(
          n,
          o,
          c
        );
        break;
      case 22:
        Cn = (m = Cn) || c.memoizedState !== null, Il(
          n,
          o,
          c
        ), Cn = m;
        break;
      default:
        Il(
          n,
          o,
          c
        );
    }
  }
  function Mm(n, o) {
    if (o.memoizedState === null && (n = o.alternate, n !== null && (n = n.memoizedState, n !== null && (n = n.dehydrated, n !== null))))
      try {
        os(n);
      } catch (c) {
        Ie(o, o.return, c);
      }
  }
  function wg(n) {
    switch (n.tag) {
      case 13:
      case 19:
        var o = n.stateNode;
        return o === null && (o = n.stateNode = new wm()), o;
      case 22:
        return n = n.stateNode, o = n._retryCache, o === null && (o = n._retryCache = new wm()), o;
      default:
        throw Error(u(435, n.tag));
    }
  }
  function Em(n, o) {
    var c = wg(n);
    o.forEach(function(m) {
      var b = B0.bind(null, n, m);
      c.has(m) || (c.add(m), m.then(b, b));
    });
  }
  function la(n, o) {
    var c = o.deletions;
    if (c !== null)
      for (var m = 0; m < c.length; m++) {
        var b = c[m], x = n, R = o, U = R;
        t: for (; U !== null; ) {
          switch (U.tag) {
            case 27:
              if (Xr(U.type)) {
                vn = U.stateNode, zi = !1;
                break t;
              }
              break;
            case 5:
              vn = U.stateNode, zi = !1;
              break t;
            case 3:
            case 4:
              vn = U.stateNode.containerInfo, zi = !0;
              break t;
          }
          U = U.return;
        }
        if (vn === null) throw Error(u(160));
        Ce(x, R, b), vn = null, zi = !1, x = b.alternate, x !== null && (x.return = null), b.return = null;
      }
    if (o.subtreeFlags & 13878)
      for (o = o.child; o !== null; )
        _h(o, n), o = o.sibling;
  }
  var sa = null;
  function _h(n, o) {
    var c = n.alternate, m = n.flags;
    switch (n.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        la(o, n), Si(n), m & 4 && (Br(3, n, n.return), vh(3, n), Br(5, n, n.return));
        break;
      case 1:
        la(o, n), Si(n), m & 512 && (Cn || c === null || ml(c, c.return)), m & 64 && Wl && (n = n.updateQueue, n !== null && (m = n.callbacks, m !== null && (c = n.shared.hiddenCallbacks, n.shared.hiddenCallbacks = c === null ? m : c.concat(m))));
        break;
      case 26:
        var b = sa;
        if (la(o, n), Si(n), m & 512 && (Cn || c === null || ml(c, c.return)), m & 4) {
          var x = c !== null ? c.memoizedState : null;
          if (m = n.memoizedState, c === null)
            if (m === null)
              if (n.stateNode === null) {
                t: {
                  m = n.type, c = n.memoizedProps, b = b.ownerDocument || b;
                  e: switch (m) {
                    case "title":
                      x = b.getElementsByTagName("title")[0], (!x || x[Pt] || x[Vn] || x.namespaceURI === "http://www.w3.org/2000/svg" || x.hasAttribute("itemprop")) && (x = b.createElement(m), b.head.insertBefore(
                        x,
                        b.querySelector("head > title")
                      )), re(x, m, c), x[Vn] = n, Bn(x), m = x;
                      break t;
                    case "link":
                      var R = $g(
                        "link",
                        "href",
                        b
                      ).get(m + (c.href || ""));
                      if (R) {
                        for (var U = 0; U < R.length; U++)
                          if (x = R[U], x.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && x.getAttribute("rel") === (c.rel == null ? null : c.rel) && x.getAttribute("title") === (c.title == null ? null : c.title) && x.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                            R.splice(U, 1);
                            break e;
                          }
                      }
                      x = b.createElement(m), re(x, m, c), b.head.appendChild(x);
                      break;
                    case "meta":
                      if (R = $g(
                        "meta",
                        "content",
                        b
                      ).get(m + (c.content || ""))) {
                        for (U = 0; U < R.length; U++)
                          if (x = R[U], x.getAttribute("content") === (c.content == null ? null : "" + c.content) && x.getAttribute("name") === (c.name == null ? null : c.name) && x.getAttribute("property") === (c.property == null ? null : c.property) && x.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && x.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                            R.splice(U, 1);
                            break e;
                          }
                      }
                      x = b.createElement(m), re(x, m, c), b.head.appendChild(x);
                      break;
                    default:
                      throw Error(u(468, m));
                  }
                  x[Vn] = n, Bn(x), m = x;
                }
                n.stateNode = m;
              } else
                Jg(
                  b,
                  n.type,
                  n.stateNode
                );
            else
              n.stateNode = o_(
                b,
                m,
                n.memoizedProps
              );
          else
            x !== m ? (x === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : x.count--, m === null ? Jg(
              b,
              n.type,
              n.stateNode
            ) : o_(
              b,
              m,
              n.memoizedProps
            )) : m === null && n.stateNode !== null && bg(
              n,
              n.memoizedProps,
              c.memoizedProps
            );
        }
        break;
      case 27:
        la(o, n), Si(n), m & 512 && (Cn || c === null || ml(c, c.return)), c !== null && m & 4 && bg(
          n,
          n.memoizedProps,
          c.memoizedProps
        );
        break;
      case 5:
        if (la(o, n), Si(n), m & 512 && (Cn || c === null || ml(c, c.return)), n.flags & 32) {
          b = n.stateNode;
          try {
            To(b, "");
          } catch (st) {
            Ie(n, n.return, st);
          }
        }
        m & 4 && n.stateNode != null && (b = n.memoizedProps, bg(
          n,
          b,
          c !== null ? c.memoizedProps : b
        )), m & 1024 && (xm = !0);
        break;
      case 6:
        if (la(o, n), Si(n), m & 4) {
          if (n.stateNode === null)
            throw Error(u(162));
          m = n.memoizedProps, c = n.stateNode;
          try {
            c.nodeValue = m;
          } catch (st) {
            Ie(n, n.return, st);
          }
        }
        break;
      case 3:
        if (Ir = null, b = sa, sa = Pm(o.containerInfo), la(o, n), sa = b, Si(n), m & 4 && c !== null && c.memoizedState.isDehydrated)
          try {
            os(o.containerInfo);
          } catch (st) {
            Ie(n, n.return, st);
          }
        xm && (xm = !1, Mg(n));
        break;
      case 4:
        m = sa, sa = Pm(
          n.stateNode.containerInfo
        ), la(o, n), Si(n), sa = m;
        break;
      case 12:
        la(o, n), Si(n);
        break;
      case 13:
        la(o, n), Si(n), n.child.flags & 8192 && n.memoizedState !== null != (c !== null && c.memoizedState !== null) && (Lg = En()), m & 4 && (m = n.updateQueue, m !== null && (n.updateQueue = null, Em(n, m)));
        break;
      case 22:
        b = n.memoizedState !== null;
        var Z = c !== null && c.memoizedState !== null, it = Wl, vt = Cn;
        if (Wl = it || b, Cn = vt || Z, la(o, n), Cn = vt, Wl = it, Si(n), m & 8192)
          t: for (o = n.stateNode, o._visibility = b ? o._visibility & -2 : o._visibility | 1, b && (c === null || Z || Wl || Cn || _n(n)), c = null, o = n; ; ) {
            if (o.tag === 5 || o.tag === 26) {
              if (c === null) {
                Z = c = o;
                try {
                  if (x = Z.stateNode, b)
                    R = x.style, typeof R.setProperty == "function" ? R.setProperty("display", "none", "important") : R.display = "none";
                  else {
                    U = Z.stateNode;
                    var St = Z.memoizedProps.style, ot = St != null && St.hasOwnProperty("display") ? St.display : null;
                    U.style.display = ot == null || typeof ot == "boolean" ? "" : ("" + ot).trim();
                  }
                } catch (st) {
                  Ie(Z, Z.return, st);
                }
              }
            } else if (o.tag === 6) {
              if (c === null) {
                Z = o;
                try {
                  Z.stateNode.nodeValue = b ? "" : Z.memoizedProps;
                } catch (st) {
                  Ie(Z, Z.return, st);
                }
              }
            } else if ((o.tag !== 22 && o.tag !== 23 || o.memoizedState === null || o === n) && o.child !== null) {
              o.child.return = o, o = o.child;
              continue;
            }
            if (o === n) break t;
            for (; o.sibling === null; ) {
              if (o.return === null || o.return === n) break t;
              c === o && (c = null), o = o.return;
            }
            c === o && (c = null), o.sibling.return = o.return, o = o.sibling;
          }
        m & 4 && (m = n.updateQueue, m !== null && (c = m.retryQueue, c !== null && (m.retryQueue = null, Em(n, c))));
        break;
      case 19:
        la(o, n), Si(n), m & 4 && (m = n.updateQueue, m !== null && (n.updateQueue = null, Em(n, m)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        la(o, n), Si(n);
    }
  }
  function Si(n) {
    var o = n.flags;
    if (o & 2) {
      try {
        for (var c, m = n.return; m !== null; ) {
          if (Zv(m)) {
            c = m;
            break;
          }
          m = m.return;
        }
        if (c == null) throw Error(u(160));
        switch (c.tag) {
          case 27:
            var b = c.stateNode, x = Bo(n);
            Sm(n, x, b);
            break;
          case 5:
            var R = c.stateNode;
            c.flags & 32 && (To(R, ""), c.flags &= -33);
            var U = Bo(n);
            Sm(n, U, R);
            break;
          case 3:
          case 4:
            var Z = c.stateNode.containerInfo, it = Bo(n);
            Bu(
              n,
              it,
              Z
            );
            break;
          default:
            throw Error(u(161));
        }
      } catch (vt) {
        Ie(n, n.return, vt);
      }
      n.flags &= -3;
    }
    o & 4096 && (n.flags &= -4097);
  }
  function Mg(n) {
    if (n.subtreeFlags & 1024)
      for (n = n.child; n !== null; ) {
        var o = n;
        Mg(o), o.tag === 5 && o.flags & 1024 && o.stateNode.reset(), n = n.sibling;
      }
  }
  function $l(n, o) {
    if (o.subtreeFlags & 8772)
      for (o = o.child; o !== null; )
        Tg(n, o.alternate, o), o = o.sibling;
  }
  function _n(n) {
    for (n = n.child; n !== null; ) {
      var o = n;
      switch (o.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Br(4, o, o.return), _n(o);
          break;
        case 1:
          ml(o, o.return);
          var c = o.stateNode;
          typeof c.componentWillUnmount == "function" && _g(
            o,
            o.return,
            c
          ), _n(o);
          break;
        case 27:
          Ha(o.stateNode);
        case 26:
        case 5:
          ml(o, o.return), _n(o);
          break;
        case 22:
          o.memoizedState === null && _n(o);
          break;
        case 30:
          _n(o);
          break;
        default:
          _n(o);
      }
      n = n.sibling;
    }
  }
  function Yr(n, o, c) {
    for (c = c && (o.subtreeFlags & 8772) !== 0, o = o.child; o !== null; ) {
      var m = o.alternate, b = n, x = o, R = x.flags;
      switch (x.tag) {
        case 0:
        case 11:
        case 15:
          Yr(
            b,
            x,
            c
          ), vh(4, x);
          break;
        case 1:
          if (Yr(
            b,
            x,
            c
          ), m = x, b = m.stateNode, typeof b.componentDidMount == "function")
            try {
              b.componentDidMount();
            } catch (it) {
              Ie(m, m.return, it);
            }
          if (m = x, b = m.updateQueue, b !== null) {
            var U = m.stateNode;
            try {
              var Z = b.shared.hiddenCallbacks;
              if (Z !== null)
                for (b.shared.hiddenCallbacks = null, b = 0; b < Z.length; b++)
                  Zd(Z[b], U);
            } catch (it) {
              Ie(m, m.return, it);
            }
          }
          c && R & 64 && bm(x), Bc(x, x.return);
          break;
        case 27:
          Tm(x);
        case 26:
        case 5:
          Yr(
            b,
            x,
            c
          ), c && m === null && R & 4 && Yc(x), Bc(x, x.return);
          break;
        case 12:
          Yr(
            b,
            x,
            c
          );
          break;
        case 13:
          Yr(
            b,
            x,
            c
          ), c && R & 4 && Mm(b, x);
          break;
        case 22:
          x.memoizedState === null && Yr(
            b,
            x,
            c
          ), Bc(x, x.return);
          break;
        case 30:
          break;
        default:
          Yr(
            b,
            x,
            c
          );
      }
      o = o.sibling;
    }
  }
  function Yo(n, o) {
    var c = null;
    n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (c = n.memoizedState.cachePool.pool), n = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (n = o.memoizedState.cachePool.pool), n !== c && (n != null && n.refCount++, c != null && Bl(c));
  }
  function Om(n, o) {
    n = null, o.alternate !== null && (n = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== n && (o.refCount++, n != null && Bl(n));
  }
  function Li(n, o, c, m) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; )
        Eg(
          n,
          o,
          c,
          m
        ), o = o.sibling;
  }
  function Eg(n, o, c, m) {
    var b = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        Li(
          n,
          o,
          c,
          m
        ), b & 2048 && vh(9, o);
        break;
      case 1:
        Li(
          n,
          o,
          c,
          m
        );
        break;
      case 3:
        Li(
          n,
          o,
          c,
          m
        ), b & 2048 && (n = null, o.alternate !== null && (n = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== n && (o.refCount++, n != null && Bl(n)));
        break;
      case 12:
        if (b & 2048) {
          Li(
            n,
            o,
            c,
            m
          ), n = o.stateNode;
          try {
            var x = o.memoizedProps, R = x.id, U = x.onPostCommit;
            typeof U == "function" && U(
              R,
              o.alternate === null ? "mount" : "update",
              n.passiveEffectDuration,
              -0
            );
          } catch (Z) {
            Ie(o, o.return, Z);
          }
        } else
          Li(
            n,
            o,
            c,
            m
          );
        break;
      case 13:
        Li(
          n,
          o,
          c,
          m
        );
        break;
      case 23:
        break;
      case 22:
        x = o.stateNode, R = o.alternate, o.memoizedState !== null ? x._visibility & 2 ? Li(
          n,
          o,
          c,
          m
        ) : qe(n, o) : x._visibility & 2 ? Li(
          n,
          o,
          c,
          m
        ) : (x._visibility |= 2, Gs(
          n,
          o,
          c,
          m,
          (o.subtreeFlags & 10256) !== 0
        )), b & 2048 && Yo(R, o);
        break;
      case 24:
        Li(
          n,
          o,
          c,
          m
        ), b & 2048 && Om(o.alternate, o);
        break;
      default:
        Li(
          n,
          o,
          c,
          m
        );
    }
  }
  function Gs(n, o, c, m, b) {
    for (b = b && (o.subtreeFlags & 10256) !== 0, o = o.child; o !== null; ) {
      var x = n, R = o, U = c, Z = m, it = R.flags;
      switch (R.tag) {
        case 0:
        case 11:
        case 15:
          Gs(
            x,
            R,
            U,
            Z,
            b
          ), vh(8, R);
          break;
        case 23:
          break;
        case 22:
          var vt = R.stateNode;
          R.memoizedState !== null ? vt._visibility & 2 ? Gs(
            x,
            R,
            U,
            Z,
            b
          ) : qe(
            x,
            R
          ) : (vt._visibility |= 2, Gs(
            x,
            R,
            U,
            Z,
            b
          )), b && it & 2048 && Yo(
            R.alternate,
            R
          );
          break;
        case 24:
          Gs(
            x,
            R,
            U,
            Z,
            b
          ), b && it & 2048 && Om(R.alternate, R);
          break;
        default:
          Gs(
            x,
            R,
            U,
            Z,
            b
          );
      }
      o = o.sibling;
    }
  }
  function qe(n, o) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; ) {
        var c = n, m = o, b = m.flags;
        switch (m.tag) {
          case 22:
            qe(c, m), b & 2048 && Yo(
              m.alternate,
              m
            );
            break;
          case 24:
            qe(c, m), b & 2048 && Om(m.alternate, m);
            break;
          default:
            qe(c, m);
        }
        o = o.sibling;
      }
  }
  var Yu = 8192;
  function zn(n) {
    if (n.subtreeFlags & Yu)
      for (n = n.child; n !== null; )
        Pv(n), n = n.sibling;
  }
  function Pv(n) {
    switch (n.tag) {
      case 26:
        zn(n), n.flags & Yu && n.memoizedState !== null && r_(
          sa,
          n.memoizedState,
          n.memoizedProps
        );
        break;
      case 5:
        zn(n);
        break;
      case 3:
      case 4:
        var o = sa;
        sa = Pm(n.stateNode.containerInfo), zn(n), sa = o;
        break;
      case 22:
        n.memoizedState === null && (o = n.alternate, o !== null && o.memoizedState !== null ? (o = Yu, Yu = 16777216, zn(n), Yu = o) : zn(n));
        break;
      default:
        zn(n);
    }
  }
  function Og(n) {
    var o = n.alternate;
    if (o !== null && (n = o.child, n !== null)) {
      o.child = null;
      do
        o = n.sibling, n.sibling = null, n = o;
      while (n !== null);
    }
  }
  function ju(n) {
    var o = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (o !== null)
        for (var c = 0; c < o.length; c++) {
          var m = o[c];
          ai = m, Ag(
            m,
            n
          );
        }
      Og(n);
    }
    if (n.subtreeFlags & 10256)
      for (n = n.child; n !== null; )
        Dg(n), n = n.sibling;
  }
  function Dg(n) {
    switch (n.tag) {
      case 0:
      case 11:
      case 15:
        ju(n), n.flags & 2048 && Br(9, n, n.return);
        break;
      case 3:
        ju(n);
        break;
      case 12:
        ju(n);
        break;
      case 22:
        var o = n.stateNode;
        n.memoizedState !== null && o._visibility & 2 && (n.return === null || n.return.tag !== 13) ? (o._visibility &= -3, ra(n)) : ju(n);
        break;
      default:
        ju(n);
    }
  }
  function ra(n) {
    var o = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (o !== null)
        for (var c = 0; c < o.length; c++) {
          var m = o[c];
          ai = m, Ag(
            m,
            n
          );
        }
      Og(n);
    }
    for (n = n.child; n !== null; ) {
      switch (o = n, o.tag) {
        case 0:
        case 11:
        case 15:
          Br(8, o, o.return), ra(o);
          break;
        case 22:
          c = o.stateNode, c._visibility & 2 && (c._visibility &= -3, ra(o));
          break;
        default:
          ra(o);
      }
      n = n.sibling;
    }
  }
  function Ag(n, o) {
    for (; ai !== null; ) {
      var c = ai;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          Br(8, c, o);
          break;
        case 23:
        case 22:
          if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
            var m = c.memoizedState.cachePool.pool;
            m != null && m.refCount++;
          }
          break;
        case 24:
          Bl(c.memoizedState.cache);
      }
      if (m = c.child, m !== null) m.return = c, ai = m;
      else
        t: for (c = n; ai !== null; ) {
          m = ai;
          var b = m.sibling, x = m.return;
          if (xg(m), m === c) {
            ai = null;
            break t;
          }
          if (b !== null) {
            b.return = x, ai = b;
            break t;
          }
          ai = x;
        }
    }
  }
  var Rg = {
    getCacheForType: function(n) {
      var o = vi(ei), c = o.data.get(n);
      return c === void 0 && (c = n(), o.data.set(n, c)), c;
    }
  }, Vv = typeof WeakMap == "function" ? WeakMap : Map, Qe = 0, sn = null, Le = null, He = 0, Ke = 0, Ca = null, Jl = !1, jc = !1, Cg = !1, Xs = 0, Ln = 0, Qs = 0, qu = 0, Fl = 0, jo = 0, qc = 0, Zc = null, za = null, zg = !1, Lg = 0, Dm = 1 / 0, Pc = null, jr = null, Hi = 0, ts = null, Vc = null, ki = 0, Am = 0, Rm = null, Hg = null, Gc = 0, kg = null;
  function oo() {
    if ((Qe & 2) !== 0 && He !== 0)
      return He & -He;
    if (V.T !== null) {
      var n = ko;
      return n !== 0 ? n : Gu();
    }
    return pc();
  }
  function Ng() {
    jo === 0 && (jo = (He & 536870912) === 0 || oe ? At() : 536870912);
    var n = ao.current;
    return n !== null && (n.flags |= 32), jo;
  }
  function lo(n, o, c) {
    (n === sn && (Ke === 2 || Ke === 9) || n.cancelPendingCommit !== null) && (es(n, 0), Ks(
      n,
      He,
      jo,
      !1
    )), se(n, c), ((Qe & 2) === 0 || n !== sn) && (n === sn && ((Qe & 2) === 0 && (qu |= c), Ln === 4 && Ks(
      n,
      He,
      jo,
      !1
    )), La(n));
  }
  function Xc(n, o, c) {
    if ((Qe & 6) !== 0) throw Error(u(327));
    var m = !c && (o & 124) === 0 && (o & n.expiredLanes) === 0 || N(n, o), b = m ? Bg(n, o) : Cm(n, o, !0), x = m;
    do {
      if (b === 0) {
        jc && !m && Ks(n, o, 0, !1);
        break;
      } else {
        if (c = n.current.alternate, x && !Gv(c)) {
          b = Cm(n, o, !1), x = !1;
          continue;
        }
        if (b === 2) {
          if (x = o, n.errorRecoveryDisabledLanes & x)
            var R = 0;
          else
            R = n.pendingLanes & -536870913, R = R !== 0 ? R : R & 536870912 ? 536870912 : 0;
          if (R !== 0) {
            o = R;
            t: {
              var U = n;
              b = Zc;
              var Z = U.current.memoizedState.isDehydrated;
              if (Z && (es(U, R).flags |= 256), R = Cm(
                U,
                R,
                !1
              ), R !== 2) {
                if (Cg && !Z) {
                  U.errorRecoveryDisabledLanes |= x, qu |= x, b = 4;
                  break t;
                }
                x = za, za = b, x !== null && (za === null ? za = x : za.push.apply(
                  za,
                  x
                ));
              }
              b = R;
            }
            if (x = !1, b !== 2) continue;
          }
        }
        if (b === 1) {
          es(n, 0), Ks(n, o, 0, !0);
          break;
        }
        t: {
          switch (m = n, x = b, x) {
            case 0:
            case 1:
              throw Error(u(345));
            case 4:
              if ((o & 4194048) !== o) break;
            case 6:
              Ks(
                m,
                o,
                jo,
                !Jl
              );
              break t;
            case 2:
              za = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(u(329));
          }
          if ((o & 62914560) === o && (b = Lg + 300 - En(), 10 < b)) {
            if (Ks(
              m,
              o,
              jo,
              !Jl
            ), Va(m, 0, !0) !== 0) break t;
            m.timeoutHandle = qm(
              bh.bind(
                null,
                m,
                c,
                za,
                Pc,
                zg,
                o,
                jo,
                qu,
                qc,
                Jl,
                x,
                2,
                -0,
                0
              ),
              b
            );
            break t;
          }
          bh(
            m,
            c,
            za,
            Pc,
            zg,
            o,
            jo,
            qu,
            qc,
            Jl,
            x,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    La(n);
  }
  function bh(n, o, c, m, b, x, R, U, Z, it, vt, St, ot, st) {
    if (n.timeoutHandle = -1, St = o.subtreeFlags, (St & 8192 || (St & 16785408) === 16785408) && (of = { stylesheets: null, count: 0, unsuspend: s_ }, Pv(o), St = ty(), St !== null)) {
      n.cancelPendingCommit = St(
        Kv.bind(
          null,
          n,
          o,
          x,
          c,
          m,
          b,
          R,
          U,
          Z,
          vt,
          1,
          ot,
          st
        )
      ), Ks(n, x, R, !it);
      return;
    }
    Kv(
      n,
      o,
      x,
      c,
      m,
      b,
      R,
      U,
      Z
    );
  }
  function Gv(n) {
    for (var o = n; ; ) {
      var c = o.tag;
      if ((c === 0 || c === 11 || c === 15) && o.flags & 16384 && (c = o.updateQueue, c !== null && (c = c.stores, c !== null)))
        for (var m = 0; m < c.length; m++) {
          var b = c[m], x = b.getSnapshot;
          b = b.value;
          try {
            if (!ti(x(), b)) return !1;
          } catch {
            return !1;
          }
        }
      if (c = o.child, o.subtreeFlags & 16384 && c !== null)
        c.return = o, o = c;
      else {
        if (o === n) break;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === n) return !0;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
    }
    return !0;
  }
  function Ks(n, o, c, m) {
    o &= ~Fl, o &= ~qu, n.suspendedLanes |= o, n.pingedLanes &= ~o, m && (n.warmLanes |= o), m = n.expirationTimes;
    for (var b = o; 0 < b; ) {
      var x = 31 - $n(b), R = 1 << x;
      m[x] = -1, b &= ~R;
    }
    c !== 0 && ze(n, c, o);
  }
  function Zu() {
    return (Qe & 6) === 0 ? (wh(0), !1) : !0;
  }
  function qr() {
    if (Le !== null) {
      if (Ke === 0)
        var n = Le.return;
      else
        n = Le, eo = Ea = null, Xd(n), zu = null, Lc = 0, n = Le;
      for (; n !== null; )
        vg(n.alternate, n), n = n.return;
      Le = null;
    }
  }
  function es(n, o) {
    var c = n.timeoutHandle;
    c !== -1 && (n.timeoutHandle = -1, Z0(c)), c = n.cancelPendingCommit, c !== null && (n.cancelPendingCommit = null, c()), qr(), sn = n, Le = c = Ma(n.current, null), He = o, Ke = 0, Ca = null, Jl = !1, jc = N(n, o), Cg = !1, qc = jo = Fl = qu = Qs = Ln = 0, za = Zc = null, zg = !1, (o & 8) !== 0 && (o |= o & 32);
    var m = n.entangledLanes;
    if (m !== 0)
      for (n = n.entanglements, m &= o; 0 < m; ) {
        var b = 31 - $n(m), x = 1 << b;
        o |= n[b], m &= ~x;
      }
    return Xs = o, wa(), c;
  }
  function Ug(n, o) {
    ve = null, V.H = sm, o === Cr || o === If ? (o = qp(), Ke = 3) : o === Ud ? (o = qp(), Ke = 4) : Ke = o === Rn ? 8 : o !== null && typeof o == "object" && typeof o.then == "function" ? 6 : 1, Ca = o, Le === null && (Ln = 1, mh(
      n,
      Pi(o, n.current)
    ));
  }
  function Xv() {
    var n = V.H;
    return V.H = sm, n === null ? sm : n;
  }
  function Pu() {
    var n = V.A;
    return V.A = Rg, n;
  }
  function Vu() {
    Ln = 4, Jl || (He & 4194048) !== He && ao.current !== null || (jc = !0), (Qs & 134217727) === 0 && (qu & 134217727) === 0 || sn === null || Ks(
      sn,
      He,
      jo,
      !1
    );
  }
  function Cm(n, o, c) {
    var m = Qe;
    Qe |= 2;
    var b = Xv(), x = Pu();
    (sn !== n || He !== o) && (Pc = null, es(n, o)), o = !1;
    var R = Ln;
    t: do
      try {
        if (Ke !== 0 && Le !== null) {
          var U = Le, Z = Ca;
          switch (Ke) {
            case 8:
              qr(), R = 6;
              break t;
            case 3:
            case 2:
            case 9:
            case 6:
              ao.current === null && (o = !0);
              var it = Ke;
              if (Ke = 0, Ca = null, Qc(n, U, Z, it), c && jc) {
                R = 0;
                break t;
              }
              break;
            default:
              it = Ke, Ke = 0, Ca = null, Qc(n, U, Z, it);
          }
        }
        zm(), R = Ln;
        break;
      } catch (vt) {
        Ug(n, vt);
      }
    while (!0);
    return o && n.shellSuspendCounter++, eo = Ea = null, Qe = m, V.H = b, V.A = x, Le === null && (sn = null, He = 0, wa()), R;
  }
  function zm() {
    for (; Le !== null; ) jg(Le);
  }
  function Bg(n, o) {
    var c = Qe;
    Qe |= 2;
    var m = Xv(), b = Pu();
    sn !== n || He !== o ? (Pc = null, Dm = En() + 500, es(n, o)) : jc = N(
      n,
      o
    );
    t: do
      try {
        if (Ke !== 0 && Le !== null) {
          o = Le;
          var x = Ca;
          e: switch (Ke) {
            case 1:
              Ke = 0, Ca = null, Qc(n, o, x, 1);
              break;
            case 2:
            case 9:
              if (Yd(x)) {
                Ke = 0, Ca = null, qg(o);
                break;
              }
              o = function() {
                Ke !== 2 && Ke !== 9 || sn !== n || (Ke = 7), La(n);
              }, x.then(o, o);
              break t;
            case 3:
              Ke = 7;
              break t;
            case 4:
              Ke = 5;
              break t;
            case 7:
              Yd(x) ? (Ke = 0, Ca = null, qg(o)) : (Ke = 0, Ca = null, Qc(n, o, x, 7));
              break;
            case 5:
              var R = null;
              switch (Le.tag) {
                case 26:
                  R = Le.memoizedState;
                case 5:
                case 27:
                  var U = Le;
                  if (!R || Fg(R)) {
                    Ke = 0, Ca = null;
                    var Z = U.sibling;
                    if (Z !== null) Le = Z;
                    else {
                      var it = U.return;
                      it !== null ? (Le = it, Sh(it)) : Le = null;
                    }
                    break e;
                  }
              }
              Ke = 0, Ca = null, Qc(n, o, x, 5);
              break;
            case 6:
              Ke = 0, Ca = null, Qc(n, o, x, 6);
              break;
            case 8:
              qr(), Ln = 6;
              break t;
            default:
              throw Error(u(462));
          }
        }
        Yg();
        break;
      } catch (vt) {
        Ug(n, vt);
      }
    while (!0);
    return eo = Ea = null, V.H = m, V.A = b, Qe = c, Le !== null ? 0 : (sn = null, He = 0, wa(), Ln);
  }
  function Yg() {
    for (; Le !== null && !cr(); )
      jg(Le);
  }
  function jg(n) {
    var o = qv(n.alternate, n, Xs);
    n.memoizedProps = n.pendingProps, o === null ? Sh(n) : Le = o;
  }
  function qg(n) {
    var o = n, c = o.alternate;
    switch (o.tag) {
      case 15:
      case 0:
        o = dg(
          c,
          o,
          o.pendingProps,
          o.type,
          void 0,
          He
        );
        break;
      case 11:
        o = dg(
          c,
          o,
          o.pendingProps,
          o.type.render,
          o.ref,
          He
        );
        break;
      case 5:
        Xd(o);
      default:
        vg(c, o), o = Le = ye(o, Xs), o = qv(c, o, Xs);
    }
    n.memoizedProps = n.pendingProps, o === null ? Sh(n) : Le = o;
  }
  function Qc(n, o, c, m) {
    eo = Ea = null, Xd(o), zu = null, Lc = 0;
    var b = o.return;
    try {
      if (Bv(
        n,
        b,
        o,
        c,
        He
      )) {
        Ln = 1, mh(
          n,
          Pi(c, n.current)
        ), Le = null;
        return;
      }
    } catch (x) {
      if (b !== null) throw Le = b, x;
      Ln = 1, mh(
        n,
        Pi(c, n.current)
      ), Le = null;
      return;
    }
    o.flags & 32768 ? (oe || m === 1 ? n = !0 : jc || (He & 536870912) !== 0 ? n = !1 : (Jl = n = !0, (m === 2 || m === 9 || m === 3 || m === 6) && (m = ao.current, m !== null && m.tag === 13 && (m.flags |= 16384))), Qv(o, n)) : Sh(o);
  }
  function Sh(n) {
    var o = n;
    do {
      if ((o.flags & 32768) !== 0) {
        Qv(
          o,
          Jl
        );
        return;
      }
      n = o.return;
      var c = yg(
        o.alternate,
        o,
        Xs
      );
      if (c !== null) {
        Le = c;
        return;
      }
      if (o = o.sibling, o !== null) {
        Le = o;
        return;
      }
      Le = o = n;
    } while (o !== null);
    Ln === 0 && (Ln = 5);
  }
  function Qv(n, o) {
    do {
      var c = N0(n.alternate, n);
      if (c !== null) {
        c.flags &= 32767, Le = c;
        return;
      }
      if (c = n.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !o && (n = n.sibling, n !== null)) {
        Le = n;
        return;
      }
      Le = n = c;
    } while (n !== null);
    Ln = 6, Le = null;
  }
  function Kv(n, o, c, m, b, x, R, U, Z) {
    n.cancelPendingCommit = null;
    do
      Hm();
    while (Hi !== 0);
    if ((Qe & 6) !== 0) throw Error(u(327));
    if (o !== null) {
      if (o === n.current) throw Error(u(177));
      if (x = o.lanes | o.childLanes, x |= Gn, he(
        n,
        c,
        x,
        R,
        U,
        Z
      ), n === sn && (Le = sn = null, He = 0), Vc = o, ts = n, ki = c, Am = x, Rm = b, Hg = m, (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? (n.callbackNode = null, n.callbackPriority = 0, Y0(pa, function() {
        return Zg(), null;
      })) : (n.callbackNode = null, n.callbackPriority = 0), m = (o.flags & 13878) !== 0, (o.subtreeFlags & 13878) !== 0 || m) {
        m = V.T, V.T = null, b = mt.p, mt.p = 2, R = Qe, Qe |= 4;
        try {
          Sg(n, o, c);
        } finally {
          Qe = R, mt.p = b, V.T = m;
        }
      }
      Hi = 1, Wv(), Th(), Lm();
    }
  }
  function Wv() {
    if (Hi === 1) {
      Hi = 0;
      var n = ts, o = Vc, c = (o.flags & 13878) !== 0;
      if ((o.subtreeFlags & 13878) !== 0 || c) {
        c = V.T, V.T = null;
        var m = mt.p;
        mt.p = 2;
        var b = Qe;
        Qe |= 4;
        try {
          _h(o, n);
          var x = zh, R = xr(n.containerInfo), U = x.focusedElem, Z = x.selectionRange;
          if (R !== U && U && U.ownerDocument && Ls(
            U.ownerDocument.documentElement,
            U
          )) {
            if (Z !== null && Hs(U)) {
              var it = Z.start, vt = Z.end;
              if (vt === void 0 && (vt = it), "selectionStart" in U)
                U.selectionStart = it, U.selectionEnd = Math.min(
                  vt,
                  U.value.length
                );
              else {
                var St = U.ownerDocument || document, ot = St && St.defaultView || window;
                if (ot.getSelection) {
                  var st = ot.getSelection(), te = U.textContent.length, ee = Math.min(Z.start, te), Ze = Z.end === void 0 ? ee : Math.min(Z.end, te);
                  !st.extend && ee > Ze && (R = Ze, Ze = ee, ee = R);
                  var tt = tn(
                    U,
                    ee
                  ), W = tn(
                    U,
                    Ze
                  );
                  if (tt && W && (st.rangeCount !== 1 || st.anchorNode !== tt.node || st.anchorOffset !== tt.offset || st.focusNode !== W.node || st.focusOffset !== W.offset)) {
                    var et = St.createRange();
                    et.setStart(tt.node, tt.offset), st.removeAllRanges(), ee > Ze ? (st.addRange(et), st.extend(W.node, W.offset)) : (et.setEnd(W.node, W.offset), st.addRange(et));
                  }
                }
              }
            }
            for (St = [], st = U; st = st.parentNode; )
              st.nodeType === 1 && St.push({
                element: st,
                left: st.scrollLeft,
                top: st.scrollTop
              });
            for (typeof U.focus == "function" && U.focus(), U = 0; U < St.length; U++) {
              var _t = St[U];
              _t.element.scrollLeft = _t.left, _t.element.scrollTop = _t.top;
            }
          }
          Uh = !!Ch, zh = Ch = null;
        } finally {
          Qe = b, mt.p = m, V.T = c;
        }
      }
      n.current = o, Hi = 2;
    }
  }
  function Th() {
    if (Hi === 2) {
      Hi = 0;
      var n = ts, o = Vc, c = (o.flags & 8772) !== 0;
      if ((o.subtreeFlags & 8772) !== 0 || c) {
        c = V.T, V.T = null;
        var m = mt.p;
        mt.p = 2;
        var b = Qe;
        Qe |= 4;
        try {
          Tg(n, o.alternate, o);
        } finally {
          Qe = b, mt.p = m, V.T = c;
        }
      }
      Hi = 3;
    }
  }
  function Lm() {
    if (Hi === 4 || Hi === 3) {
      Hi = 0, Tn();
      var n = ts, o = Vc, c = ki, m = Hg;
      (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? Hi = 5 : (Hi = 0, Vc = ts = null, Iv(n, n.pendingLanes));
      var b = n.pendingLanes;
      if (b === 0 && (jr = null), Ga(c), o = o.stateNode, Zn && typeof Zn.onCommitFiberRoot == "function")
        try {
          Zn.onCommitFiberRoot(
            go,
            o,
            void 0,
            (o.current.flags & 128) === 128
          );
        } catch {
        }
      if (m !== null) {
        o = V.T, b = mt.p, mt.p = 2, V.T = null;
        try {
          for (var x = n.onRecoverableError, R = 0; R < m.length; R++) {
            var U = m[R];
            x(U.value, {
              componentStack: U.stack
            });
          }
        } finally {
          V.T = o, mt.p = b;
        }
      }
      (ki & 3) !== 0 && Hm(), La(n), b = n.pendingLanes, (c & 4194090) !== 0 && (b & 42) !== 0 ? n === kg ? Gc++ : (Gc = 0, kg = n) : Gc = 0, wh(0);
    }
  }
  function Iv(n, o) {
    (n.pooledCacheLanes &= o) === 0 && (o = n.pooledCache, o != null && (n.pooledCache = null, Bl(o)));
  }
  function Hm(n) {
    return Wv(), Th(), Lm(), Zg();
  }
  function Zg() {
    if (Hi !== 5) return !1;
    var n = ts, o = Am;
    Am = 0;
    var c = Ga(ki), m = V.T, b = mt.p;
    try {
      mt.p = 32 > c ? 32 : c, V.T = null, c = Rm, Rm = null;
      var x = ts, R = ki;
      if (Hi = 0, Vc = ts = null, ki = 0, (Qe & 6) !== 0) throw Error(u(331));
      var U = Qe;
      if (Qe |= 4, Dg(x.current), Eg(
        x,
        x.current,
        R,
        c
      ), Qe = U, wh(0, !1), Zn && typeof Zn.onPostCommitFiberRoot == "function")
        try {
          Zn.onPostCommitFiberRoot(go, x);
        } catch {
        }
      return !0;
    } finally {
      mt.p = b, V.T = m, Iv(n, o);
    }
  }
  function Pg(n, o, c) {
    o = Pi(c, o), o = fg(n.stateNode, o, 2), n = ql(n, o, 2), n !== null && (se(n, 2), La(n));
  }
  function Ie(n, o, c) {
    if (n.tag === 3)
      Pg(n, n, c);
    else
      for (; o !== null; ) {
        if (o.tag === 3) {
          Pg(
            o,
            n,
            c
          );
          break;
        } else if (o.tag === 1) {
          var m = o.stateNode;
          if (typeof o.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (jr === null || !jr.has(m))) {
            n = Pi(c, n), c = hg(2), m = ql(o, c, 2), m !== null && (Ra(
              c,
              m,
              o,
              n
            ), se(m, 2), La(m));
            break;
          }
        }
        o = o.return;
      }
  }
  function km(n, o, c) {
    var m = n.pingCache;
    if (m === null) {
      m = n.pingCache = new Vv();
      var b = /* @__PURE__ */ new Set();
      m.set(o, b);
    } else
      b = m.get(o), b === void 0 && (b = /* @__PURE__ */ new Set(), m.set(o, b));
    b.has(c) || (Cg = !0, b.add(c), n = Vg.bind(null, n, o, c), o.then(n, n));
  }
  function Vg(n, o, c) {
    var m = n.pingCache;
    m !== null && m.delete(o), n.pingedLanes |= n.suspendedLanes & c, n.warmLanes &= ~c, sn === n && (He & c) === c && (Ln === 4 || Ln === 3 && (He & 62914560) === He && 300 > En() - Lg ? (Qe & 2) === 0 && es(n, 0) : Fl |= c, qc === He && (qc = 0)), La(n);
  }
  function Gg(n, o) {
    o === 0 && (o = kt()), n = Lo(n, o), n !== null && (se(n, o), La(n));
  }
  function U0(n) {
    var o = n.memoizedState, c = 0;
    o !== null && (c = o.retryLane), Gg(n, c);
  }
  function B0(n, o) {
    var c = 0;
    switch (n.tag) {
      case 13:
        var m = n.stateNode, b = n.memoizedState;
        b !== null && (c = b.retryLane);
        break;
      case 19:
        m = n.stateNode;
        break;
      case 22:
        m = n.stateNode._retryCache;
        break;
      default:
        throw Error(u(314));
    }
    m !== null && m.delete(o), Gg(n, c);
  }
  function Y0(n, o) {
    return ma(n, o);
  }
  var Nm = null, Zr = null, xh = !1, Kc = !1, Um = !1, Pr = 0;
  function La(n) {
    n !== Zr && n.next === null && (Zr === null ? Nm = Zr = n : Zr = Zr.next = n), Kc = !0, xh || (xh = !0, Fv());
  }
  function wh(n, o) {
    if (!Um && Kc) {
      Um = !0;
      do
        for (var c = !1, m = Nm; m !== null; ) {
          if (n !== 0) {
            var b = m.pendingLanes;
            if (b === 0) var x = 0;
            else {
              var R = m.suspendedLanes, U = m.pingedLanes;
              x = (1 << 31 - $n(42 | n) + 1) - 1, x &= b & ~(R & ~U), x = x & 201326741 ? x & 201326741 | 1 : x ? x | 2 : 0;
            }
            x !== 0 && (c = !0, Eh(m, x));
          } else
            x = He, x = Va(
              m,
              m === sn ? x : 0,
              m.cancelPendingCommit !== null || m.timeoutHandle !== -1
            ), (x & 3) === 0 || N(m, x) || (c = !0, Eh(m, x));
          m = m.next;
        }
      while (c);
      Um = !1;
    }
  }
  function $v() {
    Mh();
  }
  function Mh() {
    Kc = xh = !1;
    var n = 0;
    Pr !== 0 && ($s() && (n = Pr), Pr = 0);
    for (var o = En(), c = null, m = Nm; m !== null; ) {
      var b = m.next, x = Xg(m, o);
      x === 0 ? (m.next = null, c === null ? Nm = b : c.next = b, b === null && (Zr = c)) : (c = m, (n !== 0 || (x & 3) !== 0) && (Kc = !0)), m = b;
    }
    wh(n);
  }
  function Xg(n, o) {
    for (var c = n.suspendedLanes, m = n.pingedLanes, b = n.expirationTimes, x = n.pendingLanes & -62914561; 0 < x; ) {
      var R = 31 - $n(x), U = 1 << R, Z = b[R];
      Z === -1 ? ((U & c) === 0 || (U & m) !== 0) && (b[R] = J(U, o)) : Z <= o && (n.expiredLanes |= U), x &= ~U;
    }
    if (o = sn, c = He, c = Va(
      n,
      n === o ? c : 0,
      n.cancelPendingCommit !== null || n.timeoutHandle !== -1
    ), m = n.callbackNode, c === 0 || n === o && (Ke === 2 || Ke === 9) || n.cancelPendingCommit !== null)
      return m !== null && m !== null && ur(m), n.callbackNode = null, n.callbackPriority = 0;
    if ((c & 3) === 0 || N(n, c)) {
      if (o = c & -c, o === n.callbackPriority) return o;
      switch (m !== null && ur(m), Ga(c)) {
        case 2:
        case 8:
          c = pe;
          break;
        case 32:
          c = pa;
          break;
        case 268435456:
          c = po;
          break;
        default:
          c = pa;
      }
      return m = Jv.bind(null, n), c = ma(c, m), n.callbackPriority = o, n.callbackNode = c, o;
    }
    return m !== null && m !== null && ur(m), n.callbackPriority = 2, n.callbackNode = null, 2;
  }
  function Jv(n, o) {
    if (Hi !== 0 && Hi !== 5)
      return n.callbackNode = null, n.callbackPriority = 0, null;
    var c = n.callbackNode;
    if (Hm() && n.callbackNode !== c)
      return null;
    var m = He;
    return m = Va(
      n,
      n === sn ? m : 0,
      n.cancelPendingCommit !== null || n.timeoutHandle !== -1
    ), m === 0 ? null : (Xc(n, m, o), Xg(n, En()), n.callbackNode != null && n.callbackNode === c ? Jv.bind(null, n) : null);
  }
  function Eh(n, o) {
    if (Hm()) return null;
    Xc(n, o, !0);
  }
  function Fv() {
    P0(function() {
      (Qe & 6) !== 0 ? ma(
        dc,
        $v
      ) : Mh();
    });
  }
  function Gu() {
    return Pr === 0 && (Pr = At()), Pr;
  }
  function Bm(n) {
    return n == null || typeof n == "symbol" || typeof n == "boolean" ? null : typeof n == "function" ? n : Ts("" + n);
  }
  function Oh(n, o) {
    var c = o.ownerDocument.createElement("input");
    return c.name = o.name, c.value = o.value, n.id && c.setAttribute("form", n.id), o.parentNode.insertBefore(c, o), n = new FormData(n), c.parentNode.removeChild(c), n;
  }
  function t_(n, o, c, m, b) {
    if (o === "submit" && c && c.stateNode === b) {
      var x = Bm(
        (b[Ei] || null).action
      ), R = m.submitter;
      R && (o = (o = R[Ei] || null) ? Bm(o.formAction) : R.getAttribute("formAction"), o !== null && (x = o, R = null));
      var U = new _u(
        "action",
        "action",
        null,
        m,
        b
      );
      n.push({
        event: U,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (m.defaultPrevented) {
                if (Pr !== 0) {
                  var Z = R ? Oh(b, R) : new FormData(b);
                  lm(
                    c,
                    {
                      pending: !0,
                      data: Z,
                      method: b.method,
                      action: x
                    },
                    null,
                    Z
                  );
                }
              } else
                typeof x == "function" && (U.preventDefault(), Z = R ? Oh(b, R) : new FormData(b), lm(
                  c,
                  {
                    pending: !0,
                    data: Z,
                    method: b.method,
                    action: x
                  },
                  x,
                  Z
                ));
            },
            currentTarget: b
          }
        ]
      });
    }
  }
  for (var Hn = 0; Hn < Co.length; Hn++) {
    var Dh = Co[Hn], j0 = Dh.toLowerCase(), Me = Dh[0].toUpperCase() + Dh.slice(1);
    xa(
      j0,
      "on" + Me
    );
  }
  xa(Rd, "onAnimationEnd"), xa(Ta, "onAnimationIteration"), xa(Tu, "onAnimationStart"), xa("dblclick", "onDoubleClick"), xa("focusin", "onFocus"), xa("focusout", "onBlur"), xa(qf, "onTransitionRun"), xa(Ns, "onTransitionStart"), xa(Cd, "onTransitionCancel"), xa(wc, "onTransitionEnd"), Wo("onMouseEnter", ["mouseout", "mouseover"]), Wo("onMouseLeave", ["mouseout", "mouseover"]), Wo("onPointerEnter", ["pointerout", "pointerover"]), Wo("onPointerLeave", ["pointerout", "pointerover"]), Sl(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Sl(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Sl("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Sl(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Sl(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Sl(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Ah = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), Vr = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ah)
  );
  function Xu(n, o) {
    o = (o & 4) !== 0;
    for (var c = 0; c < n.length; c++) {
      var m = n[c], b = m.event;
      m = m.listeners;
      t: {
        var x = void 0;
        if (o)
          for (var R = m.length - 1; 0 <= R; R--) {
            var U = m[R], Z = U.instance, it = U.currentTarget;
            if (U = U.listener, Z !== x && b.isPropagationStopped())
              break t;
            x = U, b.currentTarget = it;
            try {
              x(b);
            } catch (vt) {
              hh(vt);
            }
            b.currentTarget = null, x = Z;
          }
        else
          for (R = 0; R < m.length; R++) {
            if (U = m[R], Z = U.instance, it = U.currentTarget, U = U.listener, Z !== x && b.isPropagationStopped())
              break t;
            x = U, b.currentTarget = it;
            try {
              x(b);
            } catch (vt) {
              hh(vt);
            }
            b.currentTarget = null, x = Z;
          }
      }
    }
  }
  function _e(n, o) {
    var c = o[ea];
    c === void 0 && (c = o[ea] = /* @__PURE__ */ new Set());
    var m = n + "__bubble";
    c.has(m) || (Ym(o, n, 2, !1), c.add(m));
  }
  function Wc(n, o, c) {
    var m = 0;
    o && (m |= 4), Ym(
      c,
      n,
      m,
      o
    );
  }
  var Ic = "_reactListening" + Math.random().toString(36).slice(2);
  function Qg(n) {
    if (!n[Ic]) {
      n[Ic] = !0, pu.forEach(function(c) {
        c !== "selectionchange" && (Vr.has(c) || Wc(c, !1, n), Wc(c, !0, n));
      });
      var o = n.nodeType === 9 ? n : n.ownerDocument;
      o === null || o[Ic] || (o[Ic] = !0, Wc("selectionchange", !1, o));
    }
  }
  function Ym(n, o, c, m) {
    switch (ry(o)) {
      case 2:
        var b = u_;
        break;
      case 8:
        b = c_;
        break;
      default:
        b = ly;
    }
    c = b.bind(
      null,
      o,
      c,
      n
    ), b = void 0, !vr || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (b = !0), m ? b !== void 0 ? n.addEventListener(o, c, {
      capture: !0,
      passive: b
    }) : n.addEventListener(o, c, !0) : b !== void 0 ? n.addEventListener(o, c, {
      passive: b
    }) : n.addEventListener(o, c, !1);
  }
  function qo(n, o, c, m, b) {
    var x = m;
    if ((o & 1) === 0 && (o & 2) === 0 && m !== null)
      t: for (; ; ) {
        if (m === null) return;
        var R = m.tag;
        if (R === 3 || R === 4) {
          var U = m.stateNode.containerInfo;
          if (U === b) break;
          if (R === 4)
            for (R = m.return; R !== null; ) {
              var Z = R.tag;
              if ((Z === 3 || Z === 4) && R.stateNode.containerInfo === b)
                return;
              R = R.return;
            }
          for (; U !== null; ) {
            if (R = Un(U), R === null) return;
            if (Z = R.tag, Z === 5 || Z === 6 || Z === 26 || Z === 27) {
              m = x = R;
              continue t;
            }
            U = U.parentNode;
          }
        }
        m = m.return;
      }
    Ai(function() {
      var it = x, vt = xs(c), St = [];
      t: {
        var ot = Zf.get(n);
        if (ot !== void 0) {
          var st = _u, te = n;
          switch (n) {
            case "keypress":
              if (Ue(c) === 0) break t;
            case "keydown":
            case "keyup":
              st = Wa;
              break;
            case "focusin":
              te = "focus", st = Hf;
              break;
            case "focusout":
              te = "blur", st = Hf;
              break;
            case "beforeblur":
            case "afterblur":
              st = Hf;
              break;
            case "click":
              if (c.button === 2) break t;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              st = Os;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              st = wd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              st = Uf;
              break;
            case Rd:
            case Ta:
            case Tu:
              st = Up;
              break;
            case wc:
              st = Dd;
              break;
            case "scroll":
            case "scrollend":
              st = xd;
              break;
            case "wheel":
              st = Ol;
              break;
            case "copy":
            case "cut":
            case "paste":
              st = Ds;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              st = _r;
              break;
            case "toggle":
            case "beforetoggle":
              st = Dl;
          }
          var ee = (o & 4) !== 0, Ze = !ee && (n === "scroll" || n === "scrollend"), tt = ee ? ot !== null ? ot + "Capture" : null : ot;
          ee = [];
          for (var W = it, et; W !== null; ) {
            var _t = W;
            if (et = _t.stateNode, _t = _t.tag, _t !== 5 && _t !== 26 && _t !== 27 || et === null || tt === null || (_t = Ye(W, tt), _t != null && ee.push(
              Ws(W, _t, et)
            )), Ze) break;
            W = W.return;
          }
          0 < ee.length && (ot = new st(
            ot,
            te,
            null,
            c,
            vt
          ), St.push({ event: ot, listeners: ee }));
        }
      }
      if ((o & 7) === 0) {
        t: {
          if (ot = n === "mouseover" || n === "pointerover", st = n === "mouseout" || n === "pointerout", ot && c !== tl && (te = c.relatedTarget || c.fromElement) && (Un(te) || te[dr]))
            break t;
          if ((st || ot) && (ot = vt.window === vt ? vt : (ot = vt.ownerDocument) ? ot.defaultView || ot.parentWindow : window, st ? (te = c.relatedTarget || c.toElement, st = it, te = te ? Un(te) : null, te !== null && (Ze = g(te), ee = te.tag, te !== Ze || ee !== 5 && ee !== 27 && ee !== 6) && (te = null)) : (st = null, te = it), st !== te)) {
            if (ee = Os, _t = "onMouseLeave", tt = "onMouseEnter", W = "mouse", (n === "pointerout" || n === "pointerover") && (ee = _r, _t = "onPointerLeave", tt = "onPointerEnter", W = "pointer"), Ze = st == null ? ot : yo(st), et = te == null ? ot : yo(te), ot = new ee(
              _t,
              W + "leave",
              st,
              c,
              vt
            ), ot.target = Ze, ot.relatedTarget = et, _t = null, Un(vt) === it && (ee = new ee(
              tt,
              W + "enter",
              te,
              c,
              vt
            ), ee.target = et, ee.relatedTarget = Ze, _t = ee), Ze = _t, st && te)
              e: {
                for (ee = st, tt = te, W = 0, et = ee; et; et = Gr(et))
                  W++;
                for (et = 0, _t = tt; _t; _t = Gr(_t))
                  et++;
                for (; 0 < W - et; )
                  ee = Gr(ee), W--;
                for (; 0 < et - W; )
                  tt = Gr(tt), et--;
                for (; W--; ) {
                  if (ee === tt || tt !== null && ee === tt.alternate)
                    break e;
                  ee = Gr(ee), tt = Gr(tt);
                }
                ee = null;
              }
            else ee = null;
            st !== null && Rh(
              St,
              ot,
              st,
              ee,
              !1
            ), te !== null && Ze !== null && Rh(
              St,
              Ze,
              te,
              ee,
              !0
            );
          }
        }
        t: {
          if (ot = it ? yo(it) : window, st = ot.nodeName && ot.nodeName.toLowerCase(), st === "select" || st === "input" && ot.type === "file")
            var Vt = Cs;
          else if (al(ot))
            if (Tc)
              Vt = jf;
            else {
              Vt = zl;
              var De = Tr;
            }
          else
            st = ot.nodeName, !st || st.toLowerCase() !== "input" || ot.type !== "checkbox" && ot.type !== "radio" ? it && Fo(it.elementType) && (Vt = Cs) : Vt = Fn;
          if (Vt && (Vt = Vt(n, it))) {
            Sc(
              St,
              Vt,
              c,
              vt
            );
            break t;
          }
          De && De(n, ot, it), n === "focusout" && it && ot.type === "number" && it.memoizedProps.value != null && wl(ot, "number", ot.value);
        }
        switch (De = it ? yo(it) : window, n) {
          case "focusin":
            (al(De) || De.contentEditable === "true") && (Ri = De, Zi = it, Ro = null);
            break;
          case "focusout":
            Ro = Zi = Ri = null;
            break;
          case "mousedown":
            Hl = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Hl = !1, xc(St, c, vt);
            break;
          case "selectionchange":
            if (Ao) break;
          case "keydown":
          case "keyup":
            xc(St, c, vt);
        }
        var $t;
        if (il)
          t: {
            switch (n) {
              case "compositionstart":
                var ae = "onCompositionStart";
                break t;
              case "compositionend":
                ae = "onCompositionEnd";
                break t;
              case "compositionupdate":
                ae = "onCompositionUpdate";
                break t;
            }
            ae = void 0;
          }
        else
          Rl ? As(n, c) && (ae = "onCompositionEnd") : n === "keydown" && c.keyCode === 229 && (ae = "onCompositionStart");
        ae && (Ia && c.locale !== "ko" && (Rl || ae !== "onCompositionStart" ? ae === "onCompositionEnd" && Rl && ($t = Ms()) : (Ka = vt, va = "value" in Ka ? Ka.value : Ka.textContent, Rl = !0)), De = $c(it, ae), 0 < De.length && (ae = new _a(
          ae,
          n,
          null,
          c,
          vt
        ), St.push({ event: ae, listeners: De }), $t ? ae.data = $t : ($t = Al(c), $t !== null && (ae.data = $t)))), ($t = _c ? bc(n, c) : Rs(n, c)) && (ae = $c(it, "onBeforeInput"), 0 < ae.length && (De = new _a(
          "onBeforeInput",
          "beforeinput",
          null,
          c,
          vt
        ), St.push({
          event: De,
          listeners: ae
        }), De.data = $t)), t_(
          St,
          n,
          it,
          c,
          vt
        );
      }
      Xu(St, o);
    });
  }
  function Ws(n, o, c) {
    return {
      instance: n,
      listener: o,
      currentTarget: c
    };
  }
  function $c(n, o) {
    for (var c = o + "Capture", m = []; n !== null; ) {
      var b = n, x = b.stateNode;
      if (b = b.tag, b !== 5 && b !== 26 && b !== 27 || x === null || (b = Ye(n, c), b != null && m.unshift(
        Ws(n, b, x)
      ), b = Ye(n, o), b != null && m.push(
        Ws(n, b, x)
      )), n.tag === 3) return m;
      n = n.return;
    }
    return [];
  }
  function Gr(n) {
    if (n === null) return null;
    do
      n = n.return;
    while (n && n.tag !== 5 && n.tag !== 27);
    return n || null;
  }
  function Rh(n, o, c, m, b) {
    for (var x = o._reactName, R = []; c !== null && c !== m; ) {
      var U = c, Z = U.alternate, it = U.stateNode;
      if (U = U.tag, Z !== null && Z === m) break;
      U !== 5 && U !== 26 && U !== 27 || it === null || (Z = it, b ? (it = Ye(c, x), it != null && R.unshift(
        Ws(c, it, Z)
      )) : b || (it = Ye(c, x), it != null && R.push(
        Ws(c, it, Z)
      ))), c = c.return;
    }
    R.length !== 0 && n.push({ event: o, listeners: R });
  }
  var so = /\r\n?/g, Kg = /\u0000|\uFFFD/g;
  function e_(n) {
    return (typeof n == "string" ? n : "" + n).replace(so, `
`).replace(Kg, "");
  }
  function Wg(n, o) {
    return o = e_(o), e_(n) === o;
  }
  function jm() {
  }
  function de(n, o, c, m, b, x) {
    switch (c) {
      case "children":
        typeof m == "string" ? o === "body" || o === "textarea" && m === "" || To(n, m) : (typeof m == "number" || typeof m == "bigint") && o !== "body" && To(n, "" + m);
        break;
      case "className":
        gu(n, "class", m);
        break;
      case "tabIndex":
        gu(n, "tabindex", m);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        gu(n, c, m);
        break;
      case "style":
        Jo(n, m, x);
        break;
      case "data":
        if (o !== "object") {
          gu(n, "data", m);
          break;
        }
      case "src":
      case "href":
        if (m === "" && (o !== "a" || c !== "href")) {
          n.removeAttribute(c);
          break;
        }
        if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") {
          n.removeAttribute(c);
          break;
        }
        m = Ts("" + m), n.setAttribute(c, m);
        break;
      case "action":
      case "formAction":
        if (typeof m == "function") {
          n.setAttribute(
            c,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof x == "function" && (c === "formAction" ? (o !== "input" && de(n, o, "name", b.name, b, null), de(
            n,
            o,
            "formEncType",
            b.formEncType,
            b,
            null
          ), de(
            n,
            o,
            "formMethod",
            b.formMethod,
            b,
            null
          ), de(
            n,
            o,
            "formTarget",
            b.formTarget,
            b,
            null
          )) : (de(n, o, "encType", b.encType, b, null), de(n, o, "method", b.method, b, null), de(n, o, "target", b.target, b, null)));
        if (m == null || typeof m == "symbol" || typeof m == "boolean") {
          n.removeAttribute(c);
          break;
        }
        m = Ts("" + m), n.setAttribute(c, m);
        break;
      case "onClick":
        m != null && (n.onclick = jm);
        break;
      case "onScroll":
        m != null && _e("scroll", n);
        break;
      case "onScrollEnd":
        m != null && _e("scrollend", n);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(u(61));
          if (c = m.__html, c != null) {
            if (b.children != null) throw Error(u(60));
            n.innerHTML = c;
          }
        }
        break;
      case "multiple":
        n.multiple = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "muted":
        n.muted = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") {
          n.removeAttribute("xlink:href");
          break;
        }
        c = Ts("" + m), n.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          c
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        m != null && typeof m != "function" && typeof m != "symbol" ? n.setAttribute(c, "" + m) : n.removeAttribute(c);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        m && typeof m != "function" && typeof m != "symbol" ? n.setAttribute(c, "") : n.removeAttribute(c);
        break;
      case "capture":
      case "download":
        m === !0 ? n.setAttribute(c, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? n.setAttribute(c, m) : n.removeAttribute(c);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? n.setAttribute(c, m) : n.removeAttribute(c);
        break;
      case "rowSpan":
      case "start":
        m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? n.removeAttribute(c) : n.setAttribute(c, m);
        break;
      case "popover":
        _e("beforetoggle", n), _e("toggle", n), Io(n, "popover", m);
        break;
      case "xlinkActuate":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          m
        );
        break;
      case "xlinkArcrole":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          m
        );
        break;
      case "xlinkRole":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          m
        );
        break;
      case "xlinkShow":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          m
        );
        break;
      case "xlinkTitle":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          m
        );
        break;
      case "xlinkType":
        _o(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          m
        );
        break;
      case "xmlBase":
        _o(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          m
        );
        break;
      case "xmlLang":
        _o(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          m
        );
        break;
      case "xmlSpace":
        _o(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          m
        );
        break;
      case "is":
        Io(n, "is", m);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = Cf.get(c) || c, Io(n, c, m));
    }
  }
  function ft(n, o, c, m, b, x) {
    switch (c) {
      case "style":
        Jo(n, m, x);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(u(61));
          if (c = m.__html, c != null) {
            if (b.children != null) throw Error(u(60));
            n.innerHTML = c;
          }
        }
        break;
      case "children":
        typeof m == "string" ? To(n, m) : (typeof m == "number" || typeof m == "bigint") && To(n, "" + m);
        break;
      case "onScroll":
        m != null && _e("scroll", n);
        break;
      case "onScrollEnd":
        m != null && _e("scrollend", n);
        break;
      case "onClick":
        m != null && (n.onclick = jm);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!na.hasOwnProperty(c))
          t: {
            if (c[0] === "o" && c[1] === "n" && (b = c.endsWith("Capture"), o = c.slice(2, b ? c.length - 7 : void 0), x = n[Ei] || null, x = x != null ? x[c] : null, typeof x == "function" && n.removeEventListener(o, x, b), typeof m == "function")) {
              typeof x != "function" && x !== null && (c in n ? n[c] = null : n.hasAttribute(c) && n.removeAttribute(c)), n.addEventListener(o, m, b);
              break t;
            }
            c in n ? n[c] = m : m === !0 ? n.setAttribute(c, "") : Io(n, c, m);
          }
    }
  }
  function re(n, o, c) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        _e("error", n), _e("load", n);
        var m = !1, b = !1, x;
        for (x in c)
          if (c.hasOwnProperty(x)) {
            var R = c[x];
            if (R != null)
              switch (x) {
                case "src":
                  m = !0;
                  break;
                case "srcSet":
                  b = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(u(137, o));
                default:
                  de(n, o, x, R, c, null);
              }
          }
        b && de(n, o, "srcSet", c.srcSet, c, null), m && de(n, o, "src", c.src, c, null);
        return;
      case "input":
        _e("invalid", n);
        var U = x = R = b = null, Z = null, it = null;
        for (m in c)
          if (c.hasOwnProperty(m)) {
            var vt = c[m];
            if (vt != null)
              switch (m) {
                case "name":
                  b = vt;
                  break;
                case "type":
                  R = vt;
                  break;
                case "checked":
                  Z = vt;
                  break;
                case "defaultChecked":
                  it = vt;
                  break;
                case "value":
                  x = vt;
                  break;
                case "defaultValue":
                  U = vt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (vt != null)
                    throw Error(u(137, o));
                  break;
                default:
                  de(n, o, m, vt, c, null);
              }
          }
        gc(
          n,
          x,
          U,
          Z,
          it,
          R,
          b,
          !1
        ), So(n);
        return;
      case "select":
        _e("invalid", n), m = R = x = null;
        for (b in c)
          if (c.hasOwnProperty(b) && (U = c[b], U != null))
            switch (b) {
              case "value":
                x = U;
                break;
              case "defaultValue":
                R = U;
                break;
              case "multiple":
                m = U;
              default:
                de(n, o, b, U, c, null);
            }
        o = x, c = R, n.multiple = !!m, o != null ? ia(n, !!m, o, !1) : c != null && ia(n, !!m, c, !0);
        return;
      case "textarea":
        _e("invalid", n), x = b = m = null;
        for (R in c)
          if (c.hasOwnProperty(R) && (U = c[R], U != null))
            switch (R) {
              case "value":
                m = U;
                break;
              case "defaultValue":
                b = U;
                break;
              case "children":
                x = U;
                break;
              case "dangerouslySetInnerHTML":
                if (U != null) throw Error(u(91));
                break;
              default:
                de(n, o, R, U, c, null);
            }
        $o(n, m, b, x), So(n);
        return;
      case "option":
        for (Z in c)
          if (c.hasOwnProperty(Z) && (m = c[Z], m != null))
            switch (Z) {
              case "selected":
                n.selected = m && typeof m != "function" && typeof m != "symbol";
                break;
              default:
                de(n, o, Z, m, c, null);
            }
        return;
      case "dialog":
        _e("beforetoggle", n), _e("toggle", n), _e("cancel", n), _e("close", n);
        break;
      case "iframe":
      case "object":
        _e("load", n);
        break;
      case "video":
      case "audio":
        for (m = 0; m < Ah.length; m++)
          _e(Ah[m], n);
        break;
      case "image":
        _e("error", n), _e("load", n);
        break;
      case "details":
        _e("toggle", n);
        break;
      case "embed":
      case "source":
      case "link":
        _e("error", n), _e("load", n);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (it in c)
          if (c.hasOwnProperty(it) && (m = c[it], m != null))
            switch (it) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(u(137, o));
              default:
                de(n, o, it, m, c, null);
            }
        return;
      default:
        if (Fo(o)) {
          for (vt in c)
            c.hasOwnProperty(vt) && (m = c[vt], m !== void 0 && ft(
              n,
              o,
              vt,
              m,
              c,
              void 0
            ));
          return;
        }
    }
    for (U in c)
      c.hasOwnProperty(U) && (m = c[U], m != null && de(n, o, U, m, c, null));
  }
  function q0(n, o, c, m) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var b = null, x = null, R = null, U = null, Z = null, it = null, vt = null;
        for (st in c) {
          var St = c[st];
          if (c.hasOwnProperty(st) && St != null)
            switch (st) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                Z = St;
              default:
                m.hasOwnProperty(st) || de(n, o, st, null, m, St);
            }
        }
        for (var ot in m) {
          var st = m[ot];
          if (St = c[ot], m.hasOwnProperty(ot) && (st != null || St != null))
            switch (ot) {
              case "type":
                x = st;
                break;
              case "name":
                b = st;
                break;
              case "checked":
                it = st;
                break;
              case "defaultChecked":
                vt = st;
                break;
              case "value":
                R = st;
                break;
              case "defaultValue":
                U = st;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (st != null)
                  throw Error(u(137, o));
                break;
              default:
                st !== St && de(
                  n,
                  o,
                  ot,
                  st,
                  m,
                  St
                );
            }
        }
        Di(
          n,
          R,
          U,
          Z,
          it,
          vt,
          x,
          b
        );
        return;
      case "select":
        st = R = U = ot = null;
        for (x in c)
          if (Z = c[x], c.hasOwnProperty(x) && Z != null)
            switch (x) {
              case "value":
                break;
              case "multiple":
                st = Z;
              default:
                m.hasOwnProperty(x) || de(
                  n,
                  o,
                  x,
                  null,
                  m,
                  Z
                );
            }
        for (b in m)
          if (x = m[b], Z = c[b], m.hasOwnProperty(b) && (x != null || Z != null))
            switch (b) {
              case "value":
                ot = x;
                break;
              case "defaultValue":
                U = x;
                break;
              case "multiple":
                R = x;
              default:
                x !== Z && de(
                  n,
                  o,
                  b,
                  x,
                  m,
                  Z
                );
            }
        o = U, c = R, m = st, ot != null ? ia(n, !!c, ot, !1) : !!m != !!c && (o != null ? ia(n, !!c, o, !0) : ia(n, !!c, c ? [] : "", !1));
        return;
      case "textarea":
        st = ot = null;
        for (U in c)
          if (b = c[U], c.hasOwnProperty(U) && b != null && !m.hasOwnProperty(U))
            switch (U) {
              case "value":
                break;
              case "children":
                break;
              default:
                de(n, o, U, null, m, b);
            }
        for (R in m)
          if (b = m[R], x = c[R], m.hasOwnProperty(R) && (b != null || x != null))
            switch (R) {
              case "value":
                ot = b;
                break;
              case "defaultValue":
                st = b;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (b != null) throw Error(u(91));
                break;
              default:
                b !== x && de(n, o, R, b, m, x);
            }
        yn(n, ot, st);
        return;
      case "option":
        for (var te in c)
          if (ot = c[te], c.hasOwnProperty(te) && ot != null && !m.hasOwnProperty(te))
            switch (te) {
              case "selected":
                n.selected = !1;
                break;
              default:
                de(
                  n,
                  o,
                  te,
                  null,
                  m,
                  ot
                );
            }
        for (Z in m)
          if (ot = m[Z], st = c[Z], m.hasOwnProperty(Z) && ot !== st && (ot != null || st != null))
            switch (Z) {
              case "selected":
                n.selected = ot && typeof ot != "function" && typeof ot != "symbol";
                break;
              default:
                de(
                  n,
                  o,
                  Z,
                  ot,
                  m,
                  st
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var ee in c)
          ot = c[ee], c.hasOwnProperty(ee) && ot != null && !m.hasOwnProperty(ee) && de(n, o, ee, null, m, ot);
        for (it in m)
          if (ot = m[it], st = c[it], m.hasOwnProperty(it) && ot !== st && (ot != null || st != null))
            switch (it) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (ot != null)
                  throw Error(u(137, o));
                break;
              default:
                de(
                  n,
                  o,
                  it,
                  ot,
                  m,
                  st
                );
            }
        return;
      default:
        if (Fo(o)) {
          for (var Ze in c)
            ot = c[Ze], c.hasOwnProperty(Ze) && ot !== void 0 && !m.hasOwnProperty(Ze) && ft(
              n,
              o,
              Ze,
              void 0,
              m,
              ot
            );
          for (vt in m)
            ot = m[vt], st = c[vt], !m.hasOwnProperty(vt) || ot === st || ot === void 0 && st === void 0 || ft(
              n,
              o,
              vt,
              ot,
              m,
              st
            );
          return;
        }
    }
    for (var tt in c)
      ot = c[tt], c.hasOwnProperty(tt) && ot != null && !m.hasOwnProperty(tt) && de(n, o, tt, null, m, ot);
    for (St in m)
      ot = m[St], st = c[St], !m.hasOwnProperty(St) || ot === st || ot == null && st == null || de(n, o, St, ot, m, st);
  }
  var Ch = null, zh = null;
  function Zo(n) {
    return n.nodeType === 9 ? n : n.ownerDocument;
  }
  function Is(n) {
    switch (n) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function Jc(n, o) {
    if (n === 0)
      switch (o) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return n === 1 && o === "foreignObject" ? 0 : n;
  }
  function ns(n, o) {
    return n === "textarea" || n === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.children == "bigint" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
  }
  var Fc = null;
  function $s() {
    var n = window.event;
    return n && n.type === "popstate" ? n === Fc ? !1 : (Fc = n, !0) : (Fc = null, !1);
  }
  var qm = typeof setTimeout == "function" ? setTimeout : void 0, Z0 = typeof clearTimeout == "function" ? clearTimeout : void 0, n_ = typeof Promise == "function" ? Promise : void 0, P0 = typeof queueMicrotask == "function" ? queueMicrotask : typeof n_ < "u" ? function(n) {
    return n_.resolve(null).then(n).catch(is);
  } : qm;
  function is(n) {
    setTimeout(function() {
      throw n;
    });
  }
  function Xr(n) {
    return n === "head";
  }
  function Zm(n, o) {
    var c = o, m = 0, b = 0;
    do {
      var x = c.nextSibling;
      if (n.removeChild(c), x && x.nodeType === 8)
        if (c = x.data, c === "/$") {
          if (0 < m && 8 > m) {
            c = m;
            var R = n.ownerDocument;
            if (c & 1 && Ha(R.documentElement), c & 2 && Ha(R.body), c & 4)
              for (c = R.head, Ha(c), R = c.firstChild; R; ) {
                var U = R.nextSibling, Z = R.nodeName;
                R[Pt] || Z === "SCRIPT" || Z === "STYLE" || Z === "LINK" && R.rel.toLowerCase() === "stylesheet" || c.removeChild(R), R = U;
              }
          }
          if (b === 0) {
            n.removeChild(x), os(o);
            return;
          }
          b--;
        } else
          c === "$" || c === "$?" || c === "$!" ? b++ : m = c.charCodeAt(0) - 48;
      else m = 0;
      c = x;
    } while (c);
    os(o);
  }
  function Lh(n) {
    var o = n.firstChild;
    for (o && o.nodeType === 10 && (o = o.nextSibling); o; ) {
      var c = o;
      switch (o = o.nextSibling, c.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Lh(c), mr(c);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (c.rel.toLowerCase() === "stylesheet") continue;
      }
      n.removeChild(c);
    }
  }
  function tf(n, o, c, m) {
    for (; n.nodeType === 1; ) {
      var b = c;
      if (n.nodeName.toLowerCase() !== o.toLowerCase()) {
        if (!m && (n.nodeName !== "INPUT" || n.type !== "hidden"))
          break;
      } else if (m) {
        if (!n[Pt])
          switch (o) {
            case "meta":
              if (!n.hasAttribute("itemprop")) break;
              return n;
            case "link":
              if (x = n.getAttribute("rel"), x === "stylesheet" && n.hasAttribute("data-precedence"))
                break;
              if (x !== b.rel || n.getAttribute("href") !== (b.href == null || b.href === "" ? null : b.href) || n.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin) || n.getAttribute("title") !== (b.title == null ? null : b.title))
                break;
              return n;
            case "style":
              if (n.hasAttribute("data-precedence")) break;
              return n;
            case "script":
              if (x = n.getAttribute("src"), (x !== (b.src == null ? null : b.src) || n.getAttribute("type") !== (b.type == null ? null : b.type) || n.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin)) && x && n.hasAttribute("async") && !n.hasAttribute("itemprop"))
                break;
              return n;
            default:
              return n;
          }
      } else if (o === "input" && n.type === "hidden") {
        var x = b.name == null ? null : "" + b.name;
        if (b.type === "hidden" && n.getAttribute("name") === x)
          return n;
      } else return n;
      if (n = pl(n.nextSibling), n === null) break;
    }
    return null;
  }
  function V0(n, o, c) {
    if (o === "") return null;
    for (; n.nodeType !== 3; )
      if ((n.nodeType !== 1 || n.nodeName !== "INPUT" || n.type !== "hidden") && !c || (n = pl(n.nextSibling), n === null)) return null;
    return n;
  }
  function Hh(n) {
    return n.data === "$!" || n.data === "$?" && n.ownerDocument.readyState === "complete";
  }
  function G0(n, o) {
    var c = n.ownerDocument;
    if (n.data !== "$?" || c.readyState === "complete")
      o();
    else {
      var m = function() {
        o(), c.removeEventListener("DOMContentLoaded", m);
      };
      c.addEventListener("DOMContentLoaded", m), n._reactRetry = m;
    }
  }
  function pl(n) {
    for (; n != null; n = n.nextSibling) {
      var o = n.nodeType;
      if (o === 1 || o === 3) break;
      if (o === 8) {
        if (o = n.data, o === "$" || o === "$!" || o === "$?" || o === "F!" || o === "F")
          break;
        if (o === "/$") return null;
      }
    }
    return n;
  }
  var Qr = null;
  function Ni(n) {
    n = n.previousSibling;
    for (var o = 0; n; ) {
      if (n.nodeType === 8) {
        var c = n.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (o === 0) return n;
          o--;
        } else c === "/$" && o++;
      }
      n = n.previousSibling;
    }
    return null;
  }
  function jt(n, o, c) {
    switch (o = Zo(c), n) {
      case "html":
        if (n = o.documentElement, !n) throw Error(u(452));
        return n;
      case "head":
        if (n = o.head, !n) throw Error(u(453));
        return n;
      case "body":
        if (n = o.body, !n) throw Error(u(454));
        return n;
      default:
        throw Error(u(451));
    }
  }
  function Ha(n) {
    for (var o = n.attributes; o.length; )
      n.removeAttributeNode(o[0]);
    mr(n);
  }
  var kn = /* @__PURE__ */ new Map(), Wi = /* @__PURE__ */ new Set();
  function Pm(n) {
    return typeof n.getRootNode == "function" ? n.getRootNode() : n.nodeType === 9 ? n : n.ownerDocument;
  }
  var Js = mt.d;
  mt.d = {
    f: Vm,
    r: Gm,
    D: Fs,
    C: Xm,
    L: Kr,
    m: Ii,
    X: Wr,
    S: ka,
    M: Ig
  };
  function Vm() {
    var n = Js.f(), o = Zu();
    return n || o;
  }
  function Gm(n) {
    var o = bl(n);
    o !== null && o.tag === 5 && o.type === "form" ? zc(o) : Js.r(n);
  }
  var Ui = typeof document > "u" ? null : document;
  function gl(n, o, c) {
    var m = Ui;
    if (m && typeof o == "string" && o) {
      var b = Oi(o);
      b = 'link[rel="' + n + '"][href="' + b + '"]', typeof c == "string" && (b += '[crossorigin="' + c + '"]'), Wi.has(b) || (Wi.add(b), n = { rel: n, crossOrigin: c, href: o }, m.querySelector(b) === null && (o = m.createElement("link"), re(o, "link", n), Bn(o), m.head.appendChild(o)));
    }
  }
  function Fs(n) {
    Js.D(n), gl("dns-prefetch", n, null);
  }
  function Xm(n, o) {
    Js.C(n, o), gl("preconnect", n, o);
  }
  function Kr(n, o, c) {
    Js.L(n, o, c);
    var m = Ui;
    if (m && n && o) {
      var b = 'link[rel="preload"][as="' + Oi(o) + '"]';
      o === "image" && c && c.imageSrcSet ? (b += '[imagesrcset="' + Oi(
        c.imageSrcSet
      ) + '"]', typeof c.imageSizes == "string" && (b += '[imagesizes="' + Oi(
        c.imageSizes
      ) + '"]')) : b += '[href="' + Oi(n) + '"]';
      var x = b;
      switch (o) {
        case "style":
          x = ef(n);
          break;
        case "script":
          x = Po(n);
      }
      kn.has(x) || (n = D(
        {
          rel: "preload",
          href: o === "image" && c && c.imageSrcSet ? void 0 : n,
          as: o
        },
        c
      ), kn.set(x, n), m.querySelector(b) !== null || o === "style" && m.querySelector(nf(x)) || o === "script" && m.querySelector(Qu(x)) || (o = m.createElement("link"), re(o, "link", n), Bn(o), m.head.appendChild(o)));
    }
  }
  function Ii(n, o) {
    Js.m(n, o);
    var c = Ui;
    if (c && n) {
      var m = o && typeof o.as == "string" ? o.as : "script", b = 'link[rel="modulepreload"][as="' + Oi(m) + '"][href="' + Oi(n) + '"]', x = b;
      switch (m) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          x = Po(n);
      }
      if (!kn.has(x) && (n = D({ rel: "modulepreload", href: n }, o), kn.set(x, n), c.querySelector(b) === null)) {
        switch (m) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (c.querySelector(Qu(x)))
              return;
        }
        m = c.createElement("link"), re(m, "link", n), Bn(m), c.head.appendChild(m);
      }
    }
  }
  function ka(n, o, c) {
    Js.S(n, o, c);
    var m = Ui;
    if (m && n) {
      var b = vo(m).hoistableStyles, x = ef(n);
      o = o || "default";
      var R = b.get(x);
      if (!R) {
        var U = { loading: 0, preload: null };
        if (R = m.querySelector(
          nf(x)
        ))
          U.loading = 5;
        else {
          n = D(
            { rel: "stylesheet", href: n, "data-precedence": o },
            c
          ), (c = kn.get(x)) && Km(n, c);
          var Z = R = m.createElement("link");
          Bn(Z), re(Z, "link", n), Z._p = new Promise(function(it, vt) {
            Z.onload = it, Z.onerror = vt;
          }), Z.addEventListener("load", function() {
            U.loading |= 1;
          }), Z.addEventListener("error", function() {
            U.loading |= 2;
          }), U.loading |= 4, Qm(R, o, m);
        }
        R = {
          type: "stylesheet",
          instance: R,
          count: 1,
          state: U
        }, b.set(x, R);
      }
    }
  }
  function Wr(n, o) {
    Js.X(n, o);
    var c = Ui;
    if (c && n) {
      var m = vo(c).hoistableScripts, b = Po(n), x = m.get(b);
      x || (x = c.querySelector(Qu(b)), x || (n = D({ src: n, async: !0 }, o), (o = kn.get(b)) && Wm(n, o), x = c.createElement("script"), Bn(x), re(x, "link", n), c.head.appendChild(x)), x = {
        type: "script",
        instance: x,
        count: 1,
        state: null
      }, m.set(b, x));
    }
  }
  function Ig(n, o) {
    Js.M(n, o);
    var c = Ui;
    if (c && n) {
      var m = vo(c).hoistableScripts, b = Po(n), x = m.get(b);
      x || (x = c.querySelector(Qu(b)), x || (n = D({ src: n, async: !0, type: "module" }, o), (o = kn.get(b)) && Wm(n, o), x = c.createElement("script"), Bn(x), re(x, "link", n), c.head.appendChild(x)), x = {
        type: "script",
        instance: x,
        count: 1,
        state: null
      }, m.set(b, x));
    }
  }
  function i_(n, o, c, m) {
    var b = (b = Tt.current) ? Pm(b) : null;
    if (!b) throw Error(u(446));
    switch (n) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof c.precedence == "string" && typeof c.href == "string" ? (o = ef(c.href), c = vo(
          b
        ).hoistableStyles, m = c.get(o), m || (m = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, c.set(o, m)), m) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
          n = ef(c.href);
          var x = vo(
            b
          ).hoistableStyles, R = x.get(n);
          if (R || (b = b.ownerDocument || b, R = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, x.set(n, R), (x = b.querySelector(
            nf(n)
          )) && !x._p && (R.instance = x, R.state.loading = 5), kn.has(n) || (c = {
            rel: "preload",
            as: "style",
            href: c.href,
            crossOrigin: c.crossOrigin,
            integrity: c.integrity,
            media: c.media,
            hrefLang: c.hrefLang,
            referrerPolicy: c.referrerPolicy
          }, kn.set(n, c), x || a_(
            b,
            n,
            c,
            R.state
          ))), o && m === null)
            throw Error(u(528, ""));
          return R;
        }
        if (o && m !== null)
          throw Error(u(529, ""));
        return null;
      case "script":
        return o = c.async, c = c.src, typeof c == "string" && o && typeof o != "function" && typeof o != "symbol" ? (o = Po(c), c = vo(
          b
        ).hoistableScripts, m = c.get(o), m || (m = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, c.set(o, m)), m) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(u(444, n));
    }
  }
  function ef(n) {
    return 'href="' + Oi(n) + '"';
  }
  function nf(n) {
    return 'link[rel="stylesheet"][' + n + "]";
  }
  function af(n) {
    return D({}, n, {
      "data-precedence": n.precedence,
      precedence: null
    });
  }
  function a_(n, o, c, m) {
    n.querySelector('link[rel="preload"][as="style"][' + o + "]") ? m.loading = 1 : (o = n.createElement("link"), m.preload = o, o.addEventListener("load", function() {
      return m.loading |= 1;
    }), o.addEventListener("error", function() {
      return m.loading |= 2;
    }), re(o, "link", c), Bn(o), n.head.appendChild(o));
  }
  function Po(n) {
    return '[src="' + Oi(n) + '"]';
  }
  function Qu(n) {
    return "script[async]" + n;
  }
  function o_(n, o, c) {
    if (o.count++, o.instance === null)
      switch (o.type) {
        case "style":
          var m = n.querySelector(
            'style[data-href~="' + Oi(c.href) + '"]'
          );
          if (m)
            return o.instance = m, Bn(m), m;
          var b = D({}, c, {
            "data-href": c.href,
            "data-precedence": c.precedence,
            href: null,
            precedence: null
          });
          return m = (n.ownerDocument || n).createElement(
            "style"
          ), Bn(m), re(m, "style", b), Qm(m, c.precedence, n), o.instance = m;
        case "stylesheet":
          b = ef(c.href);
          var x = n.querySelector(
            nf(b)
          );
          if (x)
            return o.state.loading |= 4, o.instance = x, Bn(x), x;
          m = af(c), (b = kn.get(b)) && Km(m, b), x = (n.ownerDocument || n).createElement("link"), Bn(x);
          var R = x;
          return R._p = new Promise(function(U, Z) {
            R.onload = U, R.onerror = Z;
          }), re(x, "link", m), o.state.loading |= 4, Qm(x, c.precedence, n), o.instance = x;
        case "script":
          return x = Po(c.src), (b = n.querySelector(
            Qu(x)
          )) ? (o.instance = b, Bn(b), b) : (m = c, (b = kn.get(x)) && (m = D({}, c), Wm(m, b)), n = n.ownerDocument || n, b = n.createElement("script"), Bn(b), re(b, "link", m), n.head.appendChild(b), o.instance = b);
        case "void":
          return null;
        default:
          throw Error(u(443, o.type));
      }
    else
      o.type === "stylesheet" && (o.state.loading & 4) === 0 && (m = o.instance, o.state.loading |= 4, Qm(m, c.precedence, n));
    return o.instance;
  }
  function Qm(n, o, c) {
    for (var m = c.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), b = m.length ? m[m.length - 1] : null, x = b, R = 0; R < m.length; R++) {
      var U = m[R];
      if (U.dataset.precedence === o) x = U;
      else if (x !== b) break;
    }
    x ? x.parentNode.insertBefore(n, x.nextSibling) : (o = c.nodeType === 9 ? c.head : c, o.insertBefore(n, o.firstChild));
  }
  function Km(n, o) {
    n.crossOrigin == null && (n.crossOrigin = o.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = o.referrerPolicy), n.title == null && (n.title = o.title);
  }
  function Wm(n, o) {
    n.crossOrigin == null && (n.crossOrigin = o.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = o.referrerPolicy), n.integrity == null && (n.integrity = o.integrity);
  }
  var Ir = null;
  function $g(n, o, c) {
    if (Ir === null) {
      var m = /* @__PURE__ */ new Map(), b = Ir = /* @__PURE__ */ new Map();
      b.set(c, m);
    } else
      b = Ir, m = b.get(c), m || (m = /* @__PURE__ */ new Map(), b.set(c, m));
    if (m.has(n)) return m;
    for (m.set(n, null), c = c.getElementsByTagName(n), b = 0; b < c.length; b++) {
      var x = c[b];
      if (!(x[Pt] || x[Vn] || n === "link" && x.getAttribute("rel") === "stylesheet") && x.namespaceURI !== "http://www.w3.org/2000/svg") {
        var R = x.getAttribute(o) || "";
        R = n + R;
        var U = m.get(R);
        U ? U.push(x) : m.set(R, [x]);
      }
    }
    return m;
  }
  function Jg(n, o, c) {
    n = n.ownerDocument || n, n.head.insertBefore(
      c,
      o === "title" ? n.querySelector("head > title") : null
    );
  }
  function l_(n, o, c) {
    if (c === 1 || o.itemProp != null) return !1;
    switch (n) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof o.precedence != "string" || typeof o.href != "string" || o.href === "")
          break;
        return !0;
      case "link":
        if (typeof o.rel != "string" || typeof o.href != "string" || o.href === "" || o.onLoad || o.onError)
          break;
        switch (o.rel) {
          case "stylesheet":
            return n = o.disabled, typeof o.precedence == "string" && n == null;
          default:
            return !0;
        }
      case "script":
        if (o.async && typeof o.async != "function" && typeof o.async != "symbol" && !o.onLoad && !o.onError && o.src && typeof o.src == "string")
          return !0;
    }
    return !1;
  }
  function Fg(n) {
    return !(n.type === "stylesheet" && (n.state.loading & 3) === 0);
  }
  var of = null;
  function s_() {
  }
  function r_(n, o, c) {
    if (of === null) throw Error(u(475));
    var m = of;
    if (o.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && (o.state.loading & 4) === 0) {
      if (o.instance === null) {
        var b = ef(c.href), x = n.querySelector(
          nf(b)
        );
        if (x) {
          n = x._p, n !== null && typeof n == "object" && typeof n.then == "function" && (m.count++, m = kh.bind(m), n.then(m, m)), o.state.loading |= 4, o.instance = x, Bn(x);
          return;
        }
        x = n.ownerDocument || n, c = af(c), (b = kn.get(b)) && Km(c, b), x = x.createElement("link"), Bn(x);
        var R = x;
        R._p = new Promise(function(U, Z) {
          R.onload = U, R.onerror = Z;
        }), re(x, "link", c), o.instance = x;
      }
      m.stylesheets === null && (m.stylesheets = /* @__PURE__ */ new Map()), m.stylesheets.set(o, n), (n = o.state.preload) && (o.state.loading & 3) === 0 && (m.count++, o = kh.bind(m), n.addEventListener("load", o), n.addEventListener("error", o));
    }
  }
  function ty() {
    if (of === null) throw Error(u(475));
    var n = of;
    return n.stylesheets && n.count === 0 && Nh(n, n.stylesheets), 0 < n.count ? function(o) {
      var c = setTimeout(function() {
        if (n.stylesheets && Nh(n, n.stylesheets), n.unsuspend) {
          var m = n.unsuspend;
          n.unsuspend = null, m();
        }
      }, 6e4);
      return n.unsuspend = o, function() {
        n.unsuspend = null, clearTimeout(c);
      };
    } : null;
  }
  function kh() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) Nh(this, this.stylesheets);
      else if (this.unsuspend) {
        var n = this.unsuspend;
        this.unsuspend = null, n();
      }
    }
  }
  var lf = null;
  function Nh(n, o) {
    n.stylesheets = null, n.unsuspend !== null && (n.count++, lf = /* @__PURE__ */ new Map(), o.forEach(ro, n), lf = null, kh.call(n));
  }
  function ro(n, o) {
    if (!(o.state.loading & 4)) {
      var c = lf.get(n);
      if (c) var m = c.get(null);
      else {
        c = /* @__PURE__ */ new Map(), lf.set(n, c);
        for (var b = n.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), x = 0; x < b.length; x++) {
          var R = b[x];
          (R.nodeName === "LINK" || R.getAttribute("media") !== "not all") && (c.set(R.dataset.precedence, R), m = R);
        }
        m && c.set(null, m);
      }
      b = o.instance, R = b.getAttribute("data-precedence"), x = c.get(R) || m, x === m && c.set(null, b), c.set(R, b), this.count++, m = kh.bind(this), b.addEventListener("load", m), b.addEventListener("error", m), x ? x.parentNode.insertBefore(b, x.nextSibling) : (n = n.nodeType === 9 ? n.head : n, n.insertBefore(b, n.firstChild)), o.state.loading |= 4;
    }
  }
  var Na = {
    $$typeof: Et,
    Provider: null,
    Consumer: null,
    _currentValue: ut,
    _currentValue2: ut,
    _threadCount: 0
  };
  function X0(n, o, c, m, b, x, R, U) {
    this.tag = 1, this.containerInfo = n, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Xt(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Xt(0), this.hiddenUpdates = Xt(null), this.identifierPrefix = m, this.onUncaughtError = b, this.onCaughtError = x, this.onRecoverableError = R, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = U, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function ey(n, o, c, m, b, x, R, U, Z, it, vt, St) {
    return n = new X0(
      n,
      o,
      c,
      R,
      U,
      Z,
      it,
      St
    ), o = 1, x === !0 && (o |= 24), x = Vi(3, null, null, o), n.current = x, x.stateNode = n, o = Oc(), o.refCount++, n.pooledCache = o, o.refCount++, x.memoizedState = {
      element: m,
      isDehydrated: c,
      cache: o
    }, jd(x), n;
  }
  function ny(n) {
    return n ? (n = Us, n) : Us;
  }
  function iy(n, o, c, m, b, x) {
    b = ny(b), m.context === null ? m.context = b : m.pendingContext = b, m = Oa(o), m.payload = { element: c }, x = x === void 0 ? null : x, x !== null && (m.callback = x), c = ql(n, m, o), c !== null && (lo(c, n, o), Eu(c, n, o));
  }
  function ay(n, o) {
    if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
      var c = n.retryLane;
      n.retryLane = c !== 0 && c < o ? c : o;
    }
  }
  function Im(n, o) {
    ay(n, o), (n = n.alternate) && ay(n, o);
  }
  function oy(n) {
    if (n.tag === 13) {
      var o = Lo(n, 67108864);
      o !== null && lo(o, n, 67108864), Im(n, 67108864);
    }
  }
  var Uh = !0;
  function u_(n, o, c, m) {
    var b = V.T;
    V.T = null;
    var x = mt.p;
    try {
      mt.p = 2, ly(n, o, c, m);
    } finally {
      mt.p = x, V.T = b;
    }
  }
  function c_(n, o, c, m) {
    var b = V.T;
    V.T = null;
    var x = mt.p;
    try {
      mt.p = 8, ly(n, o, c, m);
    } finally {
      mt.p = x, V.T = b;
    }
  }
  function ly(n, o, c, m) {
    if (Uh) {
      var b = $m(m);
      if (b === null)
        qo(
          n,
          o,
          m,
          Jm,
          c
        ), Ku(n, m);
      else if (h_(
        b,
        n,
        o,
        c,
        m
      ))
        m.stopPropagation();
      else if (Ku(n, m), o & 4 && -1 < f_.indexOf(n)) {
        for (; b !== null; ) {
          var x = bl(b);
          if (x !== null)
            switch (x.tag) {
              case 3:
                if (x = x.stateNode, x.current.memoizedState.isDehydrated) {
                  var R = Pn(x.pendingLanes);
                  if (R !== 0) {
                    var U = x;
                    for (U.pendingLanes |= 2, U.entangledLanes |= 2; R; ) {
                      var Z = 1 << 31 - $n(R);
                      U.entanglements[1] |= Z, R &= ~Z;
                    }
                    La(x), (Qe & 6) === 0 && (Dm = En() + 500, wh(0));
                  }
                }
                break;
              case 13:
                U = Lo(x, 2), U !== null && lo(U, x, 2), Zu(), Im(x, 2);
            }
          if (x = $m(m), x === null && qo(
            n,
            o,
            m,
            Jm,
            c
          ), x === b) break;
          b = x;
        }
        b !== null && m.stopPropagation();
      } else
        qo(
          n,
          o,
          m,
          null,
          c
        );
    }
  }
  function $m(n) {
    return n = xs(n), sy(n);
  }
  var Jm = null;
  function sy(n) {
    if (Jm = null, n = Un(n), n !== null) {
      var o = g(n);
      if (o === null) n = null;
      else {
        var c = o.tag;
        if (c === 13) {
          if (n = _(o), n !== null) return n;
          n = null;
        } else if (c === 3) {
          if (o.stateNode.current.memoizedState.isDehydrated)
            return o.tag === 3 ? o.stateNode.containerInfo : null;
          n = null;
        } else o !== n && (n = null);
      }
    }
    return Jm = n, null;
  }
  function ry(n) {
    switch (n) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Pa()) {
          case dc:
            return 2;
          case pe:
            return 8;
          case pa:
          case vs:
            return 32;
          case po:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var sf = !1, as = null, tr = null, er = null, Bh = /* @__PURE__ */ new Map(), Yh = /* @__PURE__ */ new Map(), $r = [], f_ = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Ku(n, o) {
    switch (n) {
      case "focusin":
      case "focusout":
        as = null;
        break;
      case "dragenter":
      case "dragleave":
        tr = null;
        break;
      case "mouseover":
      case "mouseout":
        er = null;
        break;
      case "pointerover":
      case "pointerout":
        Bh.delete(o.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Yh.delete(o.pointerId);
    }
  }
  function Wu(n, o, c, m, b, x) {
    return n === null || n.nativeEvent !== x ? (n = {
      blockedOn: o,
      domEventName: c,
      eventSystemFlags: m,
      nativeEvent: x,
      targetContainers: [b]
    }, o !== null && (o = bl(o), o !== null && oy(o)), n) : (n.eventSystemFlags |= m, o = n.targetContainers, b !== null && o.indexOf(b) === -1 && o.push(b), n);
  }
  function h_(n, o, c, m, b) {
    switch (o) {
      case "focusin":
        return as = Wu(
          as,
          n,
          o,
          c,
          m,
          b
        ), !0;
      case "dragenter":
        return tr = Wu(
          tr,
          n,
          o,
          c,
          m,
          b
        ), !0;
      case "mouseover":
        return er = Wu(
          er,
          n,
          o,
          c,
          m,
          b
        ), !0;
      case "pointerover":
        var x = b.pointerId;
        return Bh.set(
          x,
          Wu(
            Bh.get(x) || null,
            n,
            o,
            c,
            m,
            b
          )
        ), !0;
      case "gotpointercapture":
        return x = b.pointerId, Yh.set(
          x,
          Wu(
            Yh.get(x) || null,
            n,
            o,
            c,
            m,
            b
          )
        ), !0;
    }
    return !1;
  }
  function uy(n) {
    var o = Un(n.target);
    if (o !== null) {
      var c = g(o);
      if (c !== null) {
        if (o = c.tag, o === 13) {
          if (o = _(c), o !== null) {
            n.blockedOn = o, du(n.priority, function() {
              if (c.tag === 13) {
                var m = oo();
                m = On(m);
                var b = Lo(c, m);
                b !== null && lo(b, c, m), Im(c, m);
              }
            });
            return;
          }
        } else if (o === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          n.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    n.blockedOn = null;
  }
  function jh(n) {
    if (n.blockedOn !== null) return !1;
    for (var o = n.targetContainers; 0 < o.length; ) {
      var c = $m(n.nativeEvent);
      if (c === null) {
        c = n.nativeEvent;
        var m = new c.constructor(
          c.type,
          c
        );
        tl = m, c.target.dispatchEvent(m), tl = null;
      } else
        return o = bl(c), o !== null && oy(o), n.blockedOn = c, !1;
      o.shift();
    }
    return !0;
  }
  function qh(n, o, c) {
    jh(n) && c.delete(o);
  }
  function rf() {
    sf = !1, as !== null && jh(as) && (as = null), tr !== null && jh(tr) && (tr = null), er !== null && jh(er) && (er = null), Bh.forEach(qh), Yh.forEach(qh);
  }
  function Fm(n, o) {
    n.blockedOn === o && (n.blockedOn = null, sf || (sf = !0, s.unstable_scheduleCallback(
      s.unstable_NormalPriority,
      rf
    )));
  }
  var Iu = null;
  function cy(n) {
    Iu !== n && (Iu = n, s.unstable_scheduleCallback(
      s.unstable_NormalPriority,
      function() {
        Iu === n && (Iu = null);
        for (var o = 0; o < n.length; o += 3) {
          var c = n[o], m = n[o + 1], b = n[o + 2];
          if (typeof m != "function") {
            if (sy(m || c) === null)
              continue;
            break;
          }
          var x = bl(c);
          x !== null && (n.splice(o, 3), o -= 3, lm(
            x,
            {
              pending: !0,
              data: b,
              method: c.method,
              action: m
            },
            m,
            b
          ));
        }
      }
    ));
  }
  function os(n) {
    function o(Z) {
      return Fm(Z, n);
    }
    as !== null && Fm(as, n), tr !== null && Fm(tr, n), er !== null && Fm(er, n), Bh.forEach(o), Yh.forEach(o);
    for (var c = 0; c < $r.length; c++) {
      var m = $r[c];
      m.blockedOn === n && (m.blockedOn = null);
    }
    for (; 0 < $r.length && (c = $r[0], c.blockedOn === null); )
      uy(c), c.blockedOn === null && $r.shift();
    if (c = (n.ownerDocument || n).$$reactFormReplay, c != null)
      for (m = 0; m < c.length; m += 3) {
        var b = c[m], x = c[m + 1], R = b[Ei] || null;
        if (typeof x == "function")
          R || cy(c);
        else if (R) {
          var U = null;
          if (x && x.hasAttribute("formAction")) {
            if (b = x, R = x[Ei] || null)
              U = R.formAction;
            else if (sy(b) !== null) continue;
          } else U = R.action;
          typeof U == "function" ? c[m + 1] = U : (c.splice(m, 3), m -= 3), cy(c);
        }
      }
  }
  function fy(n) {
    this._internalRoot = n;
  }
  tp.prototype.render = fy.prototype.render = function(n) {
    var o = this._internalRoot;
    if (o === null) throw Error(u(409));
    var c = o.current, m = oo();
    iy(c, m, n, o, null, null);
  }, tp.prototype.unmount = fy.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
      this._internalRoot = null;
      var o = n.containerInfo;
      iy(n.current, 2, null, n, null, null), Zu(), o[dr] = null;
    }
  };
  function tp(n) {
    this._internalRoot = n;
  }
  tp.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
      var o = pc();
      n = { blockedOn: null, target: n, priority: o };
      for (var c = 0; c < $r.length && o !== 0 && o < $r[c].priority; c++) ;
      $r.splice(c, 0, n), c === 0 && uy(n);
    }
  };
  var hy = i.version;
  if (hy !== "19.1.1")
    throw Error(
      u(
        527,
        hy,
        "19.1.1"
      )
    );
  mt.findDOMNode = function(n) {
    var o = n._reactInternals;
    if (o === void 0)
      throw typeof n.render == "function" ? Error(u(188)) : (n = Object.keys(n).join(","), Error(u(268, n)));
    return n = T(o), n = n !== null ? E(n) : null, n = n === null ? null : n.stateNode, n;
  };
  var ua = {
    bundleType: 0,
    version: "19.1.1",
    rendererPackageName: "react-dom",
    currentDispatcherRef: V,
    reconcilerVersion: "19.1.1"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Zh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Zh.isDisabled && Zh.supportsFiber)
      try {
        go = Zh.inject(
          ua
        ), Zn = Zh;
      } catch {
      }
  }
  return Wy.createRoot = function(n, o) {
    if (!h(n)) throw Error(u(299));
    var c = !1, m = "", b = kc, x = ug, R = dh, U = null;
    return o != null && (o.unstable_strictMode === !0 && (c = !0), o.identifierPrefix !== void 0 && (m = o.identifierPrefix), o.onUncaughtError !== void 0 && (b = o.onUncaughtError), o.onCaughtError !== void 0 && (x = o.onCaughtError), o.onRecoverableError !== void 0 && (R = o.onRecoverableError), o.unstable_transitionCallbacks !== void 0 && (U = o.unstable_transitionCallbacks)), o = ey(
      n,
      1,
      !1,
      null,
      null,
      c,
      m,
      b,
      x,
      R,
      U,
      null
    ), n[dr] = o.current, Qg(n), new fy(o);
  }, Wy.hydrateRoot = function(n, o, c) {
    if (!h(n)) throw Error(u(299));
    var m = !1, b = "", x = kc, R = ug, U = dh, Z = null, it = null;
    return c != null && (c.unstable_strictMode === !0 && (m = !0), c.identifierPrefix !== void 0 && (b = c.identifierPrefix), c.onUncaughtError !== void 0 && (x = c.onUncaughtError), c.onCaughtError !== void 0 && (R = c.onCaughtError), c.onRecoverableError !== void 0 && (U = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (Z = c.unstable_transitionCallbacks), c.formState !== void 0 && (it = c.formState)), o = ey(
      n,
      1,
      !0,
      o,
      c ?? null,
      m,
      b,
      x,
      R,
      U,
      Z,
      it
    ), o.context = ny(null), c = o.current, m = oo(), m = On(m), b = Oa(m), b.callback = null, ql(c, b, m), c = m, o.current.lanes = c, se(o, c), La(o), n[dr] = o.current, Qg(n), new tp(o);
  }, Wy.version = "19.1.1", Wy;
}
var Iy = {};
/**
 * @license React
 * react-dom-client.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $T;
function GE() {
  return $T || ($T = 1, process.env.NODE_ENV !== "production" && function() {
    function s(t, e) {
      for (t = t.memoizedState; t !== null && 0 < e; )
        t = t.next, e--;
      return t;
    }
    function i(t, e, a, f) {
      if (a >= e.length) return f;
      var p = e[a], y = de(t) ? t.slice() : Me({}, t);
      return y[p] = i(t[p], e, a + 1, f), y;
    }
    function l(t, e, a) {
      if (e.length !== a.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var f = 0; f < a.length - 1; f++)
          if (e[f] !== a[f]) {
            console.warn(
              "copyWithRename() expects paths to be the same except for the deepest key"
            );
            return;
          }
        return u(t, e, a, 0);
      }
    }
    function u(t, e, a, f) {
      var p = e[f], y = de(t) ? t.slice() : Me({}, t);
      return f + 1 === e.length ? (y[a[f]] = y[p], de(y) ? y.splice(p, 1) : delete y[p]) : y[p] = u(
        t[p],
        e,
        a,
        f + 1
      ), y;
    }
    function h(t, e, a) {
      var f = e[a], p = de(t) ? t.slice() : Me({}, t);
      return a + 1 === e.length ? (de(p) ? p.splice(f, 1) : delete p[f], p) : (p[f] = h(t[f], e, a + 1), p);
    }
    function g() {
      return !1;
    }
    function _() {
      return null;
    }
    function S() {
    }
    function T() {
      console.error(
        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
      );
    }
    function E() {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    function D() {
    }
    function C(t) {
      var e = [];
      return t.forEach(function(a) {
        e.push(a);
      }), e.sort().join(", ");
    }
    function z(t, e, a, f) {
      return new gi(t, e, a, f);
    }
    function j(t, e) {
      t.context === uf && (Ie(t.current, 2, e, t, null, null), Nu());
    }
    function I(t, e) {
      if (ss !== null) {
        var a = e.staleFamilies;
        e = e.updatedFamilies, Nc(), il(
          t.current,
          e,
          a
        ), Nu();
      }
    }
    function Q(t) {
      ss = t;
    }
    function X(t) {
      return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
    }
    function nt(t) {
      var e = t, a = t;
      if (t.alternate) for (; e.return; ) e = e.return;
      else {
        t = e;
        do
          e = t, (e.flags & 4098) !== 0 && (a = e.return), t = e.return;
        while (t);
      }
      return e.tag === 3 ? a : null;
    }
    function Dt(t) {
      if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated;
      }
      return null;
    }
    function Et(t) {
      if (nt(t) !== t)
        throw Error("Unable to find node on an unmounted component.");
    }
    function zt(t) {
      var e = t.alternate;
      if (!e) {
        if (e = nt(t), e === null)
          throw Error("Unable to find node on an unmounted component.");
        return e !== t ? null : t;
      }
      for (var a = t, f = e; ; ) {
        var p = a.return;
        if (p === null) break;
        var y = p.alternate;
        if (y === null) {
          if (f = p.return, f !== null) {
            a = f;
            continue;
          }
          break;
        }
        if (p.child === y.child) {
          for (y = p.child; y; ) {
            if (y === a) return Et(p), t;
            if (y === f) return Et(p), e;
            y = y.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== f.return) a = p, f = y;
        else {
          for (var M = !1, A = p.child; A; ) {
            if (A === a) {
              M = !0, a = p, f = y;
              break;
            }
            if (A === f) {
              M = !0, f = p, a = y;
              break;
            }
            A = A.sibling;
          }
          if (!M) {
            for (A = y.child; A; ) {
              if (A === a) {
                M = !0, a = y, f = p;
                break;
              }
              if (A === f) {
                M = !0, f = y, a = p;
                break;
              }
              A = A.sibling;
            }
            if (!M)
              throw Error(
                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
              );
          }
        }
        if (a.alternate !== f)
          throw Error(
            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
          );
      }
      if (a.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? t : e;
    }
    function dt(t) {
      var e = t.tag;
      if (e === 5 || e === 26 || e === 27 || e === 6) return t;
      for (t = t.child; t !== null; ) {
        if (e = dt(t), e !== null) return e;
        t = t.sibling;
      }
      return null;
    }
    function Lt(t) {
      return t === null || typeof t != "object" ? null : (t = Wg && t[Wg] || t["@@iterator"], typeof t == "function" ? t : null);
    }
    function Ct(t) {
      if (t == null) return null;
      if (typeof t == "function")
        return t.$$typeof === jm ? null : t.displayName || t.name || null;
      if (typeof t == "string") return t;
      switch (t) {
        case _e:
          return "Fragment";
        case Ic:
          return "Profiler";
        case Wc:
          return "StrictMode";
        case $c:
          return "Suspense";
        case Gr:
          return "SuspenseList";
        case Kg:
          return "Activity";
      }
      if (typeof t == "object")
        switch (typeof t.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), t.$$typeof) {
          case Xu:
            return "Portal";
          case qo:
            return (t.displayName || "Context") + ".Provider";
          case Ym:
            return (t._context.displayName || "Context") + ".Consumer";
          case Ws:
            var e = t.render;
            return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
          case Rh:
            return e = t.displayName || null, e !== null ? e : Ct(t.type) || "Memo";
          case so:
            e = t._payload, t = t._init;
            try {
              return Ct(t(e));
            } catch {
            }
        }
      return null;
    }
    function Yt(t) {
      return typeof t.tag == "number" ? wt(t) : typeof t.name == "string" ? t.name : null;
    }
    function wt(t) {
      var e = t.type;
      switch (t.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (e._context.displayName || "Context") + ".Consumer";
        case 10:
          return (e.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return e;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Ct(e);
        case 8:
          return e === Wc ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if (typeof e == "function")
            return e.displayName || e.name || null;
          if (typeof e == "string") return e;
          break;
        case 29:
          if (e = t._debugInfo, e != null) {
            for (var a = e.length - 1; 0 <= a; a--)
              if (typeof e[a].name == "string") return e[a].name;
          }
          if (t.return !== null)
            return wt(t.return);
      }
      return null;
    }
    function ne(t) {
      return { current: t };
    }
    function Rt(t, e) {
      0 > Zo ? console.error("Unexpected pop.") : (e !== zh[Zo] && console.error("Unexpected Fiber popped."), t.current = Ch[Zo], Ch[Zo] = null, zh[Zo] = null, Zo--);
    }
    function Nt(t, e, a) {
      Zo++, Ch[Zo] = t.current, zh[Zo] = a, t.current = e;
    }
    function Ee(t) {
      return t === null && console.error(
        "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
      ), t;
    }
    function ge(t, e) {
      Nt(ns, e, t), Nt(Jc, t, t), Nt(Is, null, t);
      var a = e.nodeType;
      switch (a) {
        case 9:
        case 11:
          a = a === 9 ? "#document" : "#fragment", e = (e = e.documentElement) && (e = e.namespaceURI) ? Ke(e) : lc;
          break;
        default:
          if (a = e.tagName, e = e.namespaceURI)
            e = Ke(e), e = Ca(
              e,
              a
            );
          else
            switch (a) {
              case "svg":
                e = Dp;
                break;
              case "math":
                e = Z_;
                break;
              default:
                e = lc;
            }
      }
      a = a.toLowerCase(), a = yn(null, a), a = {
        context: e,
        ancestorInfo: a
      }, Rt(Is, t), Nt(Is, a, t);
    }
    function Jt(t) {
      Rt(Is, t), Rt(Jc, t), Rt(ns, t);
    }
    function V() {
      return Ee(Is.current);
    }
    function mt(t) {
      t.memoizedState !== null && Nt(Fc, t, t);
      var e = Ee(Is.current), a = t.type, f = Ca(e.context, a);
      a = yn(e.ancestorInfo, a), f = { context: f, ancestorInfo: a }, e !== f && (Nt(Jc, t, t), Nt(Is, f, t));
    }
    function ut(t) {
      Jc.current === t && (Rt(Is, t), Rt(Jc, t)), Fc.current === t && (Rt(Fc, t), Vy._currentValue = ld);
    }
    function Gt(t) {
      return typeof Symbol == "function" && Symbol.toStringTag && t[Symbol.toStringTag] || t.constructor.name || "Object";
    }
    function k(t) {
      try {
        return F(t), !1;
      } catch {
        return !0;
      }
    }
    function F(t) {
      return "" + t;
    }
    function ct(t, e) {
      if (k(t))
        return console.error(
          "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
          e,
          Gt(t)
        ), F(t);
    }
    function bt(t, e) {
      if (k(t))
        return console.error(
          "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
          e,
          Gt(t)
        ), F(t);
    }
    function Mt(t) {
      if (k(t))
        return console.error(
          "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
          Gt(t)
        ), F(t);
    }
    function Ht(t) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") return !1;
      var e = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (e.isDisabled) return !0;
      if (!e.supportsFiber)
        return console.error(
          "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
        ), !0;
      try {
        Qr = e.inject(t), Ni = e;
      } catch (a) {
        console.error("React instrumentation encountered an error: %s.", a);
      }
      return !!e.checkDCE;
    }
    function Tt(t) {
      if (typeof G0 == "function" && pl(t), Ni && typeof Ni.setStrictMode == "function")
        try {
          Ni.setStrictMode(Qr, t);
        } catch (e) {
          Ha || (Ha = !0, console.error(
            "React instrumentation encountered an error: %s",
            e
          ));
        }
    }
    function We(t) {
      jt = t;
    }
    function Ft() {
      jt !== null && typeof jt.markCommitStopped == "function" && jt.markCommitStopped();
    }
    function on(t) {
      jt !== null && typeof jt.markComponentRenderStarted == "function" && jt.markComponentRenderStarted(t);
    }
    function fi() {
      jt !== null && typeof jt.markComponentRenderStopped == "function" && jt.markComponentRenderStopped();
    }
    function da(t) {
      jt !== null && typeof jt.markRenderStarted == "function" && jt.markRenderStarted(t);
    }
    function Za() {
      jt !== null && typeof jt.markRenderStopped == "function" && jt.markRenderStopped();
    }
    function ma(t, e) {
      jt !== null && typeof jt.markStateUpdateScheduled == "function" && jt.markStateUpdateScheduled(t, e);
    }
    function ur(t) {
      return t >>>= 0, t === 0 ? 32 : 31 - (Pm(t) / Js | 0) | 0;
    }
    function cr(t) {
      if (t & 1) return "SyncHydrationLane";
      if (t & 2) return "Sync";
      if (t & 4) return "InputContinuousHydration";
      if (t & 8) return "InputContinuous";
      if (t & 16) return "DefaultHydration";
      if (t & 32) return "Default";
      if (t & 128) return "TransitionHydration";
      if (t & 4194048) return "Transition";
      if (t & 62914560) return "Retry";
      if (t & 67108864) return "SelectiveHydration";
      if (t & 134217728) return "IdleHydration";
      if (t & 268435456) return "Idle";
      if (t & 536870912) return "Offscreen";
      if (t & 1073741824) return "Deferred";
    }
    function Tn(t) {
      var e = t & 42;
      if (e !== 0) return e;
      switch (t & -t) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return t & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return t & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), t;
      }
    }
    function En(t, e, a) {
      var f = t.pendingLanes;
      if (f === 0) return 0;
      var p = 0, y = t.suspendedLanes, M = t.pingedLanes;
      t = t.warmLanes;
      var A = f & 134217727;
      return A !== 0 ? (f = A & ~y, f !== 0 ? p = Tn(f) : (M &= A, M !== 0 ? p = Tn(M) : a || (a = A & ~t, a !== 0 && (p = Tn(a))))) : (A = f & ~y, A !== 0 ? p = Tn(A) : M !== 0 ? p = Tn(M) : a || (a = f & ~t, a !== 0 && (p = Tn(a)))), p === 0 ? 0 : e !== 0 && e !== p && (e & y) === 0 && (y = p & -p, a = e & -e, y >= a || y === 32 && (a & 4194048) !== 0) ? e : p;
    }
    function Pa(t, e) {
      return (t.pendingLanes & ~(t.suspendedLanes & ~t.pingedLanes) & e) === 0;
    }
    function dc(t, e) {
      switch (t) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return e + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return e + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), -1;
      }
    }
    function pe() {
      var t = Vm;
      return Vm <<= 1, (Vm & 4194048) === 0 && (Vm = 256), t;
    }
    function pa() {
      var t = Gm;
      return Gm <<= 1, (Gm & 62914560) === 0 && (Gm = 4194304), t;
    }
    function vs(t) {
      for (var e = [], a = 0; 31 > a; a++) e.push(t);
      return e;
    }
    function po(t, e) {
      t.pendingLanes |= e, e !== 268435456 && (t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0);
    }
    function mc(t, e, a, f, p, y) {
      var M = t.pendingLanes;
      t.pendingLanes = a, t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0, t.expiredLanes &= a, t.entangledLanes &= a, t.errorRecoveryDisabledLanes &= a, t.shellSuspendCounter = 0;
      var A = t.entanglements, B = t.expirationTimes, Y = t.hiddenUpdates;
      for (a = M & ~a; 0 < a; ) {
        var lt = 31 - Wi(a), pt = 1 << lt;
        A[lt] = 0, B[lt] = -1;
        var at = Y[lt];
        if (at !== null)
          for (Y[lt] = null, lt = 0; lt < at.length; lt++) {
            var gt = at[lt];
            gt !== null && (gt.lane &= -536870913);
          }
        a &= ~pt;
      }
      f !== 0 && hu(t, f, 0), y !== 0 && p === 0 && t.tag !== 0 && (t.suspendedLanes |= y & ~(M & ~e));
    }
    function hu(t, e, a) {
      t.pendingLanes |= e, t.suspendedLanes &= ~e;
      var f = 31 - Wi(e);
      t.entangledLanes |= e, t.entanglements[f] = t.entanglements[f] | 1073741824 | a & 4194090;
    }
    function go(t, e) {
      var a = t.entangledLanes |= e;
      for (t = t.entanglements; a; ) {
        var f = 31 - Wi(a), p = 1 << f;
        p & e | t[f] & e && (t[f] |= e), a &= ~p;
      }
    }
    function Zn(t) {
      switch (t) {
        case 2:
          t = 1;
          break;
        case 8:
          t = 4;
          break;
        case 32:
          t = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          t = 128;
          break;
        case 268435456:
          t = 134217728;
          break;
        default:
          t = 0;
      }
      return t;
    }
    function ta(t, e, a) {
      if (kn)
        for (t = t.pendingUpdatersLaneMap; 0 < a; ) {
          var f = 31 - Wi(a), p = 1 << f;
          t[f].add(e), a &= ~p;
        }
    }
    function $n(t, e) {
      if (kn)
        for (var a = t.pendingUpdatersLaneMap, f = t.memoizedUpdaters; 0 < e; ) {
          var p = 31 - Wi(e);
          t = 1 << p, p = a[p], 0 < p.size && (p.forEach(function(y) {
            var M = y.alternate;
            M !== null && f.has(M) || f.add(y);
          }), p.clear()), e &= ~t;
        }
    }
    function _s(t) {
      return t &= -t, Ui < t ? gl < t ? (t & 134217727) !== 0 ? Fs : Xm : gl : Ui;
    }
    function fr() {
      var t = re.p;
      return t !== 0 ? t : (t = window.event, t === void 0 ? Fs : Um(t.type));
    }
    function hr(t, e) {
      var a = re.p;
      try {
        return re.p = t, e();
      } finally {
        re.p = a;
      }
    }
    function ga(t) {
      delete t[Ii], delete t[ka], delete t[Ig], delete t[i_], delete t[ef];
    }
    function hi(t) {
      var e = t[Ii];
      if (e) return e;
      for (var a = t.parentNode; a; ) {
        if (e = a[Wr] || a[Ii]) {
          if (a = e.alternate, e.child !== null || a !== null && a.child !== null)
            for (t = Gc(t); t !== null; ) {
              if (a = t[Ii])
                return a;
              t = Gc(t);
            }
          return e;
        }
        t = a, a = t.parentNode;
      }
      return null;
    }
    function Pn(t) {
      if (t = t[Ii] || t[Wr]) {
        var e = t.tag;
        if (e === 5 || e === 6 || e === 13 || e === 26 || e === 27 || e === 3)
          return t;
      }
      return null;
    }
    function Va(t) {
      var e = t.tag;
      if (e === 5 || e === 26 || e === 27 || e === 6)
        return t.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function N(t) {
      var e = t[nf];
      return e || (e = t[nf] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), e;
    }
    function J(t) {
      t[af] = !0;
    }
    function At(t, e) {
      kt(t, e), kt(t + "Capture", e);
    }
    function kt(t, e) {
      Po[t] && console.error(
        "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
        t
      ), Po[t] = e;
      var a = t.toLowerCase();
      for (Qu[a] = t, t === "onDoubleClick" && (Qu.ondblclick = t), t = 0; t < e.length; t++)
        a_.add(e[t]);
    }
    function Xt(t, e) {
      o_[e.type] || e.onChange || e.onInput || e.readOnly || e.disabled || e.value == null || console.error(
        t === "select" ? "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`." : "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
      ), e.onChange || e.readOnly || e.disabled || e.checked == null || console.error(
        "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
      );
    }
    function se(t) {
      return $s.call(Wm, t) ? !0 : $s.call(Km, t) ? !1 : Qm.test(t) ? Wm[t] = !0 : (Km[t] = !0, console.error("Invalid attribute name: `%s`", t), !1);
    }
    function he(t, e, a) {
      if (se(e)) {
        if (!t.hasAttribute(e)) {
          switch (typeof a) {
            case "symbol":
            case "object":
              return a;
            case "function":
              return a;
            case "boolean":
              if (a === !1) return a;
          }
          return a === void 0 ? void 0 : null;
        }
        return t = t.getAttribute(e), t === "" && a === !0 ? !0 : (ct(a, e), t === "" + a ? a : t);
      }
    }
    function ze(t, e, a) {
      if (se(e))
        if (a === null) t.removeAttribute(e);
        else {
          switch (typeof a) {
            case "undefined":
            case "function":
            case "symbol":
              t.removeAttribute(e);
              return;
            case "boolean":
              var f = e.toLowerCase().slice(0, 5);
              if (f !== "data-" && f !== "aria-") {
                t.removeAttribute(e);
                return;
              }
          }
          ct(a, e), t.setAttribute(e, "" + a);
        }
    }
    function fe(t, e, a) {
      if (a === null) t.removeAttribute(e);
      else {
        switch (typeof a) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            t.removeAttribute(e);
            return;
        }
        ct(a, e), t.setAttribute(e, "" + a);
      }
    }
    function On(t, e, a, f) {
      if (f === null) t.removeAttribute(a);
      else {
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            t.removeAttribute(a);
            return;
        }
        ct(f, a), t.setAttributeNS(e, a, "" + f);
      }
    }
    function Ga() {
    }
    function pc() {
      if (Ir === 0) {
        $g = console.log, Jg = console.info, l_ = console.warn, Fg = console.error, of = console.group, s_ = console.groupCollapsed, r_ = console.groupEnd;
        var t = {
          configurable: !0,
          enumerable: !0,
          value: Ga,
          writable: !0
        };
        Object.defineProperties(console, {
          info: t,
          log: t,
          warn: t,
          error: t,
          group: t,
          groupCollapsed: t,
          groupEnd: t
        });
      }
      Ir++;
    }
    function du() {
      if (Ir--, Ir === 0) {
        var t = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: Me({}, t, { value: $g }),
          info: Me({}, t, { value: Jg }),
          warn: Me({}, t, { value: l_ }),
          error: Me({}, t, { value: Fg }),
          group: Me({}, t, { value: of }),
          groupCollapsed: Me({}, t, { value: s_ }),
          groupEnd: Me({}, t, { value: r_ })
        });
      }
      0 > Ir && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function Nn(t) {
      if (ty === void 0)
        try {
          throw Error();
        } catch (a) {
          var e = a.stack.trim().match(/\n( *(at )?)/);
          ty = e && e[1] || "", kh = -1 < a.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < a.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + ty + t + kh;
    }
    function Vn(t, e) {
      if (!t || lf) return "";
      var a = Nh.get(t);
      if (a !== void 0) return a;
      lf = !0, a = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var f = null;
      f = ft.H, ft.H = null, pc();
      try {
        var p = {
          DetermineComponentFrameRoot: function() {
            try {
              if (e) {
                var at = function() {
                  throw Error();
                };
                if (Object.defineProperty(at.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(at, []);
                  } catch (Kt) {
                    var gt = Kt;
                  }
                  Reflect.construct(t, [], at);
                } else {
                  try {
                    at.call();
                  } catch (Kt) {
                    gt = Kt;
                  }
                  t.call(at.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (Kt) {
                  gt = Kt;
                }
                (at = t()) && typeof at.catch == "function" && at.catch(function() {
                });
              }
            } catch (Kt) {
              if (Kt && gt && typeof Kt.stack == "string")
                return [Kt.stack, gt.stack];
            }
            return [null, null];
          }
        };
        p.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var y = Object.getOwnPropertyDescriptor(
          p.DetermineComponentFrameRoot,
          "name"
        );
        y && y.configurable && Object.defineProperty(
          p.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var M = p.DetermineComponentFrameRoot(), A = M[0], B = M[1];
        if (A && B) {
          var Y = A.split(`
`), lt = B.split(`
`);
          for (M = y = 0; y < Y.length && !Y[y].includes(
            "DetermineComponentFrameRoot"
          ); )
            y++;
          for (; M < lt.length && !lt[M].includes(
            "DetermineComponentFrameRoot"
          ); )
            M++;
          if (y === Y.length || M === lt.length)
            for (y = Y.length - 1, M = lt.length - 1; 1 <= y && 0 <= M && Y[y] !== lt[M]; )
              M--;
          for (; 1 <= y && 0 <= M; y--, M--)
            if (Y[y] !== lt[M]) {
              if (y !== 1 || M !== 1)
                do
                  if (y--, M--, 0 > M || Y[y] !== lt[M]) {
                    var pt = `
` + Y[y].replace(
                      " at new ",
                      " at "
                    );
                    return t.displayName && pt.includes("<anonymous>") && (pt = pt.replace("<anonymous>", t.displayName)), typeof t == "function" && Nh.set(t, pt), pt;
                  }
                while (1 <= y && 0 <= M);
              break;
            }
        }
      } finally {
        lf = !1, ft.H = f, du(), Error.prepareStackTrace = a;
      }
      return Y = (Y = t ? t.displayName || t.name : "") ? Nn(Y) : "", typeof t == "function" && Nh.set(t, Y), Y;
    }
    function Ei(t) {
      var e = Error.prepareStackTrace;
      if (Error.prepareStackTrace = void 0, t = t.stack, Error.prepareStackTrace = e, t.startsWith(`Error: react-stack-top-frame
`) && (t = t.slice(29)), e = t.indexOf(`
`), e !== -1 && (t = t.slice(e + 1)), e = t.indexOf("react_stack_bottom_frame"), e !== -1 && (e = t.lastIndexOf(
        `
`,
        e
      )), e !== -1)
        t = t.slice(0, e);
      else return "";
      return t;
    }
    function dr(t) {
      switch (t.tag) {
        case 26:
        case 27:
        case 5:
          return Nn(t.type);
        case 16:
          return Nn("Lazy");
        case 13:
          return Nn("Suspense");
        case 19:
          return Nn("SuspenseList");
        case 0:
        case 15:
          return Vn(t.type, !1);
        case 11:
          return Vn(t.type.render, !1);
        case 1:
          return Vn(t.type, !0);
        case 31:
          return Nn("Activity");
        default:
          return "";
      }
    }
    function ea(t) {
      try {
        var e = "";
        do {
          e += dr(t);
          var a = t._debugInfo;
          if (a)
            for (var f = a.length - 1; 0 <= f; f--) {
              var p = a[f];
              if (typeof p.name == "string") {
                var y = e, M = p.env, A = Nn(
                  p.name + (M ? " [" + M + "]" : "")
                );
                e = y + A;
              }
            }
          t = t.return;
        } while (t);
        return e;
      } catch (B) {
        return `
Error generating stack: ` + B.message + `
` + B.stack;
      }
    }
    function It(t) {
      return (t = t ? t.displayName || t.name : "") ? Nn(t) : "";
    }
    function mu() {
      if (ro === null) return null;
      var t = ro._debugOwner;
      return t != null ? Yt(t) : null;
    }
    function Df() {
      if (ro === null) return "";
      var t = ro;
      try {
        var e = "";
        switch (t.tag === 6 && (t = t.return), t.tag) {
          case 26:
          case 27:
          case 5:
            e += Nn(t.type);
            break;
          case 13:
            e += Nn("Suspense");
            break;
          case 19:
            e += Nn("SuspenseList");
            break;
          case 31:
            e += Nn("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            t._debugOwner || e !== "" || (e += It(
              t.type
            ));
            break;
          case 11:
            t._debugOwner || e !== "" || (e += It(
              t.type.render
            ));
        }
        for (; t; )
          if (typeof t.tag == "number") {
            var a = t;
            t = a._debugOwner;
            var f = a._debugStack;
            t && f && (typeof f != "string" && (a._debugStack = f = Ei(f)), f !== "" && (e += `
` + f));
          } else if (t.debugStack != null) {
            var p = t.debugStack;
            (t = t.owner) && p && (e += `
` + Ei(p));
          } else break;
        var y = e;
      } catch (M) {
        y = `
Error generating stack: ` + M.message + `
` + M.stack;
      }
      return y;
    }
    function Pt(t, e, a, f, p, y, M) {
      var A = ro;
      mr(t);
      try {
        return t !== null && t._debugTask ? t._debugTask.run(
          e.bind(null, a, f, p, y, M)
        ) : e(a, f, p, y, M);
      } finally {
        mr(A);
      }
      throw Error(
        "runWithFiberInDEV should never be called in production. This is a bug in React."
      );
    }
    function mr(t) {
      ft.getCurrentStack = t === null ? null : Df, Na = !1, ro = t;
    }
    function Un(t) {
      switch (typeof t) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return t;
        case "object":
          return Mt(t), t;
        default:
          return "";
      }
    }
    function bl(t) {
      var e = t.type;
      return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
    }
    function yo(t) {
      var e = bl(t) ? "checked" : "value", a = Object.getOwnPropertyDescriptor(
        t.constructor.prototype,
        e
      );
      Mt(t[e]);
      var f = "" + t[e];
      if (!t.hasOwnProperty(e) && typeof a < "u" && typeof a.get == "function" && typeof a.set == "function") {
        var p = a.get, y = a.set;
        return Object.defineProperty(t, e, {
          configurable: !0,
          get: function() {
            return p.call(this);
          },
          set: function(M) {
            Mt(M), f = "" + M, y.call(this, M);
          }
        }), Object.defineProperty(t, e, {
          enumerable: a.enumerable
        }), {
          getValue: function() {
            return f;
          },
          setValue: function(M) {
            Mt(M), f = "" + M;
          },
          stopTracking: function() {
            t._valueTracker = null, delete t[e];
          }
        };
      }
    }
    function vo(t) {
      t._valueTracker || (t._valueTracker = yo(t));
    }
    function Bn(t) {
      if (!t) return !1;
      var e = t._valueTracker;
      if (!e) return !0;
      var a = e.getValue(), f = "";
      return t && (f = bl(t) ? t.checked ? "true" : "false" : t.value), t = f, t !== a ? (e.setValue(t), !0) : !1;
    }
    function pu(t) {
      if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
      try {
        return t.activeElement || t.body;
      } catch {
        return t.body;
      }
    }
    function na(t) {
      return t.replace(
        X0,
        function(e) {
          return "\\" + e.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function Sl(t, e) {
      e.checked === void 0 || e.defaultChecked === void 0 || ny || (console.error(
        "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        mu() || "A component",
        e.type
      ), ny = !0), e.value === void 0 || e.defaultValue === void 0 || ey || (console.error(
        "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        mu() || "A component",
        e.type
      ), ey = !0);
    }
    function Wo(t, e, a, f, p, y, M, A) {
      t.name = "", M != null && typeof M != "function" && typeof M != "symbol" && typeof M != "boolean" ? (ct(M, "type"), t.type = M) : t.removeAttribute("type"), e != null ? M === "number" ? (e === 0 && t.value === "" || t.value != e) && (t.value = "" + Un(e)) : t.value !== "" + Un(e) && (t.value = "" + Un(e)) : M !== "submit" && M !== "reset" || t.removeAttribute("value"), e != null ? bs(t, M, Un(e)) : a != null ? bs(t, M, Un(a)) : f != null && t.removeAttribute("value"), p == null && y != null && (t.defaultChecked = !!y), p != null && (t.checked = p && typeof p != "function" && typeof p != "symbol"), A != null && typeof A != "function" && typeof A != "symbol" && typeof A != "boolean" ? (ct(A, "name"), t.name = "" + Un(A)) : t.removeAttribute("name");
    }
    function bd(t, e, a, f, p, y, M, A) {
      if (y != null && typeof y != "function" && typeof y != "symbol" && typeof y != "boolean" && (ct(y, "type"), t.type = y), e != null || a != null) {
        if (!(y !== "submit" && y !== "reset" || e != null))
          return;
        a = a != null ? "" + Un(a) : "", e = e != null ? "" + Un(e) : a, A || e === t.value || (t.value = e), t.defaultValue = e;
      }
      f = f ?? p, f = typeof f != "function" && typeof f != "symbol" && !!f, t.checked = A ? t.checked : !!f, t.defaultChecked = !!f, M != null && typeof M != "function" && typeof M != "symbol" && typeof M != "boolean" && (ct(M, "name"), t.name = M);
    }
    function bs(t, e, a) {
      e === "number" && pu(t.ownerDocument) === t || t.defaultValue === "" + a || (t.defaultValue = "" + a);
    }
    function Af(t, e) {
      e.value == null && (typeof e.children == "object" && e.children !== null ? Dh.Children.forEach(e.children, function(a) {
        a == null || typeof a == "string" || typeof a == "number" || typeof a == "bigint" || ay || (ay = !0, console.error(
          "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
        ));
      }) : e.dangerouslySetInnerHTML == null || Im || (Im = !0, console.error(
        "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
      ))), e.selected == null || iy || (console.error(
        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
      ), iy = !0);
    }
    function Sd() {
      var t = mu();
      return t ? `

Check the render method of \`` + t + "`." : "";
    }
    function Io(t, e, a, f) {
      if (t = t.options, e) {
        e = {};
        for (var p = 0; p < a.length; p++)
          e["$" + a[p]] = !0;
        for (a = 0; a < t.length; a++)
          p = e.hasOwnProperty("$" + t[a].value), t[a].selected !== p && (t[a].selected = p), p && f && (t[a].defaultSelected = !0);
      } else {
        for (a = "" + Un(a), e = null, p = 0; p < t.length; p++) {
          if (t[p].value === a) {
            t[p].selected = !0, f && (t[p].defaultSelected = !0);
            return;
          }
          e !== null || t[p].disabled || (e = t[p]);
        }
        e !== null && (e.selected = !0);
      }
    }
    function gu(t, e) {
      for (t = 0; t < Uh.length; t++) {
        var a = Uh[t];
        if (e[a] != null) {
          var f = de(e[a]);
          e.multiple && !f ? console.error(
            "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
            a,
            Sd()
          ) : !e.multiple && f && console.error(
            "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
            a,
            Sd()
          );
        }
      }
      e.value === void 0 || e.defaultValue === void 0 || oy || (console.error(
        "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
      ), oy = !0);
    }
    function _o(t, e) {
      e.value === void 0 || e.defaultValue === void 0 || u_ || (console.error(
        "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
        mu() || "A component"
      ), u_ = !0), e.children != null && e.value == null && console.error(
        "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
      );
    }
    function pr(t, e, a) {
      if (e != null && (e = "" + Un(e), e !== t.value && (t.value = e), a == null)) {
        t.defaultValue !== e && (t.defaultValue = e);
        return;
      }
      t.defaultValue = a != null ? "" + Un(a) : "";
    }
    function Ss(t, e, a, f) {
      if (e == null) {
        if (f != null) {
          if (a != null)
            throw Error(
              "If you supply `defaultValue` on a <textarea>, do not pass children."
            );
          if (de(f)) {
            if (1 < f.length)
              throw Error("<textarea> can only have at most one child.");
            f = f[0];
          }
          a = f;
        }
        a == null && (a = ""), e = a;
      }
      a = Un(e), t.defaultValue = a, f = t.textContent, f === a && f !== "" && f !== null && (t.value = f);
    }
    function Tl(t, e) {
      return t.serverProps === void 0 && t.serverTail.length === 0 && t.children.length === 1 && 3 < t.distanceFromLeaf && t.distanceFromLeaf > 15 - e ? Tl(t.children[0], e) : t;
    }
    function di(t) {
      return "  " + "  ".repeat(t);
    }
    function ya(t) {
      return "+ " + "  ".repeat(t);
    }
    function we(t) {
      return "- " + "  ".repeat(t);
    }
    function ln(t) {
      switch (t.tag) {
        case 26:
        case 27:
        case 5:
          return t.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return t = t.type, t.displayName || t.name || null;
        case 11:
          return t = t.type.render, t.displayName || t.name || null;
        case 1:
          return t = t.type, t.displayName || t.name || null;
        default:
          return null;
      }
    }
    function Yn(t, e) {
      return c_.test(t) ? (t = JSON.stringify(t), t.length > e - 2 ? 8 > e ? '{"..."}' : "{" + t.slice(0, e - 7) + '..."}' : "{" + t + "}") : t.length > e ? 5 > e ? '{"..."}' : t.slice(0, e - 3) + "..." : t;
    }
    function bo(t, e, a) {
      var f = 120 - 2 * a;
      if (e === null)
        return ya(a) + Yn(t, f) + `
`;
      if (typeof e == "string") {
        for (var p = 0; p < e.length && p < t.length && e.charCodeAt(p) === t.charCodeAt(p); p++) ;
        return p > f - 8 && 10 < p && (t = "..." + t.slice(p - 8), e = "..." + e.slice(p - 8)), ya(a) + Yn(t, f) + `
` + we(a) + Yn(e, f) + `
`;
      }
      return di(a) + Yn(t, f) + `
`;
    }
    function xl(t) {
      return Object.prototype.toString.call(t).replace(/^\[object (.*)\]$/, function(e, a) {
        return a;
      });
    }
    function So(t, e) {
      switch (typeof t) {
        case "string":
          return t = JSON.stringify(t), t.length > e ? 5 > e ? '"..."' : t.slice(0, e - 4) + '..."' : t;
        case "object":
          if (t === null) return "null";
          if (de(t)) return "[...]";
          if (t.$$typeof === Vr)
            return (e = Ct(t.type)) ? "<" + e + ">" : "<...>";
          var a = xl(t);
          if (a === "Object") {
            a = "", e -= 2;
            for (var f in t)
              if (t.hasOwnProperty(f)) {
                var p = JSON.stringify(f);
                if (p !== '"' + f + '"' && (f = p), e -= f.length - 2, p = So(
                  t[f],
                  15 > e ? e : 15
                ), e -= p.length, 0 > e) {
                  a += a === "" ? "..." : ", ...";
                  break;
                }
                a += (a === "" ? "" : ",") + f + ":" + p;
              }
            return "{" + a + "}";
          }
          return a;
        case "function":
          return (e = t.displayName || t.name) ? "function " + e : "function";
        default:
          return String(t);
      }
    }
    function le(t, e) {
      return typeof t != "string" || c_.test(t) ? "{" + So(t, e - 2) + "}" : t.length > e - 2 ? 5 > e ? '"..."' : '"' + t.slice(0, e - 5) + '..."' : '"' + t + '"';
    }
    function Fe(t, e, a) {
      var f = 120 - a.length - t.length, p = [], y;
      for (y in e)
        if (e.hasOwnProperty(y) && y !== "children") {
          var M = le(
            e[y],
            120 - a.length - y.length - 1
          );
          f -= y.length + M.length + 2, p.push(y + "=" + M);
        }
      return p.length === 0 ? a + "<" + t + `>
` : 0 < f ? a + "<" + t + " " + p.join(" ") + `>
` : a + "<" + t + `
` + a + "  " + p.join(`
` + a + "  ") + `
` + a + `>
`;
    }
    function Rf(t, e, a) {
      var f = "", p = Me({}, e), y;
      for (y in t)
        if (t.hasOwnProperty(y)) {
          delete p[y];
          var M = 120 - 2 * a - y.length - 2, A = So(t[y], M);
          e.hasOwnProperty(y) ? (M = So(e[y], M), f += ya(a) + y + ": " + A + `
`, f += we(a) + y + ": " + M + `
`) : f += ya(a) + y + ": " + A + `
`;
        }
      for (var B in p)
        p.hasOwnProperty(B) && (t = So(
          p[B],
          120 - 2 * a - B.length - 2
        ), f += we(a) + B + ": " + t + `
`);
      return f;
    }
    function Oi(t, e, a, f) {
      var p = "", y = /* @__PURE__ */ new Map();
      for (Y in a)
        a.hasOwnProperty(Y) && y.set(
          Y.toLowerCase(),
          Y
        );
      if (y.size === 1 && y.has("children"))
        p += Fe(
          t,
          e,
          di(f)
        );
      else {
        for (var M in e)
          if (e.hasOwnProperty(M) && M !== "children") {
            var A = 120 - 2 * (f + 1) - M.length - 1, B = y.get(M.toLowerCase());
            if (B !== void 0) {
              y.delete(M.toLowerCase());
              var Y = e[M];
              B = a[B];
              var lt = le(
                Y,
                A
              );
              A = le(
                B,
                A
              ), typeof Y == "object" && Y !== null && typeof B == "object" && B !== null && xl(Y) === "Object" && xl(B) === "Object" && (2 < Object.keys(Y).length || 2 < Object.keys(B).length || -1 < lt.indexOf("...") || -1 < A.indexOf("...")) ? p += di(f + 1) + M + `={{
` + Rf(
                Y,
                B,
                f + 2
              ) + di(f + 1) + `}}
` : (p += ya(f + 1) + M + "=" + lt + `
`, p += we(f + 1) + M + "=" + A + `
`);
            } else
              p += di(f + 1) + M + "=" + le(e[M], A) + `
`;
          }
        y.forEach(function(pt) {
          if (pt !== "children") {
            var at = 120 - 2 * (f + 1) - pt.length - 1;
            p += we(f + 1) + pt + "=" + le(a[pt], at) + `
`;
          }
        }), p = p === "" ? di(f) + "<" + t + `>
` : di(f) + "<" + t + `
` + p + di(f) + `>
`;
      }
      return t = a.children, e = e.children, typeof t == "string" || typeof t == "number" || typeof t == "bigint" ? (y = "", (typeof e == "string" || typeof e == "number" || typeof e == "bigint") && (y = "" + e), p += bo(y, "" + t, f + 1)) : (typeof e == "string" || typeof e == "number" || typeof e == "bigint") && (p = t == null ? p + bo("" + e, null, f + 1) : p + bo("" + e, void 0, f + 1)), p;
    }
    function Di(t, e) {
      var a = ln(t);
      if (a === null) {
        for (a = "", t = t.child; t; )
          a += Di(t, e), t = t.sibling;
        return a;
      }
      return di(e) + "<" + a + `>
`;
    }
    function gc(t, e) {
      var a = Tl(t, e);
      if (a !== t && (t.children.length !== 1 || t.children[0] !== a))
        return di(e) + `...
` + gc(a, e + 1);
      a = "";
      var f = t.fiber._debugInfo;
      if (f)
        for (var p = 0; p < f.length; p++) {
          var y = f[p].name;
          typeof y == "string" && (a += di(e) + "<" + y + `>
`, e++);
        }
      if (f = "", p = t.fiber.pendingProps, t.fiber.tag === 6)
        f = bo(p, t.serverProps, e), e++;
      else if (y = ln(t.fiber), y !== null)
        if (t.serverProps === void 0) {
          f = e;
          var M = 120 - 2 * f - y.length - 2, A = "";
          for (Y in p)
            if (p.hasOwnProperty(Y) && Y !== "children") {
              var B = le(p[Y], 15);
              if (M -= Y.length + B.length + 2, 0 > M) {
                A += " ...";
                break;
              }
              A += " " + Y + "=" + B;
            }
          f = di(f) + "<" + y + A + `>
`, e++;
        } else
          t.serverProps === null ? (f = Fe(
            y,
            p,
            ya(e)
          ), e++) : typeof t.serverProps == "string" ? console.error(
            "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
          ) : (f = Oi(
            y,
            p,
            t.serverProps,
            e
          ), e++);
      var Y = "";
      for (p = t.fiber.child, y = 0; p && y < t.children.length; )
        M = t.children[y], M.fiber === p ? (Y += gc(M, e), y++) : Y += Di(p, e), p = p.sibling;
      for (p && 0 < t.children.length && (Y += di(e) + `...
`), p = t.serverTail, t.serverProps === null && e--, t = 0; t < p.length; t++)
        y = p[t], Y = typeof y == "string" ? Y + (we(e) + Yn(y, 120 - 2 * e) + `
`) : Y + Fe(
          y.type,
          y.props,
          we(e)
        );
      return a + f + Y;
    }
    function wl(t) {
      try {
        return `

` + gc(t, 0);
      } catch {
        return "";
      }
    }
    function ia(t, e, a) {
      for (var f = e, p = null, y = 0; f; )
        f === t && (y = 0), p = {
          fiber: f,
          children: p !== null ? [p] : [],
          serverProps: f === e ? a : f === t ? null : void 0,
          serverTail: [],
          distanceFromLeaf: y
        }, y++, f = f.return;
      return p !== null ? wl(p).replaceAll(/^[+-]/gm, ">") : "";
    }
    function yn(t, e) {
      var a = Me({}, t || ry), f = { tag: e };
      return $m.indexOf(e) !== -1 && (a.aTagInScope = null, a.buttonTagInScope = null, a.nobrTagInScope = null), Jm.indexOf(e) !== -1 && (a.pTagInButtonScope = null), ly.indexOf(e) !== -1 && e !== "address" && e !== "div" && e !== "p" && (a.listItemTagAutoclosing = null, a.dlItemTagAutoclosing = null), a.current = f, e === "form" && (a.formTag = f), e === "a" && (a.aTagInScope = f), e === "button" && (a.buttonTagInScope = f), e === "nobr" && (a.nobrTagInScope = f), e === "p" && (a.pTagInButtonScope = f), e === "li" && (a.listItemTagAutoclosing = f), (e === "dd" || e === "dt") && (a.dlItemTagAutoclosing = f), e === "#document" || e === "html" ? a.containerTagInScope = null : a.containerTagInScope || (a.containerTagInScope = f), t !== null || e !== "#document" && e !== "html" && e !== "body" ? a.implicitRootScope === !0 && (a.implicitRootScope = !1) : a.implicitRootScope = !0, a;
    }
    function $o(t, e, a) {
      switch (e) {
        case "select":
          return t === "hr" || t === "option" || t === "optgroup" || t === "script" || t === "template" || t === "#text";
        case "optgroup":
          return t === "option" || t === "#text";
        case "option":
          return t === "#text";
        case "tr":
          return t === "th" || t === "td" || t === "style" || t === "script" || t === "template";
        case "tbody":
        case "thead":
        case "tfoot":
          return t === "tr" || t === "style" || t === "script" || t === "template";
        case "colgroup":
          return t === "col" || t === "template";
        case "table":
          return t === "caption" || t === "colgroup" || t === "tbody" || t === "tfoot" || t === "thead" || t === "style" || t === "script" || t === "template";
        case "head":
          return t === "base" || t === "basefont" || t === "bgsound" || t === "link" || t === "meta" || t === "title" || t === "noscript" || t === "noframes" || t === "style" || t === "script" || t === "template";
        case "html":
          if (a) break;
          return t === "head" || t === "body" || t === "frameset";
        case "frameset":
          return t === "frame";
        case "#document":
          if (!a) return t === "html";
      }
      switch (t) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return e !== "h1" && e !== "h2" && e !== "h3" && e !== "h4" && e !== "h5" && e !== "h6";
        case "rp":
        case "rt":
          return sy.indexOf(e) === -1;
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return e == null;
        case "head":
          return a || e === null;
        case "html":
          return a && e === "#document" || e === null;
        case "body":
          return a && (e === "#document" || e === "html") || e === null;
      }
      return !0;
    }
    function To(t, e) {
      switch (t) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return e.pTagInButtonScope;
        case "form":
          return e.formTag || e.pTagInButtonScope;
        case "li":
          return e.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return e.dlItemTagAutoclosing;
        case "button":
          return e.buttonTagInScope;
        case "a":
          return e.aTagInScope;
        case "nobr":
          return e.nobrTagInScope;
      }
      return null;
    }
    function gr(t, e) {
      for (; t; ) {
        switch (t.tag) {
          case 5:
          case 26:
          case 27:
            if (t.type === e) return t;
        }
        t = t.return;
      }
      return null;
    }
    function yr(t, e) {
      e = e || ry;
      var a = e.current;
      if (e = (a = $o(
        t,
        a && a.tag,
        e.implicitRootScope
      ) ? null : a) ? null : To(t, e), e = a || e, !e) return !0;
      var f = e.tag;
      if (e = String(!!a) + "|" + t + "|" + f, sf[e]) return !1;
      sf[e] = !0;
      var p = (e = ro) ? gr(e.return, f) : null, y = e !== null && p !== null ? ia(p, e, null) : "", M = "<" + t + ">";
      return a ? (a = "", f === "table" && t === "tr" && (a += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
        `In HTML, %s cannot be a child of <%s>.%s
This will cause a hydration error.%s`,
        M,
        f,
        a,
        y
      )) : console.error(
        `In HTML, %s cannot be a descendant of <%s>.
This will cause a hydration error.%s`,
        M,
        f,
        y
      ), e && (t = e.return, p === null || t === null || p === t && t._debugOwner === e._debugOwner || Pt(p, function() {
        console.error(
          `<%s> cannot contain a nested %s.
See this log for the ancestor stack trace.`,
          f,
          M
        );
      })), !1;
    }
    function Jo(t, e, a) {
      if (a || $o("#text", e, !1))
        return !0;
      if (a = "#text|" + e, sf[a]) return !1;
      sf[a] = !0;
      var f = (a = ro) ? gr(a, e) : null;
      return a = a !== null && f !== null ? ia(
        f,
        a,
        a.tag !== 6 ? { children: null } : null
      ) : "", /\S/.test(t) ? console.error(
        `In HTML, text nodes cannot be a child of <%s>.
This will cause a hydration error.%s`,
        e,
        a
      ) : console.error(
        `In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.
This will cause a hydration error.%s`,
        e,
        a
      ), !1;
    }
    function Fo(t, e) {
      if (e) {
        var a = t.firstChild;
        if (a && a === t.lastChild && a.nodeType === 3) {
          a.nodeValue = e;
          return;
        }
      }
      t.textContent = e;
    }
    function Cf(t) {
      return t.replace($r, function(e, a) {
        return a.toUpperCase();
      });
    }
    function yu(t, e, a) {
      var f = e.indexOf("--") === 0;
      f || (-1 < e.indexOf("-") ? Ku.hasOwnProperty(e) && Ku[e] || (Ku[e] = !0, console.error(
        "Unsupported style property %s. Did you mean %s?",
        e,
        Cf(e.replace(Yh, "ms-"))
      )) : Bh.test(e) ? Ku.hasOwnProperty(e) && Ku[e] || (Ku[e] = !0, console.error(
        "Unsupported vendor-prefixed style property %s. Did you mean %s?",
        e,
        e.charAt(0).toUpperCase() + e.slice(1)
      )) : !f_.test(a) || Wu.hasOwnProperty(a) && Wu[a] || (Wu[a] = !0, console.error(
        `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
        e,
        a.replace(f_, "")
      )), typeof a == "number" && (isNaN(a) ? h_ || (h_ = !0, console.error(
        "`NaN` is an invalid value for the `%s` css style property.",
        e
      )) : isFinite(a) || uy || (uy = !0, console.error(
        "`Infinity` is an invalid value for the `%s` css style property.",
        e
      )))), a == null || typeof a == "boolean" || a === "" ? f ? t.setProperty(e, "") : e === "float" ? t.cssFloat = "" : t[e] = "" : f ? t.setProperty(e, a) : typeof a != "number" || a === 0 || jh.has(e) ? e === "float" ? t.cssFloat = a : (bt(a, e), t[e] = ("" + a).trim()) : t[e] = a + "px";
    }
    function Ts(t, e, a) {
      if (e != null && typeof e != "object")
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      if (e && Object.freeze(e), t = t.style, a != null) {
        if (e) {
          var f = {};
          if (a) {
            for (var p in a)
              if (a.hasOwnProperty(p) && !e.hasOwnProperty(p))
                for (var y = as[p] || [p], M = 0; M < y.length; M++)
                  f[y[M]] = p;
          }
          for (var A in e)
            if (e.hasOwnProperty(A) && (!a || a[A] !== e[A]))
              for (p = as[A] || [A], y = 0; y < p.length; y++)
                f[p[y]] = A;
          A = {};
          for (var B in e)
            for (p = as[B] || [B], y = 0; y < p.length; y++)
              A[p[y]] = B;
          B = {};
          for (var Y in f)
            if (p = f[Y], (y = A[Y]) && p !== y && (M = p + "," + y, !B[M])) {
              B[M] = !0, M = console;
              var lt = e[p];
              M.error.call(
                M,
                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                lt == null || typeof lt == "boolean" || lt === "" ? "Removing" : "Updating",
                p,
                y
              );
            }
        }
        for (var pt in a)
          !a.hasOwnProperty(pt) || e != null && e.hasOwnProperty(pt) || (pt.indexOf("--") === 0 ? t.setProperty(pt, "") : pt === "float" ? t.cssFloat = "" : t[pt] = "");
        for (var at in e)
          Y = e[at], e.hasOwnProperty(at) && a[at] !== Y && yu(t, at, Y);
      } else
        for (f in e)
          e.hasOwnProperty(f) && yu(t, f, e[f]);
    }
    function tl(t) {
      if (t.indexOf("-") === -1) return !1;
      switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function xs(t) {
      return Fm.get(t) || t;
    }
    function ws(t, e) {
      if ($s.call(os, e) && os[e])
        return !0;
      if (tp.test(e)) {
        if (t = "aria-" + e.slice(4).toLowerCase(), t = cy.hasOwnProperty(t) ? t : null, t == null)
          return console.error(
            "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
            e
          ), os[e] = !0;
        if (e !== t)
          return console.error(
            "Invalid ARIA attribute `%s`. Did you mean `%s`?",
            e,
            t
          ), os[e] = !0;
      }
      if (fy.test(e)) {
        if (t = e.toLowerCase(), t = cy.hasOwnProperty(t) ? t : null, t == null) return os[e] = !0, !1;
        e !== t && (console.error(
          "Unknown ARIA attribute `%s`. Did you mean `%s`?",
          e,
          t
        ), os[e] = !0);
      }
      return !0;
    }
    function Ml(t, e) {
      var a = [], f;
      for (f in e)
        ws(t, f) || a.push(f);
      e = a.map(function(p) {
        return "`" + p + "`";
      }).join(", "), a.length === 1 ? console.error(
        "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        e,
        t
      ) : 1 < a.length && console.error(
        "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        e,
        t
      );
    }
    function Td(t, e, a, f) {
      if ($s.call(ua, e) && ua[e])
        return !0;
      var p = e.toLowerCase();
      if (p === "onfocusin" || p === "onfocusout")
        return console.error(
          "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
        ), ua[e] = !0;
      if (typeof a == "function" && (t === "form" && e === "action" || t === "input" && e === "formAction" || t === "button" && e === "formAction"))
        return !0;
      if (f != null) {
        if (t = f.possibleRegistrationNames, f.registrationNameDependencies.hasOwnProperty(e))
          return !0;
        if (f = t.hasOwnProperty(p) ? t[p] : null, f != null)
          return console.error(
            "Invalid event handler property `%s`. Did you mean `%s`?",
            e,
            f
          ), ua[e] = !0;
        if (Zh.test(e))
          return console.error(
            "Unknown event handler property `%s`. It will be ignored.",
            e
          ), ua[e] = !0;
      } else if (Zh.test(e))
        return n.test(e) && console.error(
          "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
          e
        ), ua[e] = !0;
      if (o.test(e) || c.test(e)) return !0;
      if (p === "innerhtml")
        return console.error(
          "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
        ), ua[e] = !0;
      if (p === "aria")
        return console.error(
          "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
        ), ua[e] = !0;
      if (p === "is" && a !== null && a !== void 0 && typeof a != "string")
        return console.error(
          "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
          typeof a
        ), ua[e] = !0;
      if (typeof a == "number" && isNaN(a))
        return console.error(
          "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
          e
        ), ua[e] = !0;
      if (Iu.hasOwnProperty(p)) {
        if (p = Iu[p], p !== e)
          return console.error(
            "Invalid DOM property `%s`. Did you mean `%s`?",
            e,
            p
          ), ua[e] = !0;
      } else if (e !== p)
        return console.error(
          "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
          e,
          p
        ), ua[e] = !0;
      switch (e) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof a) {
        case "boolean":
          switch (e) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              return p = e.toLowerCase().slice(0, 5), p === "data-" || p === "aria-" ? !0 : (a ? console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                a,
                e,
                e,
                a,
                e
              ) : console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                a,
                e,
                e,
                a,
                e,
                e,
                e
              ), ua[e] = !0);
          }
        case "function":
        case "symbol":
          return ua[e] = !0, !1;
        case "string":
          if (a === "false" || a === "true") {
            switch (e) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error(
              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
              a,
              e,
              a === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
              e,
              a
            ), ua[e] = !0;
          }
      }
      return !0;
    }
    function ce(t, e, a) {
      var f = [], p;
      for (p in e)
        Td(t, p, e[p], a) || f.push(p);
      e = f.map(function(y) {
        return "`" + y + "`";
      }).join(", "), f.length === 1 ? console.error(
        "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        e,
        t
      ) : 1 < f.length && console.error(
        "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        e,
        t
      );
    }
    function Ai(t) {
      return m.test("" + t) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : t;
    }
    function Ye(t) {
      return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
    }
    function Xa(t) {
      var e = Pn(t);
      if (e && (t = e.stateNode)) {
        var a = t[ka] || null;
        t: switch (t = e.stateNode, e.type) {
          case "input":
            if (Wo(
              t,
              a.value,
              a.defaultValue,
              a.defaultValue,
              a.checked,
              a.defaultChecked,
              a.type,
              a.name
            ), e = a.name, a.type === "radio" && e != null) {
              for (a = t; a.parentNode; ) a = a.parentNode;
              for (ct(e, "name"), a = a.querySelectorAll(
                'input[name="' + na(
                  "" + e
                ) + '"][type="radio"]'
              ), e = 0; e < a.length; e++) {
                var f = a[e];
                if (f !== t && f.form === t.form) {
                  var p = f[ka] || null;
                  if (!p)
                    throw Error(
                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                    );
                  Wo(
                    f,
                    p.value,
                    p.defaultValue,
                    p.defaultValue,
                    p.checked,
                    p.defaultChecked,
                    p.type,
                    p.name
                  );
                }
              }
              for (e = 0; e < a.length; e++)
                f = a[e], f.form === t.form && Bn(f);
            }
            break t;
          case "textarea":
            pr(t, a.value, a.defaultValue);
            break t;
          case "select":
            e = a.value, e != null && Io(t, !!a.multiple, e, !1);
        }
      }
    }
    function vr(t, e, a) {
      if (U) return t(e, a);
      U = !0;
      try {
        var f = t(e);
        return f;
      } finally {
        if (U = !1, (x !== null || R !== null) && (Nu(), x && (e = x, t = R, R = x = null, Xa(e), t)))
          for (e = 0; e < t.length; e++) Xa(t[e]);
      }
    }
    function Qa(t, e) {
      var a = t.stateNode;
      if (a === null) return null;
      var f = a[ka] || null;
      if (f === null) return null;
      a = f[e];
      t: switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (f = !f.disabled) || (t = t.type, f = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !f;
          break t;
        default:
          t = !1;
      }
      if (t) return null;
      if (a && typeof a != "function")
        throw Error(
          "Expected `" + e + "` listener to be a function, instead got a value of `" + typeof a + "` type."
        );
      return a;
    }
    function Ka() {
      if (st) return st;
      var t, e = ot, a = e.length, f, p = "value" in St ? St.value : St.textContent, y = p.length;
      for (t = 0; t < a && e[t] === p[t]; t++) ;
      var M = a - t;
      for (f = 1; f <= M && e[a - f] === p[y - f]; f++) ;
      return st = p.slice(t, 1 < f ? 1 - f : void 0);
    }
    function va(t) {
      var e = t.keyCode;
      return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
    }
    function el() {
      return !0;
    }
    function Ms() {
      return !1;
    }
    function Ue(t) {
      function e(a, f, p, y, M) {
        this._reactName = a, this._targetInst = p, this.type = f, this.nativeEvent = y, this.target = M, this.currentTarget = null;
        for (var A in t)
          t.hasOwnProperty(A) && (a = t[A], this[A] = a ? a(y) : y[A]);
        return this.isDefaultPrevented = (y.defaultPrevented != null ? y.defaultPrevented : y.returnValue === !1) ? el : Ms, this.isPropagationStopped = Ms, this;
      }
      return Me(e.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var a = this.nativeEvent;
          a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1), this.isDefaultPrevented = el);
        },
        stopPropagation: function() {
          var a = this.nativeEvent;
          a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0), this.isPropagationStopped = el);
        },
        persist: function() {
        },
        isPersistent: el
      }), e;
    }
    function xo(t) {
      var e = this.nativeEvent;
      return e.getModifierState ? e.getModifierState(t) : (t = kM[t]) ? !!e[t] : !1;
    }
    function vu() {
      return xo;
    }
    function mi(t, e) {
      switch (t) {
        case "keyup":
          return QM.indexOf(e.keyCode) !== -1;
        case "keydown":
          return e.keyCode !== Z1;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function El(t) {
      return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
    }
    function _u(t, e) {
      switch (t) {
        case "compositionend":
          return El(e);
        case "keypress":
          return e.which !== V1 ? null : (X1 = !0, G1);
        case "textInput":
          return t = e.data, t === G1 && X1 ? null : t;
        default:
          return null;
      }
    }
    function Es(t, e) {
      if (ep)
        return t === "compositionend" || !K0 && mi(t, e) ? (t = Ka(), st = ot = St = null, ep = !1, t) : null;
      switch (t) {
        case "paste":
          return null;
        case "keypress":
          if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
              return e.char;
            if (e.which)
              return String.fromCharCode(e.which);
          }
          return null;
        case "compositionend":
          return P1 && e.locale !== "ko" ? null : e.data;
        default:
          return null;
      }
    }
    function xd(t) {
      var e = t && t.nodeName && t.nodeName.toLowerCase();
      return e === "input" ? !!WM[t.type] : e === "textarea";
    }
    function yc(t) {
      if (!Z) return !1;
      t = "on" + t;
      var e = t in document;
      return e || (e = document.createElement("div"), e.setAttribute(t, "return;"), e = typeof e[t] == "function"), e;
    }
    function Oe(t, e, a, f) {
      x ? R ? R.push(f) : R = [f] : x = f, e = _h(e, "onChange"), 0 < e.length && (a = new ee(
        "onChange",
        "change",
        null,
        a,
        f
      ), t.push({ event: a, listeners: e }));
    }
    function bu(t) {
      Il(t, 0);
    }
    function Jn(t) {
      var e = Va(t);
      if (Bn(e)) return t;
    }
    function Os(t, e) {
      if (t === "change") return e;
    }
    function zf() {
      my && (my.detachEvent("onpropertychange", wd), py = my = null);
    }
    function wd(t) {
      if (t.propertyName === "value" && Jn(py)) {
        var e = [];
        Oe(
          e,
          py,
          t,
          Ye(t)
        ), vr(bu, e);
      }
    }
    function Lf(t, e, a) {
      t === "focusin" ? (zf(), my = e, py = a, my.attachEvent("onpropertychange", wd)) : t === "focusout" && zf();
    }
    function Hf(t) {
      if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return Jn(py);
    }
    function Md(t, e) {
      if (t === "click") return Jn(e);
    }
    function Up(t, e) {
      if (t === "input" || t === "change")
        return Jn(e);
    }
    function Bp(t, e) {
      return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e;
    }
    function Ds(t, e) {
      if (uo(t, e)) return !0;
      if (typeof t != "object" || t === null || typeof e != "object" || e === null)
        return !1;
      var a = Object.keys(t), f = Object.keys(e);
      if (a.length !== f.length) return !1;
      for (f = 0; f < a.length; f++) {
        var p = a[f];
        if (!$s.call(e, p) || !uo(t[p], e[p]))
          return !1;
      }
      return !0;
    }
    function Ed(t) {
      for (; t && t.firstChild; ) t = t.firstChild;
      return t;
    }
    function _a(t, e) {
      var a = Ed(t);
      t = 0;
      for (var f; a; ) {
        if (a.nodeType === 3) {
          if (f = t + a.textContent.length, t <= e && f >= e)
            return { node: a, offset: e - t };
          t = f;
        }
        t: {
          for (; a; ) {
            if (a.nextSibling) {
              a = a.nextSibling;
              break t;
            }
            a = a.parentNode;
          }
          a = void 0;
        }
        a = Ed(a);
      }
    }
    function Od(t, e) {
      return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Od(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1;
    }
    function kf(t) {
      t = t != null && t.ownerDocument != null && t.ownerDocument.defaultView != null ? t.ownerDocument.defaultView : window;
      for (var e = pu(t.document); e instanceof t.HTMLIFrameElement; ) {
        try {
          var a = typeof e.contentWindow.location.href == "string";
        } catch {
          a = !1;
        }
        if (a) t = e.contentWindow;
        else break;
        e = pu(t.document);
      }
      return e;
    }
    function wo(t) {
      var e = t && t.nodeName && t.nodeName.toLowerCase();
      return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true");
    }
    function Nf(t, e, a) {
      var f = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument;
      I0 || np == null || np !== pu(f) || (f = np, "selectionStart" in f && wo(f) ? f = { start: f.selectionStart, end: f.selectionEnd } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = {
        anchorNode: f.anchorNode,
        anchorOffset: f.anchorOffset,
        focusNode: f.focusNode,
        focusOffset: f.focusOffset
      }), gy && Ds(gy, f) || (gy = f, f = _h(W0, "onSelect"), 0 < f.length && (e = new ee(
        "onSelect",
        "select",
        null,
        e,
        a
      ), t.push({ event: e, listeners: f }), e.target = np)));
    }
    function Mo(t, e) {
      var a = {};
      return a[t.toLowerCase()] = e.toLowerCase(), a["Webkit" + t] = "webkit" + e, a["Moz" + t] = "moz" + e, a;
    }
    function nl(t) {
      if ($0[t]) return $0[t];
      if (!ip[t]) return t;
      var e = ip[t], a;
      for (a in e)
        if (e.hasOwnProperty(a) && a in K1)
          return $0[t] = e[a];
      return t;
    }
    function Wa(t, e) {
      F1.set(t, e), At(e, [t]);
    }
    function qi(t, e) {
      if (typeof t == "object" && t !== null) {
        var a = F0.get(t);
        return a !== void 0 ? a : (e = {
          value: t,
          source: e,
          stack: ea(e)
        }, F0.set(t, e), e);
      }
      return {
        value: t,
        source: e,
        stack: ea(e)
      };
    }
    function _r() {
      for (var t = ap, e = tb = ap = 0; e < t; ) {
        var a = ls[e];
        ls[e++] = null;
        var f = ls[e];
        ls[e++] = null;
        var p = ls[e];
        ls[e++] = null;
        var y = ls[e];
        if (ls[e++] = null, f !== null && p !== null) {
          var M = f.pending;
          M === null ? p.next = p : (p.next = M.next, M.next = p), f.pending = p;
        }
        y !== 0 && Dd(a, p, y);
      }
    }
    function vc(t, e, a, f) {
      ls[ap++] = t, ls[ap++] = e, ls[ap++] = a, ls[ap++] = f, tb |= f, t.lanes |= f, t = t.alternate, t !== null && (t.lanes |= f);
    }
    function Uf(t, e, a, f) {
      return vc(t, e, a, f), Su(t);
    }
    function pi(t, e) {
      return vc(t, null, null, e), Su(t);
    }
    function Dd(t, e, a) {
      t.lanes |= a;
      var f = t.alternate;
      f !== null && (f.lanes |= a);
      for (var p = !1, y = t.return; y !== null; )
        y.childLanes |= a, f = y.alternate, f !== null && (f.childLanes |= a), y.tag === 22 && (t = y.stateNode, t === null || t._visibility & d_ || (p = !0)), t = y, y = y.return;
      return t.tag === 3 ? (y = t.stateNode, p && e !== null && (p = 31 - Wi(a), t = y.hiddenUpdates, f = t[p], f === null ? t[p] = [e] : f.push(e), e.lane = a | 536870912), y) : null;
    }
    function Su(t) {
      if (By > vE)
        throw ed = By = 0, Yy = Rb = null, Error(
          "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
        );
      ed > _E && (ed = 0, Yy = null, console.error(
        "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
      )), t.alternate === null && (t.flags & 4098) !== 0 && ml(t);
      for (var e = t, a = e.return; a !== null; )
        e.alternate === null && (e.flags & 4098) !== 0 && ml(t), e = a, a = e.return;
      return e.tag === 3 ? e.stateNode : null;
    }
    function Ol(t) {
      if (ss === null) return t;
      var e = ss(t);
      return e === void 0 ? t : e.current;
    }
    function br(t) {
      if (ss === null) return t;
      var e = ss(t);
      return e === void 0 ? t != null && typeof t.render == "function" && (e = Ol(t.render), t.render !== e) ? (e = { $$typeof: Ws, render: e }, t.displayName !== void 0 && (e.displayName = t.displayName), e) : t : e.current;
    }
    function Dl(t, e) {
      if (ss === null) return !1;
      var a = t.elementType;
      e = e.type;
      var f = !1, p = typeof e == "object" && e !== null ? e.$$typeof : null;
      switch (t.tag) {
        case 1:
          typeof e == "function" && (f = !0);
          break;
        case 0:
          (typeof e == "function" || p === so) && (f = !0);
          break;
        case 11:
          (p === Ws || p === so) && (f = !0);
          break;
        case 14:
        case 15:
          (p === Rh || p === so) && (f = !0);
          break;
        default:
          return !1;
      }
      return !!(f && (t = ss(a), t !== void 0 && t === ss(e)));
    }
    function Ad(t) {
      ss !== null && typeof WeakSet == "function" && (op === null && (op = /* @__PURE__ */ new WeakSet()), op.add(t));
    }
    function il(t, e, a) {
      var f = t.alternate, p = t.child, y = t.sibling, M = t.tag, A = t.type, B = null;
      switch (M) {
        case 0:
        case 15:
        case 1:
          B = A;
          break;
        case 11:
          B = A.render;
      }
      if (ss === null)
        throw Error("Expected resolveFamily to be set during hot reload.");
      var Y = !1;
      A = !1, B !== null && (B = ss(B), B !== void 0 && (a.has(B) ? A = !0 : e.has(B) && (M === 1 ? A = !0 : Y = !0))), op !== null && (op.has(t) || f !== null && op.has(f)) && (A = !0), A && (t._debugNeedsRemount = !0), (A || Y) && (f = pi(t, 2), f !== null && Rn(f, t, 2)), p === null || A || il(
        p,
        e,
        a
      ), y !== null && il(
        y,
        e,
        a
      );
    }
    function gi(t, e, a, f) {
      this.tag = t, this.key = a, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, eS || typeof Object.preventExtensions != "function" || Object.preventExtensions(this);
    }
    function _c(t) {
      return t = t.prototype, !(!t || !t.isReactComponent);
    }
    function Ia(t, e) {
      var a = t.alternate;
      switch (a === null ? (a = z(
        t.tag,
        e,
        t.key,
        t.mode
      ), a.elementType = t.elementType, a.type = t.type, a.stateNode = t.stateNode, a._debugOwner = t._debugOwner, a._debugStack = t._debugStack, a._debugTask = t._debugTask, a._debugHookTypes = t._debugHookTypes, a.alternate = t, t.alternate = a) : (a.pendingProps = e, a.type = t.type, a.flags = 0, a.subtreeFlags = 0, a.deletions = null, a.actualDuration = -0, a.actualStartTime = -1.1), a.flags = t.flags & 65011712, a.childLanes = t.childLanes, a.lanes = t.lanes, a.child = t.child, a.memoizedProps = t.memoizedProps, a.memoizedState = t.memoizedState, a.updateQueue = t.updateQueue, e = t.dependencies, a.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext,
        _debugThenableState: e._debugThenableState
      }, a.sibling = t.sibling, a.index = t.index, a.ref = t.ref, a.refCleanup = t.refCleanup, a.selfBaseDuration = t.selfBaseDuration, a.treeBaseDuration = t.treeBaseDuration, a._debugInfo = t._debugInfo, a._debugNeedsRemount = t._debugNeedsRemount, a.tag) {
        case 0:
        case 15:
          a.type = Ol(t.type);
          break;
        case 1:
          a.type = Ol(t.type);
          break;
        case 11:
          a.type = br(t.type);
      }
      return a;
    }
    function Bf(t, e) {
      t.flags &= 65011714;
      var a = t.alternate;
      return a === null ? (t.childLanes = 0, t.lanes = e, t.child = null, t.subtreeFlags = 0, t.memoizedProps = null, t.memoizedState = null, t.updateQueue = null, t.dependencies = null, t.stateNode = null, t.selfBaseDuration = 0, t.treeBaseDuration = 0) : (t.childLanes = a.childLanes, t.lanes = a.lanes, t.child = a.child, t.subtreeFlags = 0, t.deletions = null, t.memoizedProps = a.memoizedProps, t.memoizedState = a.memoizedState, t.updateQueue = a.updateQueue, t.type = a.type, e = a.dependencies, t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext,
        _debugThenableState: e._debugThenableState
      }, t.selfBaseDuration = a.selfBaseDuration, t.treeBaseDuration = a.treeBaseDuration), t;
    }
    function Sr(t, e, a, f, p, y) {
      var M = 0, A = t;
      if (typeof t == "function")
        _c(t) && (M = 1), A = Ol(A);
      else if (typeof t == "string")
        M = V(), M = Qc(t, a, M) ? 26 : t === "html" || t === "head" || t === "body" ? 27 : 5;
      else
        t: switch (t) {
          case Kg:
            return e = z(31, a, e, p), e.elementType = Kg, e.lanes = y, e;
          case _e:
            return Al(
              a.children,
              p,
              y,
              e
            );
          case Wc:
            M = 8, p |= Ua, p |= nr;
            break;
          case Ic:
            return t = a, f = p, typeof t.id != "string" && console.error(
              'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
              typeof t.id
            ), e = z(12, t, e, f | ca), e.elementType = Ic, e.lanes = y, e.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, e;
          case $c:
            return e = z(13, a, e, p), e.elementType = $c, e.lanes = y, e;
          case Gr:
            return e = z(19, a, e, p), e.elementType = Gr, e.lanes = y, e;
          default:
            if (typeof t == "object" && t !== null)
              switch (t.$$typeof) {
                case Qg:
                case qo:
                  M = 10;
                  break t;
                case Ym:
                  M = 9;
                  break t;
                case Ws:
                  M = 11, A = br(A);
                  break t;
                case Rh:
                  M = 14;
                  break t;
                case so:
                  M = 16, A = null;
                  break t;
              }
            A = "", (t === void 0 || typeof t == "object" && t !== null && Object.keys(t).length === 0) && (A += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), t === null ? a = "null" : de(t) ? a = "array" : t !== void 0 && t.$$typeof === Vr ? (a = "<" + (Ct(t.type) || "Unknown") + " />", A = " Did you accidentally export a JSX literal instead of a component?") : a = typeof t, (M = f ? Yt(f) : null) && (A += `

Check the render method of \`` + M + "`."), M = 29, a = Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (a + "." + A)
            ), A = null;
        }
      return e = z(M, a, e, p), e.elementType = t, e.type = A, e.lanes = y, e._debugOwner = f, e;
    }
    function As(t, e, a) {
      return e = Sr(
        t.type,
        t.key,
        t.props,
        t._owner,
        e,
        a
      ), e._debugOwner = t._owner, e._debugStack = t._debugStack, e._debugTask = t._debugTask, e;
    }
    function Al(t, e, a, f) {
      return t = z(7, t, f, e), t.lanes = a, t;
    }
    function Rl(t, e, a) {
      return t = z(6, t, null, e), t.lanes = a, t;
    }
    function bc(t, e, a) {
      return e = z(
        4,
        t.children !== null ? t.children : [],
        t.key,
        e
      ), e.lanes = a, e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
      }, e;
    }
    function Rs(t, e) {
      jn(), lp[sp++] = p_, lp[sp++] = m_, m_ = t, p_ = e;
    }
    function ba(t, e, a) {
      jn(), rs[us++] = Ju, rs[us++] = Fu, rs[us++] = Ph, Ph = t;
      var f = Ju;
      t = Fu;
      var p = 32 - Wi(f) - 1;
      f &= ~(1 << p), a += 1;
      var y = 32 - Wi(e) + p;
      if (30 < y) {
        var M = p - p % 5;
        y = (f & (1 << M) - 1).toString(32), f >>= M, p -= M, Ju = 1 << 32 - Wi(e) + p | a << p | f, Fu = y + t;
      } else
        Ju = 1 << y | a << p | f, Fu = t;
    }
    function al(t) {
      jn(), t.return !== null && (Rs(t, 1), ba(t, 1, 0));
    }
    function Sc(t) {
      for (; t === m_; )
        m_ = lp[--sp], lp[sp] = null, p_ = lp[--sp], lp[sp] = null;
      for (; t === Ph; )
        Ph = rs[--us], rs[us] = null, Fu = rs[--us], rs[us] = null, Ju = rs[--us], rs[us] = null;
    }
    function jn() {
      Pe || console.error(
        "Expected to be hydrating. This is a bug in React. Please file an issue."
      );
    }
    function $a(t, e) {
      if (t.return === null) {
        if (cs === null)
          cs = {
            fiber: t,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: e
          };
        else {
          if (cs.fiber !== t)
            throw Error(
              "Saw multiple hydration diff roots in a pass. This is a bug in React."
            );
          cs.distanceFromLeaf > e && (cs.distanceFromLeaf = e);
        }
        return cs;
      }
      var a = $a(
        t.return,
        e + 1
      ).children;
      return 0 < a.length && a[a.length - 1].fiber === t ? (a = a[a.length - 1], a.distanceFromLeaf > e && (a.distanceFromLeaf = e), a) : (e = {
        fiber: t,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: e
      }, a.push(e), e);
    }
    function Cl(t, e) {
      tc || (t = $a(t, 0), t.serverProps = null, e !== null && (e = Am(e), t.serverTail.push(e)));
    }
    function Eo(t) {
      var e = "", a = cs;
      throw a !== null && (cs = null, e = wl(a)), ol(
        qi(
          Error(
            `Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + e
          ),
          t
        )
      ), eb;
    }
    function Cs(t) {
      var e = t.stateNode, a = t.type, f = t.memoizedProps;
      switch (e[Ii] = t, e[ka] = f, $l(a, f), a) {
        case "dialog":
          Ce("cancel", e), Ce("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          Ce("load", e);
          break;
        case "video":
        case "audio":
          for (a = 0; a < jy.length; a++)
            Ce(jy[a], e);
          break;
        case "source":
          Ce("error", e);
          break;
        case "img":
        case "image":
        case "link":
          Ce("error", e), Ce("load", e);
          break;
        case "details":
          Ce("toggle", e);
          break;
        case "input":
          Xt("input", f), Ce("invalid", e), Sl(e, f), bd(
            e,
            f.value,
            f.defaultValue,
            f.checked,
            f.defaultChecked,
            f.type,
            f.name,
            !0
          ), vo(e);
          break;
        case "option":
          Af(e, f);
          break;
        case "select":
          Xt("select", f), Ce("invalid", e), gu(e, f);
          break;
        case "textarea":
          Xt("textarea", f), Ce("invalid", e), _o(e, f), Ss(
            e,
            f.value,
            f.defaultValue,
            f.children
          ), vo(e);
      }
      a = f.children, typeof a != "string" && typeof a != "number" && typeof a != "bigint" || e.textContent === "" + a || f.suppressHydrationWarning === !0 || Eg(e.textContent, a) ? (f.popover != null && (Ce("beforetoggle", e), Ce("toggle", e)), f.onScroll != null && Ce("scroll", e), f.onScrollEnd != null && Ce("scrollend", e), f.onClick != null && (e.onclick = Gs), e = !0) : e = !1, e || Eo(t);
    }
    function Tc(t) {
      for (co = t.return; co; )
        switch (co.tag) {
          case 5:
          case 13:
            Fr = !1;
            return;
          case 27:
          case 3:
            Fr = !0;
            return;
          default:
            co = co.return;
        }
    }
    function Oo(t) {
      if (t !== co) return !1;
      if (!Pe)
        return Tc(t), Pe = !0, !1;
      var e = t.tag, a;
      if ((a = e !== 3 && e !== 27) && ((a = e === 5) && (a = t.type, a = !(a !== "form" && a !== "button") || Jl(t.type, t.memoizedProps)), a = !a), a && Qn) {
        for (a = Qn; a; ) {
          var f = $a(t, 0), p = Am(a);
          f.serverTail.push(p), a = p.type === "Suspense" ? Hg(a) : ki(a.nextSibling);
        }
        Eo(t);
      }
      if (Tc(t), e === 13) {
        if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        Qn = Hg(t);
      } else
        e === 27 ? (e = Qn, Fl(t.type) ? (t = Zb, Zb = null, Qn = t) : Qn = e) : Qn = co ? ki(t.stateNode.nextSibling) : null;
      return !0;
    }
    function zs() {
      Qn = co = null, tc = Pe = !1;
    }
    function Do() {
      var t = Vh;
      return t !== null && (mo === null ? mo = t : mo.push.apply(
        mo,
        t
      ), Vh = null), t;
    }
    function ol(t) {
      Vh === null ? Vh = [t] : Vh.push(t);
    }
    function Yf() {
      var t = cs;
      if (t !== null) {
        cs = null;
        for (var e = wl(t); 0 < t.children.length; )
          t = t.children[0];
        Pt(t.fiber, function() {
          console.error(
            `A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`,
            "https://react.dev/link/hydration-mismatch",
            e
          );
        });
      }
    }
    function Tr() {
      rp = g_ = null, up = !1;
    }
    function zl(t, e, a) {
      Nt(nb, e._currentValue, t), e._currentValue = a, Nt(ib, e._currentRenderer, t), e._currentRenderer !== void 0 && e._currentRenderer !== null && e._currentRenderer !== oS && console.error(
        "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
      ), e._currentRenderer = oS;
    }
    function Fn(t, e) {
      t._currentValue = nb.current;
      var a = ib.current;
      Rt(ib, e), t._currentRenderer = a, Rt(nb, e);
    }
    function jf(t, e, a) {
      for (; t !== null; ) {
        var f = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e, f !== null && (f.childLanes |= e)) : f !== null && (f.childLanes & e) !== e && (f.childLanes |= e), t === a) break;
        t = t.return;
      }
      t !== a && console.error(
        "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Ll(t, e, a, f) {
      var p = t.child;
      for (p !== null && (p.return = t); p !== null; ) {
        var y = p.dependencies;
        if (y !== null) {
          var M = p.child;
          y = y.firstContext;
          t: for (; y !== null; ) {
            var A = y;
            y = p;
            for (var B = 0; B < e.length; B++)
              if (A.context === e[B]) {
                y.lanes |= a, A = y.alternate, A !== null && (A.lanes |= a), jf(
                  y.return,
                  a,
                  t
                ), f || (M = null);
                break t;
              }
            y = A.next;
          }
        } else if (p.tag === 18) {
          if (M = p.return, M === null)
            throw Error(
              "We just came from a parent so we must have had a parent. This is a bug in React."
            );
          M.lanes |= a, y = M.alternate, y !== null && (y.lanes |= a), jf(
            M,
            a,
            t
          ), M = null;
        } else M = p.child;
        if (M !== null) M.return = p;
        else
          for (M = p; M !== null; ) {
            if (M === t) {
              M = null;
              break;
            }
            if (p = M.sibling, p !== null) {
              p.return = M.return, M = p;
              break;
            }
            M = M.return;
          }
        p = M;
      }
    }
    function ti(t, e, a, f) {
      t = null;
      for (var p = e, y = !1; p !== null; ) {
        if (!y) {
          if ((p.flags & 524288) !== 0) y = !0;
          else if ((p.flags & 262144) !== 0) break;
        }
        if (p.tag === 10) {
          var M = p.alternate;
          if (M === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          if (M = M.memoizedProps, M !== null) {
            var A = p.type;
            uo(p.pendingProps.value, M.value) || (t !== null ? t.push(A) : t = [A]);
          }
        } else if (p === Fc.current) {
          if (M = p.alternate, M === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          M.memoizedState.memoizedState !== p.memoizedState.memoizedState && (t !== null ? t.push(Vy) : t = [Vy]);
        }
        p = p.return;
      }
      t !== null && Ll(
        e,
        t,
        a,
        f
      ), e.flags |= 262144;
    }
    function yi(t) {
      for (t = t.firstContext; t !== null; ) {
        if (!uo(
          t.context._currentValue,
          t.memoizedValue
        ))
          return !0;
        t = t.next;
      }
      return !1;
    }
    function Ja(t) {
      g_ = t, rp = null, t = t.dependencies, t !== null && (t.firstContext = null);
    }
    function tn(t) {
      return up && console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      ), xr(g_, t);
    }
    function Ls(t, e) {
      return g_ === null && Ja(t), xr(t, e);
    }
    function xr(t, e) {
      var a = e._currentValue;
      if (e = { context: e, memoizedValue: a, next: null }, rp === null) {
        if (t === null)
          throw Error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        rp = e, t.dependencies = {
          lanes: 0,
          firstContext: e,
          _debugThenableState: null
        }, t.flags |= 524288;
      } else rp = rp.next = e;
      return a;
    }
    function Hs() {
      return {
        controller: new iE(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function Ao(t) {
      t.controller.signal.aborted && console.warn(
        "A cache instance was retained after it was already freed. This likely indicates a bug in React."
      ), t.refCount++;
    }
    function Ri(t) {
      t.refCount--, 0 > t.refCount && console.warn(
        "A cache instance was released after it was already freed. This likely indicates a bug in React."
      ), t.refCount === 0 && aE(oE, function() {
        t.controller.abort();
      });
    }
    function Zi() {
      var t = Gh;
      return Gh = 0, t;
    }
    function Ro(t) {
      var e = Gh;
      return Gh = t, e;
    }
    function Hl(t) {
      var e = Gh;
      return Gh += t, e;
    }
    function xc(t) {
      Vo = cp(), 0 > t.actualStartTime && (t.actualStartTime = Vo);
    }
    function Sa(t) {
      if (0 <= Vo) {
        var e = cp() - Vo;
        t.actualDuration += e, t.selfBaseDuration = e, Vo = -1;
      }
    }
    function ks(t) {
      if (0 <= Vo) {
        var e = cp() - Vo;
        t.actualDuration += e, Vo = -1;
      }
    }
    function aa() {
      if (0 <= Vo) {
        var t = cp() - Vo;
        Vo = -1, Gh += t;
      }
    }
    function Fa() {
      Vo = cp();
    }
    function to(t) {
      for (var e = t.child; e; )
        t.actualDuration += e.actualDuration, e = e.sibling;
    }
    function Rd(t, e) {
      if (yy === null) {
        var a = yy = [];
        ab = 0, Xh = Sg(), fp = {
          status: "pending",
          value: void 0,
          then: function(f) {
            a.push(f);
          }
        };
      }
      return ab++, e.then(Ta, Ta), e;
    }
    function Ta() {
      if (--ab === 0 && yy !== null) {
        fp !== null && (fp.status = "fulfilled");
        var t = yy;
        yy = null, Xh = 0, fp = null;
        for (var e = 0; e < t.length; e++) (0, t[e])();
      }
    }
    function Tu(t, e) {
      var a = [], f = {
        status: "pending",
        value: null,
        reason: null,
        then: function(p) {
          a.push(p);
        }
      };
      return t.then(
        function() {
          f.status = "fulfilled", f.value = e;
          for (var p = 0; p < a.length; p++) (0, a[p])(e);
        },
        function(p) {
          for (f.status = "rejected", f.reason = p, p = 0; p < a.length; p++)
            (0, a[p])(void 0);
        }
      ), f;
    }
    function qf() {
      var t = Qh.current;
      return t !== null ? t : mn.pooledCache;
    }
    function Ns(t, e) {
      e === null ? Nt(Qh, Qh.current, t) : Nt(Qh, e.pool, t);
    }
    function Cd() {
      var t = qf();
      return t === null ? null : { parent: Bi._currentValue, pool: t };
    }
    function wc() {
      return { didWarnAboutUncachedPromise: !1, thenables: [] };
    }
    function Zf(t) {
      return t = t.status, t === "fulfilled" || t === "rejected";
    }
    function Co() {
    }
    function xa(t, e, a) {
      ft.actQueue !== null && (ft.didUsePromise = !0);
      var f = t.thenables;
      switch (a = f[a], a === void 0 ? f.push(e) : a !== e && (t.didWarnAboutUncachedPromise || (t.didWarnAboutUncachedPromise = !0, console.error(
        "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
      )), e.then(Co, Co), e = a), e.status) {
        case "fulfilled":
          return e.value;
        case "rejected":
          throw t = e.reason, Pi(t), t;
        default:
          if (typeof e.status == "string")
            e.then(Co, Co);
          else {
            if (t = mn, t !== null && 100 < t.shellSuspendCounter)
              throw Error(
                "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
            t = e, t.status = "pending", t.then(
              function(p) {
                if (e.status === "pending") {
                  var y = e;
                  y.status = "fulfilled", y.value = p;
                }
              },
              function(p) {
                if (e.status === "pending") {
                  var y = e;
                  y.status = "rejected", y.reason = p;
                }
              }
            );
          }
          switch (e.status) {
            case "fulfilled":
              return e.value;
            case "rejected":
              throw t = e.reason, Pi(t), t;
          }
          throw My = e, T_ = !0, wy;
      }
    }
    function kl() {
      if (My === null)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var t = My;
      return My = null, T_ = !1, t;
    }
    function Pi(t) {
      if (t === wy || t === S_)
        throw Error(
          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        );
    }
    function Ci(t) {
      t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function Nl(t, e) {
      t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        callbacks: null
      });
    }
    function Gn(t) {
      return {
        lane: t,
        tag: cS,
        payload: null,
        callback: null,
        next: null
      };
    }
    function wa(t, e, a) {
      var f = t.updateQueue;
      if (f === null) return null;
      if (f = f.shared, sb === f && !dS) {
        var p = wt(t);
        console.error(
          `An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`,
          p
        ), dS = !0;
      }
      return ($e & ho) !== yl ? (p = f.pending, p === null ? e.next = e : (e.next = p.next, p.next = e), f.pending = e, e = Su(t), Dd(t, null, a), e) : (vc(t, f, e, a), Su(t));
    }
    function ll(t, e, a) {
      if (e = e.updateQueue, e !== null && (e = e.shared, (a & 4194048) !== 0)) {
        var f = e.lanes;
        f &= t.pendingLanes, a |= f, e.lanes = a, go(t, a);
      }
    }
    function zo(t, e) {
      var a = t.updateQueue, f = t.alternate;
      if (f !== null && (f = f.updateQueue, a === f)) {
        var p = null, y = null;
        if (a = a.firstBaseUpdate, a !== null) {
          do {
            var M = {
              lane: a.lane,
              tag: a.tag,
              payload: a.payload,
              callback: null,
              next: null
            };
            y === null ? p = y = M : y = y.next = M, a = a.next;
          } while (a !== null);
          y === null ? p = y = e : y = y.next = e;
        } else p = y = e;
        a = {
          baseState: f.baseState,
          firstBaseUpdate: p,
          lastBaseUpdate: y,
          shared: f.shared,
          callbacks: f.callbacks
        }, t.updateQueue = a;
        return;
      }
      t = a.lastBaseUpdate, t === null ? a.firstBaseUpdate = e : t.next = e, a.lastBaseUpdate = e;
    }
    function Lo() {
      if (rb) {
        var t = fp;
        if (t !== null) throw t;
      }
    }
    function sl(t, e, a, f) {
      rb = !1;
      var p = t.updateQueue;
      cf = !1, sb = p.shared;
      var y = p.firstBaseUpdate, M = p.lastBaseUpdate, A = p.shared.pending;
      if (A !== null) {
        p.shared.pending = null;
        var B = A, Y = B.next;
        B.next = null, M === null ? y = Y : M.next = Y, M = B;
        var lt = t.alternate;
        lt !== null && (lt = lt.updateQueue, A = lt.lastBaseUpdate, A !== M && (A === null ? lt.firstBaseUpdate = Y : A.next = Y, lt.lastBaseUpdate = B));
      }
      if (y !== null) {
        var pt = p.baseState;
        M = 0, lt = Y = B = null, A = y;
        do {
          var at = A.lane & -536870913, gt = at !== A.lane;
          if (gt ? (Ne & at) === at : (f & at) === at) {
            at !== 0 && at === Xh && (rb = !0), lt !== null && (lt = lt.next = {
              lane: 0,
              tag: A.tag,
              payload: A.payload,
              callback: null,
              next: null
            });
            t: {
              at = t;
              var Kt = A, ue = e, pn = a;
              switch (Kt.tag) {
                case fS:
                  if (Kt = Kt.payload, typeof Kt == "function") {
                    up = !0;
                    var Be = Kt.call(
                      pn,
                      pt,
                      ue
                    );
                    if (at.mode & Ua) {
                      Tt(!0);
                      try {
                        Kt.call(pn, pt, ue);
                      } finally {
                        Tt(!1);
                      }
                    }
                    up = !1, pt = Be;
                    break t;
                  }
                  pt = Kt;
                  break t;
                case lb:
                  at.flags = at.flags & -65537 | 128;
                case cS:
                  if (Be = Kt.payload, typeof Be == "function") {
                    if (up = !0, Kt = Be.call(
                      pn,
                      pt,
                      ue
                    ), at.mode & Ua) {
                      Tt(!0);
                      try {
                        Be.call(pn, pt, ue);
                      } finally {
                        Tt(!1);
                      }
                    }
                    up = !1;
                  } else Kt = Be;
                  if (Kt == null) break t;
                  pt = Me({}, pt, Kt);
                  break t;
                case hS:
                  cf = !0;
              }
            }
            at = A.callback, at !== null && (t.flags |= 64, gt && (t.flags |= 8192), gt = p.callbacks, gt === null ? p.callbacks = [at] : gt.push(at));
          } else
            gt = {
              lane: at,
              tag: A.tag,
              payload: A.payload,
              callback: A.callback,
              next: null
            }, lt === null ? (Y = lt = gt, B = pt) : lt = lt.next = gt, M |= at;
          if (A = A.next, A === null) {
            if (A = p.shared.pending, A === null)
              break;
            gt = A, A = gt.next, gt.next = null, p.lastBaseUpdate = gt, p.shared.pending = null;
          }
        } while (!0);
        lt === null && (B = pt), p.baseState = B, p.firstBaseUpdate = Y, p.lastBaseUpdate = lt, y === null && (p.shared.lanes = 0), mf |= M, t.lanes = M, t.memoizedState = pt;
      }
      sb = null;
    }
    function rl(t, e) {
      if (typeof t != "function")
        throw Error(
          "Invalid argument passed as callback. Expected a function. Instead received: " + t
        );
      t.call(e);
    }
    function Us(t, e) {
      var a = t.shared.hiddenCallbacks;
      if (a !== null)
        for (t.shared.hiddenCallbacks = null, t = 0; t < a.length; t++)
          rl(a[t], e);
    }
    function Pf(t, e) {
      var a = t.callbacks;
      if (a !== null)
        for (t.callbacks = null, t = 0; t < a.length; t++)
          rl(a[t], e);
    }
    function Vi(t, e) {
      var a = nu;
      Nt(x_, a, t), Nt(hp, e, t), nu = a | e.baseLanes;
    }
    function wr(t) {
      Nt(x_, nu, t), Nt(
        hp,
        hp.current,
        t
      );
    }
    function Ma(t) {
      nu = x_.current, Rt(hp, t), Rt(x_, t);
    }
    function ye() {
      var t = ht;
      ds === null ? ds = [t] : ds.push(t);
    }
    function Ot() {
      var t = ht;
      if (ds !== null && (nc++, ds[nc] !== t)) {
        var e = wt(me);
        if (!mS.has(e) && (mS.add(e), ds !== null)) {
          for (var a = "", f = 0; f <= nc; f++) {
            var p = ds[f], y = f === nc ? t : p;
            for (p = f + 1 + ". " + p; 30 > p.length; )
              p += " ";
            p += y + `
`, a += p;
          }
          console.error(
            `React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,
            e,
            a
          );
        }
      }
    }
    function oa(t) {
      t == null || de(t) || console.error(
        "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
        ht,
        typeof t
      );
    }
    function Mr() {
      var t = wt(me);
      gS.has(t) || (gS.add(t), console.error(
        "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
        t
      ));
    }
    function cn() {
      throw Error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      );
    }
    function ul(t, e) {
      if (Oy) return !1;
      if (e === null)
        return console.error(
          "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
          ht
        ), !1;
      t.length !== e.length && console.error(
        `The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,
        ht,
        "[" + e.join(", ") + "]",
        "[" + t.join(", ") + "]"
      );
      for (var a = 0; a < e.length && a < t.length; a++)
        if (!uo(t[a], e[a])) return !1;
      return !0;
    }
    function Ul(t, e, a, f, p, y) {
      ff = y, me = e, ds = t !== null ? t._debugHookTypes : null, nc = -1, Oy = t !== null && t.type !== e.type, (Object.prototype.toString.call(a) === "[object AsyncFunction]" || Object.prototype.toString.call(a) === "[object AsyncGeneratorFunction]") && (y = wt(me), ub.has(y) || (ub.add(y), console.error(
        "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
        y === null ? "An unknown Component" : "<" + y + ">"
      ))), e.memoizedState = null, e.updateQueue = null, e.lanes = 0, ft.H = t !== null && t.memoizedState !== null ? fb : ds !== null ? yS : cb, Wh = y = (e.mode & Ua) !== bn;
      var M = hb(a, f, p);
      if (Wh = !1, mp && (M = d(
        e,
        a,
        f,
        p
      )), y) {
        Tt(!0);
        try {
          M = d(
            e,
            a,
            f,
            p
          );
        } finally {
          Tt(!1);
        }
      }
      return r(t, e), M;
    }
    function r(t, e) {
      e._debugHookTypes = ds, e.dependencies === null ? ec !== null && (e.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: ec
      }) : e.dependencies._debugThenableState = ec, ft.H = E_;
      var a = hn !== null && hn.next !== null;
      if (ff = 0, ds = ht = xi = hn = me = null, nc = -1, t !== null && (t.flags & 65011712) !== (e.flags & 65011712) && console.error(
        "Internal React error: Expected static flag was missing. Please notify the React team."
      ), w_ = !1, Ey = 0, ec = null, a)
        throw Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      t === null || $i || (t = t.dependencies, t !== null && yi(t) && ($i = !0)), T_ ? (T_ = !1, t = !0) : t = !1, t && (e = wt(e) || "Unknown", pS.has(e) || ub.has(e) || (pS.add(e), console.error(
        "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
      )));
    }
    function d(t, e, a, f) {
      me = t;
      var p = 0;
      do {
        if (mp && (ec = null), Ey = 0, mp = !1, p >= sE)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (p += 1, Oy = !1, xi = hn = null, t.updateQueue != null) {
          var y = t.updateQueue;
          y.lastEffect = null, y.events = null, y.stores = null, y.memoCache != null && (y.memoCache.index = 0);
        }
        nc = -1, ft.H = vS, y = hb(e, a, f);
      } while (mp);
      return y;
    }
    function v() {
      var t = ft.H, e = t.useState()[0];
      return e = typeof e.then == "function" ? xt(e) : e, t = t.useState()[0], (hn !== null ? hn.memoizedState : null) !== t && (me.flags |= 1024), e;
    }
    function w() {
      var t = M_ !== 0;
      return M_ = 0, t;
    }
    function O(t, e, a) {
      e.updateQueue = t.updateQueue, e.flags = (e.mode & nr) !== bn ? e.flags & -402655237 : e.flags & -2053, t.lanes &= ~a;
    }
    function H(t) {
      if (w_) {
        for (t = t.memoizedState; t !== null; ) {
          var e = t.queue;
          e !== null && (e.pending = null), t = t.next;
        }
        w_ = !1;
      }
      ff = 0, ds = xi = hn = me = null, nc = -1, ht = null, mp = !1, Ey = M_ = 0, ec = null;
    }
    function q() {
      var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return xi === null ? me.memoizedState = xi = t : xi = xi.next = t, xi;
    }
    function $() {
      if (hn === null) {
        var t = me.alternate;
        t = t !== null ? t.memoizedState : null;
      } else t = hn.next;
      var e = xi === null ? me.memoizedState : xi.next;
      if (e !== null)
        xi = e, hn = t;
      else {
        if (t === null)
          throw me.alternate === null ? Error(
            "Update hook called on initial render. This is likely a bug in React. Please file an issue."
          ) : Error("Rendered more hooks than during the previous render.");
        hn = t, t = {
          memoizedState: hn.memoizedState,
          baseState: hn.baseState,
          baseQueue: hn.baseQueue,
          queue: hn.queue,
          next: null
        }, xi === null ? me.memoizedState = xi = t : xi = xi.next = t;
      }
      return xi;
    }
    function rt() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function xt(t) {
      var e = Ey;
      return Ey += 1, ec === null && (ec = wc()), t = xa(ec, t, e), e = me, (xi === null ? e.memoizedState : xi.next) === null && (e = e.alternate, ft.H = e !== null && e.memoizedState !== null ? fb : cb), t;
    }
    function Ut(t) {
      if (t !== null && typeof t == "object") {
        if (typeof t.then == "function") return xt(t);
        if (t.$$typeof === qo) return tn(t);
      }
      throw Error("An unsupported type was passed to use(): " + String(t));
    }
    function qt(t) {
      var e = null, a = me.updateQueue;
      if (a !== null && (e = a.memoCache), e == null) {
        var f = me.alternate;
        f !== null && (f = f.updateQueue, f !== null && (f = f.memoCache, f != null && (e = {
          data: f.data.map(function(p) {
            return p.slice();
          }),
          index: 0
        })));
      }
      if (e == null && (e = { data: [], index: 0 }), a === null && (a = rt(), me.updateQueue = a), a.memoCache = e, a = e.data[e.index], a === void 0 || Oy)
        for (a = e.data[e.index] = Array(t), f = 0; f < t; f++)
          a[f] = e_;
      else
        a.length !== t && console.error(
          "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
          a.length,
          t
        );
      return e.index++, a;
    }
    function Zt(t, e) {
      return typeof e == "function" ? e(t) : e;
    }
    function oe(t, e, a) {
      var f = q();
      if (a !== void 0) {
        var p = a(e);
        if (Wh) {
          Tt(!0);
          try {
            a(e);
          } finally {
            Tt(!1);
          }
        }
      } else p = e;
      return f.memoizedState = f.baseState = p, t = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: t,
        lastRenderedState: p
      }, f.queue = t, t = t.dispatch = Vp.bind(
        null,
        me,
        t
      ), [f.memoizedState, t];
    }
    function Ge(t) {
      var e = $();
      return dn(e, hn, t);
    }
    function dn(t, e, a) {
      var f = t.queue;
      if (f === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      f.lastRenderedReducer = a;
      var p = t.baseQueue, y = f.pending;
      if (y !== null) {
        if (p !== null) {
          var M = p.next;
          p.next = y.next, y.next = M;
        }
        e.baseQueue !== p && console.error(
          "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
        ), e.baseQueue = p = y, f.pending = null;
      }
      if (y = t.baseState, p === null) t.memoizedState = y;
      else {
        e = p.next;
        var A = M = null, B = null, Y = e, lt = !1;
        do {
          var pt = Y.lane & -536870913;
          if (pt !== Y.lane ? (Ne & pt) === pt : (ff & pt) === pt) {
            var at = Y.revertLane;
            if (at === 0)
              B !== null && (B = B.next = {
                lane: 0,
                revertLane: 0,
                action: Y.action,
                hasEagerState: Y.hasEagerState,
                eagerState: Y.eagerState,
                next: null
              }), pt === Xh && (lt = !0);
            else if ((ff & at) === at) {
              Y = Y.next, at === Xh && (lt = !0);
              continue;
            } else
              pt = {
                lane: 0,
                revertLane: Y.revertLane,
                action: Y.action,
                hasEagerState: Y.hasEagerState,
                eagerState: Y.eagerState,
                next: null
              }, B === null ? (A = B = pt, M = y) : B = B.next = pt, me.lanes |= at, mf |= at;
            pt = Y.action, Wh && a(y, pt), y = Y.hasEagerState ? Y.eagerState : a(y, pt);
          } else
            at = {
              lane: pt,
              revertLane: Y.revertLane,
              action: Y.action,
              hasEagerState: Y.hasEagerState,
              eagerState: Y.eagerState,
              next: null
            }, B === null ? (A = B = at, M = y) : B = B.next = at, me.lanes |= pt, mf |= pt;
          Y = Y.next;
        } while (Y !== null && Y !== e);
        if (B === null ? M = y : B.next = A, !uo(y, t.memoizedState) && ($i = !0, lt && (a = fp, a !== null)))
          throw a;
        t.memoizedState = y, t.baseState = M, t.baseQueue = B, f.lastRenderedState = y;
      }
      return p === null && (f.lanes = 0), [t.memoizedState, f.dispatch];
    }
    function Dn(t) {
      var e = $(), a = e.queue;
      if (a === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      a.lastRenderedReducer = t;
      var f = a.dispatch, p = a.pending, y = e.memoizedState;
      if (p !== null) {
        a.pending = null;
        var M = p = p.next;
        do
          y = t(y, M.action), M = M.next;
        while (M !== p);
        uo(y, e.memoizedState) || ($i = !0), e.memoizedState = y, e.baseQueue === null && (e.baseState = y), a.lastRenderedState = y;
      }
      return [y, f];
    }
    function Gi(t, e, a) {
      var f = me, p = q();
      if (Pe) {
        if (a === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        var y = a();
        dp || y === a() || (console.error(
          "The result of getServerSnapshot should be cached to avoid an infinite loop"
        ), dp = !0);
      } else {
        if (y = e(), dp || (a = e(), uo(y, a) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), dp = !0)), mn === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        (Ne & 124) !== 0 || Vf(f, e, y);
      }
      return p.memoizedState = y, a = { value: y, getSnapshot: e }, p.queue = a, Ld(
        Bs.bind(null, f, a, t),
        [t]
      ), f.flags |= 2048, Bl(
        hs | Yi,
        Rr(),
        Er.bind(
          null,
          f,
          a,
          y,
          e
        ),
        null
      ), y;
    }
    function xu(t, e, a) {
      var f = me, p = $(), y = Pe;
      if (y) {
        if (a === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        a = a();
      } else if (a = e(), !dp) {
        var M = e();
        uo(a, M) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), dp = !0);
      }
      (M = !uo(
        (hn || p).memoizedState,
        a
      )) && (p.memoizedState = a, $i = !0), p = p.queue;
      var A = Bs.bind(null, f, p, t);
      if (ni(2048, Yi, A, [t]), p.getSnapshot !== e || M || xi !== null && xi.memoizedState.tag & hs) {
        if (f.flags |= 2048, Bl(
          hs | Yi,
          Rr(),
          Er.bind(
            null,
            f,
            p,
            a,
            e
          ),
          null
        ), mn === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        y || (ff & 124) !== 0 || Vf(f, e, a);
      }
      return a;
    }
    function Vf(t, e, a) {
      t.flags |= 16384, t = { getSnapshot: e, value: a }, e = me.updateQueue, e === null ? (e = rt(), me.updateQueue = e, e.stores = [t]) : (a = e.stores, a === null ? e.stores = [t] : a.push(t));
    }
    function Er(t, e, a, f) {
      e.value = a, e.getSnapshot = f, Gf(e) && Ys(t);
    }
    function Bs(t, e, a) {
      return a(function() {
        Gf(e) && Ys(t);
      });
    }
    function Gf(t) {
      var e = t.getSnapshot;
      t = t.value;
      try {
        var a = e();
        return !uo(t, a);
      } catch {
        return !0;
      }
    }
    function Ys(t) {
      var e = pi(t, 2);
      e !== null && Rn(e, t, 2);
    }
    function fn(t) {
      var e = q();
      if (typeof t == "function") {
        var a = t;
        if (t = a(), Wh) {
          Tt(!0);
          try {
            a();
          } finally {
            Tt(!1);
          }
        }
      }
      return e.memoizedState = e.baseState = t, e.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Zt,
        lastRenderedState: t
      }, e;
    }
    function Ea(t) {
      t = fn(t);
      var e = t.queue, a = Dc.bind(null, me, e);
      return e.dispatch = a, [t.memoizedState, a];
    }
    function eo(t) {
      var e = q();
      e.memoizedState = e.baseState = t;
      var a = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return e.queue = a, e = Zd.bind(
        null,
        me,
        !0,
        a
      ), a.dispatch = e, [t, e];
    }
    function cl(t, e) {
      var a = $();
      return Ho(a, hn, t, e);
    }
    function Ho(t, e, a, f) {
      return t.baseState = a, dn(
        t,
        hn,
        typeof f == "function" ? f : Zt
      );
    }
    function Or(t, e) {
      var a = $();
      return hn !== null ? Ho(a, hn, t, e) : (a.baseState = t, [t, a.queue.dispatch]);
    }
    function Mc(t, e, a, f, p) {
      if (Jf(t))
        throw Error("Cannot update form state while rendering.");
      if (t = e.action, t !== null) {
        var y = {
          payload: p,
          action: t,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(M) {
            y.listeners.push(M);
          }
        };
        ft.T !== null ? a(!0) : y.isTransition = !1, f(y), a = e.pending, a === null ? (y.next = e.pending = y, Dr(e, y)) : (y.next = a.next, e.pending = a.next = y);
      }
    }
    function Dr(t, e) {
      var a = e.action, f = e.payload, p = t.state;
      if (e.isTransition) {
        var y = ft.T, M = {};
        ft.T = M, ft.T._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var A = a(p, f), B = ft.S;
          B !== null && B(M, A), Xf(t, e, A);
        } catch (Y) {
          vi(t, e, Y);
        } finally {
          ft.T = y, y === null && M._updatedFibers && (t = M._updatedFibers.size, M._updatedFibers.clear(), 10 < t && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          ));
        }
      } else
        try {
          M = a(p, f), Xf(t, e, M);
        } catch (Y) {
          vi(t, e, Y);
        }
    }
    function Xf(t, e, a) {
      a !== null && typeof a == "object" && typeof a.then == "function" ? (a.then(
        function(f) {
          Ar(t, e, f);
        },
        function(f) {
          return vi(t, e, f);
        }
      ), e.isTransition || console.error(
        "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
      )) : Ar(t, e, a);
    }
    function Ar(t, e, a) {
      e.status = "fulfilled", e.value = a, Qf(e), t.state = a, e = t.pending, e !== null && (a = e.next, a === e ? t.pending = null : (a = a.next, e.next = a, Dr(t, a)));
    }
    function vi(t, e, a) {
      var f = t.pending;
      if (t.pending = null, f !== null) {
        f = f.next;
        do
          e.status = "rejected", e.reason = a, Qf(e), e = e.next;
        while (e !== f);
      }
      t.action = null;
    }
    function Qf(t) {
      t = t.listeners;
      for (var e = 0; e < t.length; e++) (0, t[e])();
    }
    function Yp(t, e) {
      return e;
    }
    function Ec(t, e) {
      if (Pe) {
        var a = mn.formState;
        if (a !== null) {
          t: {
            var f = me;
            if (Pe) {
              if (Qn) {
                e: {
                  for (var p = Qn, y = Fr; p.nodeType !== 8; ) {
                    if (!y) {
                      p = null;
                      break e;
                    }
                    if (p = ki(
                      p.nextSibling
                    ), p === null) {
                      p = null;
                      break e;
                    }
                  }
                  y = p.data, p = y === Bb || y === gT ? p : null;
                }
                if (p) {
                  Qn = ki(
                    p.nextSibling
                  ), f = p.data === Bb;
                  break t;
                }
              }
              Eo(f);
            }
            f = !1;
          }
          f && (e = a[0]);
        }
      }
      return a = q(), a.memoizedState = a.baseState = e, f = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Yp,
        lastRenderedState: e
      }, a.queue = f, a = Dc.bind(
        null,
        me,
        f
      ), f.dispatch = a, f = fn(!1), y = Zd.bind(
        null,
        me,
        !1,
        f.queue
      ), f = q(), p = {
        state: e,
        dispatch: null,
        action: t,
        pending: null
      }, f.queue = p, a = Mc.bind(
        null,
        me,
        p,
        y,
        a
      ), p.dispatch = a, f.memoizedState = t, [e, a, !1];
    }
    function zd(t) {
      var e = $();
      return Ov(e, hn, t);
    }
    function Ov(t, e, a) {
      if (e = dn(
        t,
        e,
        Yp
      )[0], t = Ge(Zt)[0], typeof e == "object" && e !== null && typeof e.then == "function")
        try {
          var f = xt(e);
        } catch (M) {
          throw M === wy ? S_ : M;
        }
      else f = e;
      e = $();
      var p = e.queue, y = p.dispatch;
      return a !== e.memoizedState && (me.flags |= 2048, Bl(
        hs | Yi,
        Rr(),
        ei.bind(null, p, a),
        null
      )), [f, y, t];
    }
    function ei(t, e) {
      t.action = e;
    }
    function Oc(t) {
      var e = $(), a = hn;
      if (a !== null)
        return Ov(e, a, t);
      $(), e = e.memoizedState, a = $();
      var f = a.queue.dispatch;
      return a.memoizedState = t, [e, f, !1];
    }
    function Bl(t, e, a, f) {
      return t = {
        tag: t,
        create: a,
        deps: f,
        inst: e,
        next: null
      }, e = me.updateQueue, e === null && (e = rt(), me.updateQueue = e), a = e.lastEffect, a === null ? e.lastEffect = t.next = t : (f = a.next, a.next = t, t.next = f, e.lastEffect = t), t;
    }
    function Rr() {
      return { destroy: void 0, resource: void 0 };
    }
    function Kf(t) {
      var e = q();
      return t = { current: t }, e.memoizedState = t;
    }
    function ko(t, e, a, f) {
      var p = q();
      f = f === void 0 ? null : f, me.flags |= t, p.memoizedState = Bl(
        hs | e,
        Rr(),
        a,
        f
      );
    }
    function ni(t, e, a, f) {
      var p = $();
      f = f === void 0 ? null : f;
      var y = p.memoizedState.inst;
      hn !== null && f !== null && ul(f, hn.memoizedState.deps) ? p.memoizedState = Bl(e, y, a, f) : (me.flags |= t, p.memoizedState = Bl(
        hs | e,
        y,
        a,
        f
      ));
    }
    function Ld(t, e) {
      (me.mode & nr) !== bn && (me.mode & tS) === bn ? ko(276826112, Yi, t, e) : ko(8390656, Yi, t, e);
    }
    function Hd(t, e) {
      var a = 4194308;
      return (me.mode & nr) !== bn && (a |= 134217728), ko(a, fa, t, e);
    }
    function Dv(t, e) {
      if (typeof e == "function") {
        t = t();
        var a = e(t);
        return function() {
          typeof a == "function" ? a() : e(null);
        };
      }
      if (e != null)
        return e.hasOwnProperty("current") || console.error(
          "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
          "an object with keys {" + Object.keys(e).join(", ") + "}"
        ), t = t(), e.current = t, function() {
          e.current = null;
        };
    }
    function kd(t, e, a) {
      typeof e != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        e !== null ? typeof e : "null"
      ), a = a != null ? a.concat([t]) : null;
      var f = 4194308;
      (me.mode & nr) !== bn && (f |= 134217728), ko(
        f,
        fa,
        Dv.bind(null, e, t),
        a
      );
    }
    function Yl(t, e, a) {
      typeof e != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        e !== null ? typeof e : "null"
      ), a = a != null ? a.concat([t]) : null, ni(
        4,
        fa,
        Dv.bind(null, e, t),
        a
      );
    }
    function Wf(t, e) {
      return q().memoizedState = [
        t,
        e === void 0 ? null : e
      ], t;
    }
    function wu(t, e) {
      var a = $();
      e = e === void 0 ? null : e;
      var f = a.memoizedState;
      return e !== null && ul(e, f[1]) ? f[0] : (a.memoizedState = [t, e], t);
    }
    function Nd(t, e) {
      var a = q();
      e = e === void 0 ? null : e;
      var f = t();
      if (Wh) {
        Tt(!0);
        try {
          t();
        } finally {
          Tt(!1);
        }
      }
      return a.memoizedState = [f, e], f;
    }
    function Cr(t, e) {
      var a = $();
      e = e === void 0 ? null : e;
      var f = a.memoizedState;
      if (e !== null && ul(e, f[1]))
        return f[0];
      if (f = t(), Wh) {
        Tt(!0);
        try {
          t();
        } finally {
          Tt(!1);
        }
      }
      return a.memoizedState = [f, e], f;
    }
    function Ud(t, e) {
      var a = q();
      return Yd(a, t, e);
    }
    function If(t, e) {
      var a = $();
      return $f(
        a,
        hn.memoizedState,
        t,
        e
      );
    }
    function Bd(t, e) {
      var a = $();
      return hn === null ? Yd(a, t, e) : $f(
        a,
        hn.memoizedState,
        t,
        e
      );
    }
    function Yd(t, e, a) {
      return a === void 0 || (ff & 1073741824) !== 0 ? t.memoizedState = e : (t.memoizedState = a, t = Bv(), me.lanes |= t, mf |= t, a);
    }
    function $f(t, e, a, f) {
      return uo(a, e) ? a : hp.current !== null ? (t = Yd(t, a, f), uo(t, e) || ($i = !0), t) : (ff & 42) === 0 ? ($i = !0, t.memoizedState = a) : (t = Bv(), me.lanes |= t, mf |= t, e);
    }
    function jp(t, e, a, f, p) {
      var y = re.p;
      re.p = y !== 0 && y < gl ? y : gl;
      var M = ft.T, A = {};
      ft.T = A, Zd(t, !1, e, a), A._updatedFibers = /* @__PURE__ */ new Set();
      try {
        var B = p(), Y = ft.S;
        if (Y !== null && Y(A, B), B !== null && typeof B == "object" && typeof B.then == "function") {
          var lt = Tu(
            B,
            f
          );
          js(
            t,
            e,
            lt,
            Ra(t)
          );
        } else
          js(
            t,
            e,
            f,
            Ra(t)
          );
      } catch (pt) {
        js(
          t,
          e,
          { then: function() {
          }, status: "rejected", reason: pt },
          Ra(t)
        );
      } finally {
        re.p = y, ft.T = M, M === null && A._updatedFibers && (t = A._updatedFibers.size, A._updatedFibers.clear(), 10 < t && console.warn(
          "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
        ));
      }
    }
    function Mu(t, e, a, f) {
      if (t.tag !== 5)
        throw Error(
          "Expected the form instance to be a HostComponent. This is a bug in React."
        );
      var p = qp(t).queue;
      jp(
        t,
        p,
        e,
        ld,
        a === null ? D : function() {
          return Zp(t), a(f);
        }
      );
    }
    function qp(t) {
      var e = t.memoizedState;
      if (e !== null) return e;
      e = {
        memoizedState: ld,
        baseState: ld,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Zt,
          lastRenderedState: ld
        },
        next: null
      };
      var a = {};
      return e.next = {
        memoizedState: a,
        baseState: a,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Zt,
          lastRenderedState: a
        },
        next: null
      }, t.memoizedState = e, t = t.alternate, t !== null && (t.memoizedState = e), e;
    }
    function Zp(t) {
      ft.T === null && console.error(
        "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
      );
      var e = qp(t).next.queue;
      js(
        t,
        e,
        {},
        Ra(t)
      );
    }
    function jl() {
      var t = fn(!1);
      return t = jp.bind(
        null,
        me,
        t.queue,
        !0,
        !1
      ), q().memoizedState = t, [!1, t];
    }
    function jd() {
      var t = Ge(Zt)[0], e = $().memoizedState;
      return [
        typeof t == "boolean" ? t : xt(t),
        e
      ];
    }
    function qd() {
      var t = Dn(Zt)[0], e = $().memoizedState;
      return [
        typeof t == "boolean" ? t : xt(t),
        e
      ];
    }
    function Oa() {
      return tn(Vy);
    }
    function ql() {
      var t = q(), e = mn.identifierPrefix;
      if (Pe) {
        var a = Fu, f = Ju;
        a = (f & ~(1 << 32 - Wi(f) - 1)).toString(32) + a, e = "«" + e + "R" + a, a = M_++, 0 < a && (e += "H" + a.toString(32)), e += "»";
      } else
        a = lE++, e = "«" + e + "r" + a.toString(32) + "»";
      return t.memoizedState = e;
    }
    function Eu() {
      return q().memoizedState = Pp.bind(
        null,
        me
      );
    }
    function Pp(t, e) {
      for (var a = t.return; a !== null; ) {
        switch (a.tag) {
          case 24:
          case 3:
            var f = Ra(a);
            t = Gn(f);
            var p = wa(a, t, f);
            p !== null && (Rn(p, a, f), ll(p, a, f)), a = Hs(), e != null && p !== null && console.error(
              "The seed argument is not enabled outside experimental channels."
            ), t.payload = { cache: a };
            return;
        }
        a = a.return;
      }
    }
    function Vp(t, e, a) {
      var f = arguments;
      typeof f[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), f = Ra(t);
      var p = {
        lane: f,
        revertLane: 0,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      Jf(t) ? Ou(e, p) : (p = Uf(t, e, p, f), p !== null && (Rn(p, t, f), Ff(p, e, f))), ma(t, f);
    }
    function Dc(t, e, a) {
      var f = arguments;
      typeof f[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), f = Ra(t), js(t, e, a, f), ma(t, f);
    }
    function js(t, e, a, f) {
      var p = {
        lane: f,
        revertLane: 0,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Jf(t)) Ou(e, p);
      else {
        var y = t.alternate;
        if (t.lanes === 0 && (y === null || y.lanes === 0) && (y = e.lastRenderedReducer, y !== null)) {
          var M = ft.H;
          ft.H = ar;
          try {
            var A = e.lastRenderedState, B = y(A, a);
            if (p.hasEagerState = !0, p.eagerState = B, uo(B, A))
              return vc(t, e, p, 0), mn === null && _r(), !1;
          } catch {
          } finally {
            ft.H = M;
          }
        }
        if (a = Uf(t, e, p, f), a !== null)
          return Rn(a, t, f), Ff(a, e, f), !0;
      }
      return !1;
    }
    function Zd(t, e, a, f) {
      if (ft.T === null && Xh === 0 && console.error(
        "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
      ), f = {
        lane: 2,
        revertLane: Sg(),
        action: f,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, Jf(t)) {
        if (e)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        e = Uf(
          t,
          a,
          f,
          2
        ), e !== null && Rn(e, t, 2);
      ma(t, 2);
    }
    function Jf(t) {
      var e = t.alternate;
      return t === me || e !== null && e === me;
    }
    function Ou(t, e) {
      mp = w_ = !0;
      var a = t.pending;
      a === null ? e.next = e : (e.next = a.next, a.next = e), t.pending = e;
    }
    function Ff(t, e, a) {
      if ((a & 4194048) !== 0) {
        var f = e.lanes;
        f &= t.pendingLanes, a |= f, e.lanes = a, go(t, a);
      }
    }
    function _i(t) {
      var e = Ae;
      return t != null && (Ae = e === null ? t : e.concat(t)), e;
    }
    function Ac(t, e, a) {
      for (var f = Object.keys(t.props), p = 0; p < f.length; p++) {
        var y = f[p];
        if (y !== "children" && y !== "key") {
          e === null && (e = As(t, a.mode, 0), e._debugInfo = Ae, e.return = a), Pt(
            e,
            function(M) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                M
              );
            },
            y
          );
          break;
        }
      }
    }
    function Rc(t) {
      var e = Dy;
      return Dy += 1, pp === null && (pp = wc()), xa(pp, t, e);
    }
    function No(t, e) {
      e = e.props.ref, t.ref = e !== void 0 ? e : null;
    }
    function ve(t, e) {
      throw e.$$typeof === Ah ? Error(
        `A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`
      ) : (t = Object.prototype.toString.call(e), Error(
        "Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."
      ));
    }
    function Xe(t, e) {
      var a = wt(t) || "Component";
      LS[a] || (LS[a] = !0, e = e.displayName || e.name || "Component", t.tag === 3 ? console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`,
        e,
        e,
        e
      ) : console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`,
        e,
        e,
        a,
        e,
        a
      ));
    }
    function xn(t, e) {
      var a = wt(t) || "Component";
      HS[a] || (HS[a] = !0, e = String(e), t.tag === 3 ? console.error(
        `Symbols are not valid as a React child.
  root.render(%s)`,
        e
      ) : console.error(
        `Symbols are not valid as a React child.
  <%s>%s</%s>`,
        a,
        e,
        a
      ));
    }
    function th(t) {
      function e(P, G) {
        if (t) {
          var K = P.deletions;
          K === null ? (P.deletions = [G], P.flags |= 16) : K.push(G);
        }
      }
      function a(P, G) {
        if (!t) return null;
        for (; G !== null; )
          e(P, G), G = G.sibling;
        return null;
      }
      function f(P) {
        for (var G = /* @__PURE__ */ new Map(); P !== null; )
          P.key !== null ? G.set(P.key, P) : G.set(P.index, P), P = P.sibling;
        return G;
      }
      function p(P, G) {
        return P = Ia(P, G), P.index = 0, P.sibling = null, P;
      }
      function y(P, G, K) {
        return P.index = K, t ? (K = P.alternate, K !== null ? (K = K.index, K < G ? (P.flags |= 67108866, G) : K) : (P.flags |= 67108866, G)) : (P.flags |= 1048576, G);
      }
      function M(P) {
        return t && P.alternate === null && (P.flags |= 67108866), P;
      }
      function A(P, G, K, yt) {
        return G === null || G.tag !== 6 ? (G = Rl(
          K,
          P.mode,
          yt
        ), G.return = P, G._debugOwner = P, G._debugTask = P._debugTask, G._debugInfo = Ae, G) : (G = p(G, K), G.return = P, G._debugInfo = Ae, G);
      }
      function B(P, G, K, yt) {
        var Bt = K.type;
        return Bt === _e ? (G = lt(
          P,
          G,
          K.props.children,
          yt,
          K.key
        ), Ac(K, G, P), G) : G !== null && (G.elementType === Bt || Dl(G, K) || typeof Bt == "object" && Bt !== null && Bt.$$typeof === so && hf(Bt) === G.type) ? (G = p(G, K.props), No(G, K), G.return = P, G._debugOwner = K._owner, G._debugInfo = Ae, G) : (G = As(K, P.mode, yt), No(G, K), G.return = P, G._debugInfo = Ae, G);
      }
      function Y(P, G, K, yt) {
        return G === null || G.tag !== 4 || G.stateNode.containerInfo !== K.containerInfo || G.stateNode.implementation !== K.implementation ? (G = bc(K, P.mode, yt), G.return = P, G._debugInfo = Ae, G) : (G = p(G, K.children || []), G.return = P, G._debugInfo = Ae, G);
      }
      function lt(P, G, K, yt, Bt) {
        return G === null || G.tag !== 7 ? (G = Al(
          K,
          P.mode,
          yt,
          Bt
        ), G.return = P, G._debugOwner = P, G._debugTask = P._debugTask, G._debugInfo = Ae, G) : (G = p(G, K), G.return = P, G._debugInfo = Ae, G);
      }
      function pt(P, G, K) {
        if (typeof G == "string" && G !== "" || typeof G == "number" || typeof G == "bigint")
          return G = Rl(
            "" + G,
            P.mode,
            K
          ), G.return = P, G._debugOwner = P, G._debugTask = P._debugTask, G._debugInfo = Ae, G;
        if (typeof G == "object" && G !== null) {
          switch (G.$$typeof) {
            case Vr:
              return K = As(
                G,
                P.mode,
                K
              ), No(K, G), K.return = P, P = _i(G._debugInfo), K._debugInfo = Ae, Ae = P, K;
            case Xu:
              return G = bc(
                G,
                P.mode,
                K
              ), G.return = P, G._debugInfo = Ae, G;
            case so:
              var yt = _i(G._debugInfo);
              return G = hf(G), P = pt(P, G, K), Ae = yt, P;
          }
          if (de(G) || Lt(G))
            return K = Al(
              G,
              P.mode,
              K,
              null
            ), K.return = P, K._debugOwner = P, K._debugTask = P._debugTask, P = _i(G._debugInfo), K._debugInfo = Ae, Ae = P, K;
          if (typeof G.then == "function")
            return yt = _i(G._debugInfo), P = pt(
              P,
              Rc(G),
              K
            ), Ae = yt, P;
          if (G.$$typeof === qo)
            return pt(
              P,
              Ls(P, G),
              K
            );
          ve(P, G);
        }
        return typeof G == "function" && Xe(P, G), typeof G == "symbol" && xn(P, G), null;
      }
      function at(P, G, K, yt) {
        var Bt = G !== null ? G.key : null;
        if (typeof K == "string" && K !== "" || typeof K == "number" || typeof K == "bigint")
          return Bt !== null ? null : A(P, G, "" + K, yt);
        if (typeof K == "object" && K !== null) {
          switch (K.$$typeof) {
            case Vr:
              return K.key === Bt ? (Bt = _i(K._debugInfo), P = B(
                P,
                G,
                K,
                yt
              ), Ae = Bt, P) : null;
            case Xu:
              return K.key === Bt ? Y(P, G, K, yt) : null;
            case so:
              return Bt = _i(K._debugInfo), K = hf(K), P = at(
                P,
                G,
                K,
                yt
              ), Ae = Bt, P;
          }
          if (de(K) || Lt(K))
            return Bt !== null ? null : (Bt = _i(K._debugInfo), P = lt(
              P,
              G,
              K,
              yt,
              null
            ), Ae = Bt, P);
          if (typeof K.then == "function")
            return Bt = _i(K._debugInfo), P = at(
              P,
              G,
              Rc(K),
              yt
            ), Ae = Bt, P;
          if (K.$$typeof === qo)
            return at(
              P,
              G,
              Ls(P, K),
              yt
            );
          ve(P, K);
        }
        return typeof K == "function" && Xe(P, K), typeof K == "symbol" && xn(P, K), null;
      }
      function gt(P, G, K, yt, Bt) {
        if (typeof yt == "string" && yt !== "" || typeof yt == "number" || typeof yt == "bigint")
          return P = P.get(K) || null, A(G, P, "" + yt, Bt);
        if (typeof yt == "object" && yt !== null) {
          switch (yt.$$typeof) {
            case Vr:
              return K = P.get(
                yt.key === null ? K : yt.key
              ) || null, P = _i(yt._debugInfo), G = B(
                G,
                K,
                yt,
                Bt
              ), Ae = P, G;
            case Xu:
              return P = P.get(
                yt.key === null ? K : yt.key
              ) || null, Y(G, P, yt, Bt);
            case so:
              var be = _i(yt._debugInfo);
              return yt = hf(yt), G = gt(
                P,
                G,
                K,
                yt,
                Bt
              ), Ae = be, G;
          }
          if (de(yt) || Lt(yt))
            return K = P.get(K) || null, P = _i(yt._debugInfo), G = lt(
              G,
              K,
              yt,
              Bt,
              null
            ), Ae = P, G;
          if (typeof yt.then == "function")
            return be = _i(yt._debugInfo), G = gt(
              P,
              G,
              K,
              Rc(yt),
              Bt
            ), Ae = be, G;
          if (yt.$$typeof === qo)
            return gt(
              P,
              G,
              K,
              Ls(G, yt),
              Bt
            );
          ve(G, yt);
        }
        return typeof yt == "function" && Xe(G, yt), typeof yt == "symbol" && xn(G, yt), null;
      }
      function Kt(P, G, K, yt) {
        if (typeof K != "object" || K === null) return yt;
        switch (K.$$typeof) {
          case Vr:
          case Xu:
            S(P, G, K);
            var Bt = K.key;
            if (typeof Bt != "string") break;
            if (yt === null) {
              yt = /* @__PURE__ */ new Set(), yt.add(Bt);
              break;
            }
            if (!yt.has(Bt)) {
              yt.add(Bt);
              break;
            }
            Pt(G, function() {
              console.error(
                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.",
                Bt
              );
            });
            break;
          case so:
            K = hf(K), Kt(P, G, K, yt);
        }
        return yt;
      }
      function ue(P, G, K, yt) {
        for (var Bt = null, be = null, Wt = null, Se = G, xe = G = 0, Sn = null; Se !== null && xe < K.length; xe++) {
          Se.index > xe ? (Sn = Se, Se = null) : Sn = Se.sibling;
          var li = at(
            P,
            Se,
            K[xe],
            yt
          );
          if (li === null) {
            Se === null && (Se = Sn);
            break;
          }
          Bt = Kt(
            P,
            li,
            K[xe],
            Bt
          ), t && Se && li.alternate === null && e(P, Se), G = y(li, G, xe), Wt === null ? be = li : Wt.sibling = li, Wt = li, Se = Sn;
        }
        if (xe === K.length)
          return a(P, Se), Pe && Rs(P, xe), be;
        if (Se === null) {
          for (; xe < K.length; xe++)
            Se = pt(P, K[xe], yt), Se !== null && (Bt = Kt(
              P,
              Se,
              K[xe],
              Bt
            ), G = y(
              Se,
              G,
              xe
            ), Wt === null ? be = Se : Wt.sibling = Se, Wt = Se);
          return Pe && Rs(P, xe), be;
        }
        for (Se = f(Se); xe < K.length; xe++)
          Sn = gt(
            Se,
            P,
            xe,
            K[xe],
            yt
          ), Sn !== null && (Bt = Kt(
            P,
            Sn,
            K[xe],
            Bt
          ), t && Sn.alternate !== null && Se.delete(
            Sn.key === null ? xe : Sn.key
          ), G = y(
            Sn,
            G,
            xe
          ), Wt === null ? be = Sn : Wt.sibling = Sn, Wt = Sn);
        return t && Se.forEach(function(rc) {
          return e(P, rc);
        }), Pe && Rs(P, xe), be;
      }
      function pn(P, G, K, yt) {
        if (K == null)
          throw Error("An iterable object provided no iterator.");
        for (var Bt = null, be = null, Wt = G, Se = G = 0, xe = null, Sn = null, li = K.next(); Wt !== null && !li.done; Se++, li = K.next()) {
          Wt.index > Se ? (xe = Wt, Wt = null) : xe = Wt.sibling;
          var rc = at(P, Wt, li.value, yt);
          if (rc === null) {
            Wt === null && (Wt = xe);
            break;
          }
          Sn = Kt(
            P,
            rc,
            li.value,
            Sn
          ), t && Wt && rc.alternate === null && e(P, Wt), G = y(rc, G, Se), be === null ? Bt = rc : be.sibling = rc, be = rc, Wt = xe;
        }
        if (li.done)
          return a(P, Wt), Pe && Rs(P, Se), Bt;
        if (Wt === null) {
          for (; !li.done; Se++, li = K.next())
            Wt = pt(P, li.value, yt), Wt !== null && (Sn = Kt(
              P,
              Wt,
              li.value,
              Sn
            ), G = y(
              Wt,
              G,
              Se
            ), be === null ? Bt = Wt : be.sibling = Wt, be = Wt);
          return Pe && Rs(P, Se), Bt;
        }
        for (Wt = f(Wt); !li.done; Se++, li = K.next())
          xe = gt(
            Wt,
            P,
            Se,
            li.value,
            yt
          ), xe !== null && (Sn = Kt(
            P,
            xe,
            li.value,
            Sn
          ), t && xe.alternate !== null && Wt.delete(
            xe.key === null ? Se : xe.key
          ), G = y(
            xe,
            G,
            Se
          ), be === null ? Bt = xe : be.sibling = xe, be = xe);
        return t && Wt.forEach(function(LE) {
          return e(P, LE);
        }), Pe && Rs(P, Se), Bt;
      }
      function Be(P, G, K, yt) {
        if (typeof K == "object" && K !== null && K.type === _e && K.key === null && (Ac(K, null, P), K = K.props.children), typeof K == "object" && K !== null) {
          switch (K.$$typeof) {
            case Vr:
              var Bt = _i(K._debugInfo);
              t: {
                for (var be = K.key; G !== null; ) {
                  if (G.key === be) {
                    if (be = K.type, be === _e) {
                      if (G.tag === 7) {
                        a(
                          P,
                          G.sibling
                        ), yt = p(
                          G,
                          K.props.children
                        ), yt.return = P, yt._debugOwner = K._owner, yt._debugInfo = Ae, Ac(K, yt, P), P = yt;
                        break t;
                      }
                    } else if (G.elementType === be || Dl(
                      G,
                      K
                    ) || typeof be == "object" && be !== null && be.$$typeof === so && hf(be) === G.type) {
                      a(
                        P,
                        G.sibling
                      ), yt = p(G, K.props), No(yt, K), yt.return = P, yt._debugOwner = K._owner, yt._debugInfo = Ae, P = yt;
                      break t;
                    }
                    a(P, G);
                    break;
                  } else e(P, G);
                  G = G.sibling;
                }
                K.type === _e ? (yt = Al(
                  K.props.children,
                  P.mode,
                  yt,
                  K.key
                ), yt.return = P, yt._debugOwner = P, yt._debugTask = P._debugTask, yt._debugInfo = Ae, Ac(K, yt, P), P = yt) : (yt = As(
                  K,
                  P.mode,
                  yt
                ), No(yt, K), yt.return = P, yt._debugInfo = Ae, P = yt);
              }
              return P = M(P), Ae = Bt, P;
            case Xu:
              t: {
                for (Bt = K, K = Bt.key; G !== null; ) {
                  if (G.key === K)
                    if (G.tag === 4 && G.stateNode.containerInfo === Bt.containerInfo && G.stateNode.implementation === Bt.implementation) {
                      a(
                        P,
                        G.sibling
                      ), yt = p(
                        G,
                        Bt.children || []
                      ), yt.return = P, P = yt;
                      break t;
                    } else {
                      a(P, G);
                      break;
                    }
                  else e(P, G);
                  G = G.sibling;
                }
                yt = bc(
                  Bt,
                  P.mode,
                  yt
                ), yt.return = P, P = yt;
              }
              return M(P);
            case so:
              return Bt = _i(K._debugInfo), K = hf(K), P = Be(
                P,
                G,
                K,
                yt
              ), Ae = Bt, P;
          }
          if (de(K))
            return Bt = _i(K._debugInfo), P = ue(
              P,
              G,
              K,
              yt
            ), Ae = Bt, P;
          if (Lt(K)) {
            if (Bt = _i(K._debugInfo), be = Lt(K), typeof be != "function")
              throw Error(
                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
              );
            var Wt = be.call(K);
            return Wt === K ? (P.tag !== 0 || Object.prototype.toString.call(P.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(Wt) !== "[object Generator]") && (CS || console.error(
              "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
            ), CS = !0) : K.entries !== be || mb || (console.error(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), mb = !0), P = pn(
              P,
              G,
              Wt,
              yt
            ), Ae = Bt, P;
          }
          if (typeof K.then == "function")
            return Bt = _i(K._debugInfo), P = Be(
              P,
              G,
              Rc(K),
              yt
            ), Ae = Bt, P;
          if (K.$$typeof === qo)
            return Be(
              P,
              G,
              Ls(P, K),
              yt
            );
          ve(P, K);
        }
        return typeof K == "string" && K !== "" || typeof K == "number" || typeof K == "bigint" ? (Bt = "" + K, G !== null && G.tag === 6 ? (a(
          P,
          G.sibling
        ), yt = p(G, Bt), yt.return = P, P = yt) : (a(P, G), yt = Rl(
          Bt,
          P.mode,
          yt
        ), yt.return = P, yt._debugOwner = P, yt._debugTask = P._debugTask, yt._debugInfo = Ae, P = yt), M(P)) : (typeof K == "function" && Xe(P, K), typeof K == "symbol" && xn(P, K), a(P, G));
      }
      return function(P, G, K, yt) {
        var Bt = Ae;
        Ae = null;
        try {
          Dy = 0;
          var be = Be(
            P,
            G,
            K,
            yt
          );
          return pp = null, be;
        } catch (Sn) {
          if (Sn === wy || Sn === S_) throw Sn;
          var Wt = z(29, Sn, null, P.mode);
          Wt.lanes = yt, Wt.return = P;
          var Se = Wt._debugInfo = Ae;
          if (Wt._debugOwner = P._debugOwner, Wt._debugTask = P._debugTask, Se != null) {
            for (var xe = Se.length - 1; 0 <= xe; xe--)
              if (typeof Se[xe].stack == "string") {
                Wt._debugOwner = Se[xe], Wt._debugTask = Se[xe].debugTask;
                break;
              }
          }
          return Wt;
        } finally {
          Ae = Bt;
        }
      };
    }
    function no(t) {
      var e = t.alternate;
      Nt(
        ji,
        ji.current & yp,
        t
      ), Nt(ms, t, t), eu === null && (e === null || hp.current !== null || e.memoizedState !== null) && (eu = t);
    }
    function zr(t) {
      if (t.tag === 22) {
        if (Nt(ji, ji.current, t), Nt(ms, t, t), eu === null) {
          var e = t.alternate;
          e !== null && e.memoizedState !== null && (eu = t);
        }
      } else fl(t);
    }
    function fl(t) {
      Nt(ji, ji.current, t), Nt(
        ms,
        ms.current,
        t
      );
    }
    function io(t) {
      Rt(ms, t), eu === t && (eu = null), Rt(ji, t);
    }
    function qs(t) {
      for (var e = t; e !== null; ) {
        if (e.tag === 13) {
          var a = e.memoizedState;
          if (a !== null && (a = a.dehydrated, a === null || a.data === oc || ts(a)))
            return e;
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
          if ((e.flags & 128) !== 0) return e;
        } else if (e.child !== null) {
          e.child.return = e, e = e.child;
          continue;
        }
        if (e === t) break;
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) return null;
          e = e.return;
        }
        e.sibling.return = e.return, e = e.sibling;
      }
      return null;
    }
    function Gp(t) {
      if (t !== null && typeof t != "function") {
        var e = String(t);
        XS.has(e) || (XS.add(e), console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          t
        ));
      }
    }
    function wn(t, e, a, f) {
      var p = t.memoizedState, y = a(f, p);
      if (t.mode & Ua) {
        Tt(!0);
        try {
          y = a(f, p);
        } finally {
          Tt(!1);
        }
      }
      y === void 0 && (e = Ct(e) || "Component", ZS.has(e) || (ZS.add(e), console.error(
        "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
        e
      ))), p = y == null ? p : Me({}, p, y), t.memoizedState = p, t.lanes === 0 && (t.updateQueue.baseState = p);
    }
    function Pd(t, e, a, f, p, y, M) {
      var A = t.stateNode;
      if (typeof A.shouldComponentUpdate == "function") {
        if (a = A.shouldComponentUpdate(
          f,
          y,
          M
        ), t.mode & Ua) {
          Tt(!0);
          try {
            a = A.shouldComponentUpdate(
              f,
              y,
              M
            );
          } finally {
            Tt(!1);
          }
        }
        return a === void 0 && console.error(
          "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
          Ct(e) || "Component"
        ), a;
      }
      return e.prototype && e.prototype.isPureReactComponent ? !Ds(a, f) || !Ds(p, y) : !0;
    }
    function Vd(t, e, a, f) {
      var p = e.state;
      typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(a, f), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(a, f), e.state !== p && (t = wt(t) || "Component", US.has(t) || (US.add(t), console.error(
        "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
        t
      )), pb.enqueueReplaceState(
        e,
        e.state,
        null
      ));
    }
    function Lr(t, e) {
      var a = e;
      if ("ref" in e) {
        a = {};
        for (var f in e)
          f !== "ref" && (a[f] = e[f]);
      }
      if (t = t.defaultProps) {
        a === e && (a = Me({}, a));
        for (var p in t)
          a[p] === void 0 && (a[p] = t[p]);
      }
      return a;
    }
    function Xp(t) {
      gb(t), console.warn(
        `%s

%s
`,
        vp ? "An error occurred in the <" + vp + "> component." : "An error occurred in one of your React components.",
        `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`
      );
    }
    function Av(t) {
      var e = vp ? "The above error occurred in the <" + vp + "> component." : "The above error occurred in one of your React components.", a = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((yb || "Anonymous") + ".");
      if (typeof t == "object" && t !== null && typeof t.environmentName == "string") {
        var f = t.environmentName;
        t = [
          `%o

%s

%s
`,
          t,
          e,
          a
        ].slice(0), typeof t[0] == "string" ? t.splice(
          0,
          1,
          wT + t[0],
          MT,
          G_ + f + G_,
          ET
        ) : t.splice(
          0,
          0,
          wT,
          MT,
          G_ + f + G_,
          ET
        ), t.unshift(console), f = CE.apply(console.error, t), f();
      } else
        console.error(
          `%o

%s

%s
`,
          t,
          e,
          a
        );
    }
    function Gd(t) {
      gb(t);
    }
    function Cc(t, e) {
      try {
        vp = e.source ? wt(e.source) : null, yb = null;
        var a = e.value;
        if (ft.actQueue !== null)
          ft.thrownErrors.push(a);
        else {
          var f = t.onUncaughtError;
          f(a, { componentStack: e.stack });
        }
      } catch (p) {
        setTimeout(function() {
          throw p;
        });
      }
    }
    function Xd(t, e, a) {
      try {
        vp = a.source ? wt(a.source) : null, yb = wt(e);
        var f = t.onCaughtError;
        f(a.value, {
          componentStack: a.stack,
          errorBoundary: e.tag === 1 ? e.stateNode : null
        });
      } catch (p) {
        setTimeout(function() {
          throw p;
        });
      }
    }
    function Xi(t, e, a) {
      return a = Gn(a), a.tag = lb, a.payload = { element: null }, a.callback = function() {
        Pt(e.source, Cc, t, e);
      }, a;
    }
    function An(t) {
      return t = Gn(t), t.tag = lb, t;
    }
    function eh(t, e, a, f) {
      var p = a.type.getDerivedStateFromError;
      if (typeof p == "function") {
        var y = f.value;
        t.payload = function() {
          return p(y);
        }, t.callback = function() {
          Ad(a), Pt(
            f.source,
            Xd,
            e,
            a,
            f
          );
        };
      }
      var M = a.stateNode;
      M !== null && typeof M.componentDidCatch == "function" && (t.callback = function() {
        Ad(a), Pt(
          f.source,
          Xd,
          e,
          a,
          f
        ), typeof p != "function" && (gf === null ? gf = /* @__PURE__ */ new Set([this]) : gf.add(this)), rE(this, f), typeof p == "function" || (a.lanes & 2) === 0 && console.error(
          "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
          wt(a) || "Unknown"
        );
      });
    }
    function nh(t, e, a, f, p) {
      if (a.flags |= 32768, kn && Yc(t, p), f !== null && typeof f == "object" && typeof f.then == "function") {
        if (e = a.alternate, e !== null && ti(
          e,
          a,
          p,
          !0
        ), Pe && (tc = !0), a = ms.current, a !== null) {
          switch (a.tag) {
            case 13:
              return eu === null ? hm() : a.alternate === null && Kn === ac && (Kn = Sb), a.flags &= -257, a.flags |= 65536, a.lanes = p, f === ob ? a.flags |= 16384 : (e = a.updateQueue, e === null ? a.updateQueue = /* @__PURE__ */ new Set([f]) : e.add(f), yg(t, f, p)), !1;
            case 22:
              return a.flags |= 65536, f === ob ? a.flags |= 16384 : (e = a.updateQueue, e === null ? (e = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([f])
              }, a.updateQueue = e) : (a = e.retryQueue, a === null ? e.retryQueue = /* @__PURE__ */ new Set([f]) : a.add(f)), yg(t, f, p)), !1;
          }
          throw Error(
            "Unexpected Suspense handler tag (" + a.tag + "). This is a bug in React."
          );
        }
        return yg(t, f, p), hm(), !1;
      }
      if (Pe)
        return tc = !0, e = ms.current, e !== null ? ((e.flags & 65536) === 0 && (e.flags |= 256), e.flags |= 65536, e.lanes = p, f !== eb && ol(
          qi(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
              { cause: f }
            ),
            a
          )
        )) : (f !== eb && ol(
          qi(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
              { cause: f }
            ),
            a
          )
        ), t = t.current.alternate, t.flags |= 65536, p &= -p, t.lanes |= p, f = qi(f, a), p = Xi(
          t.stateNode,
          f,
          p
        ), zo(t, p), Kn !== Ih && (Kn = Tp)), !1;
      var y = qi(
        Error(
          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
          { cause: f }
        ),
        a
      );
      if (Ny === null ? Ny = [y] : Ny.push(y), Kn !== Ih && (Kn = Tp), e === null) return !0;
      f = qi(f, a), a = e;
      do {
        switch (a.tag) {
          case 3:
            return a.flags |= 65536, t = p & -p, a.lanes |= t, t = Xi(
              a.stateNode,
              f,
              t
            ), zo(a, t), !1;
          case 1:
            if (e = a.type, y = a.stateNode, (a.flags & 128) === 0 && (typeof e.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (gf === null || !gf.has(y))))
              return a.flags |= 65536, p &= -p, a.lanes |= p, p = An(p), eh(
                p,
                t,
                a,
                f
              ), zo(a, p), !1;
        }
        a = a.return;
      } while (a !== null);
      return !1;
    }
    function Xn(t, e, a, f) {
      e.child = t === null ? kS(e, null, a, f) : gp(
        e,
        t.child,
        a,
        f
      );
    }
    function Qd(t, e, a, f, p) {
      a = a.render;
      var y = e.ref;
      if ("ref" in f) {
        var M = {};
        for (var A in f)
          A !== "ref" && (M[A] = f[A]);
      } else M = f;
      return Ja(e), on(e), f = Ul(
        t,
        e,
        a,
        M,
        y,
        p
      ), A = w(), fi(), t !== null && !$i ? (O(t, e, p), Pl(t, e, p)) : (Pe && A && al(e), e.flags |= 1, Xn(t, e, f, p), e.child);
    }
    function Zl(t, e, a, f, p) {
      if (t === null) {
        var y = a.type;
        return typeof y == "function" && !_c(y) && y.defaultProps === void 0 && a.compare === null ? (a = Ol(y), e.tag = 15, e.type = a, $d(e, y), ih(
          t,
          e,
          a,
          f,
          p
        )) : (t = Sr(
          a.type,
          null,
          f,
          e,
          e.mode,
          p
        ), t.ref = e.ref, t.return = e, e.child = t);
      }
      if (y = t.child, !im(t, p)) {
        var M = y.memoizedProps;
        if (a = a.compare, a = a !== null ? a : Ds, a(M, f) && t.ref === e.ref)
          return Pl(
            t,
            e,
            p
          );
      }
      return e.flags |= 1, t = Ia(y, f), t.ref = e.ref, t.return = e, e.child = t;
    }
    function ih(t, e, a, f, p) {
      if (t !== null) {
        var y = t.memoizedProps;
        if (Ds(y, f) && t.ref === e.ref && e.type === t.type)
          if ($i = !1, e.pendingProps = f = y, im(t, p))
            (t.flags & 131072) !== 0 && ($i = !0);
          else
            return e.lanes = t.lanes, Pl(t, e, p);
      }
      return Id(
        t,
        e,
        a,
        f,
        p
      );
    }
    function Kd(t, e, a) {
      var f = e.pendingProps, p = f.children, y = t !== null ? t.memoizedState : null;
      if (f.mode === "hidden") {
        if ((e.flags & 128) !== 0) {
          if (f = y !== null ? y.baseLanes | a : a, t !== null) {
            for (p = e.child = t.child, y = 0; p !== null; )
              y = y | p.lanes | p.childLanes, p = p.sibling;
            e.childLanes = y & ~f;
          } else e.childLanes = 0, e.child = null;
          return Wd(
            t,
            e,
            f,
            a
          );
        }
        if ((a & 536870912) !== 0)
          e.memoizedState = { baseLanes: 0, cachePool: null }, t !== null && Ns(
            e,
            y !== null ? y.cachePool : null
          ), y !== null ? Vi(e, y) : wr(e), zr(e);
        else
          return e.lanes = e.childLanes = 536870912, Wd(
            t,
            e,
            y !== null ? y.baseLanes | a : a,
            a
          );
      } else
        y !== null ? (Ns(e, y.cachePool), Vi(e, y), fl(e), e.memoizedState = null) : (t !== null && Ns(e, null), wr(e), fl(e));
      return Xn(t, e, p, a), e.child;
    }
    function Wd(t, e, a, f) {
      var p = qf();
      return p = p === null ? null : {
        parent: Bi._currentValue,
        pool: p
      }, e.memoizedState = {
        baseLanes: a,
        cachePool: p
      }, t !== null && Ns(e, null), wr(e), zr(e), t !== null && ti(t, e, f, !0), null;
    }
    function ah(t, e) {
      var a = e.ref;
      if (a === null)
        t !== null && t.ref !== null && (e.flags |= 4194816);
      else {
        if (typeof a != "function" && typeof a != "object")
          throw Error(
            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
          );
        (t === null || t.ref !== a) && (e.flags |= 4194816);
      }
    }
    function Id(t, e, a, f, p) {
      if (a.prototype && typeof a.prototype.render == "function") {
        var y = Ct(a) || "Unknown";
        KS[y] || (console.error(
          "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
          y,
          y
        ), KS[y] = !0);
      }
      return e.mode & Ua && ir.recordLegacyContextWarning(
        e,
        null
      ), t === null && ($d(e, e.type), a.contextTypes && (y = Ct(a) || "Unknown", IS[y] || (IS[y] = !0, console.error(
        "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
        y
      )))), Ja(e), on(e), a = Ul(
        t,
        e,
        a,
        f,
        void 0,
        p
      ), f = w(), fi(), t !== null && !$i ? (O(t, e, p), Pl(t, e, p)) : (Pe && f && al(e), e.flags |= 1, Xn(t, e, a, p), e.child);
    }
    function Qp(t, e, a, f, p, y) {
      return Ja(e), on(e), nc = -1, Oy = t !== null && t.type !== e.type, e.updateQueue = null, a = d(
        e,
        f,
        a,
        p
      ), r(t, e), f = w(), fi(), t !== null && !$i ? (O(t, e, y), Pl(t, e, y)) : (Pe && f && al(e), e.flags |= 1, Xn(t, e, a, y), e.child);
    }
    function Kp(t, e, a, f, p) {
      switch (_(e)) {
        case !1:
          var y = e.stateNode, M = new e.type(
            e.memoizedProps,
            y.context
          ).state;
          y.updater.enqueueSetState(y, M, null);
          break;
        case !0:
          e.flags |= 128, e.flags |= 65536, y = Error("Simulated error coming from DevTools");
          var A = p & -p;
          if (e.lanes |= A, M = mn, M === null)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          A = An(A), eh(
            A,
            M,
            e,
            qi(y, e)
          ), zo(e, A);
      }
      if (Ja(e), e.stateNode === null) {
        if (M = uf, y = a.contextType, "contextType" in a && y !== null && (y === void 0 || y.$$typeof !== qo) && !GS.has(a) && (GS.add(a), A = y === void 0 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof y != "object" ? " However, it is set to a " + typeof y + "." : y.$$typeof === Ym ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(y).join(", ") + "}.", console.error(
          "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
          Ct(a) || "Component",
          A
        )), typeof y == "object" && y !== null && (M = tn(y)), y = new a(f, M), e.mode & Ua) {
          Tt(!0);
          try {
            y = new a(f, M);
          } finally {
            Tt(!1);
          }
        }
        if (M = e.memoizedState = y.state !== null && y.state !== void 0 ? y.state : null, y.updater = pb, e.stateNode = y, y._reactInternals = e, y._reactInternalInstance = NS, typeof a.getDerivedStateFromProps == "function" && M === null && (M = Ct(a) || "Component", BS.has(M) || (BS.add(M), console.error(
          "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
          M,
          y.state === null ? "null" : "undefined",
          M
        ))), typeof a.getDerivedStateFromProps == "function" || typeof y.getSnapshotBeforeUpdate == "function") {
          var B = A = M = null;
          if (typeof y.componentWillMount == "function" && y.componentWillMount.__suppressDeprecationWarning !== !0 ? M = "componentWillMount" : typeof y.UNSAFE_componentWillMount == "function" && (M = "UNSAFE_componentWillMount"), typeof y.componentWillReceiveProps == "function" && y.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? A = "componentWillReceiveProps" : typeof y.UNSAFE_componentWillReceiveProps == "function" && (A = "UNSAFE_componentWillReceiveProps"), typeof y.componentWillUpdate == "function" && y.componentWillUpdate.__suppressDeprecationWarning !== !0 ? B = "componentWillUpdate" : typeof y.UNSAFE_componentWillUpdate == "function" && (B = "UNSAFE_componentWillUpdate"), M !== null || A !== null || B !== null) {
            y = Ct(a) || "Component";
            var Y = typeof a.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            jS.has(y) || (jS.add(y), console.error(
              `Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`,
              y,
              Y,
              M !== null ? `
  ` + M : "",
              A !== null ? `
  ` + A : "",
              B !== null ? `
  ` + B : ""
            ));
          }
        }
        y = e.stateNode, M = Ct(a) || "Component", y.render || (a.prototype && typeof a.prototype.render == "function" ? console.error(
          "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
          M
        ) : console.error(
          "No `render` method found on the %s instance: you may have forgotten to define `render`.",
          M
        )), !y.getInitialState || y.getInitialState.isReactClassApproved || y.state || console.error(
          "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
          M
        ), y.getDefaultProps && !y.getDefaultProps.isReactClassApproved && console.error(
          "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
          M
        ), y.contextType && console.error(
          "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
          M
        ), a.childContextTypes && !VS.has(a) && (VS.add(a), console.error(
          "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
          M
        )), a.contextTypes && !PS.has(a) && (PS.add(a), console.error(
          "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
          M
        )), typeof y.componentShouldUpdate == "function" && console.error(
          "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
          M
        ), a.prototype && a.prototype.isPureReactComponent && typeof y.shouldComponentUpdate < "u" && console.error(
          "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
          Ct(a) || "A pure component"
        ), typeof y.componentDidUnmount == "function" && console.error(
          "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
          M
        ), typeof y.componentDidReceiveProps == "function" && console.error(
          "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
          M
        ), typeof y.componentWillRecieveProps == "function" && console.error(
          "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
          M
        ), typeof y.UNSAFE_componentWillRecieveProps == "function" && console.error(
          "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
          M
        ), A = y.props !== f, y.props !== void 0 && A && console.error(
          "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
          M
        ), y.defaultProps && console.error(
          "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
          M,
          M
        ), typeof y.getSnapshotBeforeUpdate != "function" || typeof y.componentDidUpdate == "function" || YS.has(a) || (YS.add(a), console.error(
          "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
          Ct(a)
        )), typeof y.getDerivedStateFromProps == "function" && console.error(
          "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          M
        ), typeof y.getDerivedStateFromError == "function" && console.error(
          "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          M
        ), typeof a.getSnapshotBeforeUpdate == "function" && console.error(
          "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
          M
        ), (A = y.state) && (typeof A != "object" || de(A)) && console.error("%s.state: must be set to an object or null", M), typeof y.getChildContext == "function" && typeof a.childContextTypes != "object" && console.error(
          "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
          M
        ), y = e.stateNode, y.props = f, y.state = e.memoizedState, y.refs = {}, Ci(e), M = a.contextType, y.context = typeof M == "object" && M !== null ? tn(M) : uf, y.state === f && (M = Ct(a) || "Component", qS.has(M) || (qS.add(M), console.error(
          "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
          M
        ))), e.mode & Ua && ir.recordLegacyContextWarning(
          e,
          y
        ), ir.recordUnsafeLifecycleWarnings(
          e,
          y
        ), y.state = e.memoizedState, M = a.getDerivedStateFromProps, typeof M == "function" && (wn(
          e,
          a,
          M,
          f
        ), y.state = e.memoizedState), typeof a.getDerivedStateFromProps == "function" || typeof y.getSnapshotBeforeUpdate == "function" || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (M = y.state, typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount(), M !== y.state && (console.error(
          "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          wt(e) || "Component"
        ), pb.enqueueReplaceState(
          y,
          y.state,
          null
        )), sl(e, f, y, p), Lo(), y.state = e.memoizedState), typeof y.componentDidMount == "function" && (e.flags |= 4194308), (e.mode & nr) !== bn && (e.flags |= 134217728), y = !0;
      } else if (t === null) {
        y = e.stateNode;
        var lt = e.memoizedProps;
        A = Lr(a, lt), y.props = A;
        var pt = y.context;
        B = a.contextType, M = uf, typeof B == "object" && B !== null && (M = tn(B)), Y = a.getDerivedStateFromProps, B = typeof Y == "function" || typeof y.getSnapshotBeforeUpdate == "function", lt = e.pendingProps !== lt, B || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (lt || pt !== M) && Vd(
          e,
          y,
          f,
          M
        ), cf = !1;
        var at = e.memoizedState;
        y.state = at, sl(e, f, y, p), Lo(), pt = e.memoizedState, lt || at !== pt || cf ? (typeof Y == "function" && (wn(
          e,
          a,
          Y,
          f
        ), pt = e.memoizedState), (A = cf || Pd(
          e,
          a,
          A,
          f,
          at,
          pt,
          M
        )) ? (B || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount()), typeof y.componentDidMount == "function" && (e.flags |= 4194308), (e.mode & nr) !== bn && (e.flags |= 134217728)) : (typeof y.componentDidMount == "function" && (e.flags |= 4194308), (e.mode & nr) !== bn && (e.flags |= 134217728), e.memoizedProps = f, e.memoizedState = pt), y.props = f, y.state = pt, y.context = M, y = A) : (typeof y.componentDidMount == "function" && (e.flags |= 4194308), (e.mode & nr) !== bn && (e.flags |= 134217728), y = !1);
      } else {
        y = e.stateNode, Nl(t, e), M = e.memoizedProps, B = Lr(a, M), y.props = B, Y = e.pendingProps, at = y.context, pt = a.contextType, A = uf, typeof pt == "object" && pt !== null && (A = tn(pt)), lt = a.getDerivedStateFromProps, (pt = typeof lt == "function" || typeof y.getSnapshotBeforeUpdate == "function") || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (M !== Y || at !== A) && Vd(
          e,
          y,
          f,
          A
        ), cf = !1, at = e.memoizedState, y.state = at, sl(e, f, y, p), Lo();
        var gt = e.memoizedState;
        M !== Y || at !== gt || cf || t !== null && t.dependencies !== null && yi(t.dependencies) ? (typeof lt == "function" && (wn(
          e,
          a,
          lt,
          f
        ), gt = e.memoizedState), (B = cf || Pd(
          e,
          a,
          B,
          f,
          at,
          gt,
          A
        ) || t !== null && t.dependencies !== null && yi(t.dependencies)) ? (pt || typeof y.UNSAFE_componentWillUpdate != "function" && typeof y.componentWillUpdate != "function" || (typeof y.componentWillUpdate == "function" && y.componentWillUpdate(f, gt, A), typeof y.UNSAFE_componentWillUpdate == "function" && y.UNSAFE_componentWillUpdate(
          f,
          gt,
          A
        )), typeof y.componentDidUpdate == "function" && (e.flags |= 4), typeof y.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof y.componentDidUpdate != "function" || M === t.memoizedProps && at === t.memoizedState || (e.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || M === t.memoizedProps && at === t.memoizedState || (e.flags |= 1024), e.memoizedProps = f, e.memoizedState = gt), y.props = f, y.state = gt, y.context = A, y = B) : (typeof y.componentDidUpdate != "function" || M === t.memoizedProps && at === t.memoizedState || (e.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || M === t.memoizedProps && at === t.memoizedState || (e.flags |= 1024), y = !1);
      }
      if (A = y, ah(t, e), M = (e.flags & 128) !== 0, A || M) {
        if (A = e.stateNode, mr(e), M && typeof a.getDerivedStateFromError != "function")
          a = null, Vo = -1;
        else {
          if (on(e), a = SS(A), e.mode & Ua) {
            Tt(!0);
            try {
              SS(A);
            } finally {
              Tt(!1);
            }
          }
          fi();
        }
        e.flags |= 1, t !== null && M ? (e.child = gp(
          e,
          t.child,
          null,
          p
        ), e.child = gp(
          e,
          null,
          a,
          p
        )) : Xn(t, e, a, p), e.memoizedState = A.state, t = e.child;
      } else
        t = Pl(
          t,
          e,
          p
        );
      return p = e.stateNode, y && p.props !== f && (_p || console.error(
        "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
        wt(e) || "a component"
      ), _p = !0), t;
    }
    function Wp(t, e, a, f) {
      return zs(), e.flags |= 256, Xn(t, e, a, f), e.child;
    }
    function $d(t, e) {
      e && e.childContextTypes && console.error(
        `childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`,
        e.displayName || e.name || "Component"
      ), typeof e.getDerivedStateFromProps == "function" && (t = Ct(e) || "Unknown", $S[t] || (console.error(
        "%s: Function components do not support getDerivedStateFromProps.",
        t
      ), $S[t] = !0)), typeof e.contextType == "object" && e.contextType !== null && (e = Ct(e) || "Unknown", WS[e] || (console.error(
        "%s: Function components do not support contextType.",
        e
      ), WS[e] = !0));
    }
    function oh(t) {
      return { baseLanes: t, cachePool: Cd() };
    }
    function Jd(t, e, a) {
      return t = t !== null ? t.childLanes & ~a : 0, e && (t |= _l), t;
    }
    function Rv(t, e, a) {
      var f, p = e.pendingProps;
      g(e) && (e.flags |= 128);
      var y = !1, M = (e.flags & 128) !== 0;
      if ((f = M) || (f = t !== null && t.memoizedState === null ? !1 : (ji.current & Ay) !== 0), f && (y = !0, e.flags &= -129), f = (e.flags & 32) !== 0, e.flags &= -33, t === null) {
        if (Pe) {
          if (y ? no(e) : fl(e), Pe) {
            var A = Qn, B;
            if (!(B = !A)) {
              t: {
                var Y = A;
                for (B = Fr; Y.nodeType !== 8; ) {
                  if (!B) {
                    B = null;
                    break t;
                  }
                  if (Y = ki(Y.nextSibling), Y === null) {
                    B = null;
                    break t;
                  }
                }
                B = Y;
              }
              B !== null ? (jn(), e.memoizedState = {
                dehydrated: B,
                treeContext: Ph !== null ? { id: Ju, overflow: Fu } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, Y = z(18, null, null, bn), Y.stateNode = B, Y.return = e, e.child = Y, co = e, Qn = null, B = !0) : B = !1, B = !B;
            }
            B && (Cl(
              e,
              A
            ), Eo(e));
          }
          if (A = e.memoizedState, A !== null && (A = A.dehydrated, A !== null))
            return ts(A) ? e.lanes = 32 : e.lanes = 536870912, null;
          io(e);
        }
        return A = p.children, p = p.fallback, y ? (fl(e), y = e.mode, A = lh(
          {
            mode: "hidden",
            children: A
          },
          y
        ), p = Al(
          p,
          y,
          a,
          null
        ), A.return = e, p.return = e, A.sibling = p, e.child = A, y = e.child, y.memoizedState = oh(a), y.childLanes = Jd(
          t,
          f,
          a
        ), e.memoizedState = _b, p) : (no(e), Fd(
          e,
          A
        ));
      }
      var lt = t.memoizedState;
      if (lt !== null && (A = lt.dehydrated, A !== null)) {
        if (M)
          e.flags & 256 ? (no(e), e.flags &= -257, e = tm(
            t,
            e,
            a
          )) : e.memoizedState !== null ? (fl(e), e.child = t.child, e.flags |= 128, e = null) : (fl(e), y = p.fallback, A = e.mode, p = lh(
            {
              mode: "visible",
              children: p.children
            },
            A
          ), y = Al(
            y,
            A,
            a,
            null
          ), y.flags |= 2, p.return = e, y.return = e, p.sibling = y, e.child = p, gp(
            e,
            t.child,
            null,
            a
          ), p = e.child, p.memoizedState = oh(a), p.childLanes = Jd(
            t,
            f,
            a
          ), e.memoizedState = _b, e = y);
        else if (no(e), Pe && console.error(
          "We should not be hydrating here. This is a bug in React. Please file a bug."
        ), ts(A)) {
          if (f = A.nextSibling && A.nextSibling.dataset, f) {
            B = f.dgst;
            var pt = f.msg;
            Y = f.stck;
            var at = f.cstck;
          }
          A = pt, f = B, p = Y, B = y = at, y = Error(A || "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), y.stack = p || "", y.digest = f, f = B === void 0 ? null : B, p = {
            value: y,
            source: null,
            stack: f
          }, typeof f == "string" && F0.set(
            y,
            p
          ), ol(p), e = tm(
            t,
            e,
            a
          );
        } else if ($i || ti(
          t,
          e,
          a,
          !1
        ), f = (a & t.childLanes) !== 0, $i || f) {
          if (f = mn, f !== null && (p = a & -a, p = (p & 42) !== 0 ? 1 : Zn(
            p
          ), p = (p & (f.suspendedLanes | a)) !== 0 ? 0 : p, p !== 0 && p !== lt.retryLane))
            throw lt.retryLane = p, pi(
              t,
              p
            ), Rn(
              f,
              t,
              p
            ), QS;
          A.data === oc || hm(), e = tm(
            t,
            e,
            a
          );
        } else
          A.data === oc ? (e.flags |= 192, e.child = t.child, e = null) : (t = lt.treeContext, Qn = ki(
            A.nextSibling
          ), co = e, Pe = !0, Vh = null, tc = !1, cs = null, Fr = !1, t !== null && (jn(), rs[us++] = Ju, rs[us++] = Fu, rs[us++] = Ph, Ju = t.id, Fu = t.overflow, Ph = e), e = Fd(
            e,
            p.children
          ), e.flags |= 4096);
        return e;
      }
      return y ? (fl(e), y = p.fallback, A = e.mode, B = t.child, Y = B.sibling, p = Ia(
        B,
        {
          mode: "hidden",
          children: p.children
        }
      ), p.subtreeFlags = B.subtreeFlags & 65011712, Y !== null ? y = Ia(
        Y,
        y
      ) : (y = Al(
        y,
        A,
        a,
        null
      ), y.flags |= 2), y.return = e, p.return = e, p.sibling = y, e.child = p, p = y, y = e.child, A = t.child.memoizedState, A === null ? A = oh(a) : (B = A.cachePool, B !== null ? (Y = Bi._currentValue, B = B.parent !== Y ? { parent: Y, pool: Y } : B) : B = Cd(), A = {
        baseLanes: A.baseLanes | a,
        cachePool: B
      }), y.memoizedState = A, y.childLanes = Jd(
        t,
        f,
        a
      ), e.memoizedState = _b, p) : (no(e), a = t.child, t = a.sibling, a = Ia(a, {
        mode: "visible",
        children: p.children
      }), a.return = e, a.sibling = null, t !== null && (f = e.deletions, f === null ? (e.deletions = [t], e.flags |= 16) : f.push(t)), e.child = a, e.memoizedState = null, a);
    }
    function Fd(t, e) {
      return e = lh(
        { mode: "visible", children: e },
        t.mode
      ), e.return = t, t.child = e;
    }
    function lh(t, e) {
      return t = z(22, t, null, e), t.lanes = 0, t.stateNode = {
        _visibility: d_,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }, t;
    }
    function tm(t, e, a) {
      return gp(e, t.child, null, a), t = Fd(
        e,
        e.pendingProps.children
      ), t.flags |= 2, e.memoizedState = null, t;
    }
    function em(t, e, a) {
      t.lanes |= e;
      var f = t.alternate;
      f !== null && (f.lanes |= e), jf(
        t.return,
        e,
        a
      );
    }
    function Ip(t, e) {
      var a = de(t);
      return t = !a && typeof Lt(t) == "function", a || t ? (a = a ? "array" : "iterable", console.error(
        "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
        a,
        e,
        a
      ), !1) : !0;
    }
    function nm(t, e, a, f, p) {
      var y = t.memoizedState;
      y === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: f,
        tail: a,
        tailMode: p
      } : (y.isBackwards = e, y.rendering = null, y.renderingStartTime = 0, y.last = f, y.tail = a, y.tailMode = p);
    }
    function $p(t, e, a) {
      var f = e.pendingProps, p = f.revealOrder, y = f.tail;
      if (f = f.children, p !== void 0 && p !== "forwards" && p !== "backwards" && p !== "together" && !JS[p])
        if (JS[p] = !0, typeof p == "string")
          switch (p.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                p,
                p.toLowerCase()
              );
              break;
            case "forward":
            case "backward":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                p,
                p.toLowerCase()
              );
              break;
            default:
              console.error(
                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                p
              );
          }
        else
          console.error(
            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
            p
          );
      y === void 0 || vb[y] || (y !== "collapsed" && y !== "hidden" ? (vb[y] = !0, console.error(
        '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
        y
      )) : p !== "forwards" && p !== "backwards" && (vb[y] = !0, console.error(
        '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
        y
      )));
      t: if ((p === "forwards" || p === "backwards") && f !== void 0 && f !== null && f !== !1)
        if (de(f)) {
          for (var M = 0; M < f.length; M++)
            if (!Ip(f[M], M)) break t;
        } else if (M = Lt(f), typeof M == "function") {
          if (M = M.call(f))
            for (var A = M.next(), B = 0; !A.done; A = M.next()) {
              if (!Ip(A.value, B)) break t;
              B++;
            }
        } else
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            p
          );
      if (Xn(t, e, f, a), f = ji.current, (f & Ay) !== 0)
        f = f & yp | Ay, e.flags |= 128;
      else {
        if (t !== null && (t.flags & 128) !== 0)
          t: for (t = e.child; t !== null; ) {
            if (t.tag === 13)
              t.memoizedState !== null && em(
                t,
                a,
                e
              );
            else if (t.tag === 19)
              em(t, a, e);
            else if (t.child !== null) {
              t.child.return = t, t = t.child;
              continue;
            }
            if (t === e) break t;
            for (; t.sibling === null; ) {
              if (t.return === null || t.return === e)
                break t;
              t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
          }
        f &= yp;
      }
      switch (Nt(ji, f, e), p) {
        case "forwards":
          for (a = e.child, p = null; a !== null; )
            t = a.alternate, t !== null && qs(t) === null && (p = a), a = a.sibling;
          a = p, a === null ? (p = e.child, e.child = null) : (p = a.sibling, a.sibling = null), nm(
            e,
            !1,
            p,
            a,
            y
          );
          break;
        case "backwards":
          for (a = null, p = e.child, e.child = null; p !== null; ) {
            if (t = p.alternate, t !== null && qs(t) === null) {
              e.child = p;
              break;
            }
            t = p.sibling, p.sibling = a, a = p, p = t;
          }
          nm(
            e,
            !0,
            a,
            null,
            y
          );
          break;
        case "together":
          nm(e, !1, null, null, void 0);
          break;
        default:
          e.memoizedState = null;
      }
      return e.child;
    }
    function Pl(t, e, a) {
      if (t !== null && (e.dependencies = t.dependencies), Vo = -1, mf |= e.lanes, (a & e.childLanes) === 0)
        if (t !== null) {
          if (ti(
            t,
            e,
            a,
            !1
          ), (a & e.childLanes) === 0)
            return null;
        } else return null;
      if (t !== null && e.child !== t.child)
        throw Error("Resuming work not yet implemented.");
      if (e.child !== null) {
        for (t = e.child, a = Ia(t, t.pendingProps), e.child = a, a.return = e; t.sibling !== null; )
          t = t.sibling, a = a.sibling = Ia(t, t.pendingProps), a.return = e;
        a.sibling = null;
      }
      return e.child;
    }
    function im(t, e) {
      return (t.lanes & e) !== 0 ? !0 : (t = t.dependencies, !!(t !== null && yi(t)));
    }
    function H0(t, e, a) {
      switch (e.tag) {
        case 3:
          ge(
            e,
            e.stateNode.containerInfo
          ), zl(
            e,
            Bi,
            t.memoizedState.cache
          ), zs();
          break;
        case 27:
        case 5:
          mt(e);
          break;
        case 4:
          ge(
            e,
            e.stateNode.containerInfo
          );
          break;
        case 10:
          zl(
            e,
            e.type,
            e.memoizedProps.value
          );
          break;
        case 12:
          (a & e.childLanes) !== 0 && (e.flags |= 4), e.flags |= 2048;
          var f = e.stateNode;
          f.effectDuration = -0, f.passiveEffectDuration = -0;
          break;
        case 13:
          if (f = e.memoizedState, f !== null)
            return f.dehydrated !== null ? (no(e), e.flags |= 128, null) : (a & e.child.childLanes) !== 0 ? Rv(
              t,
              e,
              a
            ) : (no(e), t = Pl(
              t,
              e,
              a
            ), t !== null ? t.sibling : null);
          no(e);
          break;
        case 19:
          var p = (t.flags & 128) !== 0;
          if (f = (a & e.childLanes) !== 0, f || (ti(
            t,
            e,
            a,
            !1
          ), f = (a & e.childLanes) !== 0), p) {
            if (f)
              return $p(
                t,
                e,
                a
              );
            e.flags |= 128;
          }
          if (p = e.memoizedState, p !== null && (p.rendering = null, p.tail = null, p.lastEffect = null), Nt(
            ji,
            ji.current,
            e
          ), f) break;
          return null;
        case 22:
        case 23:
          return e.lanes = 0, Kd(t, e, a);
        case 24:
          zl(
            e,
            Bi,
            t.memoizedState.cache
          );
      }
      return Pl(t, e, a);
    }
    function am(t, e, a) {
      if (e._debugNeedsRemount && t !== null) {
        a = Sr(
          e.type,
          e.key,
          e.pendingProps,
          e._debugOwner || null,
          e.mode,
          e.lanes
        ), a._debugStack = e._debugStack, a._debugTask = e._debugTask;
        var f = e.return;
        if (f === null) throw Error("Cannot swap the root fiber.");
        if (t.alternate = null, e.alternate = null, a.index = e.index, a.sibling = e.sibling, a.return = e.return, a.ref = e.ref, a._debugInfo = e._debugInfo, e === f.child)
          f.child = a;
        else {
          var p = f.child;
          if (p === null)
            throw Error("Expected parent to have a child.");
          for (; p.sibling !== e; )
            if (p = p.sibling, p === null)
              throw Error("Expected to find the previous sibling.");
          p.sibling = a;
        }
        return e = f.deletions, e === null ? (f.deletions = [t], f.flags |= 16) : e.push(t), a.flags |= 2, a;
      }
      if (t !== null)
        if (t.memoizedProps !== e.pendingProps || e.type !== t.type)
          $i = !0;
        else {
          if (!im(t, a) && (e.flags & 128) === 0)
            return $i = !1, H0(
              t,
              e,
              a
            );
          $i = (t.flags & 131072) !== 0;
        }
      else
        $i = !1, (f = Pe) && (jn(), f = (e.flags & 1048576) !== 0), f && (f = e.index, jn(), ba(e, p_, f));
      switch (e.lanes = 0, e.tag) {
        case 16:
          t: if (f = e.pendingProps, t = hf(e.elementType), e.type = t, typeof t == "function")
            _c(t) ? (f = Lr(
              t,
              f
            ), e.tag = 1, e.type = t = Ol(t), e = Kp(
              null,
              e,
              t,
              f,
              a
            )) : (e.tag = 0, $d(e, t), e.type = t = Ol(t), e = Id(
              null,
              e,
              t,
              f,
              a
            ));
          else {
            if (t != null) {
              if (p = t.$$typeof, p === Ws) {
                e.tag = 11, e.type = t = br(t), e = Qd(
                  null,
                  e,
                  t,
                  f,
                  a
                );
                break t;
              } else if (p === Rh) {
                e.tag = 14, e = Zl(
                  null,
                  e,
                  t,
                  f,
                  a
                );
                break t;
              }
            }
            throw e = "", t !== null && typeof t == "object" && t.$$typeof === so && (e = " Did you wrap a component in React.lazy() more than once?"), t = Ct(t) || t, Error(
              "Element type is invalid. Received a promise that resolves to: " + t + ". Lazy element type must resolve to a class or function." + e
            );
          }
          return e;
        case 0:
          return Id(
            t,
            e,
            e.type,
            e.pendingProps,
            a
          );
        case 1:
          return f = e.type, p = Lr(
            f,
            e.pendingProps
          ), Kp(
            t,
            e,
            f,
            p,
            a
          );
        case 3:
          t: {
            if (ge(
              e,
              e.stateNode.containerInfo
            ), t === null)
              throw Error(
                "Should have a current fiber. This is a bug in React."
              );
            f = e.pendingProps;
            var y = e.memoizedState;
            p = y.element, Nl(t, e), sl(e, f, null, a);
            var M = e.memoizedState;
            if (f = M.cache, zl(e, Bi, f), f !== y.cache && Ll(
              e,
              [Bi],
              a,
              !0
            ), Lo(), f = M.element, y.isDehydrated)
              if (y = {
                element: f,
                isDehydrated: !1,
                cache: M.cache
              }, e.updateQueue.baseState = y, e.memoizedState = y, e.flags & 256) {
                e = Wp(
                  t,
                  e,
                  f,
                  a
                );
                break t;
              } else if (f !== p) {
                p = qi(
                  Error(
                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                  ),
                  e
                ), ol(p), e = Wp(
                  t,
                  e,
                  f,
                  a
                );
                break t;
              } else {
                switch (t = e.stateNode.containerInfo, t.nodeType) {
                  case 9:
                    t = t.body;
                    break;
                  default:
                    t = t.nodeName === "HTML" ? t.ownerDocument.body : t;
                }
                for (Qn = ki(t.firstChild), co = e, Pe = !0, Vh = null, tc = !1, cs = null, Fr = !0, t = kS(
                  e,
                  null,
                  f,
                  a
                ), e.child = t; t; )
                  t.flags = t.flags & -3 | 4096, t = t.sibling;
              }
            else {
              if (zs(), f === p) {
                e = Pl(
                  t,
                  e,
                  a
                );
                break t;
              }
              Xn(
                t,
                e,
                f,
                a
              );
            }
            e = e.child;
          }
          return e;
        case 26:
          return ah(t, e), t === null ? (t = Ks(
            e.type,
            null,
            e.pendingProps,
            null
          )) ? e.memoizedState = t : Pe || (t = e.type, a = e.pendingProps, f = Ee(
            ns.current
          ), f = He(
            f
          ).createElement(t), f[Ii] = e, f[ka] = a, zn(f, t, a), J(f), e.stateNode = f) : e.memoizedState = Ks(
            e.type,
            t.memoizedProps,
            e.pendingProps,
            t.memoizedState
          ), null;
        case 27:
          return mt(e), t === null && Pe && (f = Ee(ns.current), p = V(), f = e.stateNode = Ng(
            e.type,
            e.pendingProps,
            f,
            p,
            !1
          ), tc || (p = sn(
            f,
            e.type,
            e.pendingProps,
            p
          ), p !== null && ($a(e, 0).serverProps = p)), co = e, Fr = !0, p = Qn, Fl(e.type) ? (Zb = p, Qn = ki(
            f.firstChild
          )) : Qn = p), Xn(
            t,
            e,
            e.pendingProps.children,
            a
          ), ah(t, e), t === null && (e.flags |= 4194304), e.child;
        case 5:
          return t === null && Pe && (y = V(), f = yr(
            e.type,
            y.ancestorInfo
          ), p = Qn, (M = !p) || (M = jr(
            p,
            e.type,
            e.pendingProps,
            Fr
          ), M !== null ? (e.stateNode = M, tc || (y = sn(
            M,
            e.type,
            e.pendingProps,
            y
          ), y !== null && ($a(e, 0).serverProps = y)), co = e, Qn = ki(
            M.firstChild
          ), Fr = !1, y = !0) : y = !1, M = !y), M && (f && Cl(e, p), Eo(e))), mt(e), p = e.type, y = e.pendingProps, M = t !== null ? t.memoizedProps : null, f = y.children, Jl(p, y) ? f = null : M !== null && Jl(p, M) && (e.flags |= 32), e.memoizedState !== null && (p = Ul(
            t,
            e,
            v,
            null,
            null,
            a
          ), Vy._currentValue = p), ah(t, e), Xn(
            t,
            e,
            f,
            a
          ), e.child;
        case 6:
          return t === null && Pe && (t = e.pendingProps, a = V(), f = a.ancestorInfo.current, t = f != null ? Jo(
            t,
            f.tag,
            a.ancestorInfo.implicitRootScope
          ) : !0, a = Qn, (f = !a) || (f = Hi(
            a,
            e.pendingProps,
            Fr
          ), f !== null ? (e.stateNode = f, co = e, Qn = null, f = !0) : f = !1, f = !f), f && (t && Cl(e, a), Eo(e))), null;
        case 13:
          return Rv(t, e, a);
        case 4:
          return ge(
            e,
            e.stateNode.containerInfo
          ), f = e.pendingProps, t === null ? e.child = gp(
            e,
            null,
            f,
            a
          ) : Xn(
            t,
            e,
            f,
            a
          ), e.child;
        case 11:
          return Qd(
            t,
            e,
            e.type,
            e.pendingProps,
            a
          );
        case 7:
          return Xn(
            t,
            e,
            e.pendingProps,
            a
          ), e.child;
        case 8:
          return Xn(
            t,
            e,
            e.pendingProps.children,
            a
          ), e.child;
        case 12:
          return e.flags |= 4, e.flags |= 2048, f = e.stateNode, f.effectDuration = -0, f.passiveEffectDuration = -0, Xn(
            t,
            e,
            e.pendingProps.children,
            a
          ), e.child;
        case 10:
          return f = e.type, p = e.pendingProps, y = p.value, "value" in p || FS || (FS = !0, console.error(
            "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
          )), zl(e, f, y), Xn(
            t,
            e,
            p.children,
            a
          ), e.child;
        case 9:
          return p = e.type._context, f = e.pendingProps.children, typeof f != "function" && console.error(
            "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
          ), Ja(e), p = tn(p), on(e), f = hb(
            f,
            p,
            void 0
          ), fi(), e.flags |= 1, Xn(
            t,
            e,
            f,
            a
          ), e.child;
        case 14:
          return Zl(
            t,
            e,
            e.type,
            e.pendingProps,
            a
          );
        case 15:
          return ih(
            t,
            e,
            e.type,
            e.pendingProps,
            a
          );
        case 19:
          return $p(
            t,
            e,
            a
          );
        case 31:
          return f = e.pendingProps, a = e.mode, f = {
            mode: f.mode,
            children: f.children
          }, t === null ? (t = lh(
            f,
            a
          ), t.ref = e.ref, e.child = t, t.return = e, e = t) : (t = Ia(t.child, f), t.ref = e.ref, e.child = t, t.return = e, e = t), e;
        case 22:
          return Kd(t, e, a);
        case 24:
          return Ja(e), f = tn(Bi), t === null ? (p = qf(), p === null && (p = mn, y = Hs(), p.pooledCache = y, Ao(y), y !== null && (p.pooledCacheLanes |= a), p = y), e.memoizedState = {
            parent: f,
            cache: p
          }, Ci(e), zl(e, Bi, p)) : ((t.lanes & a) !== 0 && (Nl(t, e), sl(e, null, null, a), Lo()), p = t.memoizedState, y = e.memoizedState, p.parent !== f ? (p = {
            parent: f,
            cache: f
          }, e.memoizedState = p, e.lanes === 0 && (e.memoizedState = e.updateQueue.baseState = p), zl(e, Bi, f)) : (f = y.cache, zl(e, Bi, f), f !== p.cache && Ll(
            e,
            [Bi],
            a,
            !0
          ))), Xn(
            t,
            e,
            e.pendingProps.children,
            a
          ), e.child;
        case 29:
          throw e.pendingProps;
      }
      throw Error(
        "Unknown unit of work tag (" + e.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Da(t) {
      t.flags |= 4;
    }
    function sh(t, e) {
      if (e.type !== "stylesheet" || (e.state.loading & ps) !== od)
        t.flags &= -16777217;
      else if (t.flags |= 16777216, !Sh(e)) {
        if (e = ms.current, e !== null && ((Ne & 4194048) === Ne ? eu !== null : (Ne & 62914560) !== Ne && (Ne & 536870912) === 0 || e !== eu))
          throw My = ob, uS;
        t.flags |= 8192;
      }
    }
    function rh(t, e) {
      e !== null && (t.flags |= 4), t.flags & 16384 && (e = t.tag !== 22 ? pa() : 536870912, t.lanes |= e, Fh |= e);
    }
    function Hr(t, e) {
      if (!Pe)
        switch (t.tailMode) {
          case "hidden":
            e = t.tail;
            for (var a = null; e !== null; )
              e.alternate !== null && (a = e), e = e.sibling;
            a === null ? t.tail = null : a.sibling = null;
            break;
          case "collapsed":
            a = t.tail;
            for (var f = null; a !== null; )
              a.alternate !== null && (f = a), a = a.sibling;
            f === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : f.sibling = null;
        }
    }
    function en(t) {
      var e = t.alternate !== null && t.alternate.child === t.child, a = 0, f = 0;
      if (e)
        if ((t.mode & ca) !== bn) {
          for (var p = t.selfBaseDuration, y = t.child; y !== null; )
            a |= y.lanes | y.childLanes, f |= y.subtreeFlags & 65011712, f |= y.flags & 65011712, p += y.treeBaseDuration, y = y.sibling;
          t.treeBaseDuration = p;
        } else
          for (p = t.child; p !== null; )
            a |= p.lanes | p.childLanes, f |= p.subtreeFlags & 65011712, f |= p.flags & 65011712, p.return = t, p = p.sibling;
      else if ((t.mode & ca) !== bn) {
        p = t.actualDuration, y = t.selfBaseDuration;
        for (var M = t.child; M !== null; )
          a |= M.lanes | M.childLanes, f |= M.subtreeFlags, f |= M.flags, p += M.actualDuration, y += M.treeBaseDuration, M = M.sibling;
        t.actualDuration = p, t.treeBaseDuration = y;
      } else
        for (p = t.child; p !== null; )
          a |= p.lanes | p.childLanes, f |= p.subtreeFlags, f |= p.flags, p.return = t, p = p.sibling;
      return t.subtreeFlags |= f, t.childLanes = a, e;
    }
    function Cv(t, e, a) {
      var f = e.pendingProps;
      switch (Sc(e), e.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return en(e), null;
        case 1:
          return en(e), null;
        case 3:
          return a = e.stateNode, f = null, t !== null && (f = t.memoizedState.cache), e.memoizedState.cache !== f && (e.flags |= 2048), Fn(Bi, e), Jt(e), a.pendingContext && (a.context = a.pendingContext, a.pendingContext = null), (t === null || t.child === null) && (Oo(e) ? (Yf(), Da(e)) : t === null || t.memoizedState.isDehydrated && (e.flags & 256) === 0 || (e.flags |= 1024, Do())), en(e), null;
        case 26:
          return a = e.memoizedState, t === null ? (Da(e), a !== null ? (en(e), sh(
            e,
            a
          )) : (en(e), e.flags &= -16777217)) : a ? a !== t.memoizedState ? (Da(e), en(e), sh(
            e,
            a
          )) : (en(e), e.flags &= -16777217) : (t.memoizedProps !== f && Da(e), en(e), e.flags &= -16777217), null;
        case 27:
          ut(e), a = Ee(ns.current);
          var p = e.type;
          if (t !== null && e.stateNode != null)
            t.memoizedProps !== f && Da(e);
          else {
            if (!f) {
              if (e.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return en(e), null;
            }
            t = V(), Oo(e) ? Cs(e) : (t = Ng(
              p,
              f,
              a,
              t,
              !0
            ), e.stateNode = t, Da(e));
          }
          return en(e), null;
        case 5:
          if (ut(e), a = e.type, t !== null && e.stateNode != null)
            t.memoizedProps !== f && Da(e);
          else {
            if (!f) {
              if (e.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return en(e), null;
            }
            if (p = V(), Oo(e))
              Cs(e);
            else {
              switch (t = Ee(ns.current), yr(a, p.ancestorInfo), p = p.context, t = He(t), p) {
                case Dp:
                  t = t.createElementNS(rf, a);
                  break;
                case Z_:
                  t = t.createElementNS(
                    qh,
                    a
                  );
                  break;
                default:
                  switch (a) {
                    case "svg":
                      t = t.createElementNS(
                        rf,
                        a
                      );
                      break;
                    case "math":
                      t = t.createElementNS(
                        qh,
                        a
                      );
                      break;
                    case "script":
                      t = t.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild);
                      break;
                    case "select":
                      t = typeof f.is == "string" ? t.createElement("select", { is: f.is }) : t.createElement("select"), f.multiple ? t.multiple = !0 : f.size && (t.size = f.size);
                      break;
                    default:
                      t = typeof f.is == "string" ? t.createElement(a, {
                        is: f.is
                      }) : t.createElement(a), a.indexOf("-") === -1 && (a !== a.toLowerCase() && console.error(
                        "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                        a
                      ), Object.prototype.toString.call(t) !== "[object HTMLUnknownElement]" || $s.call(
                        vT,
                        a
                      ) || (vT[a] = !0, console.error(
                        "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                        a
                      )));
                  }
              }
              t[Ii] = e, t[ka] = f;
              t: for (p = e.child; p !== null; ) {
                if (p.tag === 5 || p.tag === 6)
                  t.appendChild(p.stateNode);
                else if (p.tag !== 4 && p.tag !== 27 && p.child !== null) {
                  p.child.return = p, p = p.child;
                  continue;
                }
                if (p === e) break t;
                for (; p.sibling === null; ) {
                  if (p.return === null || p.return === e)
                    break t;
                  p = p.return;
                }
                p.sibling.return = p.return, p = p.sibling;
              }
              e.stateNode = t;
              t: switch (zn(t, a, f), a) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  t = !!f.autoFocus;
                  break t;
                case "img":
                  t = !0;
                  break t;
                default:
                  t = !1;
              }
              t && Da(e);
            }
          }
          return en(e), e.flags &= -16777217, null;
        case 6:
          if (t && e.stateNode != null)
            t.memoizedProps !== f && Da(e);
          else {
            if (typeof f != "string" && e.stateNode === null)
              throw Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            if (t = Ee(ns.current), a = V(), Oo(e)) {
              t = e.stateNode, a = e.memoizedProps, p = !tc, f = null;
              var y = co;
              if (y !== null)
                switch (y.tag) {
                  case 3:
                    p && (p = Rm(
                      t,
                      a,
                      f
                    ), p !== null && ($a(e, 0).serverProps = p));
                    break;
                  case 27:
                  case 5:
                    f = y.memoizedProps, p && (p = Rm(
                      t,
                      a,
                      f
                    ), p !== null && ($a(
                      e,
                      0
                    ).serverProps = p));
                }
              t[Ii] = e, t = !!(t.nodeValue === a || f !== null && f.suppressHydrationWarning === !0 || Eg(t.nodeValue, a)), t || Eo(e);
            } else
              p = a.ancestorInfo.current, p != null && Jo(
                f,
                p.tag,
                a.ancestorInfo.implicitRootScope
              ), t = He(t).createTextNode(
                f
              ), t[Ii] = e, e.stateNode = t;
          }
          return en(e), null;
        case 13:
          if (f = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (p = Oo(e), f !== null && f.dehydrated !== null) {
              if (t === null) {
                if (!p)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                if (p = e.memoizedState, p = p !== null ? p.dehydrated : null, !p)
                  throw Error(
                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                p[Ii] = e, en(e), (e.mode & ca) !== bn && f !== null && (p = e.child, p !== null && (e.treeBaseDuration -= p.treeBaseDuration));
              } else
                Yf(), zs(), (e.flags & 128) === 0 && (e.memoizedState = null), e.flags |= 4, en(e), (e.mode & ca) !== bn && f !== null && (p = e.child, p !== null && (e.treeBaseDuration -= p.treeBaseDuration));
              p = !1;
            } else
              p = Do(), t !== null && t.memoizedState !== null && (t.memoizedState.hydrationErrors = p), p = !0;
            if (!p)
              return e.flags & 256 ? (io(e), e) : (io(e), null);
          }
          return io(e), (e.flags & 128) !== 0 ? (e.lanes = a, (e.mode & ca) !== bn && to(e), e) : (a = f !== null, t = t !== null && t.memoizedState !== null, a && (f = e.child, p = null, f.alternate !== null && f.alternate.memoizedState !== null && f.alternate.memoizedState.cachePool !== null && (p = f.alternate.memoizedState.cachePool.pool), y = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (y = f.memoizedState.cachePool.pool), y !== p && (f.flags |= 2048)), a !== t && a && (e.child.flags |= 8192), rh(e, e.updateQueue), en(e), (e.mode & ca) !== bn && a && (t = e.child, t !== null && (e.treeBaseDuration -= t.treeBaseDuration)), null);
        case 4:
          return Jt(e), t === null && wg(
            e.stateNode.containerInfo
          ), en(e), null;
        case 10:
          return Fn(e.type, e), en(e), null;
        case 19:
          if (Rt(ji, e), p = e.memoizedState, p === null) return en(e), null;
          if (f = (e.flags & 128) !== 0, y = p.rendering, y === null)
            if (f) Hr(p, !1);
            else {
              if (Kn !== ac || t !== null && (t.flags & 128) !== 0)
                for (t = e.child; t !== null; ) {
                  if (y = qs(t), y !== null) {
                    for (e.flags |= 128, Hr(p, !1), t = y.updateQueue, e.updateQueue = t, rh(e, t), e.subtreeFlags = 0, t = a, a = e.child; a !== null; )
                      Bf(a, t), a = a.sibling;
                    return Nt(
                      ji,
                      ji.current & yp | Ay,
                      e
                    ), e.child;
                  }
                  t = t.sibling;
                }
              p.tail !== null && is() > R_ && (e.flags |= 128, f = !0, Hr(p, !1), e.lanes = 4194304);
            }
          else {
            if (!f)
              if (t = qs(y), t !== null) {
                if (e.flags |= 128, f = !0, t = t.updateQueue, e.updateQueue = t, rh(e, t), Hr(p, !0), p.tail === null && p.tailMode === "hidden" && !y.alternate && !Pe)
                  return en(e), null;
              } else
                2 * is() - p.renderingStartTime > R_ && a !== 536870912 && (e.flags |= 128, f = !0, Hr(p, !1), e.lanes = 4194304);
            p.isBackwards ? (y.sibling = e.child, e.child = y) : (t = p.last, t !== null ? t.sibling = y : e.child = y, p.last = y);
          }
          return p.tail !== null ? (t = p.tail, p.rendering = t, p.tail = t.sibling, p.renderingStartTime = is(), t.sibling = null, a = ji.current, a = f ? a & yp | Ay : a & yp, Nt(ji, a, e), t) : (en(e), null);
        case 22:
        case 23:
          return io(e), Ma(e), f = e.memoizedState !== null, t !== null ? t.memoizedState !== null !== f && (e.flags |= 8192) : f && (e.flags |= 8192), f ? (a & 536870912) !== 0 && (e.flags & 128) === 0 && (en(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : en(e), a = e.updateQueue, a !== null && rh(e, a.retryQueue), a = null, t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (a = t.memoizedState.cachePool.pool), f = null, e.memoizedState !== null && e.memoizedState.cachePool !== null && (f = e.memoizedState.cachePool.pool), f !== a && (e.flags |= 2048), t !== null && Rt(Qh, e), null;
        case 24:
          return a = null, t !== null && (a = t.memoizedState.cache), e.memoizedState.cache !== a && (e.flags |= 2048), Fn(Bi, e), en(e), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(
        "Unknown unit of work tag (" + e.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function zv(t, e) {
      switch (Sc(e), e.tag) {
        case 1:
          return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, (e.mode & ca) !== bn && to(e), e) : null;
        case 3:
          return Fn(Bi, e), Jt(e), t = e.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (e.flags = t & -65537 | 128, e) : null;
        case 26:
        case 27:
        case 5:
          return ut(e), null;
        case 13:
          if (io(e), t = e.memoizedState, t !== null && t.dehydrated !== null) {
            if (e.alternate === null)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            zs();
          }
          return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, (e.mode & ca) !== bn && to(e), e) : null;
        case 19:
          return Rt(ji, e), null;
        case 4:
          return Jt(e), null;
        case 10:
          return Fn(e.type, e), null;
        case 22:
        case 23:
          return io(e), Ma(e), t !== null && Rt(Qh, e), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, (e.mode & ca) !== bn && to(e), e) : null;
        case 24:
          return Fn(Bi, e), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function Jp(t, e) {
      switch (Sc(e), e.tag) {
        case 3:
          Fn(Bi, e), Jt(e);
          break;
        case 26:
        case 27:
        case 5:
          ut(e);
          break;
        case 4:
          Jt(e);
          break;
        case 13:
          io(e);
          break;
        case 19:
          Rt(ji, e);
          break;
        case 10:
          Fn(e.type, e);
          break;
        case 22:
        case 23:
          io(e), Ma(e), t !== null && Rt(Qh, e);
          break;
        case 24:
          Fn(Bi, e);
      }
    }
    function hl(t) {
      return (t.mode & ca) !== bn;
    }
    function Fp(t, e) {
      hl(t) ? (Fa(), Du(e, t), aa()) : Du(e, t);
    }
    function om(t, e, a) {
      hl(t) ? (Fa(), Au(
        a,
        t,
        e
      ), aa()) : Au(
        a,
        t,
        e
      );
    }
    function Du(t, e) {
      try {
        var a = e.updateQueue, f = a !== null ? a.lastEffect : null;
        if (f !== null) {
          var p = f.next;
          a = p;
          do {
            if ((a.tag & t) === t && ((t & Yi) !== fs ? jt !== null && typeof jt.markComponentPassiveEffectMountStarted == "function" && jt.markComponentPassiveEffectMountStarted(
              e
            ) : (t & fa) !== fs && jt !== null && typeof jt.markComponentLayoutEffectMountStarted == "function" && jt.markComponentLayoutEffectMountStarted(
              e
            ), f = void 0, (t & fo) !== fs && (Ep = !0), f = Pt(
              e,
              uE,
              a
            ), (t & fo) !== fs && (Ep = !1), (t & Yi) !== fs ? jt !== null && typeof jt.markComponentPassiveEffectMountStopped == "function" && jt.markComponentPassiveEffectMountStopped() : (t & fa) !== fs && jt !== null && typeof jt.markComponentLayoutEffectMountStopped == "function" && jt.markComponentLayoutEffectMountStopped(), f !== void 0 && typeof f != "function")) {
              var y = void 0;
              y = (a.tag & fa) !== 0 ? "useLayoutEffect" : (a.tag & fo) !== 0 ? "useInsertionEffect" : "useEffect";
              var M = void 0;
              M = f === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof f.then == "function" ? `

It looks like you wrote ` + y + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + y + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + f, Pt(
                e,
                function(A, B) {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    A,
                    B
                  );
                },
                y,
                M
              );
            }
            a = a.next;
          } while (a !== p);
        }
      } catch (A) {
        ie(e, e.return, A);
      }
    }
    function Au(t, e, a) {
      try {
        var f = e.updateQueue, p = f !== null ? f.lastEffect : null;
        if (p !== null) {
          var y = p.next;
          f = y;
          do {
            if ((f.tag & t) === t) {
              var M = f.inst, A = M.destroy;
              A !== void 0 && (M.destroy = void 0, (t & Yi) !== fs ? jt !== null && typeof jt.markComponentPassiveEffectUnmountStarted == "function" && jt.markComponentPassiveEffectUnmountStarted(
                e
              ) : (t & fa) !== fs && jt !== null && typeof jt.markComponentLayoutEffectUnmountStarted == "function" && jt.markComponentLayoutEffectUnmountStarted(
                e
              ), (t & fo) !== fs && (Ep = !0), p = e, Pt(
                p,
                cE,
                p,
                a,
                A
              ), (t & fo) !== fs && (Ep = !1), (t & Yi) !== fs ? jt !== null && typeof jt.markComponentPassiveEffectUnmountStopped == "function" && jt.markComponentPassiveEffectUnmountStopped() : (t & fa) !== fs && jt !== null && typeof jt.markComponentLayoutEffectUnmountStopped == "function" && jt.markComponentLayoutEffectUnmountStopped());
            }
            f = f.next;
          } while (f !== y);
        }
      } catch (B) {
        ie(e, e.return, B);
      }
    }
    function tg(t, e) {
      hl(t) ? (Fa(), Du(e, t), aa()) : Du(e, t);
    }
    function uh(t, e, a) {
      hl(t) ? (Fa(), Au(
        a,
        t,
        e
      ), aa()) : Au(
        a,
        t,
        e
      );
    }
    function eg(t) {
      var e = t.updateQueue;
      if (e !== null) {
        var a = t.stateNode;
        t.type.defaultProps || "ref" in t.memoizedProps || _p || (a.props !== t.memoizedProps && console.error(
          "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          wt(t) || "instance"
        ), a.state !== t.memoizedState && console.error(
          "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          wt(t) || "instance"
        ));
        try {
          Pt(
            t,
            Pf,
            e,
            a
          );
        } catch (f) {
          ie(t, t.return, f);
        }
      }
    }
    function Lv(t, e, a) {
      return t.getSnapshotBeforeUpdate(e, a);
    }
    function k0(t, e) {
      var a = e.memoizedProps, f = e.memoizedState;
      e = t.stateNode, t.type.defaultProps || "ref" in t.memoizedProps || _p || (e.props !== t.memoizedProps && console.error(
        "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
        wt(t) || "instance"
      ), e.state !== t.memoizedState && console.error(
        "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
        wt(t) || "instance"
      ));
      try {
        var p = Lr(
          t.type,
          a,
          t.elementType === t.type
        ), y = Pt(
          t,
          Lv,
          e,
          p,
          f
        );
        a = tT, y !== void 0 || a.has(t.type) || (a.add(t.type), Pt(t, function() {
          console.error(
            "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
            wt(t)
          );
        })), e.__reactInternalSnapshotBeforeUpdate = y;
      } catch (M) {
        ie(t, t.return, M);
      }
    }
    function lm(t, e, a) {
      a.props = Lr(
        t.type,
        t.memoizedProps
      ), a.state = t.memoizedState, hl(t) ? (Fa(), Pt(
        t,
        OS,
        t,
        e,
        a
      ), aa()) : Pt(
        t,
        OS,
        t,
        e,
        a
      );
    }
    function Hv(t) {
      var e = t.ref;
      if (e !== null) {
        switch (t.tag) {
          case 26:
          case 27:
          case 5:
            var a = t.stateNode;
            break;
          case 30:
            a = t.stateNode;
            break;
          default:
            a = t.stateNode;
        }
        if (typeof e == "function")
          if (hl(t))
            try {
              Fa(), t.refCleanup = e(a);
            } finally {
              aa();
            }
          else t.refCleanup = e(a);
        else
          typeof e == "string" ? console.error("String refs are no longer supported.") : e.hasOwnProperty("current") || console.error(
            "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
            wt(t)
          ), e.current = a;
      }
    }
    function zc(t, e) {
      try {
        Pt(t, Hv, t);
      } catch (a) {
        ie(t, e, a);
      }
    }
    function Uo(t, e) {
      var a = t.ref, f = t.refCleanup;
      if (a !== null)
        if (typeof f == "function")
          try {
            if (hl(t))
              try {
                Fa(), Pt(t, f);
              } finally {
                aa(t);
              }
            else Pt(t, f);
          } catch (p) {
            ie(t, e, p);
          } finally {
            t.refCleanup = null, t = t.alternate, t != null && (t.refCleanup = null);
          }
        else if (typeof a == "function")
          try {
            if (hl(t))
              try {
                Fa(), Pt(t, a, null);
              } finally {
                aa(t);
              }
            else Pt(t, a, null);
          } catch (p) {
            ie(t, e, p);
          }
        else a.current = null;
    }
    function ng(t, e, a, f) {
      var p = t.memoizedProps, y = p.id, M = p.onCommit;
      p = p.onRender, e = e === null ? "mount" : "update", v_ && (e = "nested-update"), typeof p == "function" && p(
        y,
        e,
        t.actualDuration,
        t.treeBaseDuration,
        t.actualStartTime,
        a
      ), typeof M == "function" && M(
        t.memoizedProps.id,
        e,
        f,
        a
      );
    }
    function kv(t, e, a, f) {
      var p = t.memoizedProps;
      t = p.id, p = p.onPostCommit, e = e === null ? "mount" : "update", v_ && (e = "nested-update"), typeof p == "function" && p(
        t,
        e,
        f,
        a
      );
    }
    function Nv(t) {
      var e = t.type, a = t.memoizedProps, f = t.stateNode;
      try {
        Pt(
          t,
          Xs,
          f,
          e,
          a,
          t
        );
      } catch (p) {
        ie(t, t.return, p);
      }
    }
    function ig(t, e, a) {
      try {
        Pt(
          t,
          Ln,
          t.stateNode,
          t.type,
          a,
          e,
          t
        );
      } catch (f) {
        ie(t, t.return, f);
      }
    }
    function ag(t) {
      return t.tag === 5 || t.tag === 3 || t.tag === 26 || t.tag === 27 && Fl(t.type) || t.tag === 4;
    }
    function Ru(t) {
      t: for (; ; ) {
        for (; t.sibling === null; ) {
          if (t.return === null || ag(t.return)) return null;
          t = t.return;
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
          if (t.tag === 27 && Fl(t.type) || t.flags & 2 || t.child === null || t.tag === 4) continue t;
          t.child.return = t, t = t.child;
        }
        if (!(t.flags & 2)) return t.stateNode;
      }
    }
    function ch(t, e, a) {
      var f = t.tag;
      if (f === 5 || f === 6)
        t = t.stateNode, e ? (a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a).insertBefore(t, e) : (e = a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a, e.appendChild(t), a = a._reactRootContainer, a != null || e.onclick !== null || (e.onclick = Gs));
      else if (f !== 4 && (f === 27 && Fl(t.type) && (a = t.stateNode, e = null), t = t.child, t !== null))
        for (ch(t, e, a), t = t.sibling; t !== null; )
          ch(t, e, a), t = t.sibling;
    }
    function Cu(t, e, a) {
      var f = t.tag;
      if (f === 5 || f === 6)
        t = t.stateNode, e ? a.insertBefore(t, e) : a.appendChild(t);
      else if (f !== 4 && (f === 27 && Fl(t.type) && (a = t.stateNode), t = t.child, t !== null))
        for (Cu(t, e, a), t = t.sibling; t !== null; )
          Cu(t, e, a), t = t.sibling;
    }
    function Uv(t) {
      for (var e, a = t.return; a !== null; ) {
        if (ag(a)) {
          e = a;
          break;
        }
        a = a.return;
      }
      if (e == null)
        throw Error(
          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
        );
      switch (e.tag) {
        case 27:
          e = e.stateNode, a = Ru(t), Cu(
            t,
            a,
            e
          );
          break;
        case 5:
          a = e.stateNode, e.flags & 32 && (Qs(a), e.flags &= -33), e = Ru(t), Cu(
            t,
            e,
            a
          );
          break;
        case 3:
        case 4:
          e = e.stateNode.containerInfo, a = Ru(t), ch(
            t,
            a,
            e
          );
          break;
        default:
          throw Error(
            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
          );
      }
    }
    function og(t) {
      var e = t.stateNode, a = t.memoizedProps;
      try {
        Pt(
          t,
          lo,
          t.type,
          a,
          e,
          t
        );
      } catch (f) {
        ie(t, t.return, f);
      }
    }
    function sm(t, e) {
      if (t = t.containerInfo, Yb = X_, t = kf(t), wo(t)) {
        if ("selectionStart" in t)
          var a = {
            start: t.selectionStart,
            end: t.selectionEnd
          };
        else
          t: {
            a = (a = t.ownerDocument) && a.defaultView || window;
            var f = a.getSelection && a.getSelection();
            if (f && f.rangeCount !== 0) {
              a = f.anchorNode;
              var p = f.anchorOffset, y = f.focusNode;
              f = f.focusOffset;
              try {
                a.nodeType, y.nodeType;
              } catch {
                a = null;
                break t;
              }
              var M = 0, A = -1, B = -1, Y = 0, lt = 0, pt = t, at = null;
              e: for (; ; ) {
                for (var gt; pt !== a || p !== 0 && pt.nodeType !== 3 || (A = M + p), pt !== y || f !== 0 && pt.nodeType !== 3 || (B = M + f), pt.nodeType === 3 && (M += pt.nodeValue.length), (gt = pt.firstChild) !== null; )
                  at = pt, pt = gt;
                for (; ; ) {
                  if (pt === t) break e;
                  if (at === a && ++Y === p && (A = M), at === y && ++lt === f && (B = M), (gt = pt.nextSibling) !== null) break;
                  pt = at, at = pt.parentNode;
                }
                pt = gt;
              }
              a = A === -1 || B === -1 ? null : { start: A, end: B };
            } else a = null;
          }
        a = a || { start: 0, end: 0 };
      } else a = null;
      for (jb = {
        focusedElem: t,
        selectionRange: a
      }, X_ = !1, Ji = e; Ji !== null; )
        if (e = Ji, t = e.child, (e.subtreeFlags & 1024) !== 0 && t !== null)
          t.return = e, Ji = t;
        else
          for (; Ji !== null; ) {
            switch (t = e = Ji, a = t.alternate, p = t.flags, t.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                (p & 1024) !== 0 && a !== null && k0(t, a);
                break;
              case 3:
                if ((p & 1024) !== 0) {
                  if (t = t.stateNode.containerInfo, a = t.nodeType, a === 9)
                    Pc(t);
                  else if (a === 1)
                    switch (t.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        Pc(t);
                        break;
                      default:
                        t.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((p & 1024) !== 0)
                  throw Error(
                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                  );
            }
            if (t = e.sibling, t !== null) {
              t.return = e.return, Ji = t;
              break;
            }
            Ji = e.return;
          }
    }
    function lg(t, e, a) {
      var f = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 15:
          Vl(t, a), f & 4 && Fp(a, fa | hs);
          break;
        case 1:
          if (Vl(t, a), f & 4)
            if (t = a.stateNode, e === null)
              a.type.defaultProps || "ref" in a.memoizedProps || _p || (t.props !== a.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                wt(a) || "instance"
              ), t.state !== a.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                wt(a) || "instance"
              )), hl(a) ? (Fa(), Pt(
                a,
                db,
                a,
                t
              ), aa()) : Pt(
                a,
                db,
                a,
                t
              );
            else {
              var p = Lr(
                a.type,
                e.memoizedProps
              );
              e = e.memoizedState, a.type.defaultProps || "ref" in a.memoizedProps || _p || (t.props !== a.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                wt(a) || "instance"
              ), t.state !== a.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                wt(a) || "instance"
              )), hl(a) ? (Fa(), Pt(
                a,
                wS,
                a,
                t,
                p,
                e,
                t.__reactInternalSnapshotBeforeUpdate
              ), aa()) : Pt(
                a,
                wS,
                a,
                t,
                p,
                e,
                t.__reactInternalSnapshotBeforeUpdate
              );
            }
          f & 64 && eg(a), f & 512 && zc(a, a.return);
          break;
        case 3:
          if (e = Zi(), Vl(t, a), f & 64 && (f = a.updateQueue, f !== null)) {
            if (p = null, a.child !== null)
              switch (a.child.tag) {
                case 27:
                case 5:
                  p = a.child.stateNode;
                  break;
                case 1:
                  p = a.child.stateNode;
              }
            try {
              Pt(
                a,
                Pf,
                f,
                p
              );
            } catch (M) {
              ie(a, a.return, M);
            }
          }
          t.effectDuration += Ro(e);
          break;
        case 27:
          e === null && f & 4 && og(a);
        case 26:
        case 5:
          Vl(t, a), e === null && f & 4 && Nv(a), f & 512 && zc(a, a.return);
          break;
        case 12:
          if (f & 4) {
            f = Zi(), Vl(t, a), t = a.stateNode, t.effectDuration += Hl(f);
            try {
              Pt(
                a,
                ng,
                a,
                e,
                y_,
                t.effectDuration
              );
            } catch (M) {
              ie(a, a.return, M);
            }
          } else Vl(t, a);
          break;
        case 13:
          Vl(t, a), f & 4 && Lc(t, a), f & 64 && (t = a.memoizedState, t !== null && (t = t.dehydrated, t !== null && (a = vh.bind(
            null,
            a
          ), Vc(t, a))));
          break;
        case 22:
          if (f = a.memoizedState !== null || ic, !f) {
            e = e !== null && e.memoizedState !== null || oi, p = ic;
            var y = oi;
            ic = f, (oi = e) && !y ? Gl(
              t,
              a,
              (a.subtreeFlags & 8772) !== 0
            ) : Vl(t, a), ic = p, oi = y;
          }
          break;
        case 30:
          break;
        default:
          Vl(t, a);
      }
    }
    function sg(t) {
      var e = t.alternate;
      e !== null && (t.alternate = null, sg(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && ga(e)), t.stateNode = null, t._debugOwner = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
    }
    function Zs(t, e, a) {
      for (a = a.child; a !== null; )
        zu(
          t,
          e,
          a
        ), a = a.sibling;
    }
    function zu(t, e, a) {
      if (Ni && typeof Ni.onCommitFiberUnmount == "function")
        try {
          Ni.onCommitFiberUnmount(Qr, a);
        } catch (y) {
          Ha || (Ha = !0, console.error(
            "React instrumentation encountered an error: %s",
            y
          ));
        }
      switch (a.tag) {
        case 26:
          oi || Uo(a, e), Zs(
            t,
            e,
            a
          ), a.memoizedState ? a.memoizedState.count-- : a.stateNode && (a = a.stateNode, a.parentNode.removeChild(a));
          break;
        case 27:
          oi || Uo(a, e);
          var f = wi, p = Go;
          Fl(a.type) && (wi = a.stateNode, Go = !1), Zs(
            t,
            e,
            a
          ), Pt(
            a,
            Xc,
            a.stateNode
          ), wi = f, Go = p;
          break;
        case 5:
          oi || Uo(a, e);
        case 6:
          if (f = wi, p = Go, wi = null, Zs(
            t,
            e,
            a
          ), wi = f, Go = p, wi !== null)
            if (Go)
              try {
                Pt(
                  a,
                  qc,
                  wi,
                  a.stateNode
                );
              } catch (y) {
                ie(
                  a,
                  e,
                  y
                );
              }
            else
              try {
                Pt(
                  a,
                  jo,
                  wi,
                  a.stateNode
                );
              } catch (y) {
                ie(
                  a,
                  e,
                  y
                );
              }
          break;
        case 18:
          wi !== null && (Go ? (t = wi, Zc(
            t.nodeType === 9 ? t.body : t.nodeName === "HTML" ? t.ownerDocument.body : t,
            a.stateNode
          ), Gu(t)) : Zc(wi, a.stateNode));
          break;
        case 4:
          f = wi, p = Go, wi = a.stateNode.containerInfo, Go = !0, Zs(
            t,
            e,
            a
          ), wi = f, Go = p;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          oi || Au(
            fo,
            a,
            e
          ), oi || om(
            a,
            e,
            fa
          ), Zs(
            t,
            e,
            a
          );
          break;
        case 1:
          oi || (Uo(a, e), f = a.stateNode, typeof f.componentWillUnmount == "function" && lm(
            a,
            e,
            f
          )), Zs(
            t,
            e,
            a
          );
          break;
        case 21:
          Zs(
            t,
            e,
            a
          );
          break;
        case 22:
          oi = (f = oi) || a.memoizedState !== null, Zs(
            t,
            e,
            a
          ), oi = f;
          break;
        default:
          Zs(
            t,
            e,
            a
          );
      }
    }
    function Lc(t, e) {
      if (e.memoizedState === null && (t = e.alternate, t !== null && (t = t.memoizedState, t !== null && (t = t.dehydrated, t !== null))))
        try {
          Pt(
            e,
            oo,
            t
          );
        } catch (a) {
          ie(e, e.return, a);
        }
    }
    function rm(t) {
      switch (t.tag) {
        case 13:
        case 19:
          var e = t.stateNode;
          return e === null && (e = t.stateNode = new eT()), e;
        case 22:
          return t = t.stateNode, e = t._retryCache, e === null && (e = t._retryCache = new eT()), e;
        default:
          throw Error(
            "Unexpected Suspense handler tag (" + t.tag + "). This is a bug in React."
          );
      }
    }
    function Lu(t, e) {
      var a = rm(t);
      e.forEach(function(f) {
        var p = Br.bind(null, t, f);
        if (!a.has(f)) {
          if (a.add(f), kn)
            if (bp !== null && Sp !== null)
              Yc(Sp, bp);
            else
              throw Error(
                "Expected finished root and lanes to be set. This is a bug in React."
              );
          f.then(p, p);
        }
      });
    }
    function Qi(t, e) {
      var a = e.deletions;
      if (a !== null)
        for (var f = 0; f < a.length; f++) {
          var p = t, y = e, M = a[f], A = y;
          t: for (; A !== null; ) {
            switch (A.tag) {
              case 27:
                if (Fl(A.type)) {
                  wi = A.stateNode, Go = !1;
                  break t;
                }
                break;
              case 5:
                wi = A.stateNode, Go = !1;
                break t;
              case 3:
              case 4:
                wi = A.stateNode.containerInfo, Go = !0;
                break t;
            }
            A = A.return;
          }
          if (wi === null)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          zu(p, y, M), wi = null, Go = !1, p = M, y = p.alternate, y !== null && (y.return = null), p.return = null;
        }
      if (e.subtreeFlags & 13878)
        for (e = e.child; e !== null; )
          rg(e, t), e = e.sibling;
    }
    function rg(t, e) {
      var a = t.alternate, f = t.flags;
      switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Qi(e, t), Aa(t), f & 4 && (Au(
            fo | hs,
            t,
            t.return
          ), Du(fo | hs, t), om(
            t,
            t.return,
            fa | hs
          ));
          break;
        case 1:
          Qi(e, t), Aa(t), f & 512 && (oi || a === null || Uo(a, a.return)), f & 64 && ic && (t = t.updateQueue, t !== null && (f = t.callbacks, f !== null && (a = t.shared.hiddenCallbacks, t.shared.hiddenCallbacks = a === null ? f : a.concat(f))));
          break;
        case 26:
          var p = or;
          if (Qi(e, t), Aa(t), f & 512 && (oi || a === null || Uo(a, a.return)), f & 4)
            if (e = a !== null ? a.memoizedState : null, f = t.memoizedState, a === null)
              if (f === null)
                if (t.stateNode === null) {
                  t: {
                    f = t.type, a = t.memoizedProps, e = p.ownerDocument || p;
                    e: switch (f) {
                      case "title":
                        p = e.getElementsByTagName("title")[0], (!p || p[af] || p[Ii] || p.namespaceURI === rf || p.hasAttribute("itemprop")) && (p = e.createElement(f), e.head.insertBefore(
                          p,
                          e.querySelector("head > title")
                        )), zn(p, f, a), p[Ii] = t, J(p), f = p;
                        break t;
                      case "link":
                        var y = jg(
                          "link",
                          "href",
                          e
                        ).get(f + (a.href || ""));
                        if (y) {
                          for (var M = 0; M < y.length; M++)
                            if (p = y[M], p.getAttribute("href") === (a.href == null || a.href === "" ? null : a.href) && p.getAttribute("rel") === (a.rel == null ? null : a.rel) && p.getAttribute("title") === (a.title == null ? null : a.title) && p.getAttribute("crossorigin") === (a.crossOrigin == null ? null : a.crossOrigin)) {
                              y.splice(M, 1);
                              break e;
                            }
                        }
                        p = e.createElement(f), zn(p, f, a), e.head.appendChild(p);
                        break;
                      case "meta":
                        if (y = jg(
                          "meta",
                          "content",
                          e
                        ).get(f + (a.content || ""))) {
                          for (M = 0; M < y.length; M++)
                            if (p = y[M], ct(
                              a.content,
                              "content"
                            ), p.getAttribute("content") === (a.content == null ? null : "" + a.content) && p.getAttribute("name") === (a.name == null ? null : a.name) && p.getAttribute("property") === (a.property == null ? null : a.property) && p.getAttribute("http-equiv") === (a.httpEquiv == null ? null : a.httpEquiv) && p.getAttribute("charset") === (a.charSet == null ? null : a.charSet)) {
                              y.splice(M, 1);
                              break e;
                            }
                        }
                        p = e.createElement(f), zn(p, f, a), e.head.appendChild(p);
                        break;
                      default:
                        throw Error(
                          'getNodesForType encountered a type it did not expect: "' + f + '". This is a bug in React.'
                        );
                    }
                    p[Ii] = t, J(p), f = p;
                  }
                  t.stateNode = f;
                } else
                  qg(
                    p,
                    t.type,
                    t.stateNode
                  );
              else
                t.stateNode = Cm(
                  p,
                  f,
                  t.memoizedProps
                );
            else
              e !== f ? (e === null ? a.stateNode !== null && (a = a.stateNode, a.parentNode.removeChild(a)) : e.count--, f === null ? qg(
                p,
                t.type,
                t.stateNode
              ) : Cm(
                p,
                f,
                t.memoizedProps
              )) : f === null && t.stateNode !== null && ig(
                t,
                t.memoizedProps,
                a.memoizedProps
              );
          break;
        case 27:
          Qi(e, t), Aa(t), f & 512 && (oi || a === null || Uo(a, a.return)), a !== null && f & 4 && ig(
            t,
            t.memoizedProps,
            a.memoizedProps
          );
          break;
        case 5:
          if (Qi(e, t), Aa(t), f & 512 && (oi || a === null || Uo(a, a.return)), t.flags & 32) {
            e = t.stateNode;
            try {
              Pt(t, Qs, e);
            } catch (lt) {
              ie(t, t.return, lt);
            }
          }
          f & 4 && t.stateNode != null && (e = t.memoizedProps, ig(
            t,
            e,
            a !== null ? a.memoizedProps : e
          )), f & 1024 && (bb = !0, t.type !== "form" && console.error(
            "Unexpected host component type. Expected a form. This is a bug in React."
          ));
          break;
        case 6:
          if (Qi(e, t), Aa(t), f & 4) {
            if (t.stateNode === null)
              throw Error(
                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
              );
            f = t.memoizedProps, a = a !== null ? a.memoizedProps : f, e = t.stateNode;
            try {
              Pt(
                t,
                qu,
                e,
                a,
                f
              );
            } catch (lt) {
              ie(t, t.return, lt);
            }
          }
          break;
        case 3:
          if (p = Zi(), P_ = null, y = or, or = bh(e.containerInfo), Qi(e, t), or = y, Aa(t), f & 4 && a !== null && a.memoizedState.isDehydrated)
            try {
              Pt(
                t,
                kg,
                e.containerInfo
              );
            } catch (lt) {
              ie(t, t.return, lt);
            }
          bb && (bb = !1, Hu(t)), e.effectDuration += Ro(p);
          break;
        case 4:
          f = or, or = bh(
            t.stateNode.containerInfo
          ), Qi(e, t), Aa(t), or = f;
          break;
        case 12:
          f = Zi(), Qi(e, t), Aa(t), t.stateNode.effectDuration += Hl(f);
          break;
        case 13:
          Qi(e, t), Aa(t), t.child.flags & 8192 && t.memoizedState !== null != (a !== null && a.memoizedState !== null) && (Eb = is()), f & 4 && (f = t.updateQueue, f !== null && (t.updateQueue = null, Lu(t, f)));
          break;
        case 22:
          p = t.memoizedState !== null;
          var A = a !== null && a.memoizedState !== null, B = ic, Y = oi;
          if (ic = B || p, oi = Y || A, Qi(e, t), oi = Y, ic = B, Aa(t), f & 8192)
            t: for (e = t.stateNode, e._visibility = p ? e._visibility & ~d_ : e._visibility | d_, p && (a === null || A || ic || oi || Ki(t)), a = null, e = t; ; ) {
              if (e.tag === 5 || e.tag === 26) {
                if (a === null) {
                  A = a = e;
                  try {
                    y = A.stateNode, p ? Pt(A, za, y) : Pt(
                      A,
                      Lg,
                      A.stateNode,
                      A.memoizedProps
                    );
                  } catch (lt) {
                    ie(A, A.return, lt);
                  }
                }
              } else if (e.tag === 6) {
                if (a === null) {
                  A = e;
                  try {
                    M = A.stateNode, p ? Pt(A, zg, M) : Pt(
                      A,
                      Dm,
                      M,
                      A.memoizedProps
                    );
                  } catch (lt) {
                    ie(A, A.return, lt);
                  }
                }
              } else if ((e.tag !== 22 && e.tag !== 23 || e.memoizedState === null || e === t) && e.child !== null) {
                e.child.return = e, e = e.child;
                continue;
              }
              if (e === t) break t;
              for (; e.sibling === null; ) {
                if (e.return === null || e.return === t)
                  break t;
                a === e && (a = null), e = e.return;
              }
              a === e && (a = null), e.sibling.return = e.return, e = e.sibling;
            }
          f & 4 && (f = t.updateQueue, f !== null && (a = f.retryQueue, a !== null && (f.retryQueue = null, Lu(t, a))));
          break;
        case 19:
          Qi(e, t), Aa(t), f & 4 && (f = t.updateQueue, f !== null && (t.updateQueue = null, Lu(t, f)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          Qi(e, t), Aa(t);
      }
    }
    function Aa(t) {
      var e = t.flags;
      if (e & 2) {
        try {
          Pt(t, Uv, t);
        } catch (a) {
          ie(t, t.return, a);
        }
        t.flags &= -3;
      }
      e & 4096 && (t.flags &= -4097);
    }
    function Hu(t) {
      if (t.subtreeFlags & 1024)
        for (t = t.child; t !== null; ) {
          var e = t;
          Hu(e), e.tag === 5 && e.flags & 1024 && e.stateNode.reset(), t = t.sibling;
        }
    }
    function Vl(t, e) {
      if (e.subtreeFlags & 8772)
        for (e = e.child; e !== null; )
          lg(t, e.alternate, e), e = e.sibling;
    }
    function ao(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          om(
            t,
            t.return,
            fa
          ), Ki(t);
          break;
        case 1:
          Uo(t, t.return);
          var e = t.stateNode;
          typeof e.componentWillUnmount == "function" && lm(
            t,
            t.return,
            e
          ), Ki(t);
          break;
        case 27:
          Pt(
            t,
            Xc,
            t.stateNode
          );
        case 26:
        case 5:
          Uo(t, t.return), Ki(t);
          break;
        case 22:
          t.memoizedState === null && Ki(t);
          break;
        case 30:
          Ki(t);
          break;
        default:
          Ki(t);
      }
    }
    function Ki(t) {
      for (t = t.child; t !== null; )
        ao(t), t = t.sibling;
    }
    function Ps(t, e, a, f) {
      var p = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 15:
          Gl(
            t,
            a,
            f
          ), Fp(a, fa);
          break;
        case 1:
          if (Gl(
            t,
            a,
            f
          ), e = a.stateNode, typeof e.componentDidMount == "function" && Pt(
            a,
            db,
            a,
            e
          ), e = a.updateQueue, e !== null) {
            t = a.stateNode;
            try {
              Pt(
                a,
                Us,
                e,
                t
              );
            } catch (y) {
              ie(a, a.return, y);
            }
          }
          f && p & 64 && eg(a), zc(a, a.return);
          break;
        case 27:
          og(a);
        case 26:
        case 5:
          Gl(
            t,
            a,
            f
          ), f && e === null && p & 4 && Nv(a), zc(a, a.return);
          break;
        case 12:
          if (f && p & 4) {
            p = Zi(), Gl(
              t,
              a,
              f
            ), f = a.stateNode, f.effectDuration += Hl(p);
            try {
              Pt(
                a,
                ng,
                a,
                e,
                y_,
                f.effectDuration
              );
            } catch (y) {
              ie(a, a.return, y);
            }
          } else
            Gl(
              t,
              a,
              f
            );
          break;
        case 13:
          Gl(
            t,
            a,
            f
          ), f && p & 4 && Lc(t, a);
          break;
        case 22:
          a.memoizedState === null && Gl(
            t,
            a,
            f
          ), zc(a, a.return);
          break;
        case 30:
          break;
        default:
          Gl(
            t,
            a,
            f
          );
      }
    }
    function Gl(t, e, a) {
      for (a = a && (e.subtreeFlags & 8772) !== 0, e = e.child; e !== null; )
        Ps(
          t,
          e.alternate,
          e,
          a
        ), e = e.sibling;
    }
    function Xl(t, e) {
      var a = null;
      t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (a = t.memoizedState.cachePool.pool), t = null, e.memoizedState !== null && e.memoizedState.cachePool !== null && (t = e.memoizedState.cachePool.pool), t !== a && (t != null && Ao(t), a != null && Ri(a));
    }
    function dl(t, e) {
      t = null, e.alternate !== null && (t = e.alternate.memoizedState.cache), e = e.memoizedState.cache, e !== t && (Ao(e), t != null && Ri(t));
    }
    function nn(t, e, a, f) {
      if (e.subtreeFlags & 10256)
        for (e = e.child; e !== null; )
          fh(
            t,
            e,
            a,
            f
          ), e = e.sibling;
    }
    function fh(t, e, a, f) {
      var p = e.flags;
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          nn(
            t,
            e,
            a,
            f
          ), p & 2048 && tg(e, Yi | hs);
          break;
        case 1:
          nn(
            t,
            e,
            a,
            f
          );
          break;
        case 3:
          var y = Zi();
          nn(
            t,
            e,
            a,
            f
          ), p & 2048 && (a = null, e.alternate !== null && (a = e.alternate.memoizedState.cache), e = e.memoizedState.cache, e !== a && (Ao(e), a != null && Ri(a))), t.passiveEffectDuration += Ro(y);
          break;
        case 12:
          if (p & 2048) {
            p = Zi(), nn(
              t,
              e,
              a,
              f
            ), t = e.stateNode, t.passiveEffectDuration += Hl(p);
            try {
              Pt(
                e,
                kv,
                e,
                e.alternate,
                y_,
                t.passiveEffectDuration
              );
            } catch (A) {
              ie(e, e.return, A);
            }
          } else
            nn(
              t,
              e,
              a,
              f
            );
          break;
        case 13:
          nn(
            t,
            e,
            a,
            f
          );
          break;
        case 23:
          break;
        case 22:
          y = e.stateNode;
          var M = e.alternate;
          e.memoizedState !== null ? y._visibility & $u ? nn(
            t,
            e,
            a,
            f
          ) : Hc(
            t,
            e
          ) : y._visibility & $u ? nn(
            t,
            e,
            a,
            f
          ) : (y._visibility |= $u, kr(
            t,
            e,
            a,
            f,
            (e.subtreeFlags & 10256) !== 0
          )), p & 2048 && Xl(M, e);
          break;
        case 24:
          nn(
            t,
            e,
            a,
            f
          ), p & 2048 && dl(e.alternate, e);
          break;
        default:
          nn(
            t,
            e,
            a,
            f
          );
      }
    }
    function kr(t, e, a, f, p) {
      for (p = p && (e.subtreeFlags & 10256) !== 0, e = e.child; e !== null; )
        um(
          t,
          e,
          a,
          f,
          p
        ), e = e.sibling;
    }
    function um(t, e, a, f, p) {
      var y = e.flags;
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          kr(
            t,
            e,
            a,
            f,
            p
          ), tg(e, Yi);
          break;
        case 23:
          break;
        case 22:
          var M = e.stateNode;
          e.memoizedState !== null ? M._visibility & $u ? kr(
            t,
            e,
            a,
            f,
            p
          ) : Hc(
            t,
            e
          ) : (M._visibility |= $u, kr(
            t,
            e,
            a,
            f,
            p
          )), p && y & 2048 && Xl(
            e.alternate,
            e
          );
          break;
        case 24:
          kr(
            t,
            e,
            a,
            f,
            p
          ), p && y & 2048 && dl(e.alternate, e);
          break;
        default:
          kr(
            t,
            e,
            a,
            f,
            p
          );
      }
    }
    function Hc(t, e) {
      if (e.subtreeFlags & 10256)
        for (e = e.child; e !== null; ) {
          var a = t, f = e, p = f.flags;
          switch (f.tag) {
            case 22:
              Hc(
                a,
                f
              ), p & 2048 && Xl(
                f.alternate,
                f
              );
              break;
            case 24:
              Hc(
                a,
                f
              ), p & 2048 && dl(
                f.alternate,
                f
              );
              break;
            default:
              Hc(
                a,
                f
              );
          }
          e = e.sibling;
        }
    }
    function ku(t) {
      if (t.subtreeFlags & Ry)
        for (t = t.child; t !== null; )
          Nr(t), t = t.sibling;
    }
    function Nr(t) {
      switch (t.tag) {
        case 26:
          ku(t), t.flags & Ry && t.memoizedState !== null && Kv(
            or,
            t.memoizedState,
            t.memoizedProps
          );
          break;
        case 5:
          ku(t);
          break;
        case 3:
        case 4:
          var e = or;
          or = bh(
            t.stateNode.containerInfo
          ), ku(t), or = e;
          break;
        case 22:
          t.memoizedState === null && (e = t.alternate, e !== null && e.memoizedState !== null ? (e = Ry, Ry = 16777216, ku(t), Ry = e) : ku(t));
          break;
        default:
          ku(t);
      }
    }
    function hh(t) {
      var e = t.alternate;
      if (e !== null && (t = e.child, t !== null)) {
        e.child = null;
        do
          e = t.sibling, t.sibling = null, t = e;
        while (t !== null);
      }
    }
    function kc(t) {
      var e = t.deletions;
      if ((t.flags & 16) !== 0) {
        if (e !== null)
          for (var a = 0; a < e.length; a++) {
            var f = e[a];
            Ji = f, cg(
              f,
              t
            );
          }
        hh(t);
      }
      if (t.subtreeFlags & 10256)
        for (t = t.child; t !== null; )
          ug(t), t = t.sibling;
    }
    function ug(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          kc(t), t.flags & 2048 && uh(
            t,
            t.return,
            Yi | hs
          );
          break;
        case 3:
          var e = Zi();
          kc(t), t.stateNode.passiveEffectDuration += Ro(e);
          break;
        case 12:
          e = Zi(), kc(t), t.stateNode.passiveEffectDuration += Hl(e);
          break;
        case 22:
          e = t.stateNode, t.memoizedState !== null && e._visibility & $u && (t.return === null || t.return.tag !== 13) ? (e._visibility &= ~$u, dh(t)) : kc(t);
          break;
        default:
          kc(t);
      }
    }
    function dh(t) {
      var e = t.deletions;
      if ((t.flags & 16) !== 0) {
        if (e !== null)
          for (var a = 0; a < e.length; a++) {
            var f = e[a];
            Ji = f, cg(
              f,
              t
            );
          }
        hh(t);
      }
      for (t = t.child; t !== null; )
        mh(t), t = t.sibling;
    }
    function mh(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          uh(
            t,
            t.return,
            Yi
          ), dh(t);
          break;
        case 22:
          var e = t.stateNode;
          e._visibility & $u && (e._visibility &= ~$u, dh(t));
          break;
        default:
          dh(t);
      }
    }
    function cg(t, e) {
      for (; Ji !== null; ) {
        var a = Ji, f = a;
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            uh(
              f,
              e,
              Yi
            );
            break;
          case 23:
          case 22:
            f.memoizedState !== null && f.memoizedState.cachePool !== null && (f = f.memoizedState.cachePool.pool, f != null && Ao(f));
            break;
          case 24:
            Ri(f.memoizedState.cache);
        }
        if (f = a.child, f !== null) f.return = a, Ji = f;
        else
          t: for (a = t; Ji !== null; ) {
            f = Ji;
            var p = f.sibling, y = f.return;
            if (sg(f), f === a) {
              Ji = null;
              break t;
            }
            if (p !== null) {
              p.return = y, Ji = p;
              break t;
            }
            Ji = y;
          }
      }
    }
    function fg() {
      hE.forEach(function(t) {
        return t();
      });
    }
    function hg() {
      var t = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
      return t || ft.actQueue === null || console.error(
        "The current testing environment is not configured to support act(...)"
      ), t;
    }
    function Ra(t) {
      if (($e & ho) !== yl && Ne !== 0)
        return Ne & -Ne;
      var e = ft.T;
      return e !== null ? (e._updatedFibers || (e._updatedFibers = /* @__PURE__ */ new Set()), e._updatedFibers.add(t), t = Xh, t !== 0 ? t : Sg()) : fr();
    }
    function Bv() {
      _l === 0 && (_l = (Ne & 536870912) === 0 || Pe ? pe() : 536870912);
      var t = ms.current;
      return t !== null && (t.flags |= 32), _l;
    }
    function Rn(t, e, a) {
      if (Ep && console.error("useInsertionEffect must not schedule updates."), Cb && (C_ = !0), (t === mn && (an === $h || an === Jh) || t.cancelPendingCommit !== null) && (Uu(t, 0), Vs(
        t,
        Ne,
        _l,
        !1
      )), po(t, a), ($e & ho) !== 0 && t === mn) {
        if (Na)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              t = ke && wt(ke) || "Unknown", fT.has(t) || (fT.add(t), e = wt(e) || "Unknown", console.error(
                "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                e,
                t,
                t
              ));
              break;
            case 1:
              cT || (console.error(
                "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
              ), cT = !0);
          }
      } else
        kn && ta(t, e, a), Zv(e), t === mn && (($e & ho) === yl && (pf |= a), Kn === Ih && Vs(
          t,
          Ne,
          _l,
          !1
        )), Bo(t);
    }
    function ii(t, e, a) {
      if (($e & (ho | lr)) !== yl)
        throw Error("Should not already be working.");
      var f = !a && (e & 124) === 0 && (e & t.expiredLanes) === 0 || Pa(t, e), p = f ? mg(t, e) : dm(t, e, !0), y = f;
      do {
        if (p === ac) {
          wp && !f && Vs(t, e, 0, !1);
          break;
        } else {
          if (a = t.current.alternate, y && !Yv(a)) {
            p = dm(t, e, !1), y = !1;
            continue;
          }
          if (p === Tp) {
            if (y = e, t.errorRecoveryDisabledLanes & y)
              var M = 0;
            else
              M = t.pendingLanes & -536870913, M = M !== 0 ? M : M & 536870912 ? 536870912 : 0;
            if (M !== 0) {
              e = M;
              t: {
                p = t;
                var A = M;
                M = Ny;
                var B = p.current.memoizedState.isDehydrated;
                if (B && (Uu(
                  p,
                  A
                ).flags |= 256), A = dm(
                  p,
                  A,
                  !1
                ), A !== Tp) {
                  if (wb && !B) {
                    p.errorRecoveryDisabledLanes |= y, pf |= y, p = Ih;
                    break t;
                  }
                  p = mo, mo = M, p !== null && (mo === null ? mo = p : mo.push.apply(
                    mo,
                    p
                  ));
                }
                p = A;
              }
              if (y = !1, p !== Tp) continue;
            }
          }
          if (p === zy) {
            Uu(t, 0), Vs(t, e, 0, !0);
            break;
          }
          t: {
            switch (f = t, p) {
              case ac:
              case zy:
                throw Error("Root did not complete. This is a bug in React.");
              case Ih:
                if ((e & 4194048) !== e) break;
              case D_:
                Vs(
                  f,
                  e,
                  _l,
                  !df
                );
                break t;
              case Tp:
                mo = null;
                break;
              case Sb:
              case nT:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (ft.actQueue !== null)
              vm(
                f,
                a,
                e,
                mo,
                Uy,
                A_,
                _l,
                pf,
                Fh
              );
            else {
              if ((e & 62914560) === e && (y = Eb + aT - is(), 10 < y)) {
                if (Vs(
                  f,
                  e,
                  _l,
                  !df
                ), En(f, 0, !0) !== 0) break t;
                f.timeoutHandle = _T(
                  bi.bind(
                    null,
                    f,
                    a,
                    mo,
                    Uy,
                    A_,
                    e,
                    _l,
                    pf,
                    Fh,
                    df,
                    p,
                    gE,
                    lS,
                    0
                  ),
                  y
                );
                break t;
              }
              bi(
                f,
                a,
                mo,
                Uy,
                A_,
                e,
                _l,
                pf,
                Fh,
                df,
                p,
                mE,
                lS,
                0
              );
            }
          }
        }
        break;
      } while (!0);
      Bo(t);
    }
    function bi(t, e, a, f, p, y, M, A, B, Y, lt, pt, at, gt) {
      if (t.timeoutHandle = ad, pt = e.subtreeFlags, (pt & 8192 || (pt & 16785408) === 16785408) && (Py = { stylesheets: null, count: 0, unsuspend: Qv }, Nr(e), pt = Wv(), pt !== null)) {
        t.cancelPendingCommit = pt(
          vm.bind(
            null,
            t,
            e,
            y,
            a,
            f,
            p,
            M,
            A,
            B,
            lt,
            pE,
            at,
            gt
          )
        ), Vs(
          t,
          y,
          M,
          !Y
        );
        return;
      }
      vm(
        t,
        e,
        y,
        a,
        f,
        p,
        M,
        A,
        B
      );
    }
    function Yv(t) {
      for (var e = t; ; ) {
        var a = e.tag;
        if ((a === 0 || a === 11 || a === 15) && e.flags & 16384 && (a = e.updateQueue, a !== null && (a = a.stores, a !== null)))
          for (var f = 0; f < a.length; f++) {
            var p = a[f], y = p.getSnapshot;
            p = p.value;
            try {
              if (!uo(y(), p)) return !1;
            } catch {
              return !1;
            }
          }
        if (a = e.child, e.subtreeFlags & 16384 && a !== null)
          a.return = e, e = a;
        else {
          if (e === t) break;
          for (; e.sibling === null; ) {
            if (e.return === null || e.return === t) return !0;
            e = e.return;
          }
          e.sibling.return = e.return, e = e.sibling;
        }
      }
      return !0;
    }
    function Vs(t, e, a, f) {
      e &= ~Mb, e &= ~pf, t.suspendedLanes |= e, t.pingedLanes &= ~e, f && (t.warmLanes |= e), f = t.expirationTimes;
      for (var p = e; 0 < p; ) {
        var y = 31 - Wi(p), M = 1 << y;
        f[y] = -1, p &= ~M;
      }
      a !== 0 && hu(t, a, e);
    }
    function Nu() {
      return ($e & (ho | lr)) === yl ? (Bu(0), !1) : !0;
    }
    function cm() {
      if (ke !== null) {
        if (an === Xo)
          var t = ke.return;
        else
          t = ke, Tr(), H(t), pp = null, Dy = 0, t = ke;
        for (; t !== null; )
          Jp(t.alternate, t), t = t.return;
        ke = null;
      }
    }
    function Uu(t, e) {
      var a = t.timeoutHandle;
      a !== ad && (t.timeoutHandle = ad, AE(a)), a = t.cancelPendingCommit, a !== null && (t.cancelPendingCommit = null, a()), cm(), mn = t, ke = a = Ia(t.current, null), Ne = e, an = Xo, vl = null, df = !1, wp = Pa(t, e), wb = !1, Kn = ac, Fh = _l = Mb = pf = mf = 0, mo = Ny = null, A_ = !1, (e & 8) !== 0 && (e |= e & 32);
      var f = t.entangledLanes;
      if (f !== 0)
        for (t = t.entanglements, f &= e; 0 < f; ) {
          var p = 31 - Wi(f), y = 1 << p;
          e |= t[p], f &= ~y;
        }
      return nu = e, _r(), e = aS(), 1e3 < e - iS && (ft.recentlyCreatedOwnerStacks = 0, iS = e), ir.discardPendingWarnings(), a;
    }
    function ph(t, e) {
      me = null, ft.H = E_, ft.getCurrentStack = null, Na = !1, ro = null, e === wy || e === S_ ? (e = kl(), an = Hy) : e === uS ? (e = kl(), an = iT) : an = e === QS ? xb : e !== null && typeof e == "object" && typeof e.then == "function" ? xp : Ly, vl = e;
      var a = ke;
      if (a === null)
        Kn = zy, Cc(
          t,
          qi(e, t.current)
        );
      else
        switch (a.mode & ca && Sa(a), fi(), an) {
          case Ly:
            jt !== null && typeof jt.markComponentErrored == "function" && jt.markComponentErrored(
              a,
              e,
              Ne
            );
            break;
          case $h:
          case Jh:
          case Hy:
          case xp:
          case ky:
            jt !== null && typeof jt.markComponentSuspended == "function" && jt.markComponentSuspended(
              a,
              e,
              Ne
            );
        }
    }
    function fm() {
      var t = ft.H;
      return ft.H = E_, t === null ? E_ : t;
    }
    function dg() {
      var t = ft.A;
      return ft.A = fE, t;
    }
    function hm() {
      Kn = Ih, df || (Ne & 4194048) !== Ne && ms.current !== null || (wp = !0), (mf & 134217727) === 0 && (pf & 134217727) === 0 || mn === null || Vs(
        mn,
        Ne,
        _l,
        !1
      );
    }
    function dm(t, e, a) {
      var f = $e;
      $e |= ho;
      var p = fm(), y = dg();
      if (mn !== t || Ne !== e) {
        if (kn) {
          var M = t.memoizedUpdaters;
          0 < M.size && (Yc(t, Ne), M.clear()), $n(t, e);
        }
        Uy = null, Uu(t, e);
      }
      da(e), e = !1, M = Kn;
      t: do
        try {
          if (an !== Xo && ke !== null) {
            var A = ke, B = vl;
            switch (an) {
              case xb:
                cm(), M = D_;
                break t;
              case Hy:
              case $h:
              case Jh:
              case xp:
                ms.current === null && (e = !0);
                var Y = an;
                if (an = Xo, vl = null, Ur(t, A, B, Y), a && wp) {
                  M = ac;
                  break t;
                }
                break;
              default:
                Y = an, an = Xo, vl = null, Ur(t, A, B, Y);
            }
          }
          mm(), M = Kn;
          break;
        } catch (lt) {
          ph(t, lt);
        }
      while (!0);
      return e && t.shellSuspendCounter++, Tr(), $e = f, ft.H = p, ft.A = y, Za(), ke === null && (mn = null, Ne = 0, _r()), M;
    }
    function mm() {
      for (; ke !== null; ) gg(ke);
    }
    function mg(t, e) {
      var a = $e;
      $e |= ho;
      var f = fm(), p = dg();
      if (mn !== t || Ne !== e) {
        if (kn) {
          var y = t.memoizedUpdaters;
          0 < y.size && (Yc(t, Ne), y.clear()), $n(t, e);
        }
        Uy = null, R_ = is() + oT, Uu(t, e);
      } else
        wp = Pa(
          t,
          e
        );
      da(e);
      t: do
        try {
          if (an !== Xo && ke !== null)
            e: switch (e = ke, y = vl, an) {
              case Ly:
                an = Xo, vl = null, Ur(
                  t,
                  e,
                  y,
                  Ly
                );
                break;
              case $h:
              case Jh:
                if (Zf(y)) {
                  an = Xo, vl = null, pm(e);
                  break;
                }
                e = function() {
                  an !== $h && an !== Jh || mn !== t || (an = ky), Bo(t);
                }, y.then(e, e);
                break t;
              case Hy:
                an = ky;
                break t;
              case iT:
                an = Tb;
                break t;
              case ky:
                Zf(y) ? (an = Xo, vl = null, pm(e)) : (an = Xo, vl = null, Ur(
                  t,
                  e,
                  y,
                  ky
                ));
                break;
              case Tb:
                var M = null;
                switch (ke.tag) {
                  case 26:
                    M = ke.memoizedState;
                  case 5:
                  case 27:
                    var A = ke;
                    if (!M || Sh(M)) {
                      an = Xo, vl = null;
                      var B = A.sibling;
                      if (B !== null) ke = B;
                      else {
                        var Y = A.return;
                        Y !== null ? (ke = Y, gh(Y)) : ke = null;
                      }
                      break e;
                    }
                    break;
                  default:
                    console.error(
                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                    );
                }
                an = Xo, vl = null, Ur(
                  t,
                  e,
                  y,
                  Tb
                );
                break;
              case xp:
                an = Xo, vl = null, Ur(
                  t,
                  e,
                  y,
                  xp
                );
                break;
              case xb:
                cm(), Kn = D_;
                break t;
              default:
                throw Error(
                  "Unexpected SuspendedReason. This is a bug in React."
                );
            }
          ft.actQueue !== null ? mm() : pg();
          break;
        } catch (lt) {
          ph(t, lt);
        }
      while (!0);
      return Tr(), ft.H = f, ft.A = p, $e = a, ke !== null ? (jt !== null && typeof jt.markRenderYielded == "function" && jt.markRenderYielded(), ac) : (Za(), mn = null, Ne = 0, _r(), Kn);
    }
    function pg() {
      for (; ke !== null && !n_(); )
        gg(ke);
    }
    function gg(t) {
      var e = t.alternate;
      (t.mode & ca) !== bn ? (xc(t), e = Pt(
        t,
        am,
        e,
        t,
        nu
      ), Sa(t)) : e = Pt(
        t,
        am,
        e,
        t,
        nu
      ), t.memoizedProps = t.pendingProps, e === null ? gh(t) : ke = e;
    }
    function pm(t) {
      var e = Pt(t, gm, t);
      t.memoizedProps = t.pendingProps, e === null ? gh(t) : ke = e;
    }
    function gm(t) {
      var e = t.alternate, a = (t.mode & ca) !== bn;
      switch (a && xc(t), t.tag) {
        case 15:
        case 0:
          e = Qp(
            e,
            t,
            t.pendingProps,
            t.type,
            void 0,
            Ne
          );
          break;
        case 11:
          e = Qp(
            e,
            t,
            t.pendingProps,
            t.type.render,
            t.ref,
            Ne
          );
          break;
        case 5:
          H(t);
        default:
          Jp(e, t), t = ke = Bf(t, nu), e = am(e, t, nu);
      }
      return a && Sa(t), e;
    }
    function Ur(t, e, a, f) {
      Tr(), H(e), pp = null, Dy = 0;
      var p = e.return;
      try {
        if (nh(
          t,
          p,
          e,
          a,
          Ne
        )) {
          Kn = zy, Cc(
            t,
            qi(a, t.current)
          ), ke = null;
          return;
        }
      } catch (y) {
        if (p !== null) throw ke = p, y;
        Kn = zy, Cc(
          t,
          qi(a, t.current)
        ), ke = null;
        return;
      }
      e.flags & 32768 ? (Pe || f === Ly ? t = !0 : wp || (Ne & 536870912) !== 0 ? t = !1 : (df = t = !0, (f === $h || f === Jh || f === Hy || f === xp) && (f = ms.current, f !== null && f.tag === 13 && (f.flags |= 16384))), ym(e, t)) : gh(e);
    }
    function gh(t) {
      var e = t;
      do {
        if ((e.flags & 32768) !== 0) {
          ym(
            e,
            df
          );
          return;
        }
        var a = e.alternate;
        if (t = e.return, xc(e), a = Pt(
          e,
          Cv,
          a,
          e,
          nu
        ), (e.mode & ca) !== bn && ks(e), a !== null) {
          ke = a;
          return;
        }
        if (e = e.sibling, e !== null) {
          ke = e;
          return;
        }
        ke = e = t;
      } while (e !== null);
      Kn === ac && (Kn = nT);
    }
    function ym(t, e) {
      do {
        var a = zv(t.alternate, t);
        if (a !== null) {
          a.flags &= 32767, ke = a;
          return;
        }
        if ((t.mode & ca) !== bn) {
          ks(t), a = t.actualDuration;
          for (var f = t.child; f !== null; )
            a += f.actualDuration, f = f.sibling;
          t.actualDuration = a;
        }
        if (a = t.return, a !== null && (a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null), !e && (t = t.sibling, t !== null)) {
          ke = t;
          return;
        }
        ke = t = a;
      } while (t !== null);
      Kn = D_, ke = null;
    }
    function vm(t, e, a, f, p, y, M, A, B) {
      t.cancelPendingCommit = null;
      do
        Nc();
      while (ha !== td);
      if (ir.flushLegacyContextWarning(), ir.flushPendingUnsafeLifecycleWarnings(), ($e & (ho | lr)) !== yl)
        throw Error("Should not already be working.");
      if (jt !== null && typeof jt.markCommitStarted == "function" && jt.markCommitStarted(a), e === null) Ft();
      else {
        if (a === 0 && console.error(
          "finishedLanes should not be empty during a commit. This is a bug in React."
        ), e === t.current)
          throw Error(
            "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
          );
        if (y = e.lanes | e.childLanes, y |= tb, mc(
          t,
          a,
          y,
          M,
          A,
          B
        ), t === mn && (ke = mn = null, Ne = 0), Mp = e, yf = t, vf = a, Db = y, Ab = p, uT = f, (e.subtreeFlags & 10256) !== 0 || (e.flags & 10256) !== 0 ? (t.callbackNode = null, t.callbackPriority = 0, bg(tf, function() {
          return yh(), null;
        })) : (t.callbackNode = null, t.callbackPriority = 0), y_ = cp(), f = (e.flags & 13878) !== 0, (e.subtreeFlags & 13878) !== 0 || f) {
          f = ft.T, ft.T = null, p = re.p, re.p = Ui, M = $e, $e |= lr;
          try {
            sm(t, e, a);
          } finally {
            $e = M, re.p = p, ft.T = f;
          }
        }
        ha = lT, Ql(), _m(), jv();
      }
    }
    function Ql() {
      if (ha === lT) {
        ha = td;
        var t = yf, e = Mp, a = vf, f = (e.flags & 13878) !== 0;
        if ((e.subtreeFlags & 13878) !== 0 || f) {
          f = ft.T, ft.T = null;
          var p = re.p;
          re.p = Ui;
          var y = $e;
          $e |= lr;
          try {
            bp = a, Sp = t, rg(e, t), Sp = bp = null, a = jb;
            var M = kf(t.containerInfo), A = a.focusedElem, B = a.selectionRange;
            if (M !== A && A && A.ownerDocument && Od(
              A.ownerDocument.documentElement,
              A
            )) {
              if (B !== null && wo(A)) {
                var Y = B.start, lt = B.end;
                if (lt === void 0 && (lt = Y), "selectionStart" in A)
                  A.selectionStart = Y, A.selectionEnd = Math.min(
                    lt,
                    A.value.length
                  );
                else {
                  var pt = A.ownerDocument || document, at = pt && pt.defaultView || window;
                  if (at.getSelection) {
                    var gt = at.getSelection(), Kt = A.textContent.length, ue = Math.min(
                      B.start,
                      Kt
                    ), pn = B.end === void 0 ? ue : Math.min(B.end, Kt);
                    !gt.extend && ue > pn && (M = pn, pn = ue, ue = M);
                    var Be = _a(
                      A,
                      ue
                    ), P = _a(
                      A,
                      pn
                    );
                    if (Be && P && (gt.rangeCount !== 1 || gt.anchorNode !== Be.node || gt.anchorOffset !== Be.offset || gt.focusNode !== P.node || gt.focusOffset !== P.offset)) {
                      var G = pt.createRange();
                      G.setStart(Be.node, Be.offset), gt.removeAllRanges(), ue > pn ? (gt.addRange(G), gt.extend(P.node, P.offset)) : (G.setEnd(P.node, P.offset), gt.addRange(G));
                    }
                  }
                }
              }
              for (pt = [], gt = A; gt = gt.parentNode; )
                gt.nodeType === 1 && pt.push({
                  element: gt,
                  left: gt.scrollLeft,
                  top: gt.scrollTop
                });
              for (typeof A.focus == "function" && A.focus(), A = 0; A < pt.length; A++) {
                var K = pt[A];
                K.element.scrollLeft = K.left, K.element.scrollTop = K.top;
              }
            }
            X_ = !!Yb, jb = Yb = null;
          } finally {
            $e = y, re.p = p, ft.T = f;
          }
        }
        t.current = e, ha = sT;
      }
    }
    function _m() {
      if (ha === sT) {
        ha = td;
        var t = yf, e = Mp, a = vf, f = (e.flags & 8772) !== 0;
        if ((e.subtreeFlags & 8772) !== 0 || f) {
          f = ft.T, ft.T = null;
          var p = re.p;
          re.p = Ui;
          var y = $e;
          $e |= lr;
          try {
            jt !== null && typeof jt.markLayoutEffectsStarted == "function" && jt.markLayoutEffectsStarted(a), bp = a, Sp = t, lg(
              t,
              e.alternate,
              e
            ), Sp = bp = null, jt !== null && typeof jt.markLayoutEffectsStopped == "function" && jt.markLayoutEffectsStopped();
          } finally {
            $e = y, re.p = p, ft.T = f;
          }
        }
        ha = rT;
      }
    }
    function jv() {
      if (ha === yE || ha === rT) {
        ha = td, P0();
        var t = yf, e = Mp, a = vf, f = uT, p = (e.subtreeFlags & 10256) !== 0 || (e.flags & 10256) !== 0;
        p ? ha = Ob : (ha = td, Mp = yf = null, Kl(t, t.pendingLanes), ed = 0, Yy = null);
        var y = t.pendingLanes;
        if (y === 0 && (gf = null), p || Bc(t), p = _s(a), e = e.stateNode, Ni && typeof Ni.onCommitFiberRoot == "function")
          try {
            var M = (e.current.flags & 128) === 128;
            switch (p) {
              case Ui:
                var A = Zm;
                break;
              case gl:
                A = Lh;
                break;
              case Fs:
                A = tf;
                break;
              case Xm:
                A = Hh;
                break;
              default:
                A = tf;
            }
            Ni.onCommitFiberRoot(
              Qr,
              e,
              A,
              M
            );
          } catch (pt) {
            Ha || (Ha = !0, console.error(
              "React instrumentation encountered an error: %s",
              pt
            ));
          }
        if (kn && t.memoizedUpdaters.clear(), fg(), f !== null) {
          M = ft.T, A = re.p, re.p = Ui, ft.T = null;
          try {
            var B = t.onRecoverableError;
            for (e = 0; e < f.length; e++) {
              var Y = f[e], lt = qv(Y.stack);
              Pt(
                Y.source,
                B,
                Y.value,
                lt
              );
            }
          } finally {
            ft.T = M, re.p = A;
          }
        }
        (vf & 3) !== 0 && Nc(), Bo(t), y = t.pendingLanes, (a & 4194090) !== 0 && (y & 42) !== 0 ? (__ = !0, t === Rb ? By++ : (By = 0, Rb = t)) : By = 0, Bu(0), Ft();
      }
    }
    function qv(t) {
      return t = { componentStack: t }, Object.defineProperty(t, "digest", {
        get: function() {
          console.error(
            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
          );
        }
      }), t;
    }
    function Kl(t, e) {
      (t.pooledCacheLanes &= e) === 0 && (e = t.pooledCache, e != null && (t.pooledCache = null, Ri(e)));
    }
    function Nc(t) {
      return Ql(), _m(), jv(), yh();
    }
    function yh() {
      if (ha !== Ob) return !1;
      var t = yf, e = Db;
      Db = 0;
      var a = _s(vf), f = Fs > a ? Fs : a;
      a = ft.T;
      var p = re.p;
      try {
        re.p = f, ft.T = null, f = Ab, Ab = null;
        var y = yf, M = vf;
        if (ha = td, Mp = yf = null, vf = 0, ($e & (ho | lr)) !== yl)
          throw Error("Cannot flush passive effects while already rendering.");
        Cb = !0, C_ = !1, jt !== null && typeof jt.markPassiveEffectsStarted == "function" && jt.markPassiveEffectsStarted(M);
        var A = $e;
        if ($e |= lr, ug(y.current), fh(
          y,
          y.current,
          M,
          f
        ), jt !== null && typeof jt.markPassiveEffectsStopped == "function" && jt.markPassiveEffectsStopped(), Bc(y), $e = A, Bu(0, !1), C_ ? y === Yy ? ed++ : (ed = 0, Yy = y) : ed = 0, C_ = Cb = !1, Ni && typeof Ni.onPostCommitFiberRoot == "function")
          try {
            Ni.onPostCommitFiberRoot(Qr, y);
          } catch (Y) {
            Ha || (Ha = !0, console.error(
              "React instrumentation encountered an error: %s",
              Y
            ));
          }
        var B = y.current.stateNode;
        return B.effectDuration = 0, B.passiveEffectDuration = 0, !0;
      } finally {
        re.p = p, ft.T = a, Kl(t, e);
      }
    }
    function Uc(t, e, a) {
      e = qi(a, e), e = Xi(t.stateNode, e, 2), t = wa(t, e, 2), t !== null && (po(t, 2), Bo(t));
    }
    function ie(t, e, a) {
      if (Ep = !1, t.tag === 3)
        Uc(t, t, a);
      else {
        for (; e !== null; ) {
          if (e.tag === 3) {
            Uc(
              e,
              t,
              a
            );
            return;
          }
          if (e.tag === 1) {
            var f = e.stateNode;
            if (typeof e.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (gf === null || !gf.has(f))) {
              t = qi(a, t), a = An(2), f = wa(e, a, 2), f !== null && (eh(
                a,
                f,
                e,
                t
              ), po(f, 2), Bo(f));
              return;
            }
          }
          e = e.return;
        }
        console.error(
          `Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,
          a
        );
      }
    }
    function yg(t, e, a) {
      var f = t.pingCache;
      if (f === null) {
        f = t.pingCache = new dE();
        var p = /* @__PURE__ */ new Set();
        f.set(e, p);
      } else
        p = f.get(e), p === void 0 && (p = /* @__PURE__ */ new Set(), f.set(e, p));
      p.has(a) || (wb = !0, p.add(a), f = N0.bind(null, t, e, a), kn && Yc(t, a), e.then(f, f));
    }
    function N0(t, e, a) {
      var f = t.pingCache;
      f !== null && f.delete(e), t.pingedLanes |= t.suspendedLanes & a, t.warmLanes &= ~a, hg() && ft.actQueue === null && console.error(
        `A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`
      ), mn === t && (Ne & a) === a && (Kn === Ih || Kn === Sb && (Ne & 62914560) === Ne && is() - Eb < aT ? ($e & ho) === yl && Uu(t, 0) : Mb |= a, Fh === Ne && (Fh = 0)), Bo(t);
    }
    function vg(t, e) {
      e === 0 && (e = pa()), t = pi(t, e), t !== null && (po(t, e), Bo(t));
    }
    function vh(t) {
      var e = t.memoizedState, a = 0;
      e !== null && (a = e.retryLane), vg(t, a);
    }
    function Br(t, e) {
      var a = 0;
      switch (t.tag) {
        case 13:
          var f = t.stateNode, p = t.memoizedState;
          p !== null && (a = p.retryLane);
          break;
        case 19:
          f = t.stateNode;
          break;
        case 22:
          f = t.stateNode._retryCache;
          break;
        default:
          throw Error(
            "Pinged unknown suspense boundary type. This is probably a bug in React."
          );
      }
      f !== null && f.delete(e), vg(t, a);
    }
    function bm(t, e, a) {
      if ((e.subtreeFlags & 67117056) !== 0)
        for (e = e.child; e !== null; ) {
          var f = t, p = e, y = p.type === Wc;
          y = a || y, p.tag !== 22 ? p.flags & 67108864 ? y && Pt(
            p,
            _g,
            f,
            p,
            (p.mode & tS) === bn
          ) : bm(
            f,
            p,
            y
          ) : p.memoizedState === null && (y && p.flags & 8192 ? Pt(
            p,
            _g,
            f,
            p
          ) : p.subtreeFlags & 67108864 && Pt(
            p,
            bm,
            f,
            p,
            y
          )), e = e.sibling;
        }
    }
    function _g(t, e) {
      var a = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : !0;
      Tt(!0);
      try {
        ao(e), a && mh(e), Ps(t, e.alternate, e, !1), a && um(t, e, 0, null, !1, 0);
      } finally {
        Tt(!1);
      }
    }
    function Bc(t) {
      var e = !0;
      t.current.mode & (Ua | nr) || (e = !1), bm(
        t,
        t.current,
        e
      );
    }
    function ml(t) {
      if (($e & ho) === yl) {
        var e = t.tag;
        if (e === 3 || e === 1 || e === 0 || e === 11 || e === 14 || e === 15) {
          if (e = wt(t) || "ReactComponent", z_ !== null) {
            if (z_.has(e)) return;
            z_.add(e);
          } else z_ = /* @__PURE__ */ new Set([e]);
          Pt(t, function() {
            console.error(
              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
            );
          });
        }
      }
    }
    function Yc(t, e) {
      kn && t.memoizedUpdaters.forEach(function(a) {
        ta(t, a, e);
      });
    }
    function bg(t, e) {
      var a = ft.actQueue;
      return a !== null ? (a.push(e), bE) : qm(t, e);
    }
    function Zv(t) {
      hg() && ft.actQueue === null && Pt(t, function() {
        console.error(
          `An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`,
          wt(t)
        );
      });
    }
    function Bo(t) {
      t !== Op && t.next === null && (Op === null ? L_ = Op = t : Op = Op.next = t), H_ = !0, ft.actQueue !== null ? Lb || (Lb = !0, ai()) : zb || (zb = !0, ai());
    }
    function Bu(t, e) {
      if (!Hb && H_) {
        Hb = !0;
        do
          for (var a = !1, f = L_; f !== null; ) {
            if (t !== 0) {
              var p = f.pendingLanes;
              if (p === 0) var y = 0;
              else {
                var M = f.suspendedLanes, A = f.pingedLanes;
                y = (1 << 31 - Wi(42 | t) + 1) - 1, y &= p & ~(M & ~A), y = y & 201326741 ? y & 201326741 | 1 : y ? y | 2 : 0;
              }
              y !== 0 && (a = !0, xm(f, y));
            } else
              y = Ne, y = En(
                f,
                f === mn ? y : 0,
                f.cancelPendingCommit !== null || f.timeoutHandle !== ad
              ), (y & 3) === 0 || Pa(f, y) || (a = !0, xm(f, y));
            f = f.next;
          }
        while (a);
        Hb = !1;
      }
    }
    function Sm() {
      Tm();
    }
    function Tm() {
      H_ = Lb = zb = !1;
      var t = 0;
      nd !== 0 && (jc() && (t = nd), nd = 0);
      for (var e = is(), a = null, f = L_; f !== null; ) {
        var p = f.next, y = Wl(f, e);
        y === 0 ? (f.next = null, a === null ? L_ = p : a.next = p, p === null && (Op = a)) : (a = f, (t !== 0 || (y & 3) !== 0) && (H_ = !0)), f = p;
      }
      Bu(t);
    }
    function Wl(t, e) {
      for (var a = t.suspendedLanes, f = t.pingedLanes, p = t.expirationTimes, y = t.pendingLanes & -62914561; 0 < y; ) {
        var M = 31 - Wi(y), A = 1 << M, B = p[M];
        B === -1 ? ((A & a) === 0 || (A & f) !== 0) && (p[M] = dc(A, e)) : B <= e && (t.expiredLanes |= A), y &= ~A;
      }
      if (e = mn, a = Ne, a = En(
        t,
        t === e ? a : 0,
        t.cancelPendingCommit !== null || t.timeoutHandle !== ad
      ), f = t.callbackNode, a === 0 || t === e && (an === $h || an === Jh) || t.cancelPendingCommit !== null)
        return f !== null && wm(f), t.callbackNode = null, t.callbackPriority = 0;
      if ((a & 3) === 0 || Pa(t, a)) {
        if (e = a & -a, e !== t.callbackPriority || ft.actQueue !== null && f !== kb)
          wm(f);
        else return e;
        switch (_s(a)) {
          case Ui:
          case gl:
            a = Lh;
            break;
          case Fs:
            a = tf;
            break;
          case Xm:
            a = Hh;
            break;
          default:
            a = tf;
        }
        return f = Cn.bind(null, t), ft.actQueue !== null ? (ft.actQueue.push(f), a = kb) : a = qm(a, f), t.callbackPriority = e, t.callbackNode = a, e;
      }
      return f !== null && wm(f), t.callbackPriority = 2, t.callbackNode = null, 2;
    }
    function Cn(t, e) {
      if (__ = v_ = !1, ha !== td && ha !== Ob)
        return t.callbackNode = null, t.callbackPriority = 0, null;
      var a = t.callbackNode;
      if (Nc() && t.callbackNode !== a)
        return null;
      var f = Ne;
      return f = En(
        t,
        t === mn ? f : 0,
        t.cancelPendingCommit !== null || t.timeoutHandle !== ad
      ), f === 0 ? null : (ii(
        t,
        f,
        e
      ), Wl(t, is()), t.callbackNode != null && t.callbackNode === a ? Cn.bind(null, t) : null);
    }
    function xm(t, e) {
      if (Nc()) return null;
      v_ = __, __ = !1, ii(t, e, !0);
    }
    function wm(t) {
      t !== kb && t !== null && Z0(t);
    }
    function ai() {
      ft.actQueue !== null && ft.actQueue.push(function() {
        return Tm(), null;
      }), RE(function() {
        ($e & (ho | lr)) !== yl ? qm(
          Zm,
          Sm
        ) : Tm();
      });
    }
    function Sg() {
      return nd === 0 && (nd = pe()), nd;
    }
    function Tg(t) {
      return t == null || typeof t == "symbol" || typeof t == "boolean" ? null : typeof t == "function" ? t : (ct(t, "action"), Ai("" + t));
    }
    function xg(t, e) {
      var a = e.ownerDocument.createElement("input");
      return a.name = e.name, a.value = e.value, t.id && a.setAttribute("form", t.id), e.parentNode.insertBefore(a, e), t = new FormData(t), a.parentNode.removeChild(a), t;
    }
    function vn(t, e, a, f, p) {
      if (e === "submit" && a && a.stateNode === p) {
        var y = Tg(
          (p[ka] || null).action
        ), M = f.submitter;
        M && (e = (e = M[ka] || null) ? Tg(e.formAction) : M.getAttribute("formAction"), e !== null && (y = e, M = null));
        var A = new ee(
          "action",
          "action",
          null,
          f,
          p
        );
        t.push({
          event: A,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (f.defaultPrevented) {
                  if (nd !== 0) {
                    var B = M ? xg(
                      p,
                      M
                    ) : new FormData(p), Y = {
                      pending: !0,
                      data: B,
                      method: p.method,
                      action: y
                    };
                    Object.freeze(Y), Mu(
                      a,
                      Y,
                      null,
                      B
                    );
                  }
                } else
                  typeof y == "function" && (A.preventDefault(), B = M ? xg(
                    p,
                    M
                  ) : new FormData(p), Y = {
                    pending: !0,
                    data: B,
                    method: p.method,
                    action: y
                  }, Object.freeze(Y), Mu(
                    a,
                    Y,
                    y,
                    B
                  ));
              },
              currentTarget: p
            }
          ]
        });
      }
    }
    function zi(t, e, a) {
      t.currentTarget = a;
      try {
        e(t);
      } catch (f) {
        gb(f);
      }
      t.currentTarget = null;
    }
    function Il(t, e) {
      e = (e & 4) !== 0;
      for (var a = 0; a < t.length; a++) {
        var f = t[a];
        t: {
          var p = void 0, y = f.event;
          if (f = f.listeners, e)
            for (var M = f.length - 1; 0 <= M; M--) {
              var A = f[M], B = A.instance, Y = A.currentTarget;
              if (A = A.listener, B !== p && y.isPropagationStopped())
                break t;
              B !== null ? Pt(
                B,
                zi,
                y,
                A,
                Y
              ) : zi(y, A, Y), p = B;
            }
          else
            for (M = 0; M < f.length; M++) {
              if (A = f[M], B = A.instance, Y = A.currentTarget, A = A.listener, B !== p && y.isPropagationStopped())
                break t;
              B !== null ? Pt(
                B,
                zi,
                y,
                A,
                Y
              ) : zi(y, A, Y), p = B;
            }
        }
      }
    }
    function Ce(t, e) {
      Nb.has(t) || console.error(
        'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
        t
      );
      var a = e[Ig];
      a === void 0 && (a = e[Ig] = /* @__PURE__ */ new Set());
      var f = t + "__bubble";
      a.has(f) || (Em(e, t, 2, !1), a.add(f));
    }
    function Mm(t, e, a) {
      Nb.has(t) && !e && console.error(
        'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
        t
      );
      var f = 0;
      e && (f |= 4), Em(
        a,
        t,
        f,
        e
      );
    }
    function wg(t) {
      if (!t[k_]) {
        t[k_] = !0, a_.forEach(function(a) {
          a !== "selectionchange" && (Nb.has(a) || Mm(a, !1, t), Mm(a, !0, t));
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[k_] || (e[k_] = !0, Mm("selectionchange", !1, e));
      }
    }
    function Em(t, e, a, f) {
      switch (Um(e)) {
        case Ui:
          var p = Y0;
          break;
        case gl:
          p = Nm;
          break;
        default:
          p = Zr;
      }
      a = p.bind(
        null,
        e,
        a,
        t
      ), p = void 0, !it || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (p = !0), f ? p !== void 0 ? t.addEventListener(e, a, {
        capture: !0,
        passive: p
      }) : t.addEventListener(e, a, !0) : p !== void 0 ? t.addEventListener(e, a, {
        passive: p
      }) : t.addEventListener(
        e,
        a,
        !1
      );
    }
    function la(t, e, a, f, p) {
      var y = f;
      if ((e & 1) === 0 && (e & 2) === 0 && f !== null)
        t: for (; ; ) {
          if (f === null) return;
          var M = f.tag;
          if (M === 3 || M === 4) {
            var A = f.stateNode.containerInfo;
            if (A === p) break;
            if (M === 4)
              for (M = f.return; M !== null; ) {
                var B = M.tag;
                if ((B === 3 || B === 4) && M.stateNode.containerInfo === p)
                  return;
                M = M.return;
              }
            for (; A !== null; ) {
              if (M = hi(A), M === null) return;
              if (B = M.tag, B === 5 || B === 6 || B === 26 || B === 27) {
                f = y = M;
                continue t;
              }
              A = A.parentNode;
            }
          }
          f = f.return;
        }
      vr(function() {
        var Y = y, lt = Ye(a), pt = [];
        t: {
          var at = F1.get(t);
          if (at !== void 0) {
            var gt = ee, Kt = t;
            switch (t) {
              case "keypress":
                if (va(a) === 0) break t;
              case "keydown":
              case "keyup":
                gt = UM;
                break;
              case "focusin":
                Kt = "focus", gt = je;
                break;
              case "focusout":
                Kt = "blur", gt = je;
                break;
              case "beforeblur":
              case "afterblur":
                gt = je;
                break;
              case "click":
                if (a.button === 2) break t;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                gt = De;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                gt = ae;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                gt = jM;
                break;
              case W1:
              case I1:
              case $1:
                gt = Q0;
                break;
              case J1:
                gt = ZM;
                break;
              case "scroll":
              case "scrollend":
                gt = tt;
                break;
              case "wheel":
                gt = VM;
                break;
              case "copy":
              case "cut":
              case "paste":
                gt = RM;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                gt = q1;
                break;
              case "toggle":
              case "beforetoggle":
                gt = XM;
            }
            var ue = (e & 4) !== 0, pn = !ue && (t === "scroll" || t === "scrollend"), Be = ue ? at !== null ? at + "Capture" : null : at;
            ue = [];
            for (var P = Y, G; P !== null; ) {
              var K = P;
              if (G = K.stateNode, K = K.tag, K !== 5 && K !== 26 && K !== 27 || G === null || Be === null || (K = Qa(P, Be), K != null && ue.push(
                sa(
                  P,
                  K,
                  G
                )
              )), pn) break;
              P = P.return;
            }
            0 < ue.length && (at = new gt(
              at,
              Kt,
              null,
              a,
              lt
            ), pt.push({
              event: at,
              listeners: ue
            }));
          }
        }
        if ((e & 7) === 0) {
          t: {
            if (at = t === "mouseover" || t === "pointerover", gt = t === "mouseout" || t === "pointerout", at && a !== b && (Kt = a.relatedTarget || a.fromElement) && (hi(Kt) || Kt[Wr]))
              break t;
            if ((gt || at) && (at = lt.window === lt ? lt : (at = lt.ownerDocument) ? at.defaultView || at.parentWindow : window, gt ? (Kt = a.relatedTarget || a.toElement, gt = Y, Kt = Kt ? hi(Kt) : null, Kt !== null && (pn = nt(Kt), ue = Kt.tag, Kt !== pn || ue !== 5 && ue !== 27 && ue !== 6) && (Kt = null)) : (gt = null, Kt = Y), gt !== Kt)) {
              if (ue = De, K = "onMouseLeave", Be = "onMouseEnter", P = "mouse", (t === "pointerout" || t === "pointerover") && (ue = q1, K = "onPointerLeave", Be = "onPointerEnter", P = "pointer"), pn = gt == null ? at : Va(gt), G = Kt == null ? at : Va(Kt), at = new ue(
                K,
                P + "leave",
                gt,
                a,
                lt
              ), at.target = pn, at.relatedTarget = G, K = null, hi(lt) === Y && (ue = new ue(
                Be,
                P + "enter",
                Kt,
                a,
                lt
              ), ue.target = G, ue.relatedTarget = pn, K = ue), pn = K, gt && Kt)
                e: {
                  for (ue = gt, Be = Kt, P = 0, G = ue; G; G = Si(G))
                    P++;
                  for (G = 0, K = Be; K; K = Si(K))
                    G++;
                  for (; 0 < P - G; )
                    ue = Si(ue), P--;
                  for (; 0 < G - P; )
                    Be = Si(Be), G--;
                  for (; P--; ) {
                    if (ue === Be || Be !== null && ue === Be.alternate)
                      break e;
                    ue = Si(ue), Be = Si(Be);
                  }
                  ue = null;
                }
              else ue = null;
              gt !== null && Mg(
                pt,
                at,
                gt,
                ue,
                !1
              ), Kt !== null && pn !== null && Mg(
                pt,
                pn,
                Kt,
                ue,
                !0
              );
            }
          }
          t: {
            if (at = Y ? Va(Y) : window, gt = at.nodeName && at.nodeName.toLowerCase(), gt === "select" || gt === "input" && at.type === "file")
              var yt = Os;
            else if (xd(at))
              if (Q1)
                yt = Up;
              else {
                yt = Hf;
                var Bt = Lf;
              }
            else
              gt = at.nodeName, !gt || gt.toLowerCase() !== "input" || at.type !== "checkbox" && at.type !== "radio" ? Y && tl(Y.elementType) && (yt = Os) : yt = Md;
            if (yt && (yt = yt(t, Y))) {
              Oe(
                pt,
                yt,
                a,
                lt
              );
              break t;
            }
            Bt && Bt(t, at, Y), t === "focusout" && Y && at.type === "number" && Y.memoizedProps.value != null && bs(at, "number", at.value);
          }
          switch (Bt = Y ? Va(Y) : window, t) {
            case "focusin":
              (xd(Bt) || Bt.contentEditable === "true") && (np = Bt, W0 = Y, gy = null);
              break;
            case "focusout":
              gy = W0 = np = null;
              break;
            case "mousedown":
              I0 = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              I0 = !1, Nf(
                pt,
                a,
                lt
              );
              break;
            case "selectionchange":
              if (IM) break;
            case "keydown":
            case "keyup":
              Nf(
                pt,
                a,
                lt
              );
          }
          var be;
          if (K0)
            t: {
              switch (t) {
                case "compositionstart":
                  var Wt = "onCompositionStart";
                  break t;
                case "compositionend":
                  Wt = "onCompositionEnd";
                  break t;
                case "compositionupdate":
                  Wt = "onCompositionUpdate";
                  break t;
              }
              Wt = void 0;
            }
          else
            ep ? mi(t, a) && (Wt = "onCompositionEnd") : t === "keydown" && a.keyCode === Z1 && (Wt = "onCompositionStart");
          Wt && (P1 && a.locale !== "ko" && (ep || Wt !== "onCompositionStart" ? Wt === "onCompositionEnd" && ep && (be = Ka()) : (St = lt, ot = "value" in St ? St.value : St.textContent, ep = !0)), Bt = _h(
            Y,
            Wt
          ), 0 < Bt.length && (Wt = new j1(
            Wt,
            t,
            null,
            a,
            lt
          ), pt.push({
            event: Wt,
            listeners: Bt
          }), be ? Wt.data = be : (be = El(a), be !== null && (Wt.data = be)))), (be = KM ? _u(t, a) : Es(t, a)) && (Wt = _h(
            Y,
            "onBeforeInput"
          ), 0 < Wt.length && (Bt = new zM(
            "onBeforeInput",
            "beforeinput",
            null,
            a,
            lt
          ), pt.push({
            event: Bt,
            listeners: Wt
          }), Bt.data = be)), vn(
            pt,
            t,
            Y,
            a,
            lt
          );
        }
        Il(pt, e);
      });
    }
    function sa(t, e, a) {
      return {
        instance: t,
        listener: e,
        currentTarget: a
      };
    }
    function _h(t, e) {
      for (var a = e + "Capture", f = []; t !== null; ) {
        var p = t, y = p.stateNode;
        if (p = p.tag, p !== 5 && p !== 26 && p !== 27 || y === null || (p = Qa(t, a), p != null && f.unshift(
          sa(t, p, y)
        ), p = Qa(t, e), p != null && f.push(
          sa(t, p, y)
        )), t.tag === 3) return f;
        t = t.return;
      }
      return [];
    }
    function Si(t) {
      if (t === null) return null;
      do
        t = t.return;
      while (t && t.tag !== 5 && t.tag !== 27);
      return t || null;
    }
    function Mg(t, e, a, f, p) {
      for (var y = e._reactName, M = []; a !== null && a !== f; ) {
        var A = a, B = A.alternate, Y = A.stateNode;
        if (A = A.tag, B !== null && B === f) break;
        A !== 5 && A !== 26 && A !== 27 || Y === null || (B = Y, p ? (Y = Qa(a, y), Y != null && M.unshift(
          sa(a, Y, B)
        )) : p || (Y = Qa(a, y), Y != null && M.push(
          sa(a, Y, B)
        ))), a = a.return;
      }
      M.length !== 0 && t.push({ event: e, listeners: M });
    }
    function $l(t, e) {
      Ml(t, e), t !== "input" && t !== "textarea" && t !== "select" || e == null || e.value !== null || hy || (hy = !0, t === "select" && e.multiple ? console.error(
        "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
        t
      ) : console.error(
        "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
        t
      ));
      var a = {
        registrationNameDependencies: Po,
        possibleRegistrationNames: Qu
      };
      tl(t) || typeof e.is == "string" || ce(t, e, a), e.contentEditable && !e.suppressContentEditableWarning && e.children != null && console.error(
        "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
      );
    }
    function _n(t, e, a, f) {
      e !== a && (a = Li(a), Li(e) !== a && (f[t] = e));
    }
    function Yr(t, e, a) {
      e.forEach(function(f) {
        a[Og(f)] = f === "style" ? ju(t) : t.getAttribute(f);
      });
    }
    function Yo(t, e) {
      e === !1 ? console.error(
        "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
        t,
        t,
        t
      ) : console.error(
        "Expected `%s` listener to be a function, instead got a value of `%s` type.",
        t,
        typeof e
      );
    }
    function Om(t, e) {
      return t = t.namespaceURI === qh || t.namespaceURI === rf ? t.ownerDocument.createElementNS(
        t.namespaceURI,
        t.tagName
      ) : t.ownerDocument.createElement(t.tagName), t.innerHTML = e, t.innerHTML;
    }
    function Li(t) {
      return k(t) && (console.error(
        "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
        Gt(t)
      ), F(t)), (typeof t == "string" ? t : "" + t).replace(SE, `
`).replace(TE, "");
    }
    function Eg(t, e) {
      return e = Li(e), Li(t) === e;
    }
    function Gs() {
    }
    function qe(t, e, a, f, p, y) {
      switch (a) {
        case "children":
          typeof f == "string" ? (Jo(f, e, !1), e === "body" || e === "textarea" && f === "" || Fo(t, f)) : (typeof f == "number" || typeof f == "bigint") && (Jo("" + f, e, !1), e !== "body" && Fo(t, "" + f));
          break;
        case "className":
          fe(t, "class", f);
          break;
        case "tabIndex":
          fe(t, "tabindex", f);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          fe(t, a, f);
          break;
        case "style":
          Ts(t, f, y);
          break;
        case "data":
          if (e !== "object") {
            fe(t, "data", f);
            break;
          }
        case "src":
        case "href":
          if (f === "" && (e !== "a" || a !== "href")) {
            console.error(
              a === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
              a,
              a
            ), t.removeAttribute(a);
            break;
          }
          if (f == null || typeof f == "function" || typeof f == "symbol" || typeof f == "boolean") {
            t.removeAttribute(a);
            break;
          }
          ct(f, a), f = Ai("" + f), t.setAttribute(a, f);
          break;
        case "action":
        case "formAction":
          if (f != null && (e === "form" ? a === "formAction" ? console.error(
            "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
          ) : typeof f == "function" && (p.encType == null && p.method == null || B_ || (B_ = !0, console.error(
            "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
          )), p.target == null || U_ || (U_ = !0, console.error(
            "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
          ))) : e === "input" || e === "button" ? a === "action" ? console.error(
            "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
          ) : e !== "input" || p.type === "submit" || p.type === "image" || N_ ? e !== "button" || p.type == null || p.type === "submit" || N_ ? typeof f == "function" && (p.name == null || mT || (mT = !0, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          )), p.formEncType == null && p.formMethod == null || B_ || (B_ = !0, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          )), p.formTarget == null || U_ || (U_ = !0, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ))) : (N_ = !0, console.error(
            'A button can only specify a formAction along with type="submit" or no type.'
          )) : (N_ = !0, console.error(
            'An input can only specify a formAction along with type="submit" or type="image".'
          )) : console.error(
            a === "action" ? "You can only pass the action prop to <form>." : "You can only pass the formAction prop to <input> or <button>."
          )), typeof f == "function") {
            t.setAttribute(
              a,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof y == "function" && (a === "formAction" ? (e !== "input" && qe(t, e, "name", p.name, p, null), qe(
              t,
              e,
              "formEncType",
              p.formEncType,
              p,
              null
            ), qe(
              t,
              e,
              "formMethod",
              p.formMethod,
              p,
              null
            ), qe(
              t,
              e,
              "formTarget",
              p.formTarget,
              p,
              null
            )) : (qe(
              t,
              e,
              "encType",
              p.encType,
              p,
              null
            ), qe(t, e, "method", p.method, p, null), qe(
              t,
              e,
              "target",
              p.target,
              p,
              null
            )));
          if (f == null || typeof f == "symbol" || typeof f == "boolean") {
            t.removeAttribute(a);
            break;
          }
          ct(f, a), f = Ai("" + f), t.setAttribute(a, f);
          break;
        case "onClick":
          f != null && (typeof f != "function" && Yo(a, f), t.onclick = Gs);
          break;
        case "onScroll":
          f != null && (typeof f != "function" && Yo(a, f), Ce("scroll", t));
          break;
        case "onScrollEnd":
          f != null && (typeof f != "function" && Yo(a, f), Ce("scrollend", t));
          break;
        case "dangerouslySetInnerHTML":
          if (f != null) {
            if (typeof f != "object" || !("__html" in f))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (a = f.__html, a != null) {
              if (p.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              t.innerHTML = a;
            }
          }
          break;
        case "multiple":
          t.multiple = f && typeof f != "function" && typeof f != "symbol";
          break;
        case "muted":
          t.muted = f && typeof f != "function" && typeof f != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (f == null || typeof f == "function" || typeof f == "boolean" || typeof f == "symbol") {
            t.removeAttribute("xlink:href");
            break;
          }
          ct(f, a), a = Ai("" + f), t.setAttributeNS(id, "xlink:href", a);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          f != null && typeof f != "function" && typeof f != "symbol" ? (ct(f, a), t.setAttribute(a, "" + f)) : t.removeAttribute(a);
          break;
        case "inert":
          f !== "" || Y_[a] || (Y_[a] = !0, console.error(
            "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
            a
          ));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          f && typeof f != "function" && typeof f != "symbol" ? t.setAttribute(a, "") : t.removeAttribute(a);
          break;
        case "capture":
        case "download":
          f === !0 ? t.setAttribute(a, "") : f !== !1 && f != null && typeof f != "function" && typeof f != "symbol" ? (ct(f, a), t.setAttribute(a, f)) : t.removeAttribute(a);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          f != null && typeof f != "function" && typeof f != "symbol" && !isNaN(f) && 1 <= f ? (ct(f, a), t.setAttribute(a, f)) : t.removeAttribute(a);
          break;
        case "rowSpan":
        case "start":
          f == null || typeof f == "function" || typeof f == "symbol" || isNaN(f) ? t.removeAttribute(a) : (ct(f, a), t.setAttribute(a, f));
          break;
        case "popover":
          Ce("beforetoggle", t), Ce("toggle", t), ze(t, "popover", f);
          break;
        case "xlinkActuate":
          On(
            t,
            id,
            "xlink:actuate",
            f
          );
          break;
        case "xlinkArcrole":
          On(
            t,
            id,
            "xlink:arcrole",
            f
          );
          break;
        case "xlinkRole":
          On(
            t,
            id,
            "xlink:role",
            f
          );
          break;
        case "xlinkShow":
          On(
            t,
            id,
            "xlink:show",
            f
          );
          break;
        case "xlinkTitle":
          On(
            t,
            id,
            "xlink:title",
            f
          );
          break;
        case "xlinkType":
          On(
            t,
            id,
            "xlink:type",
            f
          );
          break;
        case "xmlBase":
          On(
            t,
            Ub,
            "xml:base",
            f
          );
          break;
        case "xmlLang":
          On(
            t,
            Ub,
            "xml:lang",
            f
          );
          break;
        case "xmlSpace":
          On(
            t,
            Ub,
            "xml:space",
            f
          );
          break;
        case "is":
          y != null && console.error(
            'Cannot update the "is" prop after it has been initialized.'
          ), ze(t, "is", f);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          pT || f == null || typeof f != "object" || (pT = !0, console.error(
            "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
            f
          ));
        default:
          !(2 < a.length) || a[0] !== "o" && a[0] !== "O" || a[1] !== "n" && a[1] !== "N" ? (a = xs(a), ze(t, a, f)) : Po.hasOwnProperty(a) && f != null && typeof f != "function" && Yo(a, f);
      }
    }
    function Yu(t, e, a, f, p, y) {
      switch (a) {
        case "style":
          Ts(t, f, y);
          break;
        case "dangerouslySetInnerHTML":
          if (f != null) {
            if (typeof f != "object" || !("__html" in f))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (a = f.__html, a != null) {
              if (p.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              t.innerHTML = a;
            }
          }
          break;
        case "children":
          typeof f == "string" ? Fo(t, f) : (typeof f == "number" || typeof f == "bigint") && Fo(t, "" + f);
          break;
        case "onScroll":
          f != null && (typeof f != "function" && Yo(a, f), Ce("scroll", t));
          break;
        case "onScrollEnd":
          f != null && (typeof f != "function" && Yo(a, f), Ce("scrollend", t));
          break;
        case "onClick":
          f != null && (typeof f != "function" && Yo(a, f), t.onclick = Gs);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (Po.hasOwnProperty(a))
            f != null && typeof f != "function" && Yo(a, f);
          else
            t: {
              if (a[0] === "o" && a[1] === "n" && (p = a.endsWith("Capture"), e = a.slice(2, p ? a.length - 7 : void 0), y = t[ka] || null, y = y != null ? y[a] : null, typeof y == "function" && t.removeEventListener(e, y, p), typeof f == "function")) {
                typeof y != "function" && y !== null && (a in t ? t[a] = null : t.hasAttribute(a) && t.removeAttribute(a)), t.addEventListener(e, f, p);
                break t;
              }
              a in t ? t[a] = f : f === !0 ? t.setAttribute(a, "") : ze(t, a, f);
            }
      }
    }
    function zn(t, e, a) {
      switch ($l(e, a), e) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          Ce("error", t), Ce("load", t);
          var f = !1, p = !1, y;
          for (y in a)
            if (a.hasOwnProperty(y)) {
              var M = a[y];
              if (M != null)
                switch (y) {
                  case "src":
                    f = !0;
                    break;
                  case "srcSet":
                    p = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    qe(t, e, y, M, a, null);
                }
            }
          p && qe(t, e, "srcSet", a.srcSet, a, null), f && qe(t, e, "src", a.src, a, null);
          return;
        case "input":
          Xt("input", a), Ce("invalid", t);
          var A = y = M = p = null, B = null, Y = null;
          for (f in a)
            if (a.hasOwnProperty(f)) {
              var lt = a[f];
              if (lt != null)
                switch (f) {
                  case "name":
                    p = lt;
                    break;
                  case "type":
                    M = lt;
                    break;
                  case "checked":
                    B = lt;
                    break;
                  case "defaultChecked":
                    Y = lt;
                    break;
                  case "value":
                    y = lt;
                    break;
                  case "defaultValue":
                    A = lt;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (lt != null)
                      throw Error(
                        e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    qe(t, e, f, lt, a, null);
                }
            }
          Sl(t, a), bd(
            t,
            y,
            A,
            B,
            Y,
            M,
            p,
            !1
          ), vo(t);
          return;
        case "select":
          Xt("select", a), Ce("invalid", t), f = M = y = null;
          for (p in a)
            if (a.hasOwnProperty(p) && (A = a[p], A != null))
              switch (p) {
                case "value":
                  y = A;
                  break;
                case "defaultValue":
                  M = A;
                  break;
                case "multiple":
                  f = A;
                default:
                  qe(
                    t,
                    e,
                    p,
                    A,
                    a,
                    null
                  );
              }
          gu(t, a), e = y, a = M, t.multiple = !!f, e != null ? Io(t, !!f, e, !1) : a != null && Io(t, !!f, a, !0);
          return;
        case "textarea":
          Xt("textarea", a), Ce("invalid", t), y = p = f = null;
          for (M in a)
            if (a.hasOwnProperty(M) && (A = a[M], A != null))
              switch (M) {
                case "value":
                  f = A;
                  break;
                case "defaultValue":
                  p = A;
                  break;
                case "children":
                  y = A;
                  break;
                case "dangerouslySetInnerHTML":
                  if (A != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  qe(
                    t,
                    e,
                    M,
                    A,
                    a,
                    null
                  );
              }
          _o(t, a), Ss(t, f, p, y), vo(t);
          return;
        case "option":
          Af(t, a);
          for (B in a)
            if (a.hasOwnProperty(B) && (f = a[B], f != null))
              switch (B) {
                case "selected":
                  t.selected = f && typeof f != "function" && typeof f != "symbol";
                  break;
                default:
                  qe(t, e, B, f, a, null);
              }
          return;
        case "dialog":
          Ce("beforetoggle", t), Ce("toggle", t), Ce("cancel", t), Ce("close", t);
          break;
        case "iframe":
        case "object":
          Ce("load", t);
          break;
        case "video":
        case "audio":
          for (f = 0; f < jy.length; f++)
            Ce(jy[f], t);
          break;
        case "image":
          Ce("error", t), Ce("load", t);
          break;
        case "details":
          Ce("toggle", t);
          break;
        case "embed":
        case "source":
        case "link":
          Ce("error", t), Ce("load", t);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (Y in a)
            if (a.hasOwnProperty(Y) && (f = a[Y], f != null))
              switch (Y) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  qe(t, e, Y, f, a, null);
              }
          return;
        default:
          if (tl(e)) {
            for (lt in a)
              a.hasOwnProperty(lt) && (f = a[lt], f !== void 0 && Yu(
                t,
                e,
                lt,
                f,
                a,
                void 0
              ));
            return;
          }
      }
      for (A in a)
        a.hasOwnProperty(A) && (f = a[A], f != null && qe(t, e, A, f, a, null));
    }
    function Pv(t, e, a, f) {
      switch ($l(e, f), e) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var p = null, y = null, M = null, A = null, B = null, Y = null, lt = null;
          for (gt in a) {
            var pt = a[gt];
            if (a.hasOwnProperty(gt) && pt != null)
              switch (gt) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  B = pt;
                default:
                  f.hasOwnProperty(gt) || qe(
                    t,
                    e,
                    gt,
                    null,
                    f,
                    pt
                  );
              }
          }
          for (var at in f) {
            var gt = f[at];
            if (pt = a[at], f.hasOwnProperty(at) && (gt != null || pt != null))
              switch (at) {
                case "type":
                  y = gt;
                  break;
                case "name":
                  p = gt;
                  break;
                case "checked":
                  Y = gt;
                  break;
                case "defaultChecked":
                  lt = gt;
                  break;
                case "value":
                  M = gt;
                  break;
                case "defaultValue":
                  A = gt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (gt != null)
                    throw Error(
                      e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  gt !== pt && qe(
                    t,
                    e,
                    at,
                    gt,
                    f,
                    pt
                  );
              }
          }
          e = a.type === "checkbox" || a.type === "radio" ? a.checked != null : a.value != null, f = f.type === "checkbox" || f.type === "radio" ? f.checked != null : f.value != null, e || !f || dT || (console.error(
            "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), dT = !0), !e || f || hT || (console.error(
            "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), hT = !0), Wo(
            t,
            M,
            A,
            B,
            Y,
            lt,
            y,
            p
          );
          return;
        case "select":
          gt = M = A = at = null;
          for (y in a)
            if (B = a[y], a.hasOwnProperty(y) && B != null)
              switch (y) {
                case "value":
                  break;
                case "multiple":
                  gt = B;
                default:
                  f.hasOwnProperty(y) || qe(
                    t,
                    e,
                    y,
                    null,
                    f,
                    B
                  );
              }
          for (p in f)
            if (y = f[p], B = a[p], f.hasOwnProperty(p) && (y != null || B != null))
              switch (p) {
                case "value":
                  at = y;
                  break;
                case "defaultValue":
                  A = y;
                  break;
                case "multiple":
                  M = y;
                default:
                  y !== B && qe(
                    t,
                    e,
                    p,
                    y,
                    f,
                    B
                  );
              }
          f = A, e = M, a = gt, at != null ? Io(t, !!e, at, !1) : !!a != !!e && (f != null ? Io(t, !!e, f, !0) : Io(t, !!e, e ? [] : "", !1));
          return;
        case "textarea":
          gt = at = null;
          for (A in a)
            if (p = a[A], a.hasOwnProperty(A) && p != null && !f.hasOwnProperty(A))
              switch (A) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  qe(t, e, A, null, f, p);
              }
          for (M in f)
            if (p = f[M], y = a[M], f.hasOwnProperty(M) && (p != null || y != null))
              switch (M) {
                case "value":
                  at = p;
                  break;
                case "defaultValue":
                  gt = p;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (p != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  p !== y && qe(t, e, M, p, f, y);
              }
          pr(t, at, gt);
          return;
        case "option":
          for (var Kt in a)
            if (at = a[Kt], a.hasOwnProperty(Kt) && at != null && !f.hasOwnProperty(Kt))
              switch (Kt) {
                case "selected":
                  t.selected = !1;
                  break;
                default:
                  qe(
                    t,
                    e,
                    Kt,
                    null,
                    f,
                    at
                  );
              }
          for (B in f)
            if (at = f[B], gt = a[B], f.hasOwnProperty(B) && at !== gt && (at != null || gt != null))
              switch (B) {
                case "selected":
                  t.selected = at && typeof at != "function" && typeof at != "symbol";
                  break;
                default:
                  qe(
                    t,
                    e,
                    B,
                    at,
                    f,
                    gt
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var ue in a)
            at = a[ue], a.hasOwnProperty(ue) && at != null && !f.hasOwnProperty(ue) && qe(
              t,
              e,
              ue,
              null,
              f,
              at
            );
          for (Y in f)
            if (at = f[Y], gt = a[Y], f.hasOwnProperty(Y) && at !== gt && (at != null || gt != null))
              switch (Y) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (at != null)
                    throw Error(
                      e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  qe(
                    t,
                    e,
                    Y,
                    at,
                    f,
                    gt
                  );
              }
          return;
        default:
          if (tl(e)) {
            for (var pn in a)
              at = a[pn], a.hasOwnProperty(pn) && at !== void 0 && !f.hasOwnProperty(pn) && Yu(
                t,
                e,
                pn,
                void 0,
                f,
                at
              );
            for (lt in f)
              at = f[lt], gt = a[lt], !f.hasOwnProperty(lt) || at === gt || at === void 0 && gt === void 0 || Yu(
                t,
                e,
                lt,
                at,
                f,
                gt
              );
            return;
          }
      }
      for (var Be in a)
        at = a[Be], a.hasOwnProperty(Be) && at != null && !f.hasOwnProperty(Be) && qe(t, e, Be, null, f, at);
      for (pt in f)
        at = f[pt], gt = a[pt], !f.hasOwnProperty(pt) || at === gt || at == null && gt == null || qe(t, e, pt, at, f, gt);
    }
    function Og(t) {
      switch (t) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return t;
      }
    }
    function ju(t) {
      var e = {};
      t = t.style;
      for (var a = 0; a < t.length; a++) {
        var f = t[a];
        e[f] = t.getPropertyValue(f);
      }
      return e;
    }
    function Dg(t, e, a) {
      if (e != null && typeof e != "object")
        console.error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      else {
        var f, p = f = "", y;
        for (y in e)
          if (e.hasOwnProperty(y)) {
            var M = e[y];
            M != null && typeof M != "boolean" && M !== "" && (y.indexOf("--") === 0 ? (bt(M, y), f += p + y + ":" + ("" + M).trim()) : typeof M != "number" || M === 0 || jh.has(y) ? (bt(M, y), f += p + y.replace(tr, "-$1").toLowerCase().replace(er, "-ms-") + ":" + ("" + M).trim()) : f += p + y.replace(tr, "-$1").toLowerCase().replace(er, "-ms-") + ":" + M + "px", p = ";");
          }
        f = f || null, e = t.getAttribute("style"), e !== f && (f = Li(f), Li(e) !== f && (a.style = ju(t)));
      }
    }
    function ra(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (ct(f, e), t === "" + f)
              return;
        }
      _n(e, t, f, y);
    }
    function Ag(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null) {
        switch (typeof f) {
          case "function":
          case "symbol":
            return;
        }
        if (!f) return;
      } else
        switch (typeof f) {
          case "function":
          case "symbol":
            break;
          default:
            if (f) return;
        }
      _n(e, t, f, y);
    }
    function Rg(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
            break;
          default:
            if (ct(f, a), t === "" + f)
              return;
        }
      _n(e, t, f, y);
    }
    function Vv(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(f)) return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (!isNaN(f) && (ct(f, e), t === "" + f))
              return;
        }
      _n(e, t, f, y);
    }
    function Qe(t, e, a, f, p, y) {
      if (p.delete(a), t = t.getAttribute(a), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (ct(f, e), a = Ai("" + f), t === a)
              return;
        }
      _n(e, t, f, y);
    }
    function sn(t, e, a, f) {
      for (var p = {}, y = /* @__PURE__ */ new Set(), M = t.attributes, A = 0; A < M.length; A++)
        switch (M[A].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            y.add(M[A].name);
        }
      if (tl(e)) {
        for (var B in a)
          if (a.hasOwnProperty(B)) {
            var Y = a[B];
            if (Y != null) {
              if (Po.hasOwnProperty(B))
                typeof Y != "function" && Yo(B, Y);
              else if (a.suppressHydrationWarning !== !0)
                switch (B) {
                  case "children":
                    typeof Y != "string" && typeof Y != "number" || _n(
                      "children",
                      t.textContent,
                      Y,
                      p
                    );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    M = t.innerHTML, Y = Y ? Y.__html : void 0, Y != null && (Y = Om(t, Y), _n(
                      B,
                      M,
                      Y,
                      p
                    ));
                    continue;
                  case "style":
                    y.delete(B), Dg(t, Y, p);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    y.delete(B.toLowerCase()), console.error(
                      "Assignment to read-only property will result in a no-op: `%s`",
                      B
                    );
                    continue;
                  case "className":
                    y.delete("class"), M = he(
                      t,
                      "class",
                      Y
                    ), _n(
                      "className",
                      M,
                      Y,
                      p
                    );
                    continue;
                  default:
                    f.context === lc && e !== "svg" && e !== "math" ? y.delete(B.toLowerCase()) : y.delete(B), M = he(
                      t,
                      B,
                      Y
                    ), _n(
                      B,
                      M,
                      Y,
                      p
                    );
                }
            }
          }
      } else
        for (Y in a)
          if (a.hasOwnProperty(Y) && (B = a[Y], B != null)) {
            if (Po.hasOwnProperty(Y))
              typeof B != "function" && Yo(Y, B);
            else if (a.suppressHydrationWarning !== !0)
              switch (Y) {
                case "children":
                  typeof B != "string" && typeof B != "number" || _n(
                    "children",
                    t.textContent,
                    B,
                    p
                  );
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  M = t.innerHTML, B = B ? B.__html : void 0, B != null && (B = Om(t, B), M !== B && (p[Y] = { __html: M }));
                  continue;
                case "className":
                  ra(
                    t,
                    Y,
                    "class",
                    B,
                    y,
                    p
                  );
                  continue;
                case "tabIndex":
                  ra(
                    t,
                    Y,
                    "tabindex",
                    B,
                    y,
                    p
                  );
                  continue;
                case "style":
                  y.delete(Y), Dg(t, B, p);
                  continue;
                case "multiple":
                  y.delete(Y), _n(
                    Y,
                    t.multiple,
                    B,
                    p
                  );
                  continue;
                case "muted":
                  y.delete(Y), _n(
                    Y,
                    t.muted,
                    B,
                    p
                  );
                  continue;
                case "autoFocus":
                  y.delete("autofocus"), _n(
                    Y,
                    t.autofocus,
                    B,
                    p
                  );
                  continue;
                case "data":
                  if (e !== "object") {
                    y.delete(Y), M = t.getAttribute("data"), _n(
                      Y,
                      M,
                      B,
                      p
                    );
                    continue;
                  }
                case "src":
                case "href":
                  if (!(B !== "" || e === "a" && Y === "href" || e === "object" && Y === "data")) {
                    console.error(
                      Y === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                      Y,
                      Y
                    );
                    continue;
                  }
                  Qe(
                    t,
                    Y,
                    Y,
                    B,
                    y,
                    p
                  );
                  continue;
                case "action":
                case "formAction":
                  if (M = t.getAttribute(Y), typeof B == "function") {
                    y.delete(Y.toLowerCase()), Y === "formAction" ? (y.delete("name"), y.delete("formenctype"), y.delete("formmethod"), y.delete("formtarget")) : (y.delete("enctype"), y.delete("method"), y.delete("target"));
                    continue;
                  } else if (M === xE) {
                    y.delete(Y.toLowerCase()), _n(
                      Y,
                      "function",
                      B,
                      p
                    );
                    continue;
                  }
                  Qe(
                    t,
                    Y,
                    Y.toLowerCase(),
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkHref":
                  Qe(
                    t,
                    Y,
                    "xlink:href",
                    B,
                    y,
                    p
                  );
                  continue;
                case "contentEditable":
                  Rg(
                    t,
                    Y,
                    "contenteditable",
                    B,
                    y,
                    p
                  );
                  continue;
                case "spellCheck":
                  Rg(
                    t,
                    Y,
                    "spellcheck",
                    B,
                    y,
                    p
                  );
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  Rg(
                    t,
                    Y,
                    Y,
                    B,
                    y,
                    p
                  );
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  Ag(
                    t,
                    Y,
                    Y.toLowerCase(),
                    B,
                    y,
                    p
                  );
                  continue;
                case "capture":
                case "download":
                  t: {
                    A = t;
                    var lt = M = Y, pt = p;
                    if (y.delete(lt), A = A.getAttribute(lt), A === null)
                      switch (typeof B) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break t;
                        default:
                          if (B === !1) break t;
                      }
                    else if (B != null)
                      switch (typeof B) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (B === !0 && A === "") break t;
                          break;
                        default:
                          if (ct(B, M), A === "" + B)
                            break t;
                      }
                    _n(
                      M,
                      A,
                      B,
                      pt
                    );
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  t: {
                    if (A = t, lt = M = Y, pt = p, y.delete(lt), A = A.getAttribute(lt), A === null)
                      switch (typeof B) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break t;
                        default:
                          if (isNaN(B) || 1 > B) break t;
                      }
                    else if (B != null)
                      switch (typeof B) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (!(isNaN(B) || 1 > B) && (ct(B, M), A === "" + B))
                            break t;
                      }
                    _n(
                      M,
                      A,
                      B,
                      pt
                    );
                  }
                  continue;
                case "rowSpan":
                  Vv(
                    t,
                    Y,
                    "rowspan",
                    B,
                    y,
                    p
                  );
                  continue;
                case "start":
                  Vv(
                    t,
                    Y,
                    Y,
                    B,
                    y,
                    p
                  );
                  continue;
                case "xHeight":
                  ra(
                    t,
                    Y,
                    "x-height",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkActuate":
                  ra(
                    t,
                    Y,
                    "xlink:actuate",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkArcrole":
                  ra(
                    t,
                    Y,
                    "xlink:arcrole",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkRole":
                  ra(
                    t,
                    Y,
                    "xlink:role",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkShow":
                  ra(
                    t,
                    Y,
                    "xlink:show",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkTitle":
                  ra(
                    t,
                    Y,
                    "xlink:title",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xlinkType":
                  ra(
                    t,
                    Y,
                    "xlink:type",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xmlBase":
                  ra(
                    t,
                    Y,
                    "xml:base",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xmlLang":
                  ra(
                    t,
                    Y,
                    "xml:lang",
                    B,
                    y,
                    p
                  );
                  continue;
                case "xmlSpace":
                  ra(
                    t,
                    Y,
                    "xml:space",
                    B,
                    y,
                    p
                  );
                  continue;
                case "inert":
                  B !== "" || Y_[Y] || (Y_[Y] = !0, console.error(
                    "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                    Y
                  )), Ag(
                    t,
                    Y,
                    Y,
                    B,
                    y,
                    p
                  );
                  continue;
                default:
                  if (!(2 < Y.length) || Y[0] !== "o" && Y[0] !== "O" || Y[1] !== "n" && Y[1] !== "N") {
                    A = xs(Y), M = !1, f.context === lc && e !== "svg" && e !== "math" ? y.delete(A.toLowerCase()) : (lt = Y.toLowerCase(), lt = Iu.hasOwnProperty(
                      lt
                    ) && Iu[lt] || null, lt !== null && lt !== Y && (M = !0, y.delete(lt)), y.delete(A));
                    t: if (lt = t, pt = A, A = B, se(pt))
                      if (lt.hasAttribute(pt))
                        lt = lt.getAttribute(
                          pt
                        ), ct(
                          A,
                          pt
                        ), A = lt === "" + A ? A : lt;
                      else {
                        switch (typeof A) {
                          case "function":
                          case "symbol":
                            break t;
                          case "boolean":
                            if (lt = pt.toLowerCase().slice(0, 5), lt !== "data-" && lt !== "aria-")
                              break t;
                        }
                        A = A === void 0 ? void 0 : null;
                      }
                    else A = void 0;
                    M || _n(
                      Y,
                      A,
                      B,
                      p
                    );
                  }
              }
          }
      return 0 < y.size && a.suppressHydrationWarning !== !0 && Yr(t, y, p), Object.keys(p).length === 0 ? null : p;
    }
    function Le(t, e) {
      switch (t.length) {
        case 0:
          return "";
        case 1:
          return t[0];
        case 2:
          return t[0] + " " + e + " " + t[1];
        default:
          return t.slice(0, -1).join(", ") + ", " + e + " " + t[t.length - 1];
      }
    }
    function He(t) {
      return t.nodeType === 9 ? t : t.ownerDocument;
    }
    function Ke(t) {
      switch (t) {
        case rf:
          return Dp;
        case qh:
          return Z_;
        default:
          return lc;
      }
    }
    function Ca(t, e) {
      if (t === lc)
        switch (e) {
          case "svg":
            return Dp;
          case "math":
            return Z_;
          default:
            return lc;
        }
      return t === Dp && e === "foreignObject" ? lc : t;
    }
    function Jl(t, e) {
      return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.children == "bigint" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
    }
    function jc() {
      var t = window.event;
      return t && t.type === "popstate" ? t === qb ? !1 : (qb = t, !0) : (qb = null, !1);
    }
    function Cg(t) {
      setTimeout(function() {
        throw t;
      });
    }
    function Xs(t, e, a) {
      switch (e) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          a.autoFocus && t.focus();
          break;
        case "img":
          a.src ? t.src = a.src : a.srcSet && (t.srcset = a.srcSet);
      }
    }
    function Ln(t, e, a, f) {
      Pv(t, e, a, f), t[ka] = f;
    }
    function Qs(t) {
      Fo(t, "");
    }
    function qu(t, e, a) {
      t.nodeValue = a;
    }
    function Fl(t) {
      return t === "head";
    }
    function jo(t, e) {
      t.removeChild(e);
    }
    function qc(t, e) {
      (t.nodeType === 9 ? t.body : t.nodeName === "HTML" ? t.ownerDocument.body : t).removeChild(e);
    }
    function Zc(t, e) {
      var a = e, f = 0, p = 0;
      do {
        var y = a.nextSibling;
        if (t.removeChild(a), y && y.nodeType === 8)
          if (a = y.data, a === q_) {
            if (0 < f && 8 > f) {
              a = f;
              var M = t.ownerDocument;
              if (a & ME && Xc(M.documentElement), a & EE && Xc(M.body), a & OE)
                for (a = M.head, Xc(a), M = a.firstChild; M; ) {
                  var A = M.nextSibling, B = M.nodeName;
                  M[af] || B === "SCRIPT" || B === "STYLE" || B === "LINK" && M.rel.toLowerCase() === "stylesheet" || a.removeChild(M), M = A;
                }
            }
            if (p === 0) {
              t.removeChild(y), Gu(e);
              return;
            }
            p--;
          } else
            a === j_ || a === oc || a === qy ? p++ : f = a.charCodeAt(0) - 48;
        else f = 0;
        a = y;
      } while (a);
      Gu(e);
    }
    function za(t) {
      t = t.style, typeof t.setProperty == "function" ? t.setProperty("display", "none", "important") : t.display = "none";
    }
    function zg(t) {
      t.nodeValue = "";
    }
    function Lg(t, e) {
      e = e[DE], e = e != null && e.hasOwnProperty("display") ? e.display : null, t.style.display = e == null || typeof e == "boolean" ? "" : ("" + e).trim();
    }
    function Dm(t, e) {
      t.nodeValue = e;
    }
    function Pc(t) {
      var e = t.firstChild;
      for (e && e.nodeType === 10 && (e = e.nextSibling); e; ) {
        var a = e;
        switch (e = e.nextSibling, a.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            Pc(a), ga(a);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (a.rel.toLowerCase() === "stylesheet") continue;
        }
        t.removeChild(a);
      }
    }
    function jr(t, e, a, f) {
      for (; t.nodeType === 1; ) {
        var p = a;
        if (t.nodeName.toLowerCase() !== e.toLowerCase()) {
          if (!f && (t.nodeName !== "INPUT" || t.type !== "hidden"))
            break;
        } else if (f) {
          if (!t[af])
            switch (e) {
              case "meta":
                if (!t.hasAttribute("itemprop")) break;
                return t;
              case "link":
                if (y = t.getAttribute("rel"), y === "stylesheet" && t.hasAttribute("data-precedence"))
                  break;
                if (y !== p.rel || t.getAttribute("href") !== (p.href == null || p.href === "" ? null : p.href) || t.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin) || t.getAttribute("title") !== (p.title == null ? null : p.title))
                  break;
                return t;
              case "style":
                if (t.hasAttribute("data-precedence")) break;
                return t;
              case "script":
                if (y = t.getAttribute("src"), (y !== (p.src == null ? null : p.src) || t.getAttribute("type") !== (p.type == null ? null : p.type) || t.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin)) && y && t.hasAttribute("async") && !t.hasAttribute("itemprop"))
                  break;
                return t;
              default:
                return t;
            }
        } else if (e === "input" && t.type === "hidden") {
          ct(p.name, "name");
          var y = p.name == null ? null : "" + p.name;
          if (p.type === "hidden" && t.getAttribute("name") === y)
            return t;
        } else return t;
        if (t = ki(t.nextSibling), t === null) break;
      }
      return null;
    }
    function Hi(t, e, a) {
      if (e === "") return null;
      for (; t.nodeType !== 3; )
        if ((t.nodeType !== 1 || t.nodeName !== "INPUT" || t.type !== "hidden") && !a || (t = ki(t.nextSibling), t === null)) return null;
      return t;
    }
    function ts(t) {
      return t.data === qy || t.data === oc && t.ownerDocument.readyState === yT;
    }
    function Vc(t, e) {
      var a = t.ownerDocument;
      if (t.data !== oc || a.readyState === yT)
        e();
      else {
        var f = function() {
          e(), a.removeEventListener("DOMContentLoaded", f);
        };
        a.addEventListener("DOMContentLoaded", f), t._reactRetry = f;
      }
    }
    function ki(t) {
      for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3) break;
        if (e === 8) {
          if (e = t.data, e === j_ || e === qy || e === oc || e === Bb || e === gT)
            break;
          if (e === q_) return null;
        }
      }
      return t;
    }
    function Am(t) {
      if (t.nodeType === 1) {
        for (var e = t.nodeName.toLowerCase(), a = {}, f = t.attributes, p = 0; p < f.length; p++) {
          var y = f[p];
          a[Og(y.name)] = y.name.toLowerCase() === "style" ? ju(t) : y.value;
        }
        return { type: e, props: a };
      }
      return t.nodeType === 8 ? { type: "Suspense", props: {} } : t.nodeValue;
    }
    function Rm(t, e, a) {
      return a === null || a[wE] !== !0 ? (t.nodeValue === e ? t = null : (e = Li(e), t = Li(t.nodeValue) === e ? null : t.nodeValue), t) : null;
    }
    function Hg(t) {
      t = t.nextSibling;
      for (var e = 0; t; ) {
        if (t.nodeType === 8) {
          var a = t.data;
          if (a === q_) {
            if (e === 0)
              return ki(t.nextSibling);
            e--;
          } else
            a !== j_ && a !== qy && a !== oc || e++;
        }
        t = t.nextSibling;
      }
      return null;
    }
    function Gc(t) {
      t = t.previousSibling;
      for (var e = 0; t; ) {
        if (t.nodeType === 8) {
          var a = t.data;
          if (a === j_ || a === qy || a === oc) {
            if (e === 0) return t;
            e--;
          } else a === q_ && e++;
        }
        t = t.previousSibling;
      }
      return null;
    }
    function kg(t) {
      Gu(t);
    }
    function oo(t) {
      Gu(t);
    }
    function Ng(t, e, a, f, p) {
      switch (p && yr(t, f.ancestorInfo), e = He(a), t) {
        case "html":
          if (t = e.documentElement, !t)
            throw Error(
              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        case "head":
          if (t = e.head, !t)
            throw Error(
              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        case "body":
          if (t = e.body, !t)
            throw Error(
              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        default:
          throw Error(
            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
    }
    function lo(t, e, a, f) {
      if (!a[Wr] && Pn(a)) {
        var p = a.tagName.toLowerCase();
        console.error(
          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
          p,
          p,
          p
        );
      }
      switch (t) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error(
            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
      for (p = a.attributes; p.length; )
        a.removeAttributeNode(p[0]);
      zn(a, t, e), a[Ii] = f, a[ka] = e;
    }
    function Xc(t) {
      for (var e = t.attributes; e.length; )
        t.removeAttributeNode(e[0]);
      ga(t);
    }
    function bh(t) {
      return typeof t.getRootNode == "function" ? t.getRootNode() : t.nodeType === 9 ? t : t.ownerDocument;
    }
    function Gv(t, e, a) {
      var f = Ap;
      if (f && typeof e == "string" && e) {
        var p = na(e);
        p = 'link[rel="' + t + '"][href="' + p + '"]', typeof a == "string" && (p += '[crossorigin="' + a + '"]'), xT.has(p) || (xT.add(p), t = { rel: t, crossOrigin: a, href: e }, f.querySelector(p) === null && (e = f.createElement("link"), zn(e, "link", t), J(e), f.head.appendChild(e)));
      }
    }
    function Ks(t, e, a, f) {
      var p = (p = ns.current) ? bh(p) : null;
      if (!p)
        throw Error(
          '"resourceRoot" was expected to exist. This is a bug in React.'
        );
      switch (t) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof a.precedence == "string" && typeof a.href == "string" ? (a = qr(a.href), e = N(p).hoistableStyles, f = e.get(a), f || (f = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, e.set(a, f)), f) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (a.rel === "stylesheet" && typeof a.href == "string" && typeof a.precedence == "string") {
            t = qr(a.href);
            var y = N(p).hoistableStyles, M = y.get(t);
            if (!M && (p = p.ownerDocument || p, M = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: od, preload: null }
            }, y.set(t, M), (y = p.querySelector(
              es(t)
            )) && !y._p && (M.instance = y, M.state.loading = Zy | ps), !gs.has(t))) {
              var A = {
                rel: "preload",
                as: "style",
                href: a.href,
                crossOrigin: a.crossOrigin,
                integrity: a.integrity,
                media: a.media,
                hrefLang: a.hrefLang,
                referrerPolicy: a.referrerPolicy
              };
              gs.set(t, A), y || Xv(
                p,
                t,
                A,
                M.state
              );
            }
            if (e && f === null)
              throw a = `

  - ` + Zu(e) + `
  + ` + Zu(a), Error(
                "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + a
              );
            return M;
          }
          if (e && f !== null)
            throw a = `

  - ` + Zu(e) + `
  + ` + Zu(a), Error(
              "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + a
            );
          return null;
        case "script":
          return e = a.async, a = a.src, typeof a == "string" && e && typeof e != "function" && typeof e != "symbol" ? (a = Pu(a), e = N(p).hoistableScripts, f = e.get(a), f || (f = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, e.set(a, f)), f) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(
            'getResource encountered a type it did not expect: "' + t + '". this is a bug in React.'
          );
      }
    }
    function Zu(t) {
      var e = 0, a = "<link";
      return typeof t.rel == "string" ? (e++, a += ' rel="' + t.rel + '"') : $s.call(t, "rel") && (e++, a += ' rel="' + (t.rel === null ? "null" : "invalid type " + typeof t.rel) + '"'), typeof t.href == "string" ? (e++, a += ' href="' + t.href + '"') : $s.call(t, "href") && (e++, a += ' href="' + (t.href === null ? "null" : "invalid type " + typeof t.href) + '"'), typeof t.precedence == "string" ? (e++, a += ' precedence="' + t.precedence + '"') : $s.call(t, "precedence") && (e++, a += " precedence={" + (t.precedence === null ? "null" : "invalid type " + typeof t.precedence) + "}"), Object.getOwnPropertyNames(t).length > e && (a += " ..."), a + " />";
    }
    function qr(t) {
      return 'href="' + na(t) + '"';
    }
    function es(t) {
      return 'link[rel="stylesheet"][' + t + "]";
    }
    function Ug(t) {
      return Me({}, t, {
        "data-precedence": t.precedence,
        precedence: null
      });
    }
    function Xv(t, e, a, f) {
      t.querySelector(
        'link[rel="preload"][as="style"][' + e + "]"
      ) ? f.loading = Zy : (e = t.createElement("link"), f.preload = e, e.addEventListener("load", function() {
        return f.loading |= Zy;
      }), e.addEventListener("error", function() {
        return f.loading |= ST;
      }), zn(e, "link", a), J(e), t.head.appendChild(e));
    }
    function Pu(t) {
      return '[src="' + na(t) + '"]';
    }
    function Vu(t) {
      return "script[async]" + t;
    }
    function Cm(t, e, a) {
      if (e.count++, e.instance === null)
        switch (e.type) {
          case "style":
            var f = t.querySelector(
              'style[data-href~="' + na(a.href) + '"]'
            );
            if (f)
              return e.instance = f, J(f), f;
            var p = Me({}, a, {
              "data-href": a.href,
              "data-precedence": a.precedence,
              href: null,
              precedence: null
            });
            return f = (t.ownerDocument || t).createElement("style"), J(f), zn(f, "style", p), zm(f, a.precedence, t), e.instance = f;
          case "stylesheet":
            p = qr(a.href);
            var y = t.querySelector(
              es(p)
            );
            if (y)
              return e.state.loading |= ps, e.instance = y, J(y), y;
            f = Ug(a), (p = gs.get(p)) && Bg(f, p), y = (t.ownerDocument || t).createElement("link"), J(y);
            var M = y;
            return M._p = new Promise(function(A, B) {
              M.onload = A, M.onerror = B;
            }), zn(y, "link", f), e.state.loading |= ps, zm(y, a.precedence, t), e.instance = y;
          case "script":
            return y = Pu(a.src), (p = t.querySelector(
              Vu(y)
            )) ? (e.instance = p, J(p), p) : (f = a, (p = gs.get(y)) && (f = Me({}, a), Yg(f, p)), t = t.ownerDocument || t, p = t.createElement("script"), J(p), zn(p, "link", f), t.head.appendChild(p), e.instance = p);
          case "void":
            return null;
          default:
            throw Error(
              'acquireResource encountered a resource type it did not expect: "' + e.type + '". this is a bug in React.'
            );
        }
      else
        e.type === "stylesheet" && (e.state.loading & ps) === od && (f = e.instance, e.state.loading |= ps, zm(f, a.precedence, t));
      return e.instance;
    }
    function zm(t, e, a) {
      for (var f = a.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), p = f.length ? f[f.length - 1] : null, y = p, M = 0; M < f.length; M++) {
        var A = f[M];
        if (A.dataset.precedence === e) y = A;
        else if (y !== p) break;
      }
      y ? y.parentNode.insertBefore(t, y.nextSibling) : (e = a.nodeType === 9 ? a.head : a, e.insertBefore(t, e.firstChild));
    }
    function Bg(t, e) {
      t.crossOrigin == null && (t.crossOrigin = e.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = e.referrerPolicy), t.title == null && (t.title = e.title);
    }
    function Yg(t, e) {
      t.crossOrigin == null && (t.crossOrigin = e.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = e.referrerPolicy), t.integrity == null && (t.integrity = e.integrity);
    }
    function jg(t, e, a) {
      if (P_ === null) {
        var f = /* @__PURE__ */ new Map(), p = P_ = /* @__PURE__ */ new Map();
        p.set(a, f);
      } else
        p = P_, f = p.get(a), f || (f = /* @__PURE__ */ new Map(), p.set(a, f));
      if (f.has(t)) return f;
      for (f.set(t, null), a = a.getElementsByTagName(t), p = 0; p < a.length; p++) {
        var y = a[p];
        if (!(y[af] || y[Ii] || t === "link" && y.getAttribute("rel") === "stylesheet") && y.namespaceURI !== rf) {
          var M = y.getAttribute(e) || "";
          M = t + M;
          var A = f.get(M);
          A ? A.push(y) : f.set(M, [y]);
        }
      }
      return f;
    }
    function qg(t, e, a) {
      t = t.ownerDocument || t, t.head.insertBefore(
        a,
        e === "title" ? t.querySelector("head > title") : null
      );
    }
    function Qc(t, e, a) {
      var f = !a.ancestorInfo.containerTagInScope;
      if (a.context === Dp || e.itemProp != null)
        return !f || e.itemProp == null || t !== "meta" && t !== "title" && t !== "style" && t !== "link" && t !== "script" || console.error(
          "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
          t,
          t
        ), !1;
      switch (t) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (typeof e.precedence != "string" || typeof e.href != "string" || e.href === "") {
            f && console.error(
              'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
            );
            break;
          }
          return !0;
        case "link":
          if (typeof e.rel != "string" || typeof e.href != "string" || e.href === "" || e.onLoad || e.onError) {
            if (e.rel === "stylesheet" && typeof e.precedence == "string") {
              t = e.href;
              var p = e.onError, y = e.disabled;
              a = [], e.onLoad && a.push("`onLoad`"), p && a.push("`onError`"), y != null && a.push("`disabled`"), p = Le(a, "and"), p += a.length === 1 ? " prop" : " props", y = a.length === 1 ? "an " + p : "the " + p, a.length && console.error(
                'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                t,
                y,
                p
              );
            }
            f && (typeof e.rel != "string" || typeof e.href != "string" || e.href === "" ? console.error(
              "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
            ) : (e.onError || e.onLoad) && console.error(
              "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ));
            break;
          }
          switch (e.rel) {
            case "stylesheet":
              return t = e.precedence, e = e.disabled, typeof t != "string" && f && console.error(
                'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
              ), typeof t == "string" && e == null;
            default:
              return !0;
          }
        case "script":
          if (t = e.async && typeof e.async != "function" && typeof e.async != "symbol", !t || e.onLoad || e.onError || !e.src || typeof e.src != "string") {
            f && (t ? e.onLoad || e.onError ? console.error(
              "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
            ));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          f && console.error(
            "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
            t
          );
      }
      return !1;
    }
    function Sh(t) {
      return !(t.type === "stylesheet" && (t.state.loading & TT) === od);
    }
    function Qv() {
    }
    function Kv(t, e, a) {
      if (Py === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var f = Py;
      if (e.type === "stylesheet" && (typeof a.media != "string" || matchMedia(a.media).matches !== !1) && (e.state.loading & ps) === od) {
        if (e.instance === null) {
          var p = qr(a.href), y = t.querySelector(
            es(p)
          );
          if (y) {
            t = y._p, t !== null && typeof t == "object" && typeof t.then == "function" && (f.count++, f = Th.bind(f), t.then(f, f)), e.state.loading |= ps, e.instance = y, J(y);
            return;
          }
          y = t.ownerDocument || t, a = Ug(a), (p = gs.get(p)) && Bg(a, p), y = y.createElement("link"), J(y);
          var M = y;
          M._p = new Promise(function(A, B) {
            M.onload = A, M.onerror = B;
          }), zn(y, "link", a), e.instance = y;
        }
        f.stylesheets === null && (f.stylesheets = /* @__PURE__ */ new Map()), f.stylesheets.set(e, t), (t = e.state.preload) && (e.state.loading & TT) === od && (f.count++, e = Th.bind(f), t.addEventListener("load", e), t.addEventListener("error", e));
      }
    }
    function Wv() {
      if (Py === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var t = Py;
      return t.stylesheets && t.count === 0 && Lm(t, t.stylesheets), 0 < t.count ? function(e) {
        var a = setTimeout(function() {
          if (t.stylesheets && Lm(t, t.stylesheets), t.unsuspend) {
            var f = t.unsuspend;
            t.unsuspend = null, f();
          }
        }, 6e4);
        return t.unsuspend = e, function() {
          t.unsuspend = null, clearTimeout(a);
        };
      } : null;
    }
    function Th() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets)
          Lm(this, this.stylesheets);
        else if (this.unsuspend) {
          var t = this.unsuspend;
          this.unsuspend = null, t();
        }
      }
    }
    function Lm(t, e) {
      t.stylesheets = null, t.unsuspend !== null && (t.count++, V_ = /* @__PURE__ */ new Map(), e.forEach(Iv, t), V_ = null, Th.call(t));
    }
    function Iv(t, e) {
      if (!(e.state.loading & ps)) {
        var a = V_.get(t);
        if (a) var f = a.get(Pb);
        else {
          a = /* @__PURE__ */ new Map(), V_.set(t, a);
          for (var p = t.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), y = 0; y < p.length; y++) {
            var M = p[y];
            (M.nodeName === "LINK" || M.getAttribute("media") !== "not all") && (a.set(M.dataset.precedence, M), f = M);
          }
          f && a.set(Pb, f);
        }
        p = e.instance, M = p.getAttribute("data-precedence"), y = a.get(M) || f, y === f && a.set(Pb, p), a.set(M, p), this.count++, f = Th.bind(this), p.addEventListener("load", f), p.addEventListener("error", f), y ? y.parentNode.insertBefore(p, y.nextSibling) : (t = t.nodeType === 9 ? t.head : t, t.insertBefore(p, t.firstChild)), e.state.loading |= ps;
      }
    }
    function Hm(t, e, a, f, p, y, M, A) {
      for (this.tag = 1, this.containerInfo = t, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = ad, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = vs(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = vs(0), this.hiddenUpdates = vs(null), this.identifierPrefix = f, this.onUncaughtError = p, this.onCaughtError = y, this.onRecoverableError = M, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = A, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), t = this.pendingUpdatersLaneMap = [], e = 0; 31 > e; e++) t.push(/* @__PURE__ */ new Set());
      this._debugRootType = a ? "hydrateRoot()" : "createRoot()";
    }
    function Zg(t, e, a, f, p, y, M, A, B, Y, lt, pt) {
      return t = new Hm(
        t,
        e,
        a,
        M,
        A,
        B,
        Y,
        pt
      ), e = tE, y === !0 && (e |= Ua | nr), kn && (e |= ca), y = z(3, null, null, e), t.current = y, y.stateNode = t, e = Hs(), Ao(e), t.pooledCache = e, Ao(e), y.memoizedState = {
        element: f,
        isDehydrated: a,
        cache: e
      }, Ci(y), t;
    }
    function Pg(t) {
      return t ? (t = uf, t) : uf;
    }
    function Ie(t, e, a, f, p, y) {
      if (Ni && typeof Ni.onScheduleFiberRoot == "function")
        try {
          Ni.onScheduleFiberRoot(Qr, f, a);
        } catch (M) {
          Ha || (Ha = !0, console.error(
            "React instrumentation encountered an error: %s",
            M
          ));
        }
      jt !== null && typeof jt.markRenderScheduled == "function" && jt.markRenderScheduled(e), p = Pg(p), f.context === null ? f.context = p : f.pendingContext = p, Na && ro !== null && !OT && (OT = !0, console.error(
        `Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,
        wt(ro) || "Unknown"
      )), f = Gn(e), f.payload = { element: a }, y = y === void 0 ? null : y, y !== null && (typeof y != "function" && console.error(
        "Expected the last optional `callback` argument to be a function. Instead received: %s.",
        y
      ), f.callback = y), a = wa(t, f, e), a !== null && (Rn(a, t, e), ll(a, t, e));
    }
    function km(t, e) {
      if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
        var a = t.retryLane;
        t.retryLane = a !== 0 && a < e ? a : e;
      }
    }
    function Vg(t, e) {
      km(t, e), (t = t.alternate) && km(t, e);
    }
    function Gg(t) {
      if (t.tag === 13) {
        var e = pi(t, 67108864);
        e !== null && Rn(e, t, 67108864), Vg(t, 67108864);
      }
    }
    function U0() {
      return ro;
    }
    function B0() {
      for (var t = /* @__PURE__ */ new Map(), e = 1, a = 0; 31 > a; a++) {
        var f = cr(e);
        t.set(e, f), e *= 2;
      }
      return t;
    }
    function Y0(t, e, a, f) {
      var p = ft.T;
      ft.T = null;
      var y = re.p;
      try {
        re.p = Ui, Zr(t, e, a, f);
      } finally {
        re.p = y, ft.T = p;
      }
    }
    function Nm(t, e, a, f) {
      var p = ft.T;
      ft.T = null;
      var y = re.p;
      try {
        re.p = gl, Zr(t, e, a, f);
      } finally {
        re.p = y, ft.T = p;
      }
    }
    function Zr(t, e, a, f) {
      if (X_) {
        var p = xh(f);
        if (p === null)
          la(
            t,
            e,
            f,
            Q_,
            a
          ), Pr(t, f);
        else if (wh(
          p,
          t,
          e,
          a,
          f
        ))
          f.stopPropagation();
        else if (Pr(t, f), e & 4 && -1 < zE.indexOf(t)) {
          for (; p !== null; ) {
            var y = Pn(p);
            if (y !== null)
              switch (y.tag) {
                case 3:
                  if (y = y.stateNode, y.current.memoizedState.isDehydrated) {
                    var M = Tn(y.pendingLanes);
                    if (M !== 0) {
                      var A = y;
                      for (A.pendingLanes |= 2, A.entangledLanes |= 2; M; ) {
                        var B = 1 << 31 - Wi(M);
                        A.entanglements[1] |= B, M &= ~B;
                      }
                      Bo(y), ($e & (ho | lr)) === yl && (R_ = is() + oT, Bu(0));
                    }
                  }
                  break;
                case 13:
                  A = pi(y, 2), A !== null && Rn(A, y, 2), Nu(), Vg(y, 2);
              }
            if (y = xh(f), y === null && la(
              t,
              e,
              f,
              Q_,
              a
            ), y === p) break;
            p = y;
          }
          p !== null && f.stopPropagation();
        } else
          la(
            t,
            e,
            f,
            null,
            a
          );
      }
    }
    function xh(t) {
      return t = Ye(t), Kc(t);
    }
    function Kc(t) {
      if (Q_ = null, t = hi(t), t !== null) {
        var e = nt(t);
        if (e === null) t = null;
        else {
          var a = e.tag;
          if (a === 13) {
            if (t = Dt(e), t !== null) return t;
            t = null;
          } else if (a === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
              return e.tag === 3 ? e.stateNode.containerInfo : null;
            t = null;
          } else e !== t && (t = null);
        }
      }
      return Q_ = t, null;
    }
    function Um(t) {
      switch (t) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Ui;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return gl;
        case "message":
          switch (Xr()) {
            case Zm:
              return Ui;
            case Lh:
              return gl;
            case tf:
            case V0:
              return Fs;
            case Hh:
              return Xm;
            default:
              return Fs;
          }
        default:
          return Fs;
      }
    }
    function Pr(t, e) {
      switch (t) {
        case "focusin":
        case "focusout":
          _f = null;
          break;
        case "dragenter":
        case "dragleave":
          bf = null;
          break;
        case "mouseover":
        case "mouseout":
          Sf = null;
          break;
        case "pointerover":
        case "pointerout":
          Gy.delete(e.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Xy.delete(e.pointerId);
      }
    }
    function La(t, e, a, f, p, y) {
      return t === null || t.nativeEvent !== y ? (t = {
        blockedOn: e,
        domEventName: a,
        eventSystemFlags: f,
        nativeEvent: y,
        targetContainers: [p]
      }, e !== null && (e = Pn(e), e !== null && Gg(e)), t) : (t.eventSystemFlags |= f, e = t.targetContainers, p !== null && e.indexOf(p) === -1 && e.push(p), t);
    }
    function wh(t, e, a, f, p) {
      switch (e) {
        case "focusin":
          return _f = La(
            _f,
            t,
            e,
            a,
            f,
            p
          ), !0;
        case "dragenter":
          return bf = La(
            bf,
            t,
            e,
            a,
            f,
            p
          ), !0;
        case "mouseover":
          return Sf = La(
            Sf,
            t,
            e,
            a,
            f,
            p
          ), !0;
        case "pointerover":
          var y = p.pointerId;
          return Gy.set(
            y,
            La(
              Gy.get(y) || null,
              t,
              e,
              a,
              f,
              p
            )
          ), !0;
        case "gotpointercapture":
          return y = p.pointerId, Xy.set(
            y,
            La(
              Xy.get(y) || null,
              t,
              e,
              a,
              f,
              p
            )
          ), !0;
      }
      return !1;
    }
    function $v(t) {
      var e = hi(t.target);
      if (e !== null) {
        var a = nt(e);
        if (a !== null) {
          if (e = a.tag, e === 13) {
            if (e = Dt(a), e !== null) {
              t.blockedOn = e, hr(t.priority, function() {
                if (a.tag === 13) {
                  var f = Ra(a);
                  f = Zn(f);
                  var p = pi(
                    a,
                    f
                  );
                  p !== null && Rn(p, a, f), Vg(a, f);
                }
              });
              return;
            }
          } else if (e === 3 && a.stateNode.current.memoizedState.isDehydrated) {
            t.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null;
            return;
          }
        }
      }
      t.blockedOn = null;
    }
    function Mh(t) {
      if (t.blockedOn !== null) return !1;
      for (var e = t.targetContainers; 0 < e.length; ) {
        var a = xh(t.nativeEvent);
        if (a === null) {
          a = t.nativeEvent;
          var f = new a.constructor(
            a.type,
            a
          ), p = f;
          b !== null && console.error(
            "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
          ), b = p, a.target.dispatchEvent(f), b === null && console.error(
            "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
          ), b = null;
        } else
          return e = Pn(a), e !== null && Gg(e), t.blockedOn = a, !1;
        e.shift();
      }
      return !0;
    }
    function Xg(t, e, a) {
      Mh(t) && a.delete(e);
    }
    function Jv() {
      Vb = !1, _f !== null && Mh(_f) && (_f = null), bf !== null && Mh(bf) && (bf = null), Sf !== null && Mh(Sf) && (Sf = null), Gy.forEach(Xg), Xy.forEach(Xg);
    }
    function Eh(t, e) {
      t.blockedOn === e && (t.blockedOn = null, Vb || (Vb = !0, Hn.unstable_scheduleCallback(
        Hn.unstable_NormalPriority,
        Jv
      )));
    }
    function Fv(t) {
      K_ !== t && (K_ = t, Hn.unstable_scheduleCallback(
        Hn.unstable_NormalPriority,
        function() {
          K_ === t && (K_ = null);
          for (var e = 0; e < t.length; e += 3) {
            var a = t[e], f = t[e + 1], p = t[e + 2];
            if (typeof f != "function") {
              if (Kc(f || a) === null)
                continue;
              break;
            }
            var y = Pn(a);
            y !== null && (t.splice(e, 3), e -= 3, a = {
              pending: !0,
              data: p,
              method: a.method,
              action: f
            }, Object.freeze(a), Mu(
              y,
              a,
              f,
              p
            ));
          }
        }
      ));
    }
    function Gu(t) {
      function e(B) {
        return Eh(B, t);
      }
      _f !== null && Eh(_f, t), bf !== null && Eh(bf, t), Sf !== null && Eh(Sf, t), Gy.forEach(e), Xy.forEach(e);
      for (var a = 0; a < Tf.length; a++) {
        var f = Tf[a];
        f.blockedOn === t && (f.blockedOn = null);
      }
      for (; 0 < Tf.length && (a = Tf[0], a.blockedOn === null); )
        $v(a), a.blockedOn === null && Tf.shift();
      if (a = (t.ownerDocument || t).$$reactFormReplay, a != null)
        for (f = 0; f < a.length; f += 3) {
          var p = a[f], y = a[f + 1], M = p[ka] || null;
          if (typeof y == "function")
            M || Fv(a);
          else if (M) {
            var A = null;
            if (y && y.hasAttribute("formAction")) {
              if (p = y, M = y[ka] || null)
                A = M.formAction;
              else if (Kc(p) !== null) continue;
            } else A = M.action;
            typeof A == "function" ? a[f + 1] = A : (a.splice(f, 3), f -= 3), Fv(a);
          }
        }
    }
    function Bm(t) {
      this._internalRoot = t;
    }
    function Oh(t) {
      this._internalRoot = t;
    }
    function t_(t) {
      t[Wr] && (t._reactRootContainer ? console.error(
        "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
      ) : console.error(
        "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
      ));
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Hn = Sw(), Dh = Np(), j0 = Tw(), Me = Object.assign, Ah = Symbol.for("react.element"), Vr = Symbol.for("react.transitional.element"), Xu = Symbol.for("react.portal"), _e = Symbol.for("react.fragment"), Wc = Symbol.for("react.strict_mode"), Ic = Symbol.for("react.profiler"), Qg = Symbol.for("react.provider"), Ym = Symbol.for("react.consumer"), qo = Symbol.for("react.context"), Ws = Symbol.for("react.forward_ref"), $c = Symbol.for("react.suspense"), Gr = Symbol.for("react.suspense_list"), Rh = Symbol.for("react.memo"), so = Symbol.for("react.lazy"), Kg = Symbol.for("react.activity"), e_ = Symbol.for("react.memo_cache_sentinel"), Wg = Symbol.iterator, jm = Symbol.for("react.client.reference"), de = Array.isArray, ft = Dh.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, re = j0.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, q0 = Object.freeze({
      pending: !1,
      data: null,
      method: null,
      action: null
    }), Ch = [], zh = [], Zo = -1, Is = ne(null), Jc = ne(null), ns = ne(null), Fc = ne(null), $s = Object.prototype.hasOwnProperty, qm = Hn.unstable_scheduleCallback, Z0 = Hn.unstable_cancelCallback, n_ = Hn.unstable_shouldYield, P0 = Hn.unstable_requestPaint, is = Hn.unstable_now, Xr = Hn.unstable_getCurrentPriorityLevel, Zm = Hn.unstable_ImmediatePriority, Lh = Hn.unstable_UserBlockingPriority, tf = Hn.unstable_NormalPriority, V0 = Hn.unstable_LowPriority, Hh = Hn.unstable_IdlePriority, G0 = Hn.log, pl = Hn.unstable_setDisableYieldValue, Qr = null, Ni = null, jt = null, Ha = !1, kn = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u", Wi = Math.clz32 ? Math.clz32 : ur, Pm = Math.log, Js = Math.LN2, Vm = 256, Gm = 4194304, Ui = 2, gl = 8, Fs = 32, Xm = 268435456, Kr = Math.random().toString(36).slice(2), Ii = "__reactFiber$" + Kr, ka = "__reactProps$" + Kr, Wr = "__reactContainer$" + Kr, Ig = "__reactEvents$" + Kr, i_ = "__reactListeners$" + Kr, ef = "__reactHandles$" + Kr, nf = "__reactResources$" + Kr, af = "__reactMarker$" + Kr, a_ = /* @__PURE__ */ new Set(), Po = {}, Qu = {}, o_ = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    }, Qm = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Km = {}, Wm = {}, Ir = 0, $g, Jg, l_, Fg, of, s_, r_;
    Ga.__reactDisabledLog = !0;
    var ty, kh, lf = !1, Nh = new (typeof WeakMap == "function" ? WeakMap : Map)(), ro = null, Na = !1, X0 = /[\n"\\]/g, ey = !1, ny = !1, iy = !1, ay = !1, Im = !1, oy = !1, Uh = ["value", "defaultValue"], u_ = !1, c_ = /["'&<>\n\t]|^\s|\s$/, ly = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
      " "
    ), $m = "applet caption html table td th marquee object template foreignObject desc title".split(
      " "
    ), Jm = $m.concat(["button"]), sy = "dd dt li option optgroup p rp rt".split(" "), ry = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null,
      containerTagInScope: null,
      implicitRootScope: !1
    }, sf = {}, as = {
      animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
        " "
      ),
      background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
        " "
      ),
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
        " "
      ),
      borderBlockEnd: [
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth"
      ],
      borderBlockStart: [
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth"
      ],
      borderBottom: [
        "borderBottomColor",
        "borderBottomStyle",
        "borderBottomWidth"
      ],
      borderColor: [
        "borderBottomColor",
        "borderLeftColor",
        "borderRightColor",
        "borderTopColor"
      ],
      borderImage: [
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth"
      ],
      borderInlineEnd: [
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth"
      ],
      borderInlineStart: [
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth"
      ],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: [
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderTopLeftRadius",
        "borderTopRightRadius"
      ],
      borderRight: [
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth"
      ],
      borderStyle: [
        "borderBottomStyle",
        "borderLeftStyle",
        "borderRightStyle",
        "borderTopStyle"
      ],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: [
        "borderBottomWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderTopWidth"
      ],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
        " "
      ),
      fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
        " "
      ),
      gap: ["columnGap", "rowGap"],
      grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
        " "
      ),
      gridArea: [
        "gridColumnEnd",
        "gridColumnStart",
        "gridRowEnd",
        "gridRowStart"
      ],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: [
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows"
      ],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
        " "
      ),
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: [
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationStyle"
      ],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: [
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction"
      ],
      wordWrap: ["overflowWrap"]
    }, tr = /([A-Z])/g, er = /^ms-/, Bh = /^(?:webkit|moz|o)[A-Z]/, Yh = /^-ms-/, $r = /-(.)/g, f_ = /;\s*$/, Ku = {}, Wu = {}, h_ = !1, uy = !1, jh = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    ), qh = "http://www.w3.org/1998/Math/MathML", rf = "http://www.w3.org/2000/svg", Fm = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), Iu = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, cy = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, os = {}, fy = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), tp = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), hy = !1, ua = {}, Zh = /^on./, n = /^on[^A-Z]/, o = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), c = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), m = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, b = null, x = null, R = null, U = !1, Z = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), it = !1;
    if (Z)
      try {
        var vt = {};
        Object.defineProperty(vt, "passive", {
          get: function() {
            it = !0;
          }
        }), window.addEventListener("test", vt, vt), window.removeEventListener("test", vt, vt);
      } catch {
        it = !1;
      }
    var St = null, ot = null, st = null, te = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(t) {
        return t.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, ee = Ue(te), Ze = Me({}, te, { view: 0, detail: 0 }), tt = Ue(Ze), W, et, _t, Vt = Me({}, Ze, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: vu,
      button: 0,
      buttons: 0,
      relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
      },
      movementX: function(t) {
        return "movementX" in t ? t.movementX : (t !== _t && (_t && t.type === "mousemove" ? (W = t.screenX - _t.screenX, et = t.screenY - _t.screenY) : et = W = 0, _t = t), W);
      },
      movementY: function(t) {
        return "movementY" in t ? t.movementY : et;
      }
    }), De = Ue(Vt), $t = Me({}, Vt, { dataTransfer: 0 }), ae = Ue($t), Ti = Me({}, Ze, { relatedTarget: 0 }), je = Ue(Ti), Jr = Me({}, te, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Q0 = Ue(Jr), AM = Me({}, te, {
      clipboardData: function(t) {
        return "clipboardData" in t ? t.clipboardData : window.clipboardData;
      }
    }), RM = Ue(AM), CM = Me({}, te, { data: 0 }), j1 = Ue(
      CM
    ), zM = j1, LM = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, HM = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, kM = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    }, NM = Me({}, Ze, {
      key: function(t) {
        if (t.key) {
          var e = LM[t.key] || t.key;
          if (e !== "Unidentified") return e;
        }
        return t.type === "keypress" ? (t = va(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? HM[t.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: vu,
      charCode: function(t) {
        return t.type === "keypress" ? va(t) : 0;
      },
      keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      },
      which: function(t) {
        return t.type === "keypress" ? va(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      }
    }), UM = Ue(NM), BM = Me({}, Vt, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), q1 = Ue(BM), YM = Me({}, Ze, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: vu
    }), jM = Ue(YM), qM = Me({}, te, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), ZM = Ue(qM), PM = Me({}, Vt, {
      deltaX: function(t) {
        return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
      },
      deltaY: function(t) {
        return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), VM = Ue(PM), GM = Me({}, te, {
      newState: 0,
      oldState: 0
    }), XM = Ue(GM), QM = [9, 13, 27, 32], Z1 = 229, K0 = Z && "CompositionEvent" in window, dy = null;
    Z && "documentMode" in document && (dy = document.documentMode);
    var KM = Z && "TextEvent" in window && !dy, P1 = Z && (!K0 || dy && 8 < dy && 11 >= dy), V1 = 32, G1 = String.fromCharCode(V1), X1 = !1, ep = !1, WM = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    }, my = null, py = null, Q1 = !1;
    Z && (Q1 = yc("input") && (!document.documentMode || 9 < document.documentMode));
    var uo = typeof Object.is == "function" ? Object.is : Bp, IM = Z && "documentMode" in document && 11 >= document.documentMode, np = null, W0 = null, gy = null, I0 = !1, ip = {
      animationend: Mo("Animation", "AnimationEnd"),
      animationiteration: Mo("Animation", "AnimationIteration"),
      animationstart: Mo("Animation", "AnimationStart"),
      transitionrun: Mo("Transition", "TransitionRun"),
      transitionstart: Mo("Transition", "TransitionStart"),
      transitioncancel: Mo("Transition", "TransitionCancel"),
      transitionend: Mo("Transition", "TransitionEnd")
    }, $0 = {}, K1 = {};
    Z && (K1 = document.createElement("div").style, "AnimationEvent" in window || (delete ip.animationend.animation, delete ip.animationiteration.animation, delete ip.animationstart.animation), "TransitionEvent" in window || delete ip.transitionend.transition);
    var W1 = nl("animationend"), I1 = nl("animationiteration"), $1 = nl("animationstart"), $M = nl("transitionrun"), JM = nl("transitionstart"), FM = nl("transitioncancel"), J1 = nl("transitionend"), F1 = /* @__PURE__ */ new Map(), J0 = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    J0.push("scrollEnd");
    var F0 = /* @__PURE__ */ new WeakMap(), d_ = 1, $u = 2, ls = [], ap = 0, tb = 0, uf = {};
    Object.freeze(uf);
    var ss = null, op = null, bn = 0, tE = 1, ca = 2, Ua = 8, nr = 16, tS = 64, eS = !1;
    try {
      var nS = Object.preventExtensions({});
    } catch {
      eS = !0;
    }
    var lp = [], sp = 0, m_ = null, p_ = 0, rs = [], us = 0, Ph = null, Ju = 1, Fu = "", co = null, Qn = null, Pe = !1, tc = !1, cs = null, Vh = null, Fr = !1, eb = Error(
      "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), iS = 0;
    if (typeof performance == "object" && typeof performance.now == "function")
      var eE = performance, aS = function() {
        return eE.now();
      };
    else {
      var nE = Date;
      aS = function() {
        return nE.now();
      };
    }
    var nb = ne(null), ib = ne(null), oS = {}, g_ = null, rp = null, up = !1, iE = typeof AbortController < "u" ? AbortController : function() {
      var t = [], e = this.signal = {
        aborted: !1,
        addEventListener: function(a, f) {
          t.push(f);
        }
      };
      this.abort = function() {
        e.aborted = !0, t.forEach(function(a) {
          return a();
        });
      };
    }, aE = Hn.unstable_scheduleCallback, oE = Hn.unstable_NormalPriority, Bi = {
      $$typeof: qo,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, cp = Hn.unstable_now, lS = -0, y_ = -0, Vo = -1.1, Gh = -0, v_ = !1, __ = !1, yy = null, ab = 0, Xh = 0, fp = null, sS = ft.S;
    ft.S = function(t, e) {
      typeof e == "object" && e !== null && typeof e.then == "function" && Rd(t, e), sS !== null && sS(t, e);
    };
    var Qh = ne(null), ir = {
      recordUnsafeLifecycleWarnings: function() {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function() {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    }, vy = [], _y = [], by = [], Sy = [], Ty = [], xy = [], Kh = /* @__PURE__ */ new Set();
    ir.recordUnsafeLifecycleWarnings = function(t, e) {
      Kh.has(t.type) || (typeof e.componentWillMount == "function" && e.componentWillMount.__suppressDeprecationWarning !== !0 && vy.push(t), t.mode & Ua && typeof e.UNSAFE_componentWillMount == "function" && _y.push(t), typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && by.push(t), t.mode & Ua && typeof e.UNSAFE_componentWillReceiveProps == "function" && Sy.push(t), typeof e.componentWillUpdate == "function" && e.componentWillUpdate.__suppressDeprecationWarning !== !0 && Ty.push(t), t.mode & Ua && typeof e.UNSAFE_componentWillUpdate == "function" && xy.push(t));
    }, ir.flushPendingUnsafeLifecycleWarnings = function() {
      var t = /* @__PURE__ */ new Set();
      0 < vy.length && (vy.forEach(function(A) {
        t.add(
          wt(A) || "Component"
        ), Kh.add(A.type);
      }), vy = []);
      var e = /* @__PURE__ */ new Set();
      0 < _y.length && (_y.forEach(function(A) {
        e.add(
          wt(A) || "Component"
        ), Kh.add(A.type);
      }), _y = []);
      var a = /* @__PURE__ */ new Set();
      0 < by.length && (by.forEach(function(A) {
        a.add(
          wt(A) || "Component"
        ), Kh.add(A.type);
      }), by = []);
      var f = /* @__PURE__ */ new Set();
      0 < Sy.length && (Sy.forEach(
        function(A) {
          f.add(
            wt(A) || "Component"
          ), Kh.add(A.type);
        }
      ), Sy = []);
      var p = /* @__PURE__ */ new Set();
      0 < Ty.length && (Ty.forEach(function(A) {
        p.add(
          wt(A) || "Component"
        ), Kh.add(A.type);
      }), Ty = []);
      var y = /* @__PURE__ */ new Set();
      if (0 < xy.length && (xy.forEach(function(A) {
        y.add(
          wt(A) || "Component"
        ), Kh.add(A.type);
      }), xy = []), 0 < e.size) {
        var M = C(
          e
        );
        console.error(
          `Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,
          M
        );
      }
      0 < f.size && (M = C(
        f
      ), console.error(
        `Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`,
        M
      )), 0 < y.size && (M = C(
        y
      ), console.error(
        `Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,
        M
      )), 0 < t.size && (M = C(t), console.warn(
        `componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        M
      )), 0 < a.size && (M = C(
        a
      ), console.warn(
        `componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        M
      )), 0 < p.size && (M = C(p), console.warn(
        `componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        M
      ));
    };
    var b_ = /* @__PURE__ */ new Map(), rS = /* @__PURE__ */ new Set();
    ir.recordLegacyContextWarning = function(t, e) {
      for (var a = null, f = t; f !== null; )
        f.mode & Ua && (a = f), f = f.return;
      a === null ? console.error(
        "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
      ) : !rS.has(t.type) && (f = b_.get(a), t.type.contextTypes != null || t.type.childContextTypes != null || e !== null && typeof e.getChildContext == "function") && (f === void 0 && (f = [], b_.set(a, f)), f.push(t));
    }, ir.flushLegacyContextWarning = function() {
      b_.forEach(function(t) {
        if (t.length !== 0) {
          var e = t[0], a = /* @__PURE__ */ new Set();
          t.forEach(function(p) {
            a.add(wt(p) || "Component"), rS.add(p.type);
          });
          var f = C(a);
          Pt(e, function() {
            console.error(
              `Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`,
              f
            );
          });
        }
      });
    }, ir.discardPendingWarnings = function() {
      vy = [], _y = [], by = [], Sy = [], Ty = [], xy = [], b_ = /* @__PURE__ */ new Map();
    };
    var wy = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
    ), uS = Error(
      "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), S_ = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
    ), ob = {
      then: function() {
        console.error(
          'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
        );
      }
    }, My = null, T_ = !1, fs = 0, hs = 1, fo = 2, fa = 4, Yi = 8, cS = 0, fS = 1, hS = 2, lb = 3, cf = !1, dS = !1, sb = null, rb = !1, hp = ne(null), x_ = ne(0), dp, mS = /* @__PURE__ */ new Set(), pS = /* @__PURE__ */ new Set(), ub = /* @__PURE__ */ new Set(), gS = /* @__PURE__ */ new Set(), ff = 0, me = null, hn = null, xi = null, w_ = !1, mp = !1, Wh = !1, M_ = 0, Ey = 0, ec = null, lE = 0, sE = 25, ht = null, ds = null, nc = -1, Oy = !1, E_ = {
      readContext: tn,
      use: Ut,
      useCallback: cn,
      useContext: cn,
      useEffect: cn,
      useImperativeHandle: cn,
      useLayoutEffect: cn,
      useInsertionEffect: cn,
      useMemo: cn,
      useReducer: cn,
      useRef: cn,
      useState: cn,
      useDebugValue: cn,
      useDeferredValue: cn,
      useTransition: cn,
      useSyncExternalStore: cn,
      useId: cn,
      useHostTransitionStatus: cn,
      useFormState: cn,
      useActionState: cn,
      useOptimistic: cn,
      useMemoCache: cn,
      useCacheRefresh: cn
    }, cb = null, yS = null, fb = null, vS = null, tu = null, ar = null, O_ = null;
    cb = {
      readContext: function(t) {
        return tn(t);
      },
      use: Ut,
      useCallback: function(t, e) {
        return ht = "useCallback", ye(), oa(e), Wf(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", ye(), tn(t);
      },
      useEffect: function(t, e) {
        return ht = "useEffect", ye(), oa(e), Ld(t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", ye(), oa(a), kd(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        ht = "useInsertionEffect", ye(), oa(e), ko(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", ye(), oa(e), Hd(t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", ye(), oa(e);
        var a = ft.H;
        ft.H = tu;
        try {
          return Nd(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", ye();
        var f = ft.H;
        ft.H = tu;
        try {
          return oe(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function(t) {
        return ht = "useRef", ye(), Kf(t);
      },
      useState: function(t) {
        ht = "useState", ye();
        var e = ft.H;
        ft.H = tu;
        try {
          return Ea(t);
        } finally {
          ft.H = e;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", ye();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", ye(), Ud(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", ye(), jl();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", ye(), Gi(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", ye(), ql();
      },
      useFormState: function(t, e) {
        return ht = "useFormState", ye(), Mr(), Ec(t, e);
      },
      useActionState: function(t, e) {
        return ht = "useActionState", ye(), Ec(t, e);
      },
      useOptimistic: function(t) {
        return ht = "useOptimistic", ye(), eo(t);
      },
      useHostTransitionStatus: Oa,
      useMemoCache: qt,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", ye(), Eu();
      }
    }, yS = {
      readContext: function(t) {
        return tn(t);
      },
      use: Ut,
      useCallback: function(t, e) {
        return ht = "useCallback", Ot(), Wf(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", Ot(), tn(t);
      },
      useEffect: function(t, e) {
        return ht = "useEffect", Ot(), Ld(t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", Ot(), kd(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        ht = "useInsertionEffect", Ot(), ko(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", Ot(), Hd(t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", Ot();
        var a = ft.H;
        ft.H = tu;
        try {
          return Nd(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", Ot();
        var f = ft.H;
        ft.H = tu;
        try {
          return oe(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function(t) {
        return ht = "useRef", Ot(), Kf(t);
      },
      useState: function(t) {
        ht = "useState", Ot();
        var e = ft.H;
        ft.H = tu;
        try {
          return Ea(t);
        } finally {
          ft.H = e;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", Ot(), Ud(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", Ot(), jl();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", Ot(), Gi(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", Ot(), ql();
      },
      useActionState: function(t, e) {
        return ht = "useActionState", Ot(), Ec(t, e);
      },
      useFormState: function(t, e) {
        return ht = "useFormState", Ot(), Mr(), Ec(t, e);
      },
      useOptimistic: function(t) {
        return ht = "useOptimistic", Ot(), eo(t);
      },
      useHostTransitionStatus: Oa,
      useMemoCache: qt,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), Eu();
      }
    }, fb = {
      readContext: function(t) {
        return tn(t);
      },
      use: Ut,
      useCallback: function(t, e) {
        return ht = "useCallback", Ot(), wu(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", Ot(), tn(t);
      },
      useEffect: function(t, e) {
        ht = "useEffect", Ot(), ni(2048, Yi, t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", Ot(), Yl(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        return ht = "useInsertionEffect", Ot(), ni(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", Ot(), ni(4, fa, t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", Ot();
        var a = ft.H;
        ft.H = ar;
        try {
          return Cr(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", Ot();
        var f = ft.H;
        ft.H = ar;
        try {
          return Ge(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function() {
        return ht = "useRef", Ot(), $().memoizedState;
      },
      useState: function() {
        ht = "useState", Ot();
        var t = ft.H;
        ft.H = ar;
        try {
          return Ge(Zt);
        } finally {
          ft.H = t;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", Ot(), If(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", Ot(), jd();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", Ot(), xu(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", Ot(), $().memoizedState;
      },
      useFormState: function(t) {
        return ht = "useFormState", Ot(), Mr(), zd(t);
      },
      useActionState: function(t) {
        return ht = "useActionState", Ot(), zd(t);
      },
      useOptimistic: function(t, e) {
        return ht = "useOptimistic", Ot(), cl(t, e);
      },
      useHostTransitionStatus: Oa,
      useMemoCache: qt,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), $().memoizedState;
      }
    }, vS = {
      readContext: function(t) {
        return tn(t);
      },
      use: Ut,
      useCallback: function(t, e) {
        return ht = "useCallback", Ot(), wu(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", Ot(), tn(t);
      },
      useEffect: function(t, e) {
        ht = "useEffect", Ot(), ni(2048, Yi, t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", Ot(), Yl(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        return ht = "useInsertionEffect", Ot(), ni(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", Ot(), ni(4, fa, t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", Ot();
        var a = ft.H;
        ft.H = O_;
        try {
          return Cr(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", Ot();
        var f = ft.H;
        ft.H = O_;
        try {
          return Dn(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function() {
        return ht = "useRef", Ot(), $().memoizedState;
      },
      useState: function() {
        ht = "useState", Ot();
        var t = ft.H;
        ft.H = O_;
        try {
          return Dn(Zt);
        } finally {
          ft.H = t;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", Ot(), Bd(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", Ot(), qd();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", Ot(), xu(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", Ot(), $().memoizedState;
      },
      useFormState: function(t) {
        return ht = "useFormState", Ot(), Mr(), Oc(t);
      },
      useActionState: function(t) {
        return ht = "useActionState", Ot(), Oc(t);
      },
      useOptimistic: function(t, e) {
        return ht = "useOptimistic", Ot(), Or(t, e);
      },
      useHostTransitionStatus: Oa,
      useMemoCache: qt,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), $().memoizedState;
      }
    }, tu = {
      readContext: function(t) {
        return E(), tn(t);
      },
      use: function(t) {
        return T(), Ut(t);
      },
      useCallback: function(t, e) {
        return ht = "useCallback", T(), ye(), Wf(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", T(), ye(), tn(t);
      },
      useEffect: function(t, e) {
        return ht = "useEffect", T(), ye(), Ld(t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", T(), ye(), kd(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        ht = "useInsertionEffect", T(), ye(), ko(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", T(), ye(), Hd(t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", T(), ye();
        var a = ft.H;
        ft.H = tu;
        try {
          return Nd(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", T(), ye();
        var f = ft.H;
        ft.H = tu;
        try {
          return oe(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function(t) {
        return ht = "useRef", T(), ye(), Kf(t);
      },
      useState: function(t) {
        ht = "useState", T(), ye();
        var e = ft.H;
        ft.H = tu;
        try {
          return Ea(t);
        } finally {
          ft.H = e;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", T(), ye();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", T(), ye(), Ud(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", T(), ye(), jl();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", T(), ye(), Gi(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", T(), ye(), ql();
      },
      useFormState: function(t, e) {
        return ht = "useFormState", T(), ye(), Ec(t, e);
      },
      useActionState: function(t, e) {
        return ht = "useActionState", T(), ye(), Ec(t, e);
      },
      useOptimistic: function(t) {
        return ht = "useOptimistic", T(), ye(), eo(t);
      },
      useMemoCache: function(t) {
        return T(), qt(t);
      },
      useHostTransitionStatus: Oa,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", ye(), Eu();
      }
    }, ar = {
      readContext: function(t) {
        return E(), tn(t);
      },
      use: function(t) {
        return T(), Ut(t);
      },
      useCallback: function(t, e) {
        return ht = "useCallback", T(), Ot(), wu(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", T(), Ot(), tn(t);
      },
      useEffect: function(t, e) {
        ht = "useEffect", T(), Ot(), ni(2048, Yi, t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", T(), Ot(), Yl(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        return ht = "useInsertionEffect", T(), Ot(), ni(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", T(), Ot(), ni(4, fa, t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", T(), Ot();
        var a = ft.H;
        ft.H = ar;
        try {
          return Cr(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", T(), Ot();
        var f = ft.H;
        ft.H = ar;
        try {
          return Ge(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function() {
        return ht = "useRef", T(), Ot(), $().memoizedState;
      },
      useState: function() {
        ht = "useState", T(), Ot();
        var t = ft.H;
        ft.H = ar;
        try {
          return Ge(Zt);
        } finally {
          ft.H = t;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", T(), Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", T(), Ot(), If(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", T(), Ot(), jd();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", T(), Ot(), xu(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", T(), Ot(), $().memoizedState;
      },
      useFormState: function(t) {
        return ht = "useFormState", T(), Ot(), zd(t);
      },
      useActionState: function(t) {
        return ht = "useActionState", T(), Ot(), zd(t);
      },
      useOptimistic: function(t, e) {
        return ht = "useOptimistic", T(), Ot(), cl(t, e);
      },
      useMemoCache: function(t) {
        return T(), qt(t);
      },
      useHostTransitionStatus: Oa,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), $().memoizedState;
      }
    }, O_ = {
      readContext: function(t) {
        return E(), tn(t);
      },
      use: function(t) {
        return T(), Ut(t);
      },
      useCallback: function(t, e) {
        return ht = "useCallback", T(), Ot(), wu(t, e);
      },
      useContext: function(t) {
        return ht = "useContext", T(), Ot(), tn(t);
      },
      useEffect: function(t, e) {
        ht = "useEffect", T(), Ot(), ni(2048, Yi, t, e);
      },
      useImperativeHandle: function(t, e, a) {
        return ht = "useImperativeHandle", T(), Ot(), Yl(t, e, a);
      },
      useInsertionEffect: function(t, e) {
        return ht = "useInsertionEffect", T(), Ot(), ni(4, fo, t, e);
      },
      useLayoutEffect: function(t, e) {
        return ht = "useLayoutEffect", T(), Ot(), ni(4, fa, t, e);
      },
      useMemo: function(t, e) {
        ht = "useMemo", T(), Ot();
        var a = ft.H;
        ft.H = ar;
        try {
          return Cr(t, e);
        } finally {
          ft.H = a;
        }
      },
      useReducer: function(t, e, a) {
        ht = "useReducer", T(), Ot();
        var f = ft.H;
        ft.H = ar;
        try {
          return Dn(t, e, a);
        } finally {
          ft.H = f;
        }
      },
      useRef: function() {
        return ht = "useRef", T(), Ot(), $().memoizedState;
      },
      useState: function() {
        ht = "useState", T(), Ot();
        var t = ft.H;
        ft.H = ar;
        try {
          return Dn(Zt);
        } finally {
          ft.H = t;
        }
      },
      useDebugValue: function() {
        ht = "useDebugValue", T(), Ot();
      },
      useDeferredValue: function(t, e) {
        return ht = "useDeferredValue", T(), Ot(), Bd(t, e);
      },
      useTransition: function() {
        return ht = "useTransition", T(), Ot(), qd();
      },
      useSyncExternalStore: function(t, e, a) {
        return ht = "useSyncExternalStore", T(), Ot(), xu(
          t,
          e,
          a
        );
      },
      useId: function() {
        return ht = "useId", T(), Ot(), $().memoizedState;
      },
      useFormState: function(t) {
        return ht = "useFormState", T(), Ot(), Oc(t);
      },
      useActionState: function(t) {
        return ht = "useActionState", T(), Ot(), Oc(t);
      },
      useOptimistic: function(t, e) {
        return ht = "useOptimistic", T(), Ot(), Or(t, e);
      },
      useMemoCache: function(t) {
        return T(), qt(t);
      },
      useHostTransitionStatus: Oa,
      useCacheRefresh: function() {
        return ht = "useCacheRefresh", Ot(), $().memoizedState;
      }
    };
    var _S = {
      react_stack_bottom_frame: function(t, e, a) {
        var f = Na;
        Na = !0;
        try {
          return t(e, a);
        } finally {
          Na = f;
        }
      }
    }, hb = _S.react_stack_bottom_frame.bind(_S), bS = {
      react_stack_bottom_frame: function(t) {
        var e = Na;
        Na = !0;
        try {
          return t.render();
        } finally {
          Na = e;
        }
      }
    }, SS = bS.react_stack_bottom_frame.bind(bS), TS = {
      react_stack_bottom_frame: function(t, e) {
        try {
          e.componentDidMount();
        } catch (a) {
          ie(t, t.return, a);
        }
      }
    }, db = TS.react_stack_bottom_frame.bind(
      TS
    ), xS = {
      react_stack_bottom_frame: function(t, e, a, f, p) {
        try {
          e.componentDidUpdate(a, f, p);
        } catch (y) {
          ie(t, t.return, y);
        }
      }
    }, wS = xS.react_stack_bottom_frame.bind(
      xS
    ), MS = {
      react_stack_bottom_frame: function(t, e) {
        var a = e.stack;
        t.componentDidCatch(e.value, {
          componentStack: a !== null ? a : ""
        });
      }
    }, rE = MS.react_stack_bottom_frame.bind(
      MS
    ), ES = {
      react_stack_bottom_frame: function(t, e, a) {
        try {
          a.componentWillUnmount();
        } catch (f) {
          ie(t, e, f);
        }
      }
    }, OS = ES.react_stack_bottom_frame.bind(
      ES
    ), DS = {
      react_stack_bottom_frame: function(t) {
        t.resourceKind != null && console.error(
          "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
          t.resourceKind
        );
        var e = t.create;
        return t = t.inst, e = e(), t.destroy = e;
      }
    }, uE = DS.react_stack_bottom_frame.bind(DS), AS = {
      react_stack_bottom_frame: function(t, e, a) {
        try {
          a();
        } catch (f) {
          ie(t, e, f);
        }
      }
    }, cE = AS.react_stack_bottom_frame.bind(AS), RS = {
      react_stack_bottom_frame: function(t) {
        var e = t._init;
        return e(t._payload);
      }
    }, hf = RS.react_stack_bottom_frame.bind(RS), pp = null, Dy = 0, Ae = null, mb, CS = mb = !1, zS = {}, LS = {}, HS = {};
    S = function(t, e, a) {
      if (a !== null && typeof a == "object" && a._store && (!a._store.validated && a.key == null || a._store.validated === 2)) {
        if (typeof a._store != "object")
          throw Error(
            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
          );
        a._store.validated = 1;
        var f = wt(t), p = f || "null";
        if (!zS[p]) {
          zS[p] = !0, a = a._owner, t = t._debugOwner;
          var y = "";
          t && typeof t.tag == "number" && (p = wt(t)) && (y = `

Check the render method of \`` + p + "`."), y || f && (y = `

Check the top-level render call using <` + f + ">.");
          var M = "";
          a != null && t !== a && (f = null, typeof a.tag == "number" ? f = wt(a) : typeof a.name == "string" && (f = a.name), f && (M = " It was passed a child from " + f + ".")), Pt(e, function() {
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              y,
              M
            );
          });
        }
      }
    };
    var gp = th(!0), kS = th(!1), ms = ne(null), eu = null, yp = 1, Ay = 2, ji = ne(0), NS = {}, US = /* @__PURE__ */ new Set(), BS = /* @__PURE__ */ new Set(), YS = /* @__PURE__ */ new Set(), jS = /* @__PURE__ */ new Set(), qS = /* @__PURE__ */ new Set(), ZS = /* @__PURE__ */ new Set(), PS = /* @__PURE__ */ new Set(), VS = /* @__PURE__ */ new Set(), GS = /* @__PURE__ */ new Set(), XS = /* @__PURE__ */ new Set();
    Object.freeze(NS);
    var pb = {
      enqueueSetState: function(t, e, a) {
        t = t._reactInternals;
        var f = Ra(t), p = Gn(f);
        p.payload = e, a != null && (Gp(a), p.callback = a), e = wa(t, p, f), e !== null && (Rn(e, t, f), ll(e, t, f)), ma(t, f);
      },
      enqueueReplaceState: function(t, e, a) {
        t = t._reactInternals;
        var f = Ra(t), p = Gn(f);
        p.tag = fS, p.payload = e, a != null && (Gp(a), p.callback = a), e = wa(t, p, f), e !== null && (Rn(e, t, f), ll(e, t, f)), ma(t, f);
      },
      enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var a = Ra(t), f = Gn(a);
        f.tag = hS, e != null && (Gp(e), f.callback = e), e = wa(t, f, a), e !== null && (Rn(e, t, a), ll(e, t, a)), jt !== null && typeof jt.markForceUpdateScheduled == "function" && jt.markForceUpdateScheduled(t, a);
      }
    }, gb = typeof reportError == "function" ? reportError : function(t) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var e = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof t == "object" && t !== null && typeof t.message == "string" ? String(t.message) : String(t),
          error: t
        });
        if (!window.dispatchEvent(e)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", t);
        return;
      }
      console.error(t);
    }, vp = null, yb = null, QS = Error(
      "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
    ), $i = !1, KS = {}, WS = {}, IS = {}, $S = {}, _p = !1, JS = {}, vb = {}, _b = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    }, FS = !1, tT = null;
    tT = /* @__PURE__ */ new Set();
    var ic = !1, oi = !1, bb = !1, eT = typeof WeakSet == "function" ? WeakSet : Set, Ji = null, bp = null, Sp = null, wi = null, Go = !1, or = null, Ry = 8192, fE = {
      getCacheForType: function(t) {
        var e = tn(Bi), a = e.data.get(t);
        return a === void 0 && (a = t(), e.data.set(t, a)), a;
      },
      getOwner: function() {
        return ro;
      }
    };
    if (typeof Symbol == "function" && Symbol.for) {
      var Cy = Symbol.for;
      Cy("selector.component"), Cy("selector.has_pseudo_class"), Cy("selector.role"), Cy("selector.test_id"), Cy("selector.text");
    }
    var hE = [], dE = typeof WeakMap == "function" ? WeakMap : Map, yl = 0, ho = 2, lr = 4, ac = 0, zy = 1, Tp = 2, Sb = 3, Ih = 4, D_ = 6, nT = 5, $e = yl, mn = null, ke = null, Ne = 0, Xo = 0, Ly = 1, $h = 2, Hy = 3, iT = 4, Tb = 5, xp = 6, ky = 7, xb = 8, Jh = 9, an = Xo, vl = null, df = !1, wp = !1, wb = !1, nu = 0, Kn = ac, mf = 0, pf = 0, Mb = 0, _l = 0, Fh = 0, Ny = null, mo = null, A_ = !1, Eb = 0, aT = 300, R_ = 1 / 0, oT = 500, Uy = null, gf = null, mE = 0, pE = 1, gE = 2, td = 0, lT = 1, sT = 2, rT = 3, yE = 4, Ob = 5, ha = 0, yf = null, Mp = null, vf = 0, Db = 0, Ab = null, uT = null, vE = 50, By = 0, Rb = null, Cb = !1, C_ = !1, _E = 50, ed = 0, Yy = null, Ep = !1, z_ = null, cT = !1, fT = /* @__PURE__ */ new Set(), bE = {}, L_ = null, Op = null, zb = !1, Lb = !1, H_ = !1, Hb = !1, nd = 0, kb = {};
    (function() {
      for (var t = 0; t < J0.length; t++) {
        var e = J0[t], a = e.toLowerCase();
        e = e[0].toUpperCase() + e.slice(1), Wa(a, "on" + e);
      }
      Wa(W1, "onAnimationEnd"), Wa(I1, "onAnimationIteration"), Wa($1, "onAnimationStart"), Wa("dblclick", "onDoubleClick"), Wa("focusin", "onFocus"), Wa("focusout", "onBlur"), Wa($M, "onTransitionRun"), Wa(JM, "onTransitionStart"), Wa(FM, "onTransitionCancel"), Wa(J1, "onTransitionEnd");
    })(), kt("onMouseEnter", ["mouseout", "mouseover"]), kt("onMouseLeave", ["mouseout", "mouseover"]), kt("onPointerEnter", ["pointerout", "pointerover"]), kt("onPointerLeave", ["pointerout", "pointerover"]), At(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ), At(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ), At("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), At(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ), At(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ), At(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var jy = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), Nb = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(jy)
    ), k_ = "_reactListening" + Math.random().toString(36).slice(2), hT = !1, dT = !1, N_ = !1, mT = !1, U_ = !1, B_ = !1, pT = !1, Y_ = {}, SE = /\r\n?/g, TE = /\u0000|\uFFFD/g, id = "http://www.w3.org/1999/xlink", Ub = "http://www.w3.org/XML/1998/namespace", xE = "javascript:throw new Error('React form unexpectedly submitted.')", wE = "suppressHydrationWarning", j_ = "$", q_ = "/$", oc = "$?", qy = "$!", ME = 1, EE = 2, OE = 4, Bb = "F!", gT = "F", yT = "complete", DE = "style", lc = 0, Dp = 1, Z_ = 2, Yb = null, jb = null, vT = { dialog: !0, webview: !0 }, qb = null, _T = typeof setTimeout == "function" ? setTimeout : void 0, AE = typeof clearTimeout == "function" ? clearTimeout : void 0, ad = -1, bT = typeof Promise == "function" ? Promise : void 0, RE = typeof queueMicrotask == "function" ? queueMicrotask : typeof bT < "u" ? function(t) {
      return bT.resolve(null).then(t).catch(Cg);
    } : _T, Zb = null, od = 0, Zy = 1, ST = 2, TT = 3, ps = 4, gs = /* @__PURE__ */ new Map(), xT = /* @__PURE__ */ new Set(), sc = re.d;
    re.d = {
      f: function() {
        var t = sc.f(), e = Nu();
        return t || e;
      },
      r: function(t) {
        var e = Pn(t);
        e !== null && e.tag === 5 && e.type === "form" ? Zp(e) : sc.r(t);
      },
      D: function(t) {
        sc.D(t), Gv("dns-prefetch", t, null);
      },
      C: function(t, e) {
        sc.C(t, e), Gv("preconnect", t, e);
      },
      L: function(t, e, a) {
        sc.L(t, e, a);
        var f = Ap;
        if (f && t && e) {
          var p = 'link[rel="preload"][as="' + na(e) + '"]';
          e === "image" && a && a.imageSrcSet ? (p += '[imagesrcset="' + na(
            a.imageSrcSet
          ) + '"]', typeof a.imageSizes == "string" && (p += '[imagesizes="' + na(
            a.imageSizes
          ) + '"]')) : p += '[href="' + na(t) + '"]';
          var y = p;
          switch (e) {
            case "style":
              y = qr(t);
              break;
            case "script":
              y = Pu(t);
          }
          gs.has(y) || (t = Me(
            {
              rel: "preload",
              href: e === "image" && a && a.imageSrcSet ? void 0 : t,
              as: e
            },
            a
          ), gs.set(y, t), f.querySelector(p) !== null || e === "style" && f.querySelector(
            es(y)
          ) || e === "script" && f.querySelector(Vu(y)) || (e = f.createElement("link"), zn(e, "link", t), J(e), f.head.appendChild(e)));
        }
      },
      m: function(t, e) {
        sc.m(t, e);
        var a = Ap;
        if (a && t) {
          var f = e && typeof e.as == "string" ? e.as : "script", p = 'link[rel="modulepreload"][as="' + na(f) + '"][href="' + na(t) + '"]', y = p;
          switch (f) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              y = Pu(t);
          }
          if (!gs.has(y) && (t = Me({ rel: "modulepreload", href: t }, e), gs.set(y, t), a.querySelector(p) === null)) {
            switch (f) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (a.querySelector(Vu(y)))
                  return;
            }
            f = a.createElement("link"), zn(f, "link", t), J(f), a.head.appendChild(f);
          }
        }
      },
      X: function(t, e) {
        sc.X(t, e);
        var a = Ap;
        if (a && t) {
          var f = N(a).hoistableScripts, p = Pu(t), y = f.get(p);
          y || (y = a.querySelector(
            Vu(p)
          ), y || (t = Me({ src: t, async: !0 }, e), (e = gs.get(p)) && Yg(t, e), y = a.createElement("script"), J(y), zn(y, "link", t), a.head.appendChild(y)), y = {
            type: "script",
            instance: y,
            count: 1,
            state: null
          }, f.set(p, y));
        }
      },
      S: function(t, e, a) {
        sc.S(t, e, a);
        var f = Ap;
        if (f && t) {
          var p = N(f).hoistableStyles, y = qr(t);
          e = e || "default";
          var M = p.get(y);
          if (!M) {
            var A = { loading: od, preload: null };
            if (M = f.querySelector(
              es(y)
            ))
              A.loading = Zy | ps;
            else {
              t = Me(
                {
                  rel: "stylesheet",
                  href: t,
                  "data-precedence": e
                },
                a
              ), (a = gs.get(y)) && Bg(t, a);
              var B = M = f.createElement("link");
              J(B), zn(B, "link", t), B._p = new Promise(function(Y, lt) {
                B.onload = Y, B.onerror = lt;
              }), B.addEventListener("load", function() {
                A.loading |= Zy;
              }), B.addEventListener("error", function() {
                A.loading |= ST;
              }), A.loading |= ps, zm(M, e, f);
            }
            M = {
              type: "stylesheet",
              instance: M,
              count: 1,
              state: A
            }, p.set(y, M);
          }
        }
      },
      M: function(t, e) {
        sc.M(t, e);
        var a = Ap;
        if (a && t) {
          var f = N(a).hoistableScripts, p = Pu(t), y = f.get(p);
          y || (y = a.querySelector(
            Vu(p)
          ), y || (t = Me({ src: t, async: !0, type: "module" }, e), (e = gs.get(p)) && Yg(t, e), y = a.createElement("script"), J(y), zn(y, "link", t), a.head.appendChild(y)), y = {
            type: "script",
            instance: y,
            count: 1,
            state: null
          }, f.set(p, y));
        }
      }
    };
    var Ap = typeof document > "u" ? null : document, P_ = null, Py = null, Pb = null, V_ = null, ld = q0, Vy = {
      $$typeof: qo,
      Provider: null,
      Consumer: null,
      _currentValue: ld,
      _currentValue2: ld,
      _threadCount: 0
    }, wT = "%c%s%c ", MT = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", ET = "", G_ = " ", CE = Function.prototype.bind, OT = !1, DT = null, AT = null, RT = null, CT = null, zT = null, LT = null, HT = null, kT = null, NT = null;
    DT = function(t, e, a, f) {
      e = s(t, e), e !== null && (a = i(e.memoizedState, a, 0, f), e.memoizedState = a, e.baseState = a, t.memoizedProps = Me({}, t.memoizedProps), a = pi(t, 2), a !== null && Rn(a, t, 2));
    }, AT = function(t, e, a) {
      e = s(t, e), e !== null && (a = h(e.memoizedState, a, 0), e.memoizedState = a, e.baseState = a, t.memoizedProps = Me({}, t.memoizedProps), a = pi(t, 2), a !== null && Rn(a, t, 2));
    }, RT = function(t, e, a, f) {
      e = s(t, e), e !== null && (a = l(e.memoizedState, a, f), e.memoizedState = a, e.baseState = a, t.memoizedProps = Me({}, t.memoizedProps), a = pi(t, 2), a !== null && Rn(a, t, 2));
    }, CT = function(t, e, a) {
      t.pendingProps = i(t.memoizedProps, e, 0, a), t.alternate && (t.alternate.pendingProps = t.pendingProps), e = pi(t, 2), e !== null && Rn(e, t, 2);
    }, zT = function(t, e) {
      t.pendingProps = h(t.memoizedProps, e, 0), t.alternate && (t.alternate.pendingProps = t.pendingProps), e = pi(t, 2), e !== null && Rn(e, t, 2);
    }, LT = function(t, e, a) {
      t.pendingProps = l(
        t.memoizedProps,
        e,
        a
      ), t.alternate && (t.alternate.pendingProps = t.pendingProps), e = pi(t, 2), e !== null && Rn(e, t, 2);
    }, HT = function(t) {
      var e = pi(t, 2);
      e !== null && Rn(e, t, 2);
    }, kT = function(t) {
      _ = t;
    }, NT = function(t) {
      g = t;
    };
    var X_ = !0, Q_ = null, Vb = !1, _f = null, bf = null, Sf = null, Gy = /* @__PURE__ */ new Map(), Xy = /* @__PURE__ */ new Map(), Tf = [], zE = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    ), K_ = null;
    if (Oh.prototype.render = Bm.prototype.render = function(t) {
      var e = this._internalRoot;
      if (e === null) throw Error("Cannot update an unmounted root.");
      var a = arguments;
      typeof a[1] == "function" ? console.error(
        "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ) : X(a[1]) ? console.error(
        "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
      ) : typeof a[1] < "u" && console.error(
        "You passed a second argument to root.render(...) but it only accepts one argument."
      ), a = t;
      var f = e.current, p = Ra(f);
      Ie(f, p, a, e, null, null);
    }, Oh.prototype.unmount = Bm.prototype.unmount = function() {
      var t = arguments;
      if (typeof t[0] == "function" && console.error(
        "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ), t = this._internalRoot, t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        ($e & (ho | lr)) !== yl && console.error(
          "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
        ), Ie(t.current, 2, null, t, null, null), Nu(), e[Wr] = null;
      }
    }, Oh.prototype.unstable_scheduleHydration = function(t) {
      if (t) {
        var e = fr();
        t = { blockedOn: null, target: t, priority: e };
        for (var a = 0; a < Tf.length && e !== 0 && e < Tf[a].priority; a++) ;
        Tf.splice(a, 0, t), a === 0 && $v(t);
      }
    }, function() {
      var t = Dh.version;
      if (t !== "19.1.1")
        throw Error(
          `Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (t + `
  - react-dom:  19.1.1
Learn more: https://react.dev/warnings/version-mismatch`)
        );
    }(), typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
    ), re.findDOMNode = function(t) {
      var e = t._reactInternals;
      if (e === void 0)
        throw typeof t.render == "function" ? Error("Unable to find node on an unmounted component.") : (t = Object.keys(t).join(","), Error(
          "Argument appears to not be a ReactComponent. Keys: " + t
        ));
      return t = zt(e), t = t !== null ? dt(t) : null, t = t === null ? null : t.stateNode, t;
    }, !function() {
      var t = {
        bundleType: 1,
        version: "19.1.1",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ft,
        reconcilerVersion: "19.1.1"
      };
      return t.overrideHookState = DT, t.overrideHookStateDeletePath = AT, t.overrideHookStateRenamePath = RT, t.overrideProps = CT, t.overridePropsDeletePath = zT, t.overridePropsRenamePath = LT, t.scheduleUpdate = HT, t.setErrorHandler = kT, t.setSuspenseHandler = NT, t.scheduleRefresh = I, t.scheduleRoot = j, t.setRefreshHandler = Q, t.getCurrentFiber = U0, t.getLaneLabelMap = B0, t.injectProfilingHooks = We, Ht(t);
    }() && Z && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && navigator.userAgent.indexOf("Edge") === -1 || -1 < navigator.userAgent.indexOf("Firefox"))) {
      var UT = window.location.protocol;
      /^(https?|file):$/.test(UT) && console.info(
        "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (UT === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq` : ""),
        "font-weight:bold"
      );
    }
    Iy.createRoot = function(t, e) {
      if (!X(t))
        throw Error("Target container is not a DOM element.");
      t_(t);
      var a = !1, f = "", p = Xp, y = Av, M = Gd, A = null;
      return e != null && (e.hydrate ? console.warn(
        "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
      ) : typeof e == "object" && e !== null && e.$$typeof === Vr && console.error(
        `You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`
      ), e.unstable_strictMode === !0 && (a = !0), e.identifierPrefix !== void 0 && (f = e.identifierPrefix), e.onUncaughtError !== void 0 && (p = e.onUncaughtError), e.onCaughtError !== void 0 && (y = e.onCaughtError), e.onRecoverableError !== void 0 && (M = e.onRecoverableError), e.unstable_transitionCallbacks !== void 0 && (A = e.unstable_transitionCallbacks)), e = Zg(
        t,
        1,
        !1,
        null,
        null,
        a,
        f,
        p,
        y,
        M,
        A,
        null
      ), t[Wr] = e.current, wg(t), new Bm(e);
    }, Iy.hydrateRoot = function(t, e, a) {
      if (!X(t))
        throw Error("Target container is not a DOM element.");
      t_(t), e === void 0 && console.error(
        "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
      );
      var f = !1, p = "", y = Xp, M = Av, A = Gd, B = null, Y = null;
      return a != null && (a.unstable_strictMode === !0 && (f = !0), a.identifierPrefix !== void 0 && (p = a.identifierPrefix), a.onUncaughtError !== void 0 && (y = a.onUncaughtError), a.onCaughtError !== void 0 && (M = a.onCaughtError), a.onRecoverableError !== void 0 && (A = a.onRecoverableError), a.unstable_transitionCallbacks !== void 0 && (B = a.unstable_transitionCallbacks), a.formState !== void 0 && (Y = a.formState)), e = Zg(
        t,
        1,
        !0,
        e,
        a ?? null,
        f,
        p,
        y,
        M,
        A,
        B,
        Y
      ), e.context = Pg(null), a = e.current, f = Ra(a), f = Zn(f), p = Gn(f), p.callback = null, wa(a, p, f), a = f, e.current.lanes = a, po(e, a), Bo(e), t[Wr] = e.current, wg(t), new Oh(e);
    }, Iy.version = "19.1.1", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Iy;
}
var JT;
function XE() {
  if (JT) return $_.exports;
  JT = 1;
  function s() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s);
      } catch (i) {
        console.error(i);
      }
    }
  }
  return process.env.NODE_ENV === "production" ? (s(), $_.exports = VE()) : $_.exports = GE(), $_.exports;
}
var QE = XE();
function KE({ value: s, onChange: i }) {
  const [l, u] = si.useState([]);
  return si.useEffect(() => {
    fetch("/api/products").then((h) => {
      if (!h.ok) throw new Error(`HTTP ${h.status}`);
      return h.json();
    }).then(u).catch((h) => console.error("products error", h));
  }, []), /* @__PURE__ */ Qt.jsxs("select", { value: s, onChange: (h) => i(h.target.value), className: "form-select", children: [
    /* @__PURE__ */ Qt.jsx("option", { value: "", children: "Wybierz produkt..." }),
    l.map((h) => /* @__PURE__ */ Qt.jsx("option", { value: h.name, children: h.label }, h.name))
  ] });
}
function WE({ value: s, onChange: i }) {
  const [l, u] = si.useState([]);
  return si.useEffect(() => {
    fetch("/api/cities").then((h) => {
      if (!h.ok) throw new Error(`HTTP ${h.status}`);
      return h.json();
    }).then(u).catch((h) => console.error("cities error", h));
  }, []), /* @__PURE__ */ Qt.jsxs("select", { value: s, onChange: (h) => i(h.target.value), className: "form-select", children: [
    /* @__PURE__ */ Qt.jsx("option", { value: "", children: "Wszystkie miasta..." }),
    l.map((h) => /* @__PURE__ */ Qt.jsx("option", { value: h, children: h }, h))
  ] });
}
function IE({ sort: s, order: i, onSortChange: l, onOrderChange: u }) {
  return /* @__PURE__ */ Qt.jsxs("div", { className: "d-flex gap-2 my-2", children: [
    /* @__PURE__ */ Qt.jsxs("select", { value: s, onChange: (h) => l(h.target.value), className: "form-select form-select-sm", children: [
      /* @__PURE__ */ Qt.jsx("option", { value: "price", children: "Cena" }),
      /* @__PURE__ */ Qt.jsx("option", { value: "expiration", children: "Ważność" }),
      /* @__PURE__ */ Qt.jsx("option", { value: "fetched_at", children: "Data pobrania" })
    ] }),
    /* @__PURE__ */ Qt.jsxs("select", { value: i, onChange: (h) => u(h.target.value), className: "form-select form-select-sm", children: [
      /* @__PURE__ */ Qt.jsx("option", { value: "asc", children: "Rosnąco" }),
      /* @__PURE__ */ Qt.jsx("option", { value: "desc", children: "Malejąco" })
    ] })
  ] });
}
function $E({ offers: s }) {
  return /* @__PURE__ */ Qt.jsx("div", { className: "table-responsive", children: /* @__PURE__ */ Qt.jsxs("table", { className: "table table-bordered", children: [
    /* @__PURE__ */ Qt.jsx("thead", { children: /* @__PURE__ */ Qt.jsxs("tr", { children: [
      /* @__PURE__ */ Qt.jsx("th", { children: "Cena (za 1 g)" }),
      /* @__PURE__ */ Qt.jsx("th", { children: "Apteka" }),
      /* @__PURE__ */ Qt.jsx("th", { children: "Adres" }),
      /* @__PURE__ */ Qt.jsx("th", { children: "Mapa" })
    ] }) }),
    /* @__PURE__ */ Qt.jsx("tbody", { children: s.map((i, l) => /* @__PURE__ */ Qt.jsxs("tr", { children: [
      /* @__PURE__ */ Qt.jsxs("td", { children: [
        (i.price_per_g ?? i.price).toFixed(2),
        " zł"
      ] }),
      /* @__PURE__ */ Qt.jsx("td", { children: i.pharmacy ?? "–" }),
      /* @__PURE__ */ Qt.jsx("td", { children: i.address ?? "–" }),
      /* @__PURE__ */ Qt.jsx("td", { children: i.map_url ? /* @__PURE__ */ Qt.jsx("a", { href: i.map_url, target: "_blank", className: "btn btn-sm btn-outline-light", children: "Mapa" }) : "–" })
    ] }, l)) })
  ] }) });
}
function JE({ total: s, limit: i, offset: l, onChange: u }) {
  const h = Math.ceil(s / i), g = Math.floor(l / i) + 1;
  return h <= 1 ? null : /* @__PURE__ */ Qt.jsx("div", { className: "my-3", id: "pagination", children: Array.from({ length: h }, (_, S) => S + 1).map((_) => /* @__PURE__ */ Qt.jsx(
    "button",
    {
      className: "btn btn-outline-light btn-sm mx-1",
      disabled: _ === g,
      onClick: () => u((_ - 1) * i),
      children: _
    },
    _
  )) });
}
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function Sv(s) {
  return s + 0.5 | 0;
}
const wf = (s, i, l) => Math.max(Math.min(s, l), i);
function lv(s) {
  return wf(Sv(s * 2.55), 0, 255);
}
function Mf(s) {
  return wf(Sv(s * 255), 0, 255);
}
function hc(s) {
  return wf(Sv(s / 2.55) / 100, 0, 1);
}
function FT(s) {
  return wf(Sv(s * 100), 0, 100);
}
const ys = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, s1 = [..."0123456789ABCDEF"], FE = (s) => s1[s & 15], t2 = (s) => s1[(s & 240) >> 4] + s1[s & 15], t0 = (s) => (s & 240) >> 4 === (s & 15), e2 = (s) => t0(s.r) && t0(s.g) && t0(s.b) && t0(s.a);
function n2(s) {
  var i = s.length, l;
  return s[0] === "#" && (i === 4 || i === 5 ? l = {
    r: 255 & ys[s[1]] * 17,
    g: 255 & ys[s[2]] * 17,
    b: 255 & ys[s[3]] * 17,
    a: i === 5 ? ys[s[4]] * 17 : 255
  } : (i === 7 || i === 9) && (l = {
    r: ys[s[1]] << 4 | ys[s[2]],
    g: ys[s[3]] << 4 | ys[s[4]],
    b: ys[s[5]] << 4 | ys[s[6]],
    a: i === 9 ? ys[s[7]] << 4 | ys[s[8]] : 255
  })), l;
}
const i2 = (s, i) => s < 255 ? i(s) : "";
function a2(s) {
  var i = e2(s) ? FE : t2;
  return s ? "#" + i(s.r) + i(s.g) + i(s.b) + i2(s.a, i) : void 0;
}
const o2 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function xw(s, i, l) {
  const u = i * Math.min(l, 1 - l), h = (g, _ = (g + s / 30) % 12) => l - u * Math.max(Math.min(_ - 3, 9 - _, 1), -1);
  return [h(0), h(8), h(4)];
}
function l2(s, i, l) {
  const u = (h, g = (h + s / 60) % 6) => l - l * i * Math.max(Math.min(g, 4 - g, 1), 0);
  return [u(5), u(3), u(1)];
}
function s2(s, i, l) {
  const u = xw(s, 1, 0.5);
  let h;
  for (i + l > 1 && (h = 1 / (i + l), i *= h, l *= h), h = 0; h < 3; h++)
    u[h] *= 1 - i - l, u[h] += i;
  return u;
}
function r2(s, i, l, u, h) {
  return s === h ? (i - l) / u + (i < l ? 6 : 0) : i === h ? (l - s) / u + 2 : (s - i) / u + 4;
}
function _1(s) {
  const l = s.r / 255, u = s.g / 255, h = s.b / 255, g = Math.max(l, u, h), _ = Math.min(l, u, h), S = (g + _) / 2;
  let T, E, D;
  return g !== _ && (D = g - _, E = S > 0.5 ? D / (2 - g - _) : D / (g + _), T = r2(l, u, h, D, g), T = T * 60 + 0.5), [T | 0, E || 0, S];
}
function b1(s, i, l, u) {
  return (Array.isArray(i) ? s(i[0], i[1], i[2]) : s(i, l, u)).map(Mf);
}
function S1(s, i, l) {
  return b1(xw, s, i, l);
}
function u2(s, i, l) {
  return b1(s2, s, i, l);
}
function c2(s, i, l) {
  return b1(l2, s, i, l);
}
function ww(s) {
  return (s % 360 + 360) % 360;
}
function f2(s) {
  const i = o2.exec(s);
  let l = 255, u;
  if (!i)
    return;
  i[5] !== u && (l = i[6] ? lv(+i[5]) : Mf(+i[5]));
  const h = ww(+i[2]), g = +i[3] / 100, _ = +i[4] / 100;
  return i[1] === "hwb" ? u = u2(h, g, _) : i[1] === "hsv" ? u = c2(h, g, _) : u = S1(h, g, _), {
    r: u[0],
    g: u[1],
    b: u[2],
    a: l
  };
}
function h2(s, i) {
  var l = _1(s);
  l[0] = ww(l[0] + i), l = S1(l), s.r = l[0], s.g = l[1], s.b = l[2];
}
function d2(s) {
  if (!s)
    return;
  const i = _1(s), l = i[0], u = FT(i[1]), h = FT(i[2]);
  return s.a < 255 ? `hsla(${l}, ${u}%, ${h}%, ${hc(s.a)})` : `hsl(${l}, ${u}%, ${h}%)`;
}
const tx = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, ex = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function m2() {
  const s = {}, i = Object.keys(ex), l = Object.keys(tx);
  let u, h, g, _, S;
  for (u = 0; u < i.length; u++) {
    for (_ = S = i[u], h = 0; h < l.length; h++)
      g = l[h], S = S.replace(g, tx[g]);
    g = parseInt(ex[_], 16), s[S] = [g >> 16 & 255, g >> 8 & 255, g & 255];
  }
  return s;
}
let e0;
function p2(s) {
  e0 || (e0 = m2(), e0.transparent = [0, 0, 0, 0]);
  const i = e0[s.toLowerCase()];
  return i && {
    r: i[0],
    g: i[1],
    b: i[2],
    a: i.length === 4 ? i[3] : 255
  };
}
const g2 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function y2(s) {
  const i = g2.exec(s);
  let l = 255, u, h, g;
  if (i) {
    if (i[7] !== u) {
      const _ = +i[7];
      l = i[8] ? lv(_) : wf(_ * 255, 0, 255);
    }
    return u = +i[1], h = +i[3], g = +i[5], u = 255 & (i[2] ? lv(u) : wf(u, 0, 255)), h = 255 & (i[4] ? lv(h) : wf(h, 0, 255)), g = 255 & (i[6] ? lv(g) : wf(g, 0, 255)), {
      r: u,
      g: h,
      b: g,
      a: l
    };
  }
}
function v2(s) {
  return s && (s.a < 255 ? `rgba(${s.r}, ${s.g}, ${s.b}, ${hc(s.a)})` : `rgb(${s.r}, ${s.g}, ${s.b})`);
}
const Qb = (s) => s <= 31308e-7 ? s * 12.92 : Math.pow(s, 1 / 2.4) * 1.055 - 0.055, Rp = (s) => s <= 0.04045 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);
function _2(s, i, l) {
  const u = Rp(hc(s.r)), h = Rp(hc(s.g)), g = Rp(hc(s.b));
  return {
    r: Mf(Qb(u + l * (Rp(hc(i.r)) - u))),
    g: Mf(Qb(h + l * (Rp(hc(i.g)) - h))),
    b: Mf(Qb(g + l * (Rp(hc(i.b)) - g))),
    a: s.a + l * (i.a - s.a)
  };
}
function n0(s, i, l) {
  if (s) {
    let u = _1(s);
    u[i] = Math.max(0, Math.min(u[i] + u[i] * l, i === 0 ? 360 : 1)), u = S1(u), s.r = u[0], s.g = u[1], s.b = u[2];
  }
}
function Mw(s, i) {
  return s && Object.assign(i || {}, s);
}
function nx(s) {
  var i = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(s) ? s.length >= 3 && (i = { r: s[0], g: s[1], b: s[2], a: 255 }, s.length > 3 && (i.a = Mf(s[3]))) : (i = Mw(s, { r: 0, g: 0, b: 0, a: 1 }), i.a = Mf(i.a)), i;
}
function b2(s) {
  return s.charAt(0) === "r" ? y2(s) : f2(s);
}
class gv {
  constructor(i) {
    if (i instanceof gv)
      return i;
    const l = typeof i;
    let u;
    l === "object" ? u = nx(i) : l === "string" && (u = n2(i) || p2(i) || b2(i)), this._rgb = u, this._valid = !!u;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var i = Mw(this._rgb);
    return i && (i.a = hc(i.a)), i;
  }
  set rgb(i) {
    this._rgb = nx(i);
  }
  rgbString() {
    return this._valid ? v2(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? a2(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? d2(this._rgb) : void 0;
  }
  mix(i, l) {
    if (i) {
      const u = this.rgb, h = i.rgb;
      let g;
      const _ = l === g ? 0.5 : l, S = 2 * _ - 1, T = u.a - h.a, E = ((S * T === -1 ? S : (S + T) / (1 + S * T)) + 1) / 2;
      g = 1 - E, u.r = 255 & E * u.r + g * h.r + 0.5, u.g = 255 & E * u.g + g * h.g + 0.5, u.b = 255 & E * u.b + g * h.b + 0.5, u.a = _ * u.a + (1 - _) * h.a, this.rgb = u;
    }
    return this;
  }
  interpolate(i, l) {
    return i && (this._rgb = _2(this._rgb, i._rgb, l)), this;
  }
  clone() {
    return new gv(this.rgb);
  }
  alpha(i) {
    return this._rgb.a = Mf(i), this;
  }
  clearer(i) {
    const l = this._rgb;
    return l.a *= 1 - i, this;
  }
  greyscale() {
    const i = this._rgb, l = Sv(i.r * 0.3 + i.g * 0.59 + i.b * 0.11);
    return i.r = i.g = i.b = l, this;
  }
  opaquer(i) {
    const l = this._rgb;
    return l.a *= 1 + i, this;
  }
  negate() {
    const i = this._rgb;
    return i.r = 255 - i.r, i.g = 255 - i.g, i.b = 255 - i.b, this;
  }
  lighten(i) {
    return n0(this._rgb, 2, i), this;
  }
  darken(i) {
    return n0(this._rgb, 2, -i), this;
  }
  saturate(i) {
    return n0(this._rgb, 1, i), this;
  }
  desaturate(i) {
    return n0(this._rgb, 1, -i), this;
  }
  rotate(i) {
    return h2(this._rgb, i), this;
  }
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
function uc() {
}
const S2 = /* @__PURE__ */ (() => {
  let s = 0;
  return () => s++;
})();
function Mn(s) {
  return s == null;
}
function Fi(s) {
  if (Array.isArray && Array.isArray(s))
    return !0;
  const i = Object.prototype.toString.call(s);
  return i.slice(0, 7) === "[object" && i.slice(-6) === "Array]";
}
function Ve(s) {
  return s !== null && Object.prototype.toString.call(s) === "[object Object]";
}
function qa(s) {
  return (typeof s == "number" || s instanceof Number) && isFinite(+s);
}
function iu(s, i) {
  return qa(s) ? s : i;
}
function gn(s, i) {
  return typeof s > "u" ? i : s;
}
const T2 = (s, i) => typeof s == "string" && s.endsWith("%") ? parseFloat(s) / 100 * i : +s;
function ri(s, i, l) {
  if (s && typeof s.call == "function")
    return s.apply(l, i);
}
function un(s, i, l, u) {
  let h, g, _;
  if (Fi(s))
    for (g = s.length, h = 0; h < g; h++)
      i.call(l, s[h], h);
  else if (Ve(s))
    for (_ = Object.keys(s), g = _.length, h = 0; h < g; h++)
      i.call(l, s[_[h]], _[h]);
}
function _0(s, i) {
  let l, u, h, g;
  if (!s || !i || s.length !== i.length)
    return !1;
  for (l = 0, u = s.length; l < u; ++l)
    if (h = s[l], g = i[l], h.datasetIndex !== g.datasetIndex || h.index !== g.index)
      return !1;
  return !0;
}
function b0(s) {
  if (Fi(s))
    return s.map(b0);
  if (Ve(s)) {
    const i = /* @__PURE__ */ Object.create(null), l = Object.keys(s), u = l.length;
    let h = 0;
    for (; h < u; ++h)
      i[l[h]] = b0(s[l[h]]);
    return i;
  }
  return s;
}
function Ew(s) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(s) === -1;
}
function x2(s, i, l, u) {
  if (!Ew(s))
    return;
  const h = i[s], g = l[s];
  Ve(h) && Ve(g) ? yv(h, g, u) : i[s] = b0(g);
}
function yv(s, i, l) {
  const u = Fi(i) ? i : [
    i
  ], h = u.length;
  if (!Ve(s))
    return s;
  l = l || {};
  const g = l.merger || x2;
  let _;
  for (let S = 0; S < h; ++S) {
    if (_ = u[S], !Ve(_))
      continue;
    const T = Object.keys(_);
    for (let E = 0, D = T.length; E < D; ++E)
      g(T[E], s, _, l);
  }
  return s;
}
function cv(s, i) {
  return yv(s, i, {
    merger: w2
  });
}
function w2(s, i, l) {
  if (!Ew(s))
    return;
  const u = i[s], h = l[s];
  Ve(u) && Ve(h) ? cv(u, h) : Object.prototype.hasOwnProperty.call(i, s) || (i[s] = b0(h));
}
const ix = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (s) => s,
  // default resolvers
  x: (s) => s.x,
  y: (s) => s.y
};
function M2(s) {
  const i = s.split("."), l = [];
  let u = "";
  for (const h of i)
    u += h, u.endsWith("\\") ? u = u.slice(0, -1) + "." : (l.push(u), u = "");
  return l;
}
function E2(s) {
  const i = M2(s);
  return (l) => {
    for (const u of i) {
      if (u === "")
        break;
      l = l && l[u];
    }
    return l;
  };
}
function S0(s, i) {
  return (ix[i] || (ix[i] = E2(i)))(s);
}
function T1(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
const T0 = (s) => typeof s < "u", Ef = (s) => typeof s == "function", ax = (s, i) => {
  if (s.size !== i.size)
    return !1;
  for (const l of s)
    if (!i.has(l))
      return !1;
  return !0;
};
function O2(s) {
  return s.type === "mouseup" || s.type === "click" || s.type === "contextmenu";
}
const ja = Math.PI, cu = 2 * ja, D2 = cu + ja, x0 = Number.POSITIVE_INFINITY, A2 = ja / 180, sr = ja / 2, sd = ja / 4, ox = ja * 2 / 3, Ow = Math.log10, zp = Math.sign;
function fv(s, i, l) {
  return Math.abs(s - i) < l;
}
function lx(s) {
  const i = Math.round(s);
  s = fv(s, i, s / 1e3) ? i : s;
  const l = Math.pow(10, Math.floor(Ow(s))), u = s / l;
  return (u <= 1 ? 1 : u <= 2 ? 2 : u <= 5 ? 5 : 10) * l;
}
function R2(s) {
  const i = [], l = Math.sqrt(s);
  let u;
  for (u = 1; u < l; u++)
    s % u === 0 && (i.push(u), i.push(s / u));
  return l === (l | 0) && i.push(l), i.sort((h, g) => h - g).pop(), i;
}
function C2(s) {
  return typeof s == "symbol" || typeof s == "object" && s !== null && !(Symbol.toPrimitive in s || "toString" in s || "valueOf" in s);
}
function vv(s) {
  return !C2(s) && !isNaN(parseFloat(s)) && isFinite(s);
}
function z2(s, i) {
  const l = Math.round(s);
  return l - i <= s && l + i >= s;
}
function L2(s, i, l) {
  let u, h, g;
  for (u = 0, h = s.length; u < h; u++)
    g = s[u][l], isNaN(g) || (i.min = Math.min(i.min, g), i.max = Math.max(i.max, g));
}
function dd(s) {
  return s * (ja / 180);
}
function H2(s) {
  return s * (180 / ja);
}
function sx(s) {
  if (!qa(s))
    return;
  let i = 1, l = 0;
  for (; Math.round(s * i) / i !== s; )
    i *= 10, l++;
  return l;
}
function k2(s, i) {
  const l = i.x - s.x, u = i.y - s.y, h = Math.sqrt(l * l + u * u);
  let g = Math.atan2(u, l);
  return g < -0.5 * ja && (g += cu), {
    angle: g,
    distance: h
  };
}
function r1(s, i) {
  return Math.sqrt(Math.pow(i.x - s.x, 2) + Math.pow(i.y - s.y, 2));
}
function N2(s, i) {
  return (s - i + D2) % cu - ja;
}
function lu(s) {
  return (s % cu + cu) % cu;
}
function Dw(s, i, l, u) {
  const h = lu(s), g = lu(i), _ = lu(l), S = lu(g - h), T = lu(_ - h), E = lu(h - g), D = lu(h - _);
  return h === g || h === _ || u && g === _ || S > T && E < D;
}
function rr(s, i, l) {
  return Math.max(i, Math.min(l, s));
}
function U2(s) {
  return rr(s, -32768, 32767);
}
function Aw(s, i, l, u = 1e-6) {
  return s >= Math.min(i, l) - u && s <= Math.max(i, l) + u;
}
function x1(s, i, l) {
  l = l || ((_) => s[_] < i);
  let u = s.length - 1, h = 0, g;
  for (; u - h > 1; )
    g = h + u >> 1, l(g) ? h = g : u = g;
  return {
    lo: h,
    hi: u
  };
}
const md = (s, i, l, u) => x1(s, l, u ? (h) => {
  const g = s[h][i];
  return g < l || g === l && s[h + 1][i] === l;
} : (h) => s[h][i] < l), B2 = (s, i, l) => x1(s, l, (u) => s[u][i] >= l);
function Y2(s, i, l) {
  let u = 0, h = s.length;
  for (; u < h && s[u] < i; )
    u++;
  for (; h > u && s[h - 1] > l; )
    h--;
  return u > 0 || h < s.length ? s.slice(u, h) : s;
}
const Rw = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function j2(s, i) {
  if (s._chartjs) {
    s._chartjs.listeners.push(i);
    return;
  }
  Object.defineProperty(s, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        i
      ]
    }
  }), Rw.forEach((l) => {
    const u = "_onData" + T1(l), h = s[l];
    Object.defineProperty(s, l, {
      configurable: !0,
      enumerable: !1,
      value(...g) {
        const _ = h.apply(this, g);
        return s._chartjs.listeners.forEach((S) => {
          typeof S[u] == "function" && S[u](...g);
        }), _;
      }
    });
  });
}
function rx(s, i) {
  const l = s._chartjs;
  if (!l)
    return;
  const u = l.listeners, h = u.indexOf(i);
  h !== -1 && u.splice(h, 1), !(u.length > 0) && (Rw.forEach((g) => {
    delete s[g];
  }), delete s._chartjs);
}
function q2(s) {
  const i = new Set(s);
  return i.size === s.length ? s : Array.from(i);
}
const Cw = function() {
  return typeof window > "u" ? function(s) {
    return s();
  } : window.requestAnimationFrame;
}();
function zw(s, i) {
  let l = [], u = !1;
  return function(...h) {
    l = h, u || (u = !0, Cw.call(window, () => {
      u = !1, s.apply(i, l);
    }));
  };
}
function Z2(s, i) {
  let l;
  return function(...u) {
    return i ? (clearTimeout(l), l = setTimeout(s, i, u)) : s.apply(this, u), i;
  };
}
const P2 = (s) => s === "start" ? "left" : s === "end" ? "right" : "center", ux = (s, i, l) => s === "start" ? i : s === "end" ? l : (i + l) / 2;
function V2(s, i, l) {
  const u = i.length;
  let h = 0, g = u;
  if (s._sorted) {
    const { iScale: _, vScale: S, _parsed: T } = s, E = s.dataset && s.dataset.options ? s.dataset.options.spanGaps : null, D = _.axis, { min: C, max: z, minDefined: j, maxDefined: I } = _.getUserBounds();
    if (j) {
      if (h = Math.min(
        // @ts-expect-error Need to type _parsed
        md(T, D, C).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        l ? u : md(i, D, _.getPixelForValue(C)).lo
      ), E) {
        const Q = T.slice(0, h + 1).reverse().findIndex((X) => !Mn(X[S.axis]));
        h -= Math.max(0, Q);
      }
      h = rr(h, 0, u - 1);
    }
    if (I) {
      let Q = Math.max(
        // @ts-expect-error Need to type _parsed
        md(T, _.axis, z, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        l ? 0 : md(i, D, _.getPixelForValue(z), !0).hi + 1
      );
      if (E) {
        const X = T.slice(Q - 1).findIndex((nt) => !Mn(nt[S.axis]));
        Q += Math.max(0, X);
      }
      g = rr(Q, h, u) - h;
    } else
      g = u - h;
  }
  return {
    start: h,
    count: g
  };
}
function G2(s) {
  const { xScale: i, yScale: l, _scaleRanges: u } = s, h = {
    xmin: i.min,
    xmax: i.max,
    ymin: l.min,
    ymax: l.max
  };
  if (!u)
    return s._scaleRanges = h, !0;
  const g = u.xmin !== i.min || u.xmax !== i.max || u.ymin !== l.min || u.ymax !== l.max;
  return Object.assign(u, h), g;
}
const i0 = (s) => s === 0 || s === 1, cx = (s, i, l) => -(Math.pow(2, 10 * (s -= 1)) * Math.sin((s - i) * cu / l)), fx = (s, i, l) => Math.pow(2, -10 * s) * Math.sin((s - i) * cu / l) + 1, hv = {
  linear: (s) => s,
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => -s * (s - 2),
  easeInOutQuad: (s) => (s /= 0.5) < 1 ? 0.5 * s * s : -0.5 * (--s * (s - 2) - 1),
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => (s -= 1) * s * s + 1,
  easeInOutCubic: (s) => (s /= 0.5) < 1 ? 0.5 * s * s * s : 0.5 * ((s -= 2) * s * s + 2),
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => -((s -= 1) * s * s * s - 1),
  easeInOutQuart: (s) => (s /= 0.5) < 1 ? 0.5 * s * s * s * s : -0.5 * ((s -= 2) * s * s * s - 2),
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => (s -= 1) * s * s * s * s + 1,
  easeInOutQuint: (s) => (s /= 0.5) < 1 ? 0.5 * s * s * s * s * s : 0.5 * ((s -= 2) * s * s * s * s + 2),
  easeInSine: (s) => -Math.cos(s * sr) + 1,
  easeOutSine: (s) => Math.sin(s * sr),
  easeInOutSine: (s) => -0.5 * (Math.cos(ja * s) - 1),
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * (s - 1)),
  easeOutExpo: (s) => s === 1 ? 1 : -Math.pow(2, -10 * s) + 1,
  easeInOutExpo: (s) => i0(s) ? s : s < 0.5 ? 0.5 * Math.pow(2, 10 * (s * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (s * 2 - 1)) + 2),
  easeInCirc: (s) => s >= 1 ? s : -(Math.sqrt(1 - s * s) - 1),
  easeOutCirc: (s) => Math.sqrt(1 - (s -= 1) * s),
  easeInOutCirc: (s) => (s /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - s * s) - 1) : 0.5 * (Math.sqrt(1 - (s -= 2) * s) + 1),
  easeInElastic: (s) => i0(s) ? s : cx(s, 0.075, 0.3),
  easeOutElastic: (s) => i0(s) ? s : fx(s, 0.075, 0.3),
  easeInOutElastic(s) {
    return i0(s) ? s : s < 0.5 ? 0.5 * cx(s * 2, 0.1125, 0.45) : 0.5 + 0.5 * fx(s * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(s) {
    return s * s * ((1.70158 + 1) * s - 1.70158);
  },
  easeOutBack(s) {
    return (s -= 1) * s * ((1.70158 + 1) * s + 1.70158) + 1;
  },
  easeInOutBack(s) {
    let i = 1.70158;
    return (s /= 0.5) < 1 ? 0.5 * (s * s * (((i *= 1.525) + 1) * s - i)) : 0.5 * ((s -= 2) * s * (((i *= 1.525) + 1) * s + i) + 2);
  },
  easeInBounce: (s) => 1 - hv.easeOutBounce(1 - s),
  easeOutBounce(s) {
    return s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375;
  },
  easeInOutBounce: (s) => s < 0.5 ? hv.easeInBounce(s * 2) * 0.5 : hv.easeOutBounce(s * 2 - 1) * 0.5 + 0.5
};
function w1(s) {
  if (s && typeof s == "object") {
    const i = s.toString();
    return i === "[object CanvasPattern]" || i === "[object CanvasGradient]";
  }
  return !1;
}
function hx(s) {
  return w1(s) ? s : new gv(s);
}
function Kb(s) {
  return w1(s) ? s : new gv(s).saturate(0.5).darken(0.1).hexString();
}
const X2 = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], Q2 = [
  "color",
  "borderColor",
  "backgroundColor"
];
function K2(s) {
  s.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), s.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (i) => i !== "onProgress" && i !== "onComplete" && i !== "fn"
  }), s.set("animations", {
    colors: {
      type: "color",
      properties: Q2
    },
    numbers: {
      type: "number",
      properties: X2
    }
  }), s.describe("animations", {
    _fallback: "animation"
  }), s.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (i) => i | 0
        }
      }
    }
  });
}
function W2(s) {
  s.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const dx = /* @__PURE__ */ new Map();
function I2(s, i) {
  i = i || {};
  const l = s + JSON.stringify(i);
  let u = dx.get(l);
  return u || (u = new Intl.NumberFormat(s, i), dx.set(l, u)), u;
}
function Lw(s, i, l) {
  return I2(i, l).format(s);
}
const $2 = {
  values(s) {
    return Fi(s) ? s : "" + s;
  },
  numeric(s, i, l) {
    if (s === 0)
      return "0";
    const u = this.chart.options.locale;
    let h, g = s;
    if (l.length > 1) {
      const E = Math.max(Math.abs(l[0].value), Math.abs(l[l.length - 1].value));
      (E < 1e-4 || E > 1e15) && (h = "scientific"), g = J2(s, l);
    }
    const _ = Ow(Math.abs(g)), S = isNaN(_) ? 1 : Math.max(Math.min(-1 * Math.floor(_), 20), 0), T = {
      notation: h,
      minimumFractionDigits: S,
      maximumFractionDigits: S
    };
    return Object.assign(T, this.options.ticks.format), Lw(s, u, T);
  }
};
function J2(s, i) {
  let l = i.length > 3 ? i[2].value - i[1].value : i[1].value - i[0].value;
  return Math.abs(l) >= 1 && s !== Math.floor(s) && (l = s - Math.floor(s)), l;
}
var Hw = {
  formatters: $2
};
function F2(s) {
  s.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (i, l) => l.lineWidth,
      tickColor: (i, l) => l.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Hw.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), s.route("scale.ticks", "color", "", "color"), s.route("scale.grid", "color", "", "borderColor"), s.route("scale.border", "color", "", "borderColor"), s.route("scale.title", "color", "", "color"), s.describe("scale", {
    _fallback: !1,
    _scriptable: (i) => !i.startsWith("before") && !i.startsWith("after") && i !== "callback" && i !== "parser",
    _indexable: (i) => i !== "borderDash" && i !== "tickBorderDash" && i !== "dash"
  }), s.describe("scales", {
    _fallback: "scale"
  }), s.describe("scale.ticks", {
    _scriptable: (i) => i !== "backdropPadding" && i !== "callback",
    _indexable: (i) => i !== "backdropPadding"
  });
}
const gd = /* @__PURE__ */ Object.create(null), u1 = /* @__PURE__ */ Object.create(null);
function dv(s, i) {
  if (!i)
    return s;
  const l = i.split(".");
  for (let u = 0, h = l.length; u < h; ++u) {
    const g = l[u];
    s = s[g] || (s[g] = /* @__PURE__ */ Object.create(null));
  }
  return s;
}
function Wb(s, i, l) {
  return typeof i == "string" ? yv(dv(s, i), l) : yv(dv(s, ""), i);
}
class tO {
  constructor(i, l) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (u) => u.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (u, h) => Kb(h.backgroundColor), this.hoverBorderColor = (u, h) => Kb(h.borderColor), this.hoverColor = (u, h) => Kb(h.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(i), this.apply(l);
  }
  set(i, l) {
    return Wb(this, i, l);
  }
  get(i) {
    return dv(this, i);
  }
  describe(i, l) {
    return Wb(u1, i, l);
  }
  override(i, l) {
    return Wb(gd, i, l);
  }
  route(i, l, u, h) {
    const g = dv(this, i), _ = dv(this, u), S = "_" + l;
    Object.defineProperties(g, {
      [S]: {
        value: g[l],
        writable: !0
      },
      [l]: {
        enumerable: !0,
        get() {
          const T = this[S], E = _[h];
          return Ve(T) ? Object.assign({}, E, T) : gn(T, E);
        },
        set(T) {
          this[S] = T;
        }
      }
    });
  }
  apply(i) {
    i.forEach((l) => l(this));
  }
}
var Mi = /* @__PURE__ */ new tO({
  _scriptable: (s) => !s.startsWith("on"),
  _indexable: (s) => s !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  K2,
  W2,
  F2
]);
function eO(s) {
  return !s || Mn(s.size) || Mn(s.family) ? null : (s.style ? s.style + " " : "") + (s.weight ? s.weight + " " : "") + s.size + "px " + s.family;
}
function mx(s, i, l, u, h) {
  let g = i[h];
  return g || (g = i[h] = s.measureText(h).width, l.push(h)), g > u && (u = g), u;
}
function rd(s, i, l) {
  const u = s.currentDevicePixelRatio, h = l !== 0 ? Math.max(l / 2, 0.5) : 0;
  return Math.round((i - h) * u) / u + h;
}
function px(s, i) {
  !i && !s || (i = i || s.getContext("2d"), i.save(), i.resetTransform(), i.clearRect(0, 0, s.width, s.height), i.restore());
}
function c1(s, i, l, u) {
  nO(s, i, l, u);
}
function nO(s, i, l, u, h) {
  let g, _, S, T, E, D, C, z;
  const j = i.pointStyle, I = i.rotation, Q = i.radius;
  let X = (I || 0) * A2;
  if (j && typeof j == "object" && (g = j.toString(), g === "[object HTMLImageElement]" || g === "[object HTMLCanvasElement]")) {
    s.save(), s.translate(l, u), s.rotate(X), s.drawImage(j, -j.width / 2, -j.height / 2, j.width, j.height), s.restore();
    return;
  }
  if (!(isNaN(Q) || Q <= 0)) {
    switch (s.beginPath(), j) {
      // Default includes circle
      default:
        s.arc(l, u, Q, 0, cu), s.closePath();
        break;
      case "triangle":
        D = Q, s.moveTo(l + Math.sin(X) * D, u - Math.cos(X) * Q), X += ox, s.lineTo(l + Math.sin(X) * D, u - Math.cos(X) * Q), X += ox, s.lineTo(l + Math.sin(X) * D, u - Math.cos(X) * Q), s.closePath();
        break;
      case "rectRounded":
        E = Q * 0.516, T = Q - E, _ = Math.cos(X + sd) * T, C = Math.cos(X + sd) * T, S = Math.sin(X + sd) * T, z = Math.sin(X + sd) * T, s.arc(l - C, u - S, E, X - ja, X - sr), s.arc(l + z, u - _, E, X - sr, X), s.arc(l + C, u + S, E, X, X + sr), s.arc(l - z, u + _, E, X + sr, X + ja), s.closePath();
        break;
      case "rect":
        if (!I) {
          T = Math.SQRT1_2 * Q, D = T, s.rect(l - D, u - T, 2 * D, 2 * T);
          break;
        }
        X += sd;
      /* falls through */
      case "rectRot":
        C = Math.cos(X) * Q, _ = Math.cos(X) * Q, S = Math.sin(X) * Q, z = Math.sin(X) * Q, s.moveTo(l - C, u - S), s.lineTo(l + z, u - _), s.lineTo(l + C, u + S), s.lineTo(l - z, u + _), s.closePath();
        break;
      case "crossRot":
        X += sd;
      /* falls through */
      case "cross":
        C = Math.cos(X) * Q, _ = Math.cos(X) * Q, S = Math.sin(X) * Q, z = Math.sin(X) * Q, s.moveTo(l - C, u - S), s.lineTo(l + C, u + S), s.moveTo(l + z, u - _), s.lineTo(l - z, u + _);
        break;
      case "star":
        C = Math.cos(X) * Q, _ = Math.cos(X) * Q, S = Math.sin(X) * Q, z = Math.sin(X) * Q, s.moveTo(l - C, u - S), s.lineTo(l + C, u + S), s.moveTo(l + z, u - _), s.lineTo(l - z, u + _), X += sd, C = Math.cos(X) * Q, _ = Math.cos(X) * Q, S = Math.sin(X) * Q, z = Math.sin(X) * Q, s.moveTo(l - C, u - S), s.lineTo(l + C, u + S), s.moveTo(l + z, u - _), s.lineTo(l - z, u + _);
        break;
      case "line":
        _ = Math.cos(X) * Q, S = Math.sin(X) * Q, s.moveTo(l - _, u - S), s.lineTo(l + _, u + S);
        break;
      case "dash":
        s.moveTo(l, u), s.lineTo(l + Math.cos(X) * Q, u + Math.sin(X) * Q);
        break;
      case !1:
        s.closePath();
        break;
    }
    s.fill(), i.borderWidth > 0 && s.stroke();
  }
}
function _v(s, i, l) {
  return l = l || 0.5, !i || s && s.x > i.left - l && s.x < i.right + l && s.y > i.top - l && s.y < i.bottom + l;
}
function M1(s, i) {
  s.save(), s.beginPath(), s.rect(i.left, i.top, i.right - i.left, i.bottom - i.top), s.clip();
}
function E1(s) {
  s.restore();
}
function iO(s, i, l, u, h) {
  if (!i)
    return s.lineTo(l.x, l.y);
  if (h === "middle") {
    const g = (i.x + l.x) / 2;
    s.lineTo(g, i.y), s.lineTo(g, l.y);
  } else h === "after" != !!u ? s.lineTo(i.x, l.y) : s.lineTo(l.x, i.y);
  s.lineTo(l.x, l.y);
}
function aO(s, i, l, u) {
  if (!i)
    return s.lineTo(l.x, l.y);
  s.bezierCurveTo(u ? i.cp1x : i.cp2x, u ? i.cp1y : i.cp2y, u ? l.cp2x : l.cp1x, u ? l.cp2y : l.cp1y, l.x, l.y);
}
function oO(s, i) {
  i.translation && s.translate(i.translation[0], i.translation[1]), Mn(i.rotation) || s.rotate(i.rotation), i.color && (s.fillStyle = i.color), i.textAlign && (s.textAlign = i.textAlign), i.textBaseline && (s.textBaseline = i.textBaseline);
}
function lO(s, i, l, u, h) {
  if (h.strikethrough || h.underline) {
    const g = s.measureText(u), _ = i - g.actualBoundingBoxLeft, S = i + g.actualBoundingBoxRight, T = l - g.actualBoundingBoxAscent, E = l + g.actualBoundingBoxDescent, D = h.strikethrough ? (T + E) / 2 : E;
    s.strokeStyle = s.fillStyle, s.beginPath(), s.lineWidth = h.decorationWidth || 2, s.moveTo(_, D), s.lineTo(S, D), s.stroke();
  }
}
function sO(s, i) {
  const l = s.fillStyle;
  s.fillStyle = i.color, s.fillRect(i.left, i.top, i.width, i.height), s.fillStyle = l;
}
function gx(s, i, l, u, h, g = {}) {
  const _ = Fi(i) ? i : [
    i
  ], S = g.strokeWidth > 0 && g.strokeColor !== "";
  let T, E;
  for (s.save(), s.font = h.string, oO(s, g), T = 0; T < _.length; ++T)
    E = _[T], g.backdrop && sO(s, g.backdrop), S && (g.strokeColor && (s.strokeStyle = g.strokeColor), Mn(g.strokeWidth) || (s.lineWidth = g.strokeWidth), s.strokeText(E, l, u, g.maxWidth)), s.fillText(E, l, u, g.maxWidth), lO(s, l, u, E, g), u += Number(h.lineHeight);
  s.restore();
}
function yx(s, i) {
  const { x: l, y: u, w: h, h: g, radius: _ } = i;
  s.arc(l + _.topLeft, u + _.topLeft, _.topLeft, 1.5 * ja, ja, !0), s.lineTo(l, u + g - _.bottomLeft), s.arc(l + _.bottomLeft, u + g - _.bottomLeft, _.bottomLeft, ja, sr, !0), s.lineTo(l + h - _.bottomRight, u + g), s.arc(l + h - _.bottomRight, u + g - _.bottomRight, _.bottomRight, sr, 0, !0), s.lineTo(l + h, u + _.topRight), s.arc(l + h - _.topRight, u + _.topRight, _.topRight, 0, -sr, !0), s.lineTo(l + _.topLeft, u);
}
const rO = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, uO = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function cO(s, i) {
  const l = ("" + s).match(rO);
  if (!l || l[1] === "normal")
    return i * 1.2;
  switch (s = +l[2], l[3]) {
    case "px":
      return s;
    case "%":
      s /= 100;
      break;
  }
  return i * s;
}
const fO = (s) => +s || 0;
function kw(s, i) {
  const l = {}, u = Ve(i), h = u ? Object.keys(i) : i, g = Ve(s) ? u ? (_) => gn(s[_], s[i[_]]) : (_) => s[_] : () => s;
  for (const _ of h)
    l[_] = fO(g(_));
  return l;
}
function hO(s) {
  return kw(s, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function g0(s) {
  return kw(s, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function Of(s) {
  const i = hO(s);
  return i.width = i.left + i.right, i.height = i.top + i.bottom, i;
}
function uu(s, i) {
  s = s || {}, i = i || Mi.font;
  let l = gn(s.size, i.size);
  typeof l == "string" && (l = parseInt(l, 10));
  let u = gn(s.style, i.style);
  u && !("" + u).match(uO) && (console.warn('Invalid font style specified: "' + u + '"'), u = void 0);
  const h = {
    family: gn(s.family, i.family),
    lineHeight: cO(gn(s.lineHeight, i.lineHeight), l),
    size: l,
    style: u,
    weight: gn(s.weight, i.weight),
    string: ""
  };
  return h.string = eO(h), h;
}
function a0(s, i, l, u) {
  let h, g, _;
  for (h = 0, g = s.length; h < g; ++h)
    if (_ = s[h], _ !== void 0 && _ !== void 0)
      return _;
}
function dO(s, i, l) {
  const { min: u, max: h } = s, g = T2(i, (h - u) / 2), _ = (S, T) => l && S === 0 ? 0 : S + T;
  return {
    min: _(u, -Math.abs(g)),
    max: _(h, g)
  };
}
function yd(s, i) {
  return Object.assign(Object.create(s), i);
}
function O1(s, i = [
  ""
], l, u, h = () => s[0]) {
  const g = l || s;
  typeof u > "u" && (u = Yw("_fallback", s));
  const _ = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: s,
    _rootScopes: g,
    _fallback: u,
    _getTarget: h,
    override: (S) => O1([
      S,
      ...s
    ], i, g, u)
  };
  return new Proxy(_, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(S, T) {
      return delete S[T], delete S._keys, delete s[0][T], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(S, T) {
      return Uw(S, T, () => SO(T, i, s, S));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(S, T) {
      return Reflect.getOwnPropertyDescriptor(S._scopes[0], T);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(s[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(S, T) {
      return _x(S).includes(T);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(S) {
      return _x(S);
    },
    /**
    * A trap for setting property values.
    */
    set(S, T, E) {
      const D = S._storage || (S._storage = h());
      return S[T] = D[T] = E, delete S._keys, !0;
    }
  });
}
function Lp(s, i, l, u) {
  const h = {
    _cacheable: !1,
    _proxy: s,
    _context: i,
    _subProxy: l,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: Nw(s, u),
    setContext: (g) => Lp(s, g, l, u),
    override: (g) => Lp(s.override(g), i, l, u)
  };
  return new Proxy(h, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(g, _) {
      return delete g[_], delete s[_], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(g, _, S) {
      return Uw(g, _, () => pO(g, _, S));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(g, _) {
      return g._descriptors.allKeys ? Reflect.has(s, _) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(s, _);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(s);
    },
    /**
    * A trap for the in operator.
    */
    has(g, _) {
      return Reflect.has(s, _);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(s);
    },
    /**
    * A trap for setting property values.
    */
    set(g, _, S) {
      return s[_] = S, delete g[_], !0;
    }
  });
}
function Nw(s, i = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: l = i.scriptable, _indexable: u = i.indexable, _allKeys: h = i.allKeys } = s;
  return {
    allKeys: h,
    scriptable: l,
    indexable: u,
    isScriptable: Ef(l) ? l : () => l,
    isIndexable: Ef(u) ? u : () => u
  };
}
const mO = (s, i) => s ? s + T1(i) : i, D1 = (s, i) => Ve(i) && s !== "adapters" && (Object.getPrototypeOf(i) === null || i.constructor === Object);
function Uw(s, i, l) {
  if (Object.prototype.hasOwnProperty.call(s, i) || i === "constructor")
    return s[i];
  const u = l();
  return s[i] = u, u;
}
function pO(s, i, l) {
  const { _proxy: u, _context: h, _subProxy: g, _descriptors: _ } = s;
  let S = u[i];
  return Ef(S) && _.isScriptable(i) && (S = gO(i, S, s, l)), Fi(S) && S.length && (S = yO(i, S, s, _.isIndexable)), D1(i, S) && (S = Lp(S, h, g && g[i], _)), S;
}
function gO(s, i, l, u) {
  const { _proxy: h, _context: g, _subProxy: _, _stack: S } = l;
  if (S.has(s))
    throw new Error("Recursion detected: " + Array.from(S).join("->") + "->" + s);
  S.add(s);
  let T = i(g, _ || u);
  return S.delete(s), D1(s, T) && (T = A1(h._scopes, h, s, T)), T;
}
function yO(s, i, l, u) {
  const { _proxy: h, _context: g, _subProxy: _, _descriptors: S } = l;
  if (typeof g.index < "u" && u(s))
    return i[g.index % i.length];
  if (Ve(i[0])) {
    const T = i, E = h._scopes.filter((D) => D !== T);
    i = [];
    for (const D of T) {
      const C = A1(E, h, s, D);
      i.push(Lp(C, g, _ && _[s], S));
    }
  }
  return i;
}
function Bw(s, i, l) {
  return Ef(s) ? s(i, l) : s;
}
const vO = (s, i) => s === !0 ? i : typeof s == "string" ? S0(i, s) : void 0;
function _O(s, i, l, u, h) {
  for (const g of i) {
    const _ = vO(l, g);
    if (_) {
      s.add(_);
      const S = Bw(_._fallback, l, h);
      if (typeof S < "u" && S !== l && S !== u)
        return S;
    } else if (_ === !1 && typeof u < "u" && l !== u)
      return null;
  }
  return !1;
}
function A1(s, i, l, u) {
  const h = i._rootScopes, g = Bw(i._fallback, l, u), _ = [
    ...s,
    ...h
  ], S = /* @__PURE__ */ new Set();
  S.add(u);
  let T = vx(S, _, l, g || l, u);
  return T === null || typeof g < "u" && g !== l && (T = vx(S, _, g, T, u), T === null) ? !1 : O1(Array.from(S), [
    ""
  ], h, g, () => bO(i, l, u));
}
function vx(s, i, l, u, h) {
  for (; l; )
    l = _O(s, i, l, u, h);
  return l;
}
function bO(s, i, l) {
  const u = s._getTarget();
  i in u || (u[i] = {});
  const h = u[i];
  return Fi(h) && Ve(l) ? l : h || {};
}
function SO(s, i, l, u) {
  let h;
  for (const g of i)
    if (h = Yw(mO(g, s), l), typeof h < "u")
      return D1(s, h) ? A1(l, u, s, h) : h;
}
function Yw(s, i) {
  for (const l of i) {
    if (!l)
      continue;
    const u = l[s];
    if (typeof u < "u")
      return u;
  }
}
function _x(s) {
  let i = s._keys;
  return i || (i = s._keys = TO(s._scopes)), i;
}
function TO(s) {
  const i = /* @__PURE__ */ new Set();
  for (const l of s)
    for (const u of Object.keys(l).filter((h) => !h.startsWith("_")))
      i.add(u);
  return Array.from(i);
}
const xO = Number.EPSILON || 1e-14, Hp = (s, i) => i < s.length && !s[i].skip && s[i], jw = (s) => s === "x" ? "y" : "x";
function wO(s, i, l, u) {
  const h = s.skip ? i : s, g = i, _ = l.skip ? i : l, S = r1(g, h), T = r1(_, g);
  let E = S / (S + T), D = T / (S + T);
  E = isNaN(E) ? 0 : E, D = isNaN(D) ? 0 : D;
  const C = u * E, z = u * D;
  return {
    previous: {
      x: g.x - C * (_.x - h.x),
      y: g.y - C * (_.y - h.y)
    },
    next: {
      x: g.x + z * (_.x - h.x),
      y: g.y + z * (_.y - h.y)
    }
  };
}
function MO(s, i, l) {
  const u = s.length;
  let h, g, _, S, T, E = Hp(s, 0);
  for (let D = 0; D < u - 1; ++D)
    if (T = E, E = Hp(s, D + 1), !(!T || !E)) {
      if (fv(i[D], 0, xO)) {
        l[D] = l[D + 1] = 0;
        continue;
      }
      h = l[D] / i[D], g = l[D + 1] / i[D], S = Math.pow(h, 2) + Math.pow(g, 2), !(S <= 9) && (_ = 3 / Math.sqrt(S), l[D] = h * _ * i[D], l[D + 1] = g * _ * i[D]);
    }
}
function EO(s, i, l = "x") {
  const u = jw(l), h = s.length;
  let g, _, S, T = Hp(s, 0);
  for (let E = 0; E < h; ++E) {
    if (_ = S, S = T, T = Hp(s, E + 1), !S)
      continue;
    const D = S[l], C = S[u];
    _ && (g = (D - _[l]) / 3, S[`cp1${l}`] = D - g, S[`cp1${u}`] = C - g * i[E]), T && (g = (T[l] - D) / 3, S[`cp2${l}`] = D + g, S[`cp2${u}`] = C + g * i[E]);
  }
}
function OO(s, i = "x") {
  const l = jw(i), u = s.length, h = Array(u).fill(0), g = Array(u);
  let _, S, T, E = Hp(s, 0);
  for (_ = 0; _ < u; ++_)
    if (S = T, T = E, E = Hp(s, _ + 1), !!T) {
      if (E) {
        const D = E[i] - T[i];
        h[_] = D !== 0 ? (E[l] - T[l]) / D : 0;
      }
      g[_] = S ? E ? zp(h[_ - 1]) !== zp(h[_]) ? 0 : (h[_ - 1] + h[_]) / 2 : h[_ - 1] : h[_];
    }
  MO(s, h, g), EO(s, g, i);
}
function o0(s, i, l) {
  return Math.max(Math.min(s, l), i);
}
function DO(s, i) {
  let l, u, h, g, _, S = _v(s[0], i);
  for (l = 0, u = s.length; l < u; ++l)
    _ = g, g = S, S = l < u - 1 && _v(s[l + 1], i), g && (h = s[l], _ && (h.cp1x = o0(h.cp1x, i.left, i.right), h.cp1y = o0(h.cp1y, i.top, i.bottom)), S && (h.cp2x = o0(h.cp2x, i.left, i.right), h.cp2y = o0(h.cp2y, i.top, i.bottom)));
}
function AO(s, i, l, u, h) {
  let g, _, S, T;
  if (i.spanGaps && (s = s.filter((E) => !E.skip)), i.cubicInterpolationMode === "monotone")
    OO(s, h);
  else {
    let E = u ? s[s.length - 1] : s[0];
    for (g = 0, _ = s.length; g < _; ++g)
      S = s[g], T = wO(E, S, s[Math.min(g + 1, _ - (u ? 0 : 1)) % _], i.tension), S.cp1x = T.previous.x, S.cp1y = T.previous.y, S.cp2x = T.next.x, S.cp2y = T.next.y, E = S;
  }
  i.capBezierPoints && DO(s, l);
}
function R1() {
  return typeof window < "u" && typeof document < "u";
}
function C1(s) {
  let i = s.parentNode;
  return i && i.toString() === "[object ShadowRoot]" && (i = i.host), i;
}
function w0(s, i, l) {
  let u;
  return typeof s == "string" ? (u = parseInt(s, 10), s.indexOf("%") !== -1 && (u = u / 100 * i.parentNode[l])) : u = s, u;
}
const D0 = (s) => s.ownerDocument.defaultView.getComputedStyle(s, null);
function RO(s, i) {
  return D0(s).getPropertyValue(i);
}
const CO = [
  "top",
  "right",
  "bottom",
  "left"
];
function pd(s, i, l) {
  const u = {};
  l = l ? "-" + l : "";
  for (let h = 0; h < 4; h++) {
    const g = CO[h];
    u[g] = parseFloat(s[i + "-" + g + l]) || 0;
  }
  return u.width = u.left + u.right, u.height = u.top + u.bottom, u;
}
const zO = (s, i, l) => (s > 0 || i > 0) && (!l || !l.shadowRoot);
function LO(s, i) {
  const l = s.touches, u = l && l.length ? l[0] : s, { offsetX: h, offsetY: g } = u;
  let _ = !1, S, T;
  if (zO(h, g, s.target))
    S = h, T = g;
  else {
    const E = i.getBoundingClientRect();
    S = u.clientX - E.left, T = u.clientY - E.top, _ = !0;
  }
  return {
    x: S,
    y: T,
    box: _
  };
}
function cd(s, i) {
  if ("native" in s)
    return s;
  const { canvas: l, currentDevicePixelRatio: u } = i, h = D0(l), g = h.boxSizing === "border-box", _ = pd(h, "padding"), S = pd(h, "border", "width"), { x: T, y: E, box: D } = LO(s, l), C = _.left + (D && S.left), z = _.top + (D && S.top);
  let { width: j, height: I } = i;
  return g && (j -= _.width + S.width, I -= _.height + S.height), {
    x: Math.round((T - C) / j * l.width / u),
    y: Math.round((E - z) / I * l.height / u)
  };
}
function HO(s, i, l) {
  let u, h;
  if (i === void 0 || l === void 0) {
    const g = s && C1(s);
    if (!g)
      i = s.clientWidth, l = s.clientHeight;
    else {
      const _ = g.getBoundingClientRect(), S = D0(g), T = pd(S, "border", "width"), E = pd(S, "padding");
      i = _.width - E.width - T.width, l = _.height - E.height - T.height, u = w0(S.maxWidth, g, "clientWidth"), h = w0(S.maxHeight, g, "clientHeight");
    }
  }
  return {
    width: i,
    height: l,
    maxWidth: u || x0,
    maxHeight: h || x0
  };
}
const l0 = (s) => Math.round(s * 10) / 10;
function kO(s, i, l, u) {
  const h = D0(s), g = pd(h, "margin"), _ = w0(h.maxWidth, s, "clientWidth") || x0, S = w0(h.maxHeight, s, "clientHeight") || x0, T = HO(s, i, l);
  let { width: E, height: D } = T;
  if (h.boxSizing === "content-box") {
    const z = pd(h, "border", "width"), j = pd(h, "padding");
    E -= j.width + z.width, D -= j.height + z.height;
  }
  return E = Math.max(0, E - g.width), D = Math.max(0, u ? E / u : D - g.height), E = l0(Math.min(E, _, T.maxWidth)), D = l0(Math.min(D, S, T.maxHeight)), E && !D && (D = l0(E / 2)), (i !== void 0 || l !== void 0) && u && T.height && D > T.height && (D = T.height, E = l0(Math.floor(D * u))), {
    width: E,
    height: D
  };
}
function bx(s, i, l) {
  const u = i || 1, h = Math.floor(s.height * u), g = Math.floor(s.width * u);
  s.height = Math.floor(s.height), s.width = Math.floor(s.width);
  const _ = s.canvas;
  return _.style && (l || !_.style.height && !_.style.width) && (_.style.height = `${s.height}px`, _.style.width = `${s.width}px`), s.currentDevicePixelRatio !== u || _.height !== h || _.width !== g ? (s.currentDevicePixelRatio = u, _.height = h, _.width = g, s.ctx.setTransform(u, 0, 0, u, 0, 0), !0) : !1;
}
const NO = function() {
  let s = !1;
  try {
    const i = {
      get passive() {
        return s = !0, !1;
      }
    };
    R1() && (window.addEventListener("test", null, i), window.removeEventListener("test", null, i));
  } catch {
  }
  return s;
}();
function Sx(s, i) {
  const l = RO(s, i), u = l && l.match(/^(\d+)(\.\d+)?px$/);
  return u ? +u[1] : void 0;
}
function fd(s, i, l, u) {
  return {
    x: s.x + l * (i.x - s.x),
    y: s.y + l * (i.y - s.y)
  };
}
function UO(s, i, l, u) {
  return {
    x: s.x + l * (i.x - s.x),
    y: u === "middle" ? l < 0.5 ? s.y : i.y : u === "after" ? l < 1 ? s.y : i.y : l > 0 ? i.y : s.y
  };
}
function BO(s, i, l, u) {
  const h = {
    x: s.cp2x,
    y: s.cp2y
  }, g = {
    x: i.cp1x,
    y: i.cp1y
  }, _ = fd(s, h, l), S = fd(h, g, l), T = fd(g, i, l), E = fd(_, S, l), D = fd(S, T, l);
  return fd(E, D, l);
}
const YO = function(s, i) {
  return {
    x(l) {
      return s + s + i - l;
    },
    setWidth(l) {
      i = l;
    },
    textAlign(l) {
      return l === "center" ? l : l === "right" ? "left" : "right";
    },
    xPlus(l, u) {
      return l - u;
    },
    leftForLtr(l, u) {
      return l - u;
    }
  };
}, jO = function() {
  return {
    x(s) {
      return s;
    },
    setWidth(s) {
    },
    textAlign(s) {
      return s;
    },
    xPlus(s, i) {
      return s + i;
    },
    leftForLtr(s, i) {
      return s;
    }
  };
};
function Ib(s, i, l) {
  return s ? YO(i, l) : jO();
}
function qO(s, i) {
  let l, u;
  (i === "ltr" || i === "rtl") && (l = s.canvas.style, u = [
    l.getPropertyValue("direction"),
    l.getPropertyPriority("direction")
  ], l.setProperty("direction", i, "important"), s.prevTextDirection = u);
}
function ZO(s, i) {
  i !== void 0 && (delete s.prevTextDirection, s.canvas.style.setProperty("direction", i[0], i[1]));
}
function qw(s) {
  return s === "angle" ? {
    between: Dw,
    compare: N2,
    normalize: lu
  } : {
    between: Aw,
    compare: (i, l) => i - l,
    normalize: (i) => i
  };
}
function Tx({ start: s, end: i, count: l, loop: u, style: h }) {
  return {
    start: s % l,
    end: i % l,
    loop: u && (i - s + 1) % l === 0,
    style: h
  };
}
function PO(s, i, l) {
  const { property: u, start: h, end: g } = l, { between: _, normalize: S } = qw(u), T = i.length;
  let { start: E, end: D, loop: C } = s, z, j;
  if (C) {
    for (E += T, D += T, z = 0, j = T; z < j && _(S(i[E % T][u]), h, g); ++z)
      E--, D--;
    E %= T, D %= T;
  }
  return D < E && (D += T), {
    start: E,
    end: D,
    loop: C,
    style: s.style
  };
}
function Zw(s, i, l) {
  if (!l)
    return [
      s
    ];
  const { property: u, start: h, end: g } = l, _ = i.length, { compare: S, between: T, normalize: E } = qw(u), { start: D, end: C, loop: z, style: j } = PO(s, i, l), I = [];
  let Q = !1, X = null, nt, Dt, Et;
  const zt = () => T(h, Et, nt) && S(h, Et) !== 0, dt = () => S(g, nt) === 0 || T(g, Et, nt), Lt = () => Q || zt(), Ct = () => !Q || dt();
  for (let Yt = D, wt = D; Yt <= C; ++Yt)
    Dt = i[Yt % _], !Dt.skip && (nt = E(Dt[u]), nt !== Et && (Q = T(nt, h, g), X === null && Lt() && (X = S(nt, h) === 0 ? Yt : wt), X !== null && Ct() && (I.push(Tx({
      start: X,
      end: Yt,
      loop: z,
      count: _,
      style: j
    })), X = null), wt = Yt, Et = nt));
  return X !== null && I.push(Tx({
    start: X,
    end: C,
    loop: z,
    count: _,
    style: j
  })), I;
}
function Pw(s, i) {
  const l = [], u = s.segments;
  for (let h = 0; h < u.length; h++) {
    const g = Zw(u[h], s.points, i);
    g.length && l.push(...g);
  }
  return l;
}
function VO(s, i, l, u) {
  let h = 0, g = i - 1;
  if (l && !u)
    for (; h < i && !s[h].skip; )
      h++;
  for (; h < i && s[h].skip; )
    h++;
  for (h %= i, l && (g += h); g > h && s[g % i].skip; )
    g--;
  return g %= i, {
    start: h,
    end: g
  };
}
function GO(s, i, l, u) {
  const h = s.length, g = [];
  let _ = i, S = s[i], T;
  for (T = i + 1; T <= l; ++T) {
    const E = s[T % h];
    E.skip || E.stop ? S.skip || (u = !1, g.push({
      start: i % h,
      end: (T - 1) % h,
      loop: u
    }), i = _ = E.stop ? T : null) : (_ = T, S.skip && (i = T)), S = E;
  }
  return _ !== null && g.push({
    start: i % h,
    end: _ % h,
    loop: u
  }), g;
}
function XO(s, i) {
  const l = s.points, u = s.options.spanGaps, h = l.length;
  if (!h)
    return [];
  const g = !!s._loop, { start: _, end: S } = VO(l, h, g, u);
  if (u === !0)
    return xx(s, [
      {
        start: _,
        end: S,
        loop: g
      }
    ], l, i);
  const T = S < _ ? S + h : S, E = !!s._fullLoop && _ === 0 && S === h - 1;
  return xx(s, GO(l, _, T, E), l, i);
}
function xx(s, i, l, u) {
  return !u || !u.setContext || !l ? i : QO(s, i, l, u);
}
function QO(s, i, l, u) {
  const h = s._chart.getContext(), g = wx(s.options), { _datasetIndex: _, options: { spanGaps: S } } = s, T = l.length, E = [];
  let D = g, C = i[0].start, z = C;
  function j(I, Q, X, nt) {
    const Dt = S ? -1 : 1;
    if (I !== Q) {
      for (I += T; l[I % T].skip; )
        I -= Dt;
      for (; l[Q % T].skip; )
        Q += Dt;
      I % T !== Q % T && (E.push({
        start: I % T,
        end: Q % T,
        loop: X,
        style: nt
      }), D = nt, C = Q % T);
    }
  }
  for (const I of i) {
    C = S ? C : I.start;
    let Q = l[C % T], X;
    for (z = C + 1; z <= I.end; z++) {
      const nt = l[z % T];
      X = wx(u.setContext(yd(h, {
        type: "segment",
        p0: Q,
        p1: nt,
        p0DataIndex: (z - 1) % T,
        p1DataIndex: z % T,
        datasetIndex: _
      }))), KO(X, D) && j(C, z - 1, I.loop, D), Q = nt, D = X;
    }
    C < z - 1 && j(C, z - 1, I.loop, D);
  }
  return E;
}
function wx(s) {
  return {
    backgroundColor: s.backgroundColor,
    borderCapStyle: s.borderCapStyle,
    borderDash: s.borderDash,
    borderDashOffset: s.borderDashOffset,
    borderJoinStyle: s.borderJoinStyle,
    borderWidth: s.borderWidth,
    borderColor: s.borderColor
  };
}
function KO(s, i) {
  if (!i)
    return !1;
  const l = [], u = function(h, g) {
    return w1(g) ? (l.includes(g) || l.push(g), l.indexOf(g)) : g;
  };
  return JSON.stringify(s, u) !== JSON.stringify(i, u);
}
function s0(s, i, l) {
  return s.options.clip ? s[l] : i[l];
}
function WO(s, i) {
  const { xScale: l, yScale: u } = s;
  return l && u ? {
    left: s0(l, i, "left"),
    right: s0(l, i, "right"),
    top: s0(u, i, "top"),
    bottom: s0(u, i, "bottom")
  } : i;
}
function Vw(s, i) {
  const l = i._clip;
  if (l.disabled)
    return !1;
  const u = WO(i, s.chartArea);
  return {
    left: l.left === !1 ? 0 : u.left - (l.left === !0 ? 0 : l.left),
    right: l.right === !1 ? s.width : u.right + (l.right === !0 ? 0 : l.right),
    top: l.top === !1 ? 0 : u.top - (l.top === !0 ? 0 : l.top),
    bottom: l.bottom === !1 ? s.height : u.bottom + (l.bottom === !0 ? 0 : l.bottom)
  };
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
class IO {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(i, l, u, h) {
    const g = l.listeners[h], _ = l.duration;
    g.forEach((S) => S({
      chart: i,
      initial: l.initial,
      numSteps: _,
      currentStep: Math.min(u - l.start, _)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Cw.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(i = Date.now()) {
    let l = 0;
    this._charts.forEach((u, h) => {
      if (!u.running || !u.items.length)
        return;
      const g = u.items;
      let _ = g.length - 1, S = !1, T;
      for (; _ >= 0; --_)
        T = g[_], T._active ? (T._total > u.duration && (u.duration = T._total), T.tick(i), S = !0) : (g[_] = g[g.length - 1], g.pop());
      S && (h.draw(), this._notify(h, u, i, "progress")), g.length || (u.running = !1, this._notify(h, u, i, "complete"), u.initial = !1), l += g.length;
    }), this._lastDate = i, l === 0 && (this._running = !1);
  }
  _getAnims(i) {
    const l = this._charts;
    let u = l.get(i);
    return u || (u = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, l.set(i, u)), u;
  }
  listen(i, l, u) {
    this._getAnims(i).listeners[l].push(u);
  }
  add(i, l) {
    !l || !l.length || this._getAnims(i).items.push(...l);
  }
  has(i) {
    return this._getAnims(i).items.length > 0;
  }
  start(i) {
    const l = this._charts.get(i);
    l && (l.running = !0, l.start = Date.now(), l.duration = l.items.reduce((u, h) => Math.max(u, h._duration), 0), this._refresh());
  }
  running(i) {
    if (!this._running)
      return !1;
    const l = this._charts.get(i);
    return !(!l || !l.running || !l.items.length);
  }
  stop(i) {
    const l = this._charts.get(i);
    if (!l || !l.items.length)
      return;
    const u = l.items;
    let h = u.length - 1;
    for (; h >= 0; --h)
      u[h].cancel();
    l.items = [], this._notify(i, l, Date.now(), "complete");
  }
  remove(i) {
    return this._charts.delete(i);
  }
}
var cc = /* @__PURE__ */ new IO();
const Mx = "transparent", $O = {
  boolean(s, i, l) {
    return l > 0.5 ? i : s;
  },
  color(s, i, l) {
    const u = hx(s || Mx), h = u.valid && hx(i || Mx);
    return h && h.valid ? h.mix(u, l).hexString() : i;
  },
  number(s, i, l) {
    return s + (i - s) * l;
  }
};
class JO {
  constructor(i, l, u, h) {
    const g = l[u];
    h = a0([
      i.to,
      h,
      g,
      i.from
    ]);
    const _ = a0([
      i.from,
      g,
      h
    ]);
    this._active = !0, this._fn = i.fn || $O[i.type || typeof _], this._easing = hv[i.easing] || hv.linear, this._start = Math.floor(Date.now() + (i.delay || 0)), this._duration = this._total = Math.floor(i.duration), this._loop = !!i.loop, this._target = l, this._prop = u, this._from = _, this._to = h, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(i, l, u) {
    if (this._active) {
      this._notify(!1);
      const h = this._target[this._prop], g = u - this._start, _ = this._duration - g;
      this._start = u, this._duration = Math.floor(Math.max(_, i.duration)), this._total += g, this._loop = !!i.loop, this._to = a0([
        i.to,
        l,
        h,
        i.from
      ]), this._from = a0([
        i.from,
        h,
        l
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(i) {
    const l = i - this._start, u = this._duration, h = this._prop, g = this._from, _ = this._loop, S = this._to;
    let T;
    if (this._active = g !== S && (_ || l < u), !this._active) {
      this._target[h] = S, this._notify(!0);
      return;
    }
    if (l < 0) {
      this._target[h] = g;
      return;
    }
    T = l / u % 2, T = _ && T > 1 ? 2 - T : T, T = this._easing(Math.min(1, Math.max(0, T))), this._target[h] = this._fn(g, S, T);
  }
  wait() {
    const i = this._promises || (this._promises = []);
    return new Promise((l, u) => {
      i.push({
        res: l,
        rej: u
      });
    });
  }
  _notify(i) {
    const l = i ? "res" : "rej", u = this._promises || [];
    for (let h = 0; h < u.length; h++)
      u[h][l]();
  }
}
class Gw {
  constructor(i, l) {
    this._chart = i, this._properties = /* @__PURE__ */ new Map(), this.configure(l);
  }
  configure(i) {
    if (!Ve(i))
      return;
    const l = Object.keys(Mi.animation), u = this._properties;
    Object.getOwnPropertyNames(i).forEach((h) => {
      const g = i[h];
      if (!Ve(g))
        return;
      const _ = {};
      for (const S of l)
        _[S] = g[S];
      (Fi(g.properties) && g.properties || [
        h
      ]).forEach((S) => {
        (S === h || !u.has(S)) && u.set(S, _);
      });
    });
  }
  _animateOptions(i, l) {
    const u = l.options, h = tD(i, u);
    if (!h)
      return [];
    const g = this._createAnimations(h, u);
    return u.$shared && FO(i.options.$animations, u).then(() => {
      i.options = u;
    }, () => {
    }), g;
  }
  _createAnimations(i, l) {
    const u = this._properties, h = [], g = i.$animations || (i.$animations = {}), _ = Object.keys(l), S = Date.now();
    let T;
    for (T = _.length - 1; T >= 0; --T) {
      const E = _[T];
      if (E.charAt(0) === "$")
        continue;
      if (E === "options") {
        h.push(...this._animateOptions(i, l));
        continue;
      }
      const D = l[E];
      let C = g[E];
      const z = u.get(E);
      if (C)
        if (z && C.active()) {
          C.update(z, D, S);
          continue;
        } else
          C.cancel();
      if (!z || !z.duration) {
        i[E] = D;
        continue;
      }
      g[E] = C = new JO(z, i, E, D), h.push(C);
    }
    return h;
  }
  update(i, l) {
    if (this._properties.size === 0) {
      Object.assign(i, l);
      return;
    }
    const u = this._createAnimations(i, l);
    if (u.length)
      return cc.add(this._chart, u), !0;
  }
}
function FO(s, i) {
  const l = [], u = Object.keys(i);
  for (let h = 0; h < u.length; h++) {
    const g = s[u[h]];
    g && g.active() && l.push(g.wait());
  }
  return Promise.all(l);
}
function tD(s, i) {
  if (!i)
    return;
  let l = s.options;
  if (!l) {
    s.options = i;
    return;
  }
  return l.$shared && (s.options = l = Object.assign({}, l, {
    $shared: !1,
    $animations: {}
  })), l;
}
function Ex(s, i) {
  const l = s && s.options || {}, u = l.reverse, h = l.min === void 0 ? i : 0, g = l.max === void 0 ? i : 0;
  return {
    start: u ? g : h,
    end: u ? h : g
  };
}
function eD(s, i, l) {
  if (l === !1)
    return !1;
  const u = Ex(s, l), h = Ex(i, l);
  return {
    top: h.end,
    right: u.end,
    bottom: h.start,
    left: u.start
  };
}
function nD(s) {
  let i, l, u, h;
  return Ve(s) ? (i = s.top, l = s.right, u = s.bottom, h = s.left) : i = l = u = h = s, {
    top: i,
    right: l,
    bottom: u,
    left: h,
    disabled: s === !1
  };
}
function Xw(s, i) {
  const l = [], u = s._getSortedDatasetMetas(i);
  let h, g;
  for (h = 0, g = u.length; h < g; ++h)
    l.push(u[h].index);
  return l;
}
function Ox(s, i, l, u = {}) {
  const h = s.keys, g = u.mode === "single";
  let _, S, T, E;
  if (i === null)
    return;
  let D = !1;
  for (_ = 0, S = h.length; _ < S; ++_) {
    if (T = +h[_], T === l) {
      if (D = !0, u.all)
        continue;
      break;
    }
    E = s.values[T], qa(E) && (g || i === 0 || zp(i) === zp(E)) && (i += E);
  }
  return !D && !u.all ? 0 : i;
}
function iD(s, i) {
  const { iScale: l, vScale: u } = i, h = l.axis === "x" ? "x" : "y", g = u.axis === "x" ? "x" : "y", _ = Object.keys(s), S = new Array(_.length);
  let T, E, D;
  for (T = 0, E = _.length; T < E; ++T)
    D = _[T], S[T] = {
      [h]: D,
      [g]: s[D]
    };
  return S;
}
function $b(s, i) {
  const l = s && s.options.stacked;
  return l || l === void 0 && i.stack !== void 0;
}
function aD(s, i, l) {
  return `${s.id}.${i.id}.${l.stack || l.type}`;
}
function oD(s) {
  const { min: i, max: l, minDefined: u, maxDefined: h } = s.getUserBounds();
  return {
    min: u ? i : Number.NEGATIVE_INFINITY,
    max: h ? l : Number.POSITIVE_INFINITY
  };
}
function lD(s, i, l) {
  const u = s[i] || (s[i] = {});
  return u[l] || (u[l] = {});
}
function Dx(s, i, l, u) {
  for (const h of i.getMatchingVisibleMetas(u).reverse()) {
    const g = s[h.index];
    if (l && g > 0 || !l && g < 0)
      return h.index;
  }
  return null;
}
function Ax(s, i) {
  const { chart: l, _cachedMeta: u } = s, h = l._stacks || (l._stacks = {}), { iScale: g, vScale: _, index: S } = u, T = g.axis, E = _.axis, D = aD(g, _, u), C = i.length;
  let z;
  for (let j = 0; j < C; ++j) {
    const I = i[j], { [T]: Q, [E]: X } = I, nt = I._stacks || (I._stacks = {});
    z = nt[E] = lD(h, D, Q), z[S] = X, z._top = Dx(z, _, !0, u.type), z._bottom = Dx(z, _, !1, u.type);
    const Dt = z._visualValues || (z._visualValues = {});
    Dt[S] = X;
  }
}
function Jb(s, i) {
  const l = s.scales;
  return Object.keys(l).filter((u) => l[u].axis === i).shift();
}
function sD(s, i) {
  return yd(s, {
    active: !1,
    dataset: void 0,
    datasetIndex: i,
    index: i,
    mode: "default",
    type: "dataset"
  });
}
function rD(s, i, l) {
  return yd(s, {
    active: !1,
    dataIndex: i,
    parsed: void 0,
    raw: void 0,
    element: l,
    index: i,
    mode: "default",
    type: "data"
  });
}
function $y(s, i) {
  const l = s.controller.index, u = s.vScale && s.vScale.axis;
  if (u) {
    i = i || s._parsed;
    for (const h of i) {
      const g = h._stacks;
      if (!g || g[u] === void 0 || g[u][l] === void 0)
        return;
      delete g[u][l], g[u]._visualValues !== void 0 && g[u]._visualValues[l] !== void 0 && delete g[u]._visualValues[l];
    }
  }
}
const Fb = (s) => s === "reset" || s === "none", Rx = (s, i) => i ? s : Object.assign({}, s), uD = (s, i, l) => s && !i.hidden && i._stacked && {
  keys: Xw(l, !0),
  values: null
};
class Qw {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(i, l) {
    this.chart = i, this._ctx = i.ctx, this.index = l, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const i = this._cachedMeta;
    this.configure(), this.linkScales(), i._stacked = $b(i.vScale, i), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(i) {
    this.index !== i && $y(this._cachedMeta), this.index = i;
  }
  linkScales() {
    const i = this.chart, l = this._cachedMeta, u = this.getDataset(), h = (C, z, j, I) => C === "x" ? z : C === "r" ? I : j, g = l.xAxisID = gn(u.xAxisID, Jb(i, "x")), _ = l.yAxisID = gn(u.yAxisID, Jb(i, "y")), S = l.rAxisID = gn(u.rAxisID, Jb(i, "r")), T = l.indexAxis, E = l.iAxisID = h(T, g, _, S), D = l.vAxisID = h(T, _, g, S);
    l.xScale = this.getScaleForId(g), l.yScale = this.getScaleForId(_), l.rScale = this.getScaleForId(S), l.iScale = this.getScaleForId(E), l.vScale = this.getScaleForId(D);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(i) {
    return this.chart.scales[i];
  }
  _getOtherScale(i) {
    const l = this._cachedMeta;
    return i === l.iScale ? l.vScale : l.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const i = this._cachedMeta;
    this._data && rx(this._data, this), i._stacked && $y(i);
  }
  _dataCheck() {
    const i = this.getDataset(), l = i.data || (i.data = []), u = this._data;
    if (Ve(l)) {
      const h = this._cachedMeta;
      this._data = iD(l, h);
    } else if (u !== l) {
      if (u) {
        rx(u, this);
        const h = this._cachedMeta;
        $y(h), h._parsed = [];
      }
      l && Object.isExtensible(l) && j2(l, this), this._syncList = [], this._data = l;
    }
  }
  addElements() {
    const i = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (i.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(i) {
    const l = this._cachedMeta, u = this.getDataset();
    let h = !1;
    this._dataCheck();
    const g = l._stacked;
    l._stacked = $b(l.vScale, l), l.stack !== u.stack && (h = !0, $y(l), l.stack = u.stack), this._resyncElements(i), (h || g !== l._stacked) && (Ax(this, l._parsed), l._stacked = $b(l.vScale, l));
  }
  configure() {
    const i = this.chart.config, l = i.datasetScopeKeys(this._type), u = i.getOptionScopes(this.getDataset(), l, !0);
    this.options = i.createResolver(u, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(i, l) {
    const { _cachedMeta: u, _data: h } = this, { iScale: g, _stacked: _ } = u, S = g.axis;
    let T = i === 0 && l === h.length ? !0 : u._sorted, E = i > 0 && u._parsed[i - 1], D, C, z;
    if (this._parsing === !1)
      u._parsed = h, u._sorted = !0, z = h;
    else {
      Fi(h[i]) ? z = this.parseArrayData(u, h, i, l) : Ve(h[i]) ? z = this.parseObjectData(u, h, i, l) : z = this.parsePrimitiveData(u, h, i, l);
      const j = () => C[S] === null || E && C[S] < E[S];
      for (D = 0; D < l; ++D)
        u._parsed[D + i] = C = z[D], T && (j() && (T = !1), E = C);
      u._sorted = T;
    }
    _ && Ax(this, z);
  }
  parsePrimitiveData(i, l, u, h) {
    const { iScale: g, vScale: _ } = i, S = g.axis, T = _.axis, E = g.getLabels(), D = g === _, C = new Array(h);
    let z, j, I;
    for (z = 0, j = h; z < j; ++z)
      I = z + u, C[z] = {
        [S]: D || g.parse(E[I], I),
        [T]: _.parse(l[I], I)
      };
    return C;
  }
  parseArrayData(i, l, u, h) {
    const { xScale: g, yScale: _ } = i, S = new Array(h);
    let T, E, D, C;
    for (T = 0, E = h; T < E; ++T)
      D = T + u, C = l[D], S[T] = {
        x: g.parse(C[0], D),
        y: _.parse(C[1], D)
      };
    return S;
  }
  parseObjectData(i, l, u, h) {
    const { xScale: g, yScale: _ } = i, { xAxisKey: S = "x", yAxisKey: T = "y" } = this._parsing, E = new Array(h);
    let D, C, z, j;
    for (D = 0, C = h; D < C; ++D)
      z = D + u, j = l[z], E[D] = {
        x: g.parse(S0(j, S), z),
        y: _.parse(S0(j, T), z)
      };
    return E;
  }
  getParsed(i) {
    return this._cachedMeta._parsed[i];
  }
  getDataElement(i) {
    return this._cachedMeta.data[i];
  }
  applyStack(i, l, u) {
    const h = this.chart, g = this._cachedMeta, _ = l[i.axis], S = {
      keys: Xw(h, !0),
      values: l._stacks[i.axis]._visualValues
    };
    return Ox(S, _, g.index, {
      mode: u
    });
  }
  updateRangeFromParsed(i, l, u, h) {
    const g = u[l.axis];
    let _ = g === null ? NaN : g;
    const S = h && u._stacks[l.axis];
    h && S && (h.values = S, _ = Ox(h, g, this._cachedMeta.index)), i.min = Math.min(i.min, _), i.max = Math.max(i.max, _);
  }
  getMinMax(i, l) {
    const u = this._cachedMeta, h = u._parsed, g = u._sorted && i === u.iScale, _ = h.length, S = this._getOtherScale(i), T = uD(l, u, this.chart), E = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: D, max: C } = oD(S);
    let z, j;
    function I() {
      j = h[z];
      const Q = j[S.axis];
      return !qa(j[i.axis]) || D > Q || C < Q;
    }
    for (z = 0; z < _ && !(!I() && (this.updateRangeFromParsed(E, i, j, T), g)); ++z)
      ;
    if (g) {
      for (z = _ - 1; z >= 0; --z)
        if (!I()) {
          this.updateRangeFromParsed(E, i, j, T);
          break;
        }
    }
    return E;
  }
  getAllParsedValues(i) {
    const l = this._cachedMeta._parsed, u = [];
    let h, g, _;
    for (h = 0, g = l.length; h < g; ++h)
      _ = l[h][i.axis], qa(_) && u.push(_);
    return u;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(i) {
    const l = this._cachedMeta, u = l.iScale, h = l.vScale, g = this.getParsed(i);
    return {
      label: u ? "" + u.getLabelForValue(g[u.axis]) : "",
      value: h ? "" + h.getLabelForValue(g[h.axis]) : ""
    };
  }
  _update(i) {
    const l = this._cachedMeta;
    this.update(i || "default"), l._clip = nD(gn(this.options.clip, eD(l.xScale, l.yScale, this.getMaxOverflow())));
  }
  update(i) {
  }
  draw() {
    const i = this._ctx, l = this.chart, u = this._cachedMeta, h = u.data || [], g = l.chartArea, _ = [], S = this._drawStart || 0, T = this._drawCount || h.length - S, E = this.options.drawActiveElementsOnTop;
    let D;
    for (u.dataset && u.dataset.draw(i, g, S, T), D = S; D < S + T; ++D) {
      const C = h[D];
      C.hidden || (C.active && E ? _.push(C) : C.draw(i, g));
    }
    for (D = 0; D < _.length; ++D)
      _[D].draw(i, g);
  }
  getStyle(i, l) {
    const u = l ? "active" : "default";
    return i === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(u) : this.resolveDataElementOptions(i || 0, u);
  }
  getContext(i, l, u) {
    const h = this.getDataset();
    let g;
    if (i >= 0 && i < this._cachedMeta.data.length) {
      const _ = this._cachedMeta.data[i];
      g = _.$context || (_.$context = rD(this.getContext(), i, _)), g.parsed = this.getParsed(i), g.raw = h.data[i], g.index = g.dataIndex = i;
    } else
      g = this.$context || (this.$context = sD(this.chart.getContext(), this.index)), g.dataset = h, g.index = g.datasetIndex = this.index;
    return g.active = !!l, g.mode = u, g;
  }
  resolveDatasetElementOptions(i) {
    return this._resolveElementOptions(this.datasetElementType.id, i);
  }
  resolveDataElementOptions(i, l) {
    return this._resolveElementOptions(this.dataElementType.id, l, i);
  }
  _resolveElementOptions(i, l = "default", u) {
    const h = l === "active", g = this._cachedDataOpts, _ = i + "-" + l, S = g[_], T = this.enableOptionSharing && T0(u);
    if (S)
      return Rx(S, T);
    const E = this.chart.config, D = E.datasetElementScopeKeys(this._type, i), C = h ? [
      `${i}Hover`,
      "hover",
      i,
      ""
    ] : [
      i,
      ""
    ], z = E.getOptionScopes(this.getDataset(), D), j = Object.keys(Mi.elements[i]), I = () => this.getContext(u, h, l), Q = E.resolveNamedOptions(z, j, I, C);
    return Q.$shared && (Q.$shared = T, g[_] = Object.freeze(Rx(Q, T))), Q;
  }
  _resolveAnimations(i, l, u) {
    const h = this.chart, g = this._cachedDataOpts, _ = `animation-${l}`, S = g[_];
    if (S)
      return S;
    let T;
    if (h.options.animation !== !1) {
      const D = this.chart.config, C = D.datasetAnimationScopeKeys(this._type, l), z = D.getOptionScopes(this.getDataset(), C);
      T = D.createResolver(z, this.getContext(i, u, l));
    }
    const E = new Gw(h, T && T.animations);
    return T && T._cacheable && (g[_] = Object.freeze(E)), E;
  }
  getSharedOptions(i) {
    if (i.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, i));
  }
  includeOptions(i, l) {
    return !l || Fb(i) || this.chart._animationsDisabled;
  }
  _getSharedOptions(i, l) {
    const u = this.resolveDataElementOptions(i, l), h = this._sharedOptions, g = this.getSharedOptions(u), _ = this.includeOptions(l, g) || g !== h;
    return this.updateSharedOptions(g, l, u), {
      sharedOptions: g,
      includeOptions: _
    };
  }
  updateElement(i, l, u, h) {
    Fb(h) ? Object.assign(i, u) : this._resolveAnimations(l, h).update(i, u);
  }
  updateSharedOptions(i, l, u) {
    i && !Fb(l) && this._resolveAnimations(void 0, l).update(i, u);
  }
  _setStyle(i, l, u, h) {
    i.active = h;
    const g = this.getStyle(l, h);
    this._resolveAnimations(l, u, h).update(i, {
      options: !h && this.getSharedOptions(g) || g
    });
  }
  removeHoverStyle(i, l, u) {
    this._setStyle(i, u, "active", !1);
  }
  setHoverStyle(i, l, u) {
    this._setStyle(i, u, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const i = this._cachedMeta.dataset;
    i && this._setStyle(i, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const i = this._cachedMeta.dataset;
    i && this._setStyle(i, void 0, "active", !0);
  }
  _resyncElements(i) {
    const l = this._data, u = this._cachedMeta.data;
    for (const [S, T, E] of this._syncList)
      this[S](T, E);
    this._syncList = [];
    const h = u.length, g = l.length, _ = Math.min(g, h);
    _ && this.parse(0, _), g > h ? this._insertElements(h, g - h, i) : g < h && this._removeElements(g, h - g);
  }
  _insertElements(i, l, u = !0) {
    const h = this._cachedMeta, g = h.data, _ = i + l;
    let S;
    const T = (E) => {
      for (E.length += l, S = E.length - 1; S >= _; S--)
        E[S] = E[S - l];
    };
    for (T(g), S = i; S < _; ++S)
      g[S] = new this.dataElementType();
    this._parsing && T(h._parsed), this.parse(i, l), u && this.updateElements(g, i, l, "reset");
  }
  updateElements(i, l, u, h) {
  }
  _removeElements(i, l) {
    const u = this._cachedMeta;
    if (this._parsing) {
      const h = u._parsed.splice(i, l);
      u._stacked && $y(u, h);
    }
    u.data.splice(i, l);
  }
  _sync(i) {
    if (this._parsing)
      this._syncList.push(i);
    else {
      const [l, u, h] = i;
      this[l](u, h);
    }
    this.chart._dataChanges.push([
      this.index,
      ...i
    ]);
  }
  _onDataPush() {
    const i = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - i,
      i
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(i, l) {
    l && this._sync([
      "_removeElements",
      i,
      l
    ]);
    const u = arguments.length - 2;
    u && this._sync([
      "_insertElements",
      i,
      u
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
class cD extends Qw {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(i) {
    const l = this._cachedMeta, { dataset: u, data: h = [], _dataset: g } = l, _ = this.chart._animationsDisabled;
    let { start: S, count: T } = V2(l, h, _);
    this._drawStart = S, this._drawCount = T, G2(l) && (S = 0, T = h.length), u._chart = this.chart, u._datasetIndex = this.index, u._decimated = !!g._decimated, u.points = h;
    const E = this.resolveDatasetElementOptions(i);
    this.options.showLine || (E.borderWidth = 0), E.segment = this.options.segment, this.updateElement(u, void 0, {
      animated: !_,
      options: E
    }, i), this.updateElements(h, S, T, i);
  }
  updateElements(i, l, u, h) {
    const g = h === "reset", { iScale: _, vScale: S, _stacked: T, _dataset: E } = this._cachedMeta, { sharedOptions: D, includeOptions: C } = this._getSharedOptions(l, h), z = _.axis, j = S.axis, { spanGaps: I, segment: Q } = this.options, X = vv(I) ? I : Number.POSITIVE_INFINITY, nt = this.chart._animationsDisabled || g || h === "none", Dt = l + u, Et = i.length;
    let zt = l > 0 && this.getParsed(l - 1);
    for (let dt = 0; dt < Et; ++dt) {
      const Lt = i[dt], Ct = nt ? Lt : {};
      if (dt < l || dt >= Dt) {
        Ct.skip = !0;
        continue;
      }
      const Yt = this.getParsed(dt), wt = Mn(Yt[j]), ne = Ct[z] = _.getPixelForValue(Yt[z], dt), Rt = Ct[j] = g || wt ? S.getBasePixel() : S.getPixelForValue(T ? this.applyStack(S, Yt, T) : Yt[j], dt);
      Ct.skip = isNaN(ne) || isNaN(Rt) || wt, Ct.stop = dt > 0 && Math.abs(Yt[z] - zt[z]) > X, Q && (Ct.parsed = Yt, Ct.raw = E.data[dt]), C && (Ct.options = D || this.resolveDataElementOptions(dt, Lt.active ? "active" : h)), nt || this.updateElement(Lt, dt, Ct, h), zt = Yt;
    }
  }
  getMaxOverflow() {
    const i = this._cachedMeta, l = i.dataset, u = l.options && l.options.borderWidth || 0, h = i.data || [];
    if (!h.length)
      return u;
    const g = h[0].size(this.resolveDataElementOptions(0)), _ = h[h.length - 1].size(this.resolveDataElementOptions(h.length - 1));
    return Math.max(u, g, _) / 2;
  }
  draw() {
    const i = this._cachedMeta;
    i.dataset.updateControlPoints(this.chart.chartArea, i.iScale.axis), super.draw();
  }
}
function ud() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class z1 {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(i) {
    Object.assign(z1.prototype, i);
  }
  options;
  constructor(i) {
    this.options = i || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return ud();
  }
  parse() {
    return ud();
  }
  format() {
    return ud();
  }
  add() {
    return ud();
  }
  diff() {
    return ud();
  }
  startOf() {
    return ud();
  }
  endOf() {
    return ud();
  }
}
var Kw = {
  _date: z1
};
function fD(s, i, l, u) {
  const { controller: h, data: g, _sorted: _ } = s, S = h._cachedMeta.iScale, T = s.dataset && s.dataset.options ? s.dataset.options.spanGaps : null;
  if (S && i === S.axis && i !== "r" && _ && g.length) {
    const E = S._reversePixels ? B2 : md;
    if (u) {
      if (h._sharedOptions) {
        const D = g[0], C = typeof D.getRange == "function" && D.getRange(i);
        if (C) {
          const z = E(g, i, l - C), j = E(g, i, l + C);
          return {
            lo: z.lo,
            hi: j.hi
          };
        }
      }
    } else {
      const D = E(g, i, l);
      if (T) {
        const { vScale: C } = h._cachedMeta, { _parsed: z } = s, j = z.slice(0, D.lo + 1).reverse().findIndex((Q) => !Mn(Q[C.axis]));
        D.lo -= Math.max(0, j);
        const I = z.slice(D.hi).findIndex((Q) => !Mn(Q[C.axis]));
        D.hi += Math.max(0, I);
      }
      return D;
    }
  }
  return {
    lo: 0,
    hi: g.length - 1
  };
}
function A0(s, i, l, u, h) {
  const g = s.getSortedVisibleDatasetMetas(), _ = l[i];
  for (let S = 0, T = g.length; S < T; ++S) {
    const { index: E, data: D } = g[S], { lo: C, hi: z } = fD(g[S], i, _, h);
    for (let j = C; j <= z; ++j) {
      const I = D[j];
      I.skip || u(I, E, j);
    }
  }
}
function hD(s) {
  const i = s.indexOf("x") !== -1, l = s.indexOf("y") !== -1;
  return function(u, h) {
    const g = i ? Math.abs(u.x - h.x) : 0, _ = l ? Math.abs(u.y - h.y) : 0;
    return Math.sqrt(Math.pow(g, 2) + Math.pow(_, 2));
  };
}
function t1(s, i, l, u, h) {
  const g = [];
  return !h && !s.isPointInArea(i) || A0(s, l, i, function(S, T, E) {
    !h && !_v(S, s.chartArea, 0) || S.inRange(i.x, i.y, u) && g.push({
      element: S,
      datasetIndex: T,
      index: E
    });
  }, !0), g;
}
function dD(s, i, l, u) {
  let h = [];
  function g(_, S, T) {
    const { startAngle: E, endAngle: D } = _.getProps([
      "startAngle",
      "endAngle"
    ], u), { angle: C } = k2(_, {
      x: i.x,
      y: i.y
    });
    Dw(C, E, D) && h.push({
      element: _,
      datasetIndex: S,
      index: T
    });
  }
  return A0(s, l, i, g), h;
}
function mD(s, i, l, u, h, g) {
  let _ = [];
  const S = hD(l);
  let T = Number.POSITIVE_INFINITY;
  function E(D, C, z) {
    const j = D.inRange(i.x, i.y, h);
    if (u && !j)
      return;
    const I = D.getCenterPoint(h);
    if (!(!!g || s.isPointInArea(I)) && !j)
      return;
    const X = S(i, I);
    X < T ? (_ = [
      {
        element: D,
        datasetIndex: C,
        index: z
      }
    ], T = X) : X === T && _.push({
      element: D,
      datasetIndex: C,
      index: z
    });
  }
  return A0(s, l, i, E), _;
}
function e1(s, i, l, u, h, g) {
  return !g && !s.isPointInArea(i) ? [] : l === "r" && !u ? dD(s, i, l, h) : mD(s, i, l, u, h, g);
}
function Cx(s, i, l, u, h) {
  const g = [], _ = l === "x" ? "inXRange" : "inYRange";
  let S = !1;
  return A0(s, l, i, (T, E, D) => {
    T[_] && T[_](i[l], h) && (g.push({
      element: T,
      datasetIndex: E,
      index: D
    }), S = S || T.inRange(i.x, i.y, h));
  }), u && !S ? [] : g;
}
var pD = {
  modes: {
    index(s, i, l, u) {
      const h = cd(i, s), g = l.axis || "x", _ = l.includeInvisible || !1, S = l.intersect ? t1(s, h, g, u, _) : e1(s, h, g, !1, u, _), T = [];
      return S.length ? (s.getSortedVisibleDatasetMetas().forEach((E) => {
        const D = S[0].index, C = E.data[D];
        C && !C.skip && T.push({
          element: C,
          datasetIndex: E.index,
          index: D
        });
      }), T) : [];
    },
    dataset(s, i, l, u) {
      const h = cd(i, s), g = l.axis || "xy", _ = l.includeInvisible || !1;
      let S = l.intersect ? t1(s, h, g, u, _) : e1(s, h, g, !1, u, _);
      if (S.length > 0) {
        const T = S[0].datasetIndex, E = s.getDatasetMeta(T).data;
        S = [];
        for (let D = 0; D < E.length; ++D)
          S.push({
            element: E[D],
            datasetIndex: T,
            index: D
          });
      }
      return S;
    },
    point(s, i, l, u) {
      const h = cd(i, s), g = l.axis || "xy", _ = l.includeInvisible || !1;
      return t1(s, h, g, u, _);
    },
    nearest(s, i, l, u) {
      const h = cd(i, s), g = l.axis || "xy", _ = l.includeInvisible || !1;
      return e1(s, h, g, l.intersect, u, _);
    },
    x(s, i, l, u) {
      const h = cd(i, s);
      return Cx(s, h, "x", l.intersect, u);
    },
    y(s, i, l, u) {
      const h = cd(i, s);
      return Cx(s, h, "y", l.intersect, u);
    }
  }
};
const Ww = [
  "left",
  "top",
  "right",
  "bottom"
];
function Jy(s, i) {
  return s.filter((l) => l.pos === i);
}
function zx(s, i) {
  return s.filter((l) => Ww.indexOf(l.pos) === -1 && l.box.axis === i);
}
function Fy(s, i) {
  return s.sort((l, u) => {
    const h = i ? u : l, g = i ? l : u;
    return h.weight === g.weight ? h.index - g.index : h.weight - g.weight;
  });
}
function gD(s) {
  const i = [];
  let l, u, h, g, _, S;
  for (l = 0, u = (s || []).length; l < u; ++l)
    h = s[l], { position: g, options: { stack: _, stackWeight: S = 1 } } = h, i.push({
      index: l,
      box: h,
      pos: g,
      horizontal: h.isHorizontal(),
      weight: h.weight,
      stack: _ && g + _,
      stackWeight: S
    });
  return i;
}
function yD(s) {
  const i = {};
  for (const l of s) {
    const { stack: u, pos: h, stackWeight: g } = l;
    if (!u || !Ww.includes(h))
      continue;
    const _ = i[u] || (i[u] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _.count++, _.weight += g;
  }
  return i;
}
function vD(s, i) {
  const l = yD(s), { vBoxMaxWidth: u, hBoxMaxHeight: h } = i;
  let g, _, S;
  for (g = 0, _ = s.length; g < _; ++g) {
    S = s[g];
    const { fullSize: T } = S.box, E = l[S.stack], D = E && S.stackWeight / E.weight;
    S.horizontal ? (S.width = D ? D * u : T && i.availableWidth, S.height = h) : (S.width = u, S.height = D ? D * h : T && i.availableHeight);
  }
  return l;
}
function _D(s) {
  const i = gD(s), l = Fy(i.filter((E) => E.box.fullSize), !0), u = Fy(Jy(i, "left"), !0), h = Fy(Jy(i, "right")), g = Fy(Jy(i, "top"), !0), _ = Fy(Jy(i, "bottom")), S = zx(i, "x"), T = zx(i, "y");
  return {
    fullSize: l,
    leftAndTop: u.concat(g),
    rightAndBottom: h.concat(T).concat(_).concat(S),
    chartArea: Jy(i, "chartArea"),
    vertical: u.concat(h).concat(T),
    horizontal: g.concat(_).concat(S)
  };
}
function Lx(s, i, l, u) {
  return Math.max(s[l], i[l]) + Math.max(s[u], i[u]);
}
function Iw(s, i) {
  s.top = Math.max(s.top, i.top), s.left = Math.max(s.left, i.left), s.bottom = Math.max(s.bottom, i.bottom), s.right = Math.max(s.right, i.right);
}
function bD(s, i, l, u) {
  const { pos: h, box: g } = l, _ = s.maxPadding;
  if (!Ve(h)) {
    l.size && (s[h] -= l.size);
    const C = u[l.stack] || {
      size: 0,
      count: 1
    };
    C.size = Math.max(C.size, l.horizontal ? g.height : g.width), l.size = C.size / C.count, s[h] += l.size;
  }
  g.getPadding && Iw(_, g.getPadding());
  const S = Math.max(0, i.outerWidth - Lx(_, s, "left", "right")), T = Math.max(0, i.outerHeight - Lx(_, s, "top", "bottom")), E = S !== s.w, D = T !== s.h;
  return s.w = S, s.h = T, l.horizontal ? {
    same: E,
    other: D
  } : {
    same: D,
    other: E
  };
}
function SD(s) {
  const i = s.maxPadding;
  function l(u) {
    const h = Math.max(i[u] - s[u], 0);
    return s[u] += h, h;
  }
  s.y += l("top"), s.x += l("left"), l("right"), l("bottom");
}
function TD(s, i) {
  const l = i.maxPadding;
  function u(h) {
    const g = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return h.forEach((_) => {
      g[_] = Math.max(i[_], l[_]);
    }), g;
  }
  return u(s ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function sv(s, i, l, u) {
  const h = [];
  let g, _, S, T, E, D;
  for (g = 0, _ = s.length, E = 0; g < _; ++g) {
    S = s[g], T = S.box, T.update(S.width || i.w, S.height || i.h, TD(S.horizontal, i));
    const { same: C, other: z } = bD(i, l, S, u);
    E |= C && h.length, D = D || z, T.fullSize || h.push(S);
  }
  return E && sv(h, i, l, u) || D;
}
function r0(s, i, l, u, h) {
  s.top = l, s.left = i, s.right = i + u, s.bottom = l + h, s.width = u, s.height = h;
}
function Hx(s, i, l, u) {
  const h = l.padding;
  let { x: g, y: _ } = i;
  for (const S of s) {
    const T = S.box, E = u[S.stack] || {
      placed: 0,
      weight: 1
    }, D = S.stackWeight / E.weight || 1;
    if (S.horizontal) {
      const C = i.w * D, z = E.size || T.height;
      T0(E.start) && (_ = E.start), T.fullSize ? r0(T, h.left, _, l.outerWidth - h.right - h.left, z) : r0(T, i.left + E.placed, _, C, z), E.start = _, E.placed += C, _ = T.bottom;
    } else {
      const C = i.h * D, z = E.size || T.width;
      T0(E.start) && (g = E.start), T.fullSize ? r0(T, g, h.top, z, l.outerHeight - h.bottom - h.top) : r0(T, g, i.top + E.placed, z, C), E.start = g, E.placed += C, g = T.right;
    }
  }
  i.x = g, i.y = _;
}
var u0 = {
  addBox(s, i) {
    s.boxes || (s.boxes = []), i.fullSize = i.fullSize || !1, i.position = i.position || "top", i.weight = i.weight || 0, i._layers = i._layers || function() {
      return [
        {
          z: 0,
          draw(l) {
            i.draw(l);
          }
        }
      ];
    }, s.boxes.push(i);
  },
  removeBox(s, i) {
    const l = s.boxes ? s.boxes.indexOf(i) : -1;
    l !== -1 && s.boxes.splice(l, 1);
  },
  configure(s, i, l) {
    i.fullSize = l.fullSize, i.position = l.position, i.weight = l.weight;
  },
  update(s, i, l, u) {
    if (!s)
      return;
    const h = Of(s.options.layout.padding), g = Math.max(i - h.width, 0), _ = Math.max(l - h.height, 0), S = _D(s.boxes), T = S.vertical, E = S.horizontal;
    un(s.boxes, (Q) => {
      typeof Q.beforeLayout == "function" && Q.beforeLayout();
    });
    const D = T.reduce((Q, X) => X.box.options && X.box.options.display === !1 ? Q : Q + 1, 0) || 1, C = Object.freeze({
      outerWidth: i,
      outerHeight: l,
      padding: h,
      availableWidth: g,
      availableHeight: _,
      vBoxMaxWidth: g / 2 / D,
      hBoxMaxHeight: _ / 2
    }), z = Object.assign({}, h);
    Iw(z, Of(u));
    const j = Object.assign({
      maxPadding: z,
      w: g,
      h: _,
      x: h.left,
      y: h.top
    }, h), I = vD(T.concat(E), C);
    sv(S.fullSize, j, C, I), sv(T, j, C, I), sv(E, j, C, I) && sv(T, j, C, I), SD(j), Hx(S.leftAndTop, j, C, I), j.x += j.w, j.y += j.h, Hx(S.rightAndBottom, j, C, I), s.chartArea = {
      left: j.left,
      top: j.top,
      right: j.left + j.w,
      bottom: j.top + j.h,
      height: j.h,
      width: j.w
    }, un(S.chartArea, (Q) => {
      const X = Q.box;
      Object.assign(X, s.chartArea), X.update(j.w, j.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class $w {
  acquireContext(i, l) {
  }
  releaseContext(i) {
    return !1;
  }
  addEventListener(i, l, u) {
  }
  removeEventListener(i, l, u) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(i, l, u, h) {
    return l = Math.max(0, l || i.width), u = u || i.height, {
      width: l,
      height: Math.max(0, h ? Math.floor(l / h) : u)
    };
  }
  isAttached(i) {
    return !0;
  }
  updateConfig(i) {
  }
}
class xD extends $w {
  acquireContext(i) {
    return i && i.getContext && i.getContext("2d") || null;
  }
  updateConfig(i) {
    i.options.animation = !1;
  }
}
const y0 = "$chartjs", wD = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, kx = (s) => s === null || s === "";
function MD(s, i) {
  const l = s.style, u = s.getAttribute("height"), h = s.getAttribute("width");
  if (s[y0] = {
    initial: {
      height: u,
      width: h,
      style: {
        display: l.display,
        height: l.height,
        width: l.width
      }
    }
  }, l.display = l.display || "block", l.boxSizing = l.boxSizing || "border-box", kx(h)) {
    const g = Sx(s, "width");
    g !== void 0 && (s.width = g);
  }
  if (kx(u))
    if (s.style.height === "")
      s.height = s.width / (i || 2);
    else {
      const g = Sx(s, "height");
      g !== void 0 && (s.height = g);
    }
  return s;
}
const Jw = NO ? {
  passive: !0
} : !1;
function ED(s, i, l) {
  s && s.addEventListener(i, l, Jw);
}
function OD(s, i, l) {
  s && s.canvas && s.canvas.removeEventListener(i, l, Jw);
}
function DD(s, i) {
  const l = wD[s.type] || s.type, { x: u, y: h } = cd(s, i);
  return {
    type: l,
    chart: i,
    native: s,
    x: u !== void 0 ? u : null,
    y: h !== void 0 ? h : null
  };
}
function M0(s, i) {
  for (const l of s)
    if (l === i || l.contains(i))
      return !0;
}
function AD(s, i, l) {
  const u = s.canvas, h = new MutationObserver((g) => {
    let _ = !1;
    for (const S of g)
      _ = _ || M0(S.addedNodes, u), _ = _ && !M0(S.removedNodes, u);
    _ && l();
  });
  return h.observe(document, {
    childList: !0,
    subtree: !0
  }), h;
}
function RD(s, i, l) {
  const u = s.canvas, h = new MutationObserver((g) => {
    let _ = !1;
    for (const S of g)
      _ = _ || M0(S.removedNodes, u), _ = _ && !M0(S.addedNodes, u);
    _ && l();
  });
  return h.observe(document, {
    childList: !0,
    subtree: !0
  }), h;
}
const bv = /* @__PURE__ */ new Map();
let Nx = 0;
function Fw() {
  const s = window.devicePixelRatio;
  s !== Nx && (Nx = s, bv.forEach((i, l) => {
    l.currentDevicePixelRatio !== s && i();
  }));
}
function CD(s, i) {
  bv.size || window.addEventListener("resize", Fw), bv.set(s, i);
}
function zD(s) {
  bv.delete(s), bv.size || window.removeEventListener("resize", Fw);
}
function LD(s, i, l) {
  const u = s.canvas, h = u && C1(u);
  if (!h)
    return;
  const g = zw((S, T) => {
    const E = h.clientWidth;
    l(S, T), E < h.clientWidth && l();
  }, window), _ = new ResizeObserver((S) => {
    const T = S[0], E = T.contentRect.width, D = T.contentRect.height;
    E === 0 && D === 0 || g(E, D);
  });
  return _.observe(h), CD(s, g), _;
}
function n1(s, i, l) {
  l && l.disconnect(), i === "resize" && zD(s);
}
function HD(s, i, l) {
  const u = s.canvas, h = zw((g) => {
    s.ctx !== null && l(DD(g, s));
  }, s);
  return ED(u, i, h), h;
}
class kD extends $w {
  acquireContext(i, l) {
    const u = i && i.getContext && i.getContext("2d");
    return u && u.canvas === i ? (MD(i, l), u) : null;
  }
  releaseContext(i) {
    const l = i.canvas;
    if (!l[y0])
      return !1;
    const u = l[y0].initial;
    [
      "height",
      "width"
    ].forEach((g) => {
      const _ = u[g];
      Mn(_) ? l.removeAttribute(g) : l.setAttribute(g, _);
    });
    const h = u.style || {};
    return Object.keys(h).forEach((g) => {
      l.style[g] = h[g];
    }), l.width = l.width, delete l[y0], !0;
  }
  addEventListener(i, l, u) {
    this.removeEventListener(i, l);
    const h = i.$proxies || (i.$proxies = {}), _ = {
      attach: AD,
      detach: RD,
      resize: LD
    }[l] || HD;
    h[l] = _(i, l, u);
  }
  removeEventListener(i, l) {
    const u = i.$proxies || (i.$proxies = {}), h = u[l];
    if (!h)
      return;
    ({
      attach: n1,
      detach: n1,
      resize: n1
    }[l] || OD)(i, l, h), u[l] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(i, l, u, h) {
    return kO(i, l, u, h);
  }
  isAttached(i) {
    const l = i && C1(i);
    return !!(l && l.isConnected);
  }
}
function ND(s) {
  return !R1() || typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas ? xD : kD;
}
let Tv = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = !1;
  options;
  $animations;
  tooltipPosition(i) {
    const { x: l, y: u } = this.getProps([
      "x",
      "y"
    ], i);
    return {
      x: l,
      y: u
    };
  }
  hasValue() {
    return vv(this.x) && vv(this.y);
  }
  getProps(i, l) {
    const u = this.$animations;
    if (!l || !u)
      return this;
    const h = {};
    return i.forEach((g) => {
      h[g] = u[g] && u[g].active() ? u[g]._to : this[g];
    }), h;
  }
};
function UD(s, i) {
  const l = s.options.ticks, u = BD(s), h = Math.min(l.maxTicksLimit || u, u), g = l.major.enabled ? jD(i) : [], _ = g.length, S = g[0], T = g[_ - 1], E = [];
  if (_ > h)
    return qD(i, E, g, _ / h), E;
  const D = YD(g, i, h);
  if (_ > 0) {
    let C, z;
    const j = _ > 1 ? Math.round((T - S) / (_ - 1)) : null;
    for (c0(i, E, D, Mn(j) ? 0 : S - j, S), C = 0, z = _ - 1; C < z; C++)
      c0(i, E, D, g[C], g[C + 1]);
    return c0(i, E, D, T, Mn(j) ? i.length : T + j), E;
  }
  return c0(i, E, D), E;
}
function BD(s) {
  const i = s.options.offset, l = s._tickSize(), u = s._length / l + (i ? 0 : 1), h = s._maxLength / l;
  return Math.floor(Math.min(u, h));
}
function YD(s, i, l) {
  const u = ZD(s), h = i.length / l;
  if (!u)
    return Math.max(h, 1);
  const g = R2(u);
  for (let _ = 0, S = g.length - 1; _ < S; _++) {
    const T = g[_];
    if (T > h)
      return T;
  }
  return Math.max(h, 1);
}
function jD(s) {
  const i = [];
  let l, u;
  for (l = 0, u = s.length; l < u; l++)
    s[l].major && i.push(l);
  return i;
}
function qD(s, i, l, u) {
  let h = 0, g = l[0], _;
  for (u = Math.ceil(u), _ = 0; _ < s.length; _++)
    _ === g && (i.push(s[_]), h++, g = l[h * u]);
}
function c0(s, i, l, u, h) {
  const g = gn(u, 0), _ = Math.min(gn(h, s.length), s.length);
  let S = 0, T, E, D;
  for (l = Math.ceil(l), h && (T = h - u, l = T / Math.floor(T / l)), D = g; D < 0; )
    S++, D = Math.round(g + S * l);
  for (E = Math.max(g, 0); E < _; E++)
    E === D && (i.push(s[E]), S++, D = Math.round(g + S * l));
}
function ZD(s) {
  const i = s.length;
  let l, u;
  if (i < 2)
    return !1;
  for (u = s[0], l = 1; l < i; ++l)
    if (s[l] - s[l - 1] !== u)
      return !1;
  return u;
}
const PD = (s) => s === "left" ? "right" : s === "right" ? "left" : s, Ux = (s, i, l) => i === "top" || i === "left" ? s[i] + l : s[i] - l, Bx = (s, i) => Math.min(i || s, s);
function Yx(s, i) {
  const l = [], u = s.length / i, h = s.length;
  let g = 0;
  for (; g < h; g += u)
    l.push(s[Math.floor(g)]);
  return l;
}
function VD(s, i, l) {
  const u = s.ticks.length, h = Math.min(i, u - 1), g = s._startPixel, _ = s._endPixel, S = 1e-6;
  let T = s.getPixelForTick(h), E;
  if (!(l && (u === 1 ? E = Math.max(T - g, _ - T) : i === 0 ? E = (s.getPixelForTick(1) - T) / 2 : E = (T - s.getPixelForTick(h - 1)) / 2, T += h < i ? E : -E, T < g - S || T > _ + S)))
    return T;
}
function GD(s, i) {
  un(s, (l) => {
    const u = l.gc, h = u.length / 2;
    let g;
    if (h > i) {
      for (g = 0; g < h; ++g)
        delete l.data[u[g]];
      u.splice(0, h);
    }
  });
}
function tv(s) {
  return s.drawTicks ? s.tickLength : 0;
}
function jx(s, i) {
  if (!s.display)
    return 0;
  const l = uu(s.font, i), u = Of(s.padding);
  return (Fi(s.text) ? s.text.length : 1) * l.lineHeight + u.height;
}
function XD(s, i) {
  return yd(s, {
    scale: i,
    type: "scale"
  });
}
function QD(s, i, l) {
  return yd(s, {
    tick: l,
    index: i,
    type: "tick"
  });
}
function KD(s, i, l) {
  let u = P2(s);
  return (l && i !== "right" || !l && i === "right") && (u = PD(u)), u;
}
function WD(s, i, l, u) {
  const { top: h, left: g, bottom: _, right: S, chart: T } = s, { chartArea: E, scales: D } = T;
  let C = 0, z, j, I;
  const Q = _ - h, X = S - g;
  if (s.isHorizontal()) {
    if (j = ux(u, g, S), Ve(l)) {
      const nt = Object.keys(l)[0], Dt = l[nt];
      I = D[nt].getPixelForValue(Dt) + Q - i;
    } else l === "center" ? I = (E.bottom + E.top) / 2 + Q - i : I = Ux(s, l, i);
    z = S - g;
  } else {
    if (Ve(l)) {
      const nt = Object.keys(l)[0], Dt = l[nt];
      j = D[nt].getPixelForValue(Dt) - X + i;
    } else l === "center" ? j = (E.left + E.right) / 2 - X + i : j = Ux(s, l, i);
    I = ux(u, _, h), C = l === "left" ? -sr : sr;
  }
  return {
    titleX: j,
    titleY: I,
    maxWidth: z,
    rotation: C
  };
}
class xv extends Tv {
  constructor(i) {
    super(), this.id = i.id, this.type = i.type, this.options = void 0, this.ctx = i.ctx, this.chart = i.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(i) {
    this.options = i.setContext(this.getContext()), this.axis = i.axis, this._userMin = this.parse(i.min), this._userMax = this.parse(i.max), this._suggestedMin = this.parse(i.suggestedMin), this._suggestedMax = this.parse(i.suggestedMax);
  }
  parse(i, l) {
    return i;
  }
  getUserBounds() {
    let { _userMin: i, _userMax: l, _suggestedMin: u, _suggestedMax: h } = this;
    return i = iu(i, Number.POSITIVE_INFINITY), l = iu(l, Number.NEGATIVE_INFINITY), u = iu(u, Number.POSITIVE_INFINITY), h = iu(h, Number.NEGATIVE_INFINITY), {
      min: iu(i, u),
      max: iu(l, h),
      minDefined: qa(i),
      maxDefined: qa(l)
    };
  }
  getMinMax(i) {
    let { min: l, max: u, minDefined: h, maxDefined: g } = this.getUserBounds(), _;
    if (h && g)
      return {
        min: l,
        max: u
      };
    const S = this.getMatchingVisibleMetas();
    for (let T = 0, E = S.length; T < E; ++T)
      _ = S[T].controller.getMinMax(this, i), h || (l = Math.min(l, _.min)), g || (u = Math.max(u, _.max));
    return l = g && l > u ? u : l, u = h && l > u ? l : u, {
      min: iu(l, iu(u, l)),
      max: iu(u, iu(l, u))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const i = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? i.xLabels : i.yLabels) || i.labels || [];
  }
  getLabelItems(i = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(i));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    ri(this.options.beforeUpdate, [
      this
    ]);
  }
  update(i, l, u) {
    const { beginAtZero: h, grace: g, ticks: _ } = this.options, S = _.sampleSize;
    this.beforeUpdate(), this.maxWidth = i, this.maxHeight = l, this._margins = u = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, u), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + u.left + u.right : this.height + u.top + u.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = dO(this, g, h), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const T = S < this.ticks.length;
    this._convertTicksToLabels(T ? Yx(this.ticks, S) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), _.display && (_.autoSkip || _.source === "auto") && (this.ticks = UD(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), T && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let i = this.options.reverse, l, u;
    this.isHorizontal() ? (l = this.left, u = this.right) : (l = this.top, u = this.bottom, i = !i), this._startPixel = l, this._endPixel = u, this._reversePixels = i, this._length = u - l, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    ri(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    ri(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    ri(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(i) {
    this.chart.notifyPlugins(i, this.getContext()), ri(this.options[i], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    ri(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(i) {
    const l = this.options.ticks;
    let u, h, g;
    for (u = 0, h = i.length; u < h; u++)
      g = i[u], g.label = ri(l.callback, [
        g.value,
        u,
        i
      ], this);
  }
  afterTickToLabelConversion() {
    ri(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    ri(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const i = this.options, l = i.ticks, u = Bx(this.ticks.length, i.ticks.maxTicksLimit), h = l.minRotation || 0, g = l.maxRotation;
    let _ = h, S, T, E;
    if (!this._isVisible() || !l.display || h >= g || u <= 1 || !this.isHorizontal()) {
      this.labelRotation = h;
      return;
    }
    const D = this._getLabelSizes(), C = D.widest.width, z = D.highest.height, j = rr(this.chart.width - C, 0, this.maxWidth);
    S = i.offset ? this.maxWidth / u : j / (u - 1), C + 6 > S && (S = j / (u - (i.offset ? 0.5 : 1)), T = this.maxHeight - tv(i.grid) - l.padding - jx(i.title, this.chart.options.font), E = Math.sqrt(C * C + z * z), _ = H2(Math.min(Math.asin(rr((D.highest.height + 6) / S, -1, 1)), Math.asin(rr(T / E, -1, 1)) - Math.asin(rr(z / E, -1, 1)))), _ = Math.max(h, Math.min(g, _))), this.labelRotation = _;
  }
  afterCalculateLabelRotation() {
    ri(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    ri(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const i = {
      width: 0,
      height: 0
    }, { chart: l, options: { ticks: u, title: h, grid: g } } = this, _ = this._isVisible(), S = this.isHorizontal();
    if (_) {
      const T = jx(h, l.options.font);
      if (S ? (i.width = this.maxWidth, i.height = tv(g) + T) : (i.height = this.maxHeight, i.width = tv(g) + T), u.display && this.ticks.length) {
        const { first: E, last: D, widest: C, highest: z } = this._getLabelSizes(), j = u.padding * 2, I = dd(this.labelRotation), Q = Math.cos(I), X = Math.sin(I);
        if (S) {
          const nt = u.mirror ? 0 : X * C.width + Q * z.height;
          i.height = Math.min(this.maxHeight, i.height + nt + j);
        } else {
          const nt = u.mirror ? 0 : Q * C.width + X * z.height;
          i.width = Math.min(this.maxWidth, i.width + nt + j);
        }
        this._calculatePadding(E, D, X, Q);
      }
    }
    this._handleMargins(), S ? (this.width = this._length = l.width - this._margins.left - this._margins.right, this.height = i.height) : (this.width = i.width, this.height = this._length = l.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(i, l, u, h) {
    const { ticks: { align: g, padding: _ }, position: S } = this.options, T = this.labelRotation !== 0, E = S !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const D = this.getPixelForTick(0) - this.left, C = this.right - this.getPixelForTick(this.ticks.length - 1);
      let z = 0, j = 0;
      T ? E ? (z = h * i.width, j = u * l.height) : (z = u * i.height, j = h * l.width) : g === "start" ? j = l.width : g === "end" ? z = i.width : g !== "inner" && (z = i.width / 2, j = l.width / 2), this.paddingLeft = Math.max((z - D + _) * this.width / (this.width - D), 0), this.paddingRight = Math.max((j - C + _) * this.width / (this.width - C), 0);
    } else {
      let D = l.height / 2, C = i.height / 2;
      g === "start" ? (D = 0, C = i.height) : g === "end" && (D = l.height, C = 0), this.paddingTop = D + _, this.paddingBottom = C + _;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    ri(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: i, position: l } = this.options;
    return l === "top" || l === "bottom" || i === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(i) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(i);
    let l, u;
    for (l = 0, u = i.length; l < u; l++)
      Mn(i[l].label) && (i.splice(l, 1), u--, l--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let i = this._labelSizes;
    if (!i) {
      const l = this.options.ticks.sampleSize;
      let u = this.ticks;
      l < u.length && (u = Yx(u, l)), this._labelSizes = i = this._computeLabelSizes(u, u.length, this.options.ticks.maxTicksLimit);
    }
    return i;
  }
  _computeLabelSizes(i, l, u) {
    const { ctx: h, _longestTextCache: g } = this, _ = [], S = [], T = Math.floor(l / Bx(l, u));
    let E = 0, D = 0, C, z, j, I, Q, X, nt, Dt, Et, zt, dt;
    for (C = 0; C < l; C += T) {
      if (I = i[C].label, Q = this._resolveTickFontOptions(C), h.font = X = Q.string, nt = g[X] = g[X] || {
        data: {},
        gc: []
      }, Dt = Q.lineHeight, Et = zt = 0, !Mn(I) && !Fi(I))
        Et = mx(h, nt.data, nt.gc, Et, I), zt = Dt;
      else if (Fi(I))
        for (z = 0, j = I.length; z < j; ++z)
          dt = I[z], !Mn(dt) && !Fi(dt) && (Et = mx(h, nt.data, nt.gc, Et, dt), zt += Dt);
      _.push(Et), S.push(zt), E = Math.max(Et, E), D = Math.max(zt, D);
    }
    GD(g, l);
    const Lt = _.indexOf(E), Ct = S.indexOf(D), Yt = (wt) => ({
      width: _[wt] || 0,
      height: S[wt] || 0
    });
    return {
      first: Yt(0),
      last: Yt(l - 1),
      widest: Yt(Lt),
      highest: Yt(Ct),
      widths: _,
      heights: S
    };
  }
  getLabelForValue(i) {
    return i;
  }
  getPixelForValue(i, l) {
    return NaN;
  }
  getValueForPixel(i) {
  }
  getPixelForTick(i) {
    const l = this.ticks;
    return i < 0 || i > l.length - 1 ? null : this.getPixelForValue(l[i].value);
  }
  getPixelForDecimal(i) {
    this._reversePixels && (i = 1 - i);
    const l = this._startPixel + i * this._length;
    return U2(this._alignToPixels ? rd(this.chart, l, 0) : l);
  }
  getDecimalForPixel(i) {
    const l = (i - this._startPixel) / this._length;
    return this._reversePixels ? 1 - l : l;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: i, max: l } = this;
    return i < 0 && l < 0 ? l : i > 0 && l > 0 ? i : 0;
  }
  getContext(i) {
    const l = this.ticks || [];
    if (i >= 0 && i < l.length) {
      const u = l[i];
      return u.$context || (u.$context = QD(this.getContext(), i, u));
    }
    return this.$context || (this.$context = XD(this.chart.getContext(), this));
  }
  _tickSize() {
    const i = this.options.ticks, l = dd(this.labelRotation), u = Math.abs(Math.cos(l)), h = Math.abs(Math.sin(l)), g = this._getLabelSizes(), _ = i.autoSkipPadding || 0, S = g ? g.widest.width + _ : 0, T = g ? g.highest.height + _ : 0;
    return this.isHorizontal() ? T * u > S * h ? S / u : T / h : T * h < S * u ? T / u : S / h;
  }
  _isVisible() {
    const i = this.options.display;
    return i !== "auto" ? !!i : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(i) {
    const l = this.axis, u = this.chart, h = this.options, { grid: g, position: _, border: S } = h, T = g.offset, E = this.isHorizontal(), C = this.ticks.length + (T ? 1 : 0), z = tv(g), j = [], I = S.setContext(this.getContext()), Q = I.display ? I.width : 0, X = Q / 2, nt = function(V) {
      return rd(u, V, Q);
    };
    let Dt, Et, zt, dt, Lt, Ct, Yt, wt, ne, Rt, Nt, Ee;
    if (_ === "top")
      Dt = nt(this.bottom), Ct = this.bottom - z, wt = Dt - X, Rt = nt(i.top) + X, Ee = i.bottom;
    else if (_ === "bottom")
      Dt = nt(this.top), Rt = i.top, Ee = nt(i.bottom) - X, Ct = Dt + X, wt = this.top + z;
    else if (_ === "left")
      Dt = nt(this.right), Lt = this.right - z, Yt = Dt - X, ne = nt(i.left) + X, Nt = i.right;
    else if (_ === "right")
      Dt = nt(this.left), ne = i.left, Nt = nt(i.right) - X, Lt = Dt + X, Yt = this.left + z;
    else if (l === "x") {
      if (_ === "center")
        Dt = nt((i.top + i.bottom) / 2 + 0.5);
      else if (Ve(_)) {
        const V = Object.keys(_)[0], mt = _[V];
        Dt = nt(this.chart.scales[V].getPixelForValue(mt));
      }
      Rt = i.top, Ee = i.bottom, Ct = Dt + X, wt = Ct + z;
    } else if (l === "y") {
      if (_ === "center")
        Dt = nt((i.left + i.right) / 2);
      else if (Ve(_)) {
        const V = Object.keys(_)[0], mt = _[V];
        Dt = nt(this.chart.scales[V].getPixelForValue(mt));
      }
      Lt = Dt - X, Yt = Lt - z, ne = i.left, Nt = i.right;
    }
    const ge = gn(h.ticks.maxTicksLimit, C), Jt = Math.max(1, Math.ceil(C / ge));
    for (Et = 0; Et < C; Et += Jt) {
      const V = this.getContext(Et), mt = g.setContext(V), ut = S.setContext(V), Gt = mt.lineWidth, k = mt.color, F = ut.dash || [], ct = ut.dashOffset, bt = mt.tickWidth, Mt = mt.tickColor, Ht = mt.tickBorderDash || [], Tt = mt.tickBorderDashOffset;
      zt = VD(this, Et, T), zt !== void 0 && (dt = rd(u, zt, Gt), E ? Lt = Yt = ne = Nt = dt : Ct = wt = Rt = Ee = dt, j.push({
        tx1: Lt,
        ty1: Ct,
        tx2: Yt,
        ty2: wt,
        x1: ne,
        y1: Rt,
        x2: Nt,
        y2: Ee,
        width: Gt,
        color: k,
        borderDash: F,
        borderDashOffset: ct,
        tickWidth: bt,
        tickColor: Mt,
        tickBorderDash: Ht,
        tickBorderDashOffset: Tt
      }));
    }
    return this._ticksLength = C, this._borderValue = Dt, j;
  }
  _computeLabelItems(i) {
    const l = this.axis, u = this.options, { position: h, ticks: g } = u, _ = this.isHorizontal(), S = this.ticks, { align: T, crossAlign: E, padding: D, mirror: C } = g, z = tv(u.grid), j = z + D, I = C ? -D : j, Q = -dd(this.labelRotation), X = [];
    let nt, Dt, Et, zt, dt, Lt, Ct, Yt, wt, ne, Rt, Nt, Ee = "middle";
    if (h === "top")
      Lt = this.bottom - I, Ct = this._getXAxisLabelAlignment();
    else if (h === "bottom")
      Lt = this.top + I, Ct = this._getXAxisLabelAlignment();
    else if (h === "left") {
      const Jt = this._getYAxisLabelAlignment(z);
      Ct = Jt.textAlign, dt = Jt.x;
    } else if (h === "right") {
      const Jt = this._getYAxisLabelAlignment(z);
      Ct = Jt.textAlign, dt = Jt.x;
    } else if (l === "x") {
      if (h === "center")
        Lt = (i.top + i.bottom) / 2 + j;
      else if (Ve(h)) {
        const Jt = Object.keys(h)[0], V = h[Jt];
        Lt = this.chart.scales[Jt].getPixelForValue(V) + j;
      }
      Ct = this._getXAxisLabelAlignment();
    } else if (l === "y") {
      if (h === "center")
        dt = (i.left + i.right) / 2 - j;
      else if (Ve(h)) {
        const Jt = Object.keys(h)[0], V = h[Jt];
        dt = this.chart.scales[Jt].getPixelForValue(V);
      }
      Ct = this._getYAxisLabelAlignment(z).textAlign;
    }
    l === "y" && (T === "start" ? Ee = "top" : T === "end" && (Ee = "bottom"));
    const ge = this._getLabelSizes();
    for (nt = 0, Dt = S.length; nt < Dt; ++nt) {
      Et = S[nt], zt = Et.label;
      const Jt = g.setContext(this.getContext(nt));
      Yt = this.getPixelForTick(nt) + g.labelOffset, wt = this._resolveTickFontOptions(nt), ne = wt.lineHeight, Rt = Fi(zt) ? zt.length : 1;
      const V = Rt / 2, mt = Jt.color, ut = Jt.textStrokeColor, Gt = Jt.textStrokeWidth;
      let k = Ct;
      _ ? (dt = Yt, Ct === "inner" && (nt === Dt - 1 ? k = this.options.reverse ? "left" : "right" : nt === 0 ? k = this.options.reverse ? "right" : "left" : k = "center"), h === "top" ? E === "near" || Q !== 0 ? Nt = -Rt * ne + ne / 2 : E === "center" ? Nt = -ge.highest.height / 2 - V * ne + ne : Nt = -ge.highest.height + ne / 2 : E === "near" || Q !== 0 ? Nt = ne / 2 : E === "center" ? Nt = ge.highest.height / 2 - V * ne : Nt = ge.highest.height - Rt * ne, C && (Nt *= -1), Q !== 0 && !Jt.showLabelBackdrop && (dt += ne / 2 * Math.sin(Q))) : (Lt = Yt, Nt = (1 - Rt) * ne / 2);
      let F;
      if (Jt.showLabelBackdrop) {
        const ct = Of(Jt.backdropPadding), bt = ge.heights[nt], Mt = ge.widths[nt];
        let Ht = Nt - ct.top, Tt = 0 - ct.left;
        switch (Ee) {
          case "middle":
            Ht -= bt / 2;
            break;
          case "bottom":
            Ht -= bt;
            break;
        }
        switch (Ct) {
          case "center":
            Tt -= Mt / 2;
            break;
          case "right":
            Tt -= Mt;
            break;
          case "inner":
            nt === Dt - 1 ? Tt -= Mt : nt > 0 && (Tt -= Mt / 2);
            break;
        }
        F = {
          left: Tt,
          top: Ht,
          width: Mt + ct.width,
          height: bt + ct.height,
          color: Jt.backdropColor
        };
      }
      X.push({
        label: zt,
        font: wt,
        textOffset: Nt,
        options: {
          rotation: Q,
          color: mt,
          strokeColor: ut,
          strokeWidth: Gt,
          textAlign: k,
          textBaseline: Ee,
          translation: [
            dt,
            Lt
          ],
          backdrop: F
        }
      });
    }
    return X;
  }
  _getXAxisLabelAlignment() {
    const { position: i, ticks: l } = this.options;
    if (-dd(this.labelRotation))
      return i === "top" ? "left" : "right";
    let h = "center";
    return l.align === "start" ? h = "left" : l.align === "end" ? h = "right" : l.align === "inner" && (h = "inner"), h;
  }
  _getYAxisLabelAlignment(i) {
    const { position: l, ticks: { crossAlign: u, mirror: h, padding: g } } = this.options, _ = this._getLabelSizes(), S = i + g, T = _.widest.width;
    let E, D;
    return l === "left" ? h ? (D = this.right + g, u === "near" ? E = "left" : u === "center" ? (E = "center", D += T / 2) : (E = "right", D += T)) : (D = this.right - S, u === "near" ? E = "right" : u === "center" ? (E = "center", D -= T / 2) : (E = "left", D = this.left)) : l === "right" ? h ? (D = this.left + g, u === "near" ? E = "right" : u === "center" ? (E = "center", D -= T / 2) : (E = "left", D -= T)) : (D = this.left + S, u === "near" ? E = "left" : u === "center" ? (E = "center", D += T / 2) : (E = "right", D = this.right)) : E = "right", {
      textAlign: E,
      x: D
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const i = this.chart, l = this.options.position;
    if (l === "left" || l === "right")
      return {
        top: 0,
        left: this.left,
        bottom: i.height,
        right: this.right
      };
    if (l === "top" || l === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: i.width
      };
  }
  drawBackground() {
    const { ctx: i, options: { backgroundColor: l }, left: u, top: h, width: g, height: _ } = this;
    l && (i.save(), i.fillStyle = l, i.fillRect(u, h, g, _), i.restore());
  }
  getLineWidthForValue(i) {
    const l = this.options.grid;
    if (!this._isVisible() || !l.display)
      return 0;
    const h = this.ticks.findIndex((g) => g.value === i);
    return h >= 0 ? l.setContext(this.getContext(h)).lineWidth : 0;
  }
  drawGrid(i) {
    const l = this.options.grid, u = this.ctx, h = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(i));
    let g, _;
    const S = (T, E, D) => {
      !D.width || !D.color || (u.save(), u.lineWidth = D.width, u.strokeStyle = D.color, u.setLineDash(D.borderDash || []), u.lineDashOffset = D.borderDashOffset, u.beginPath(), u.moveTo(T.x, T.y), u.lineTo(E.x, E.y), u.stroke(), u.restore());
    };
    if (l.display)
      for (g = 0, _ = h.length; g < _; ++g) {
        const T = h[g];
        l.drawOnChartArea && S({
          x: T.x1,
          y: T.y1
        }, {
          x: T.x2,
          y: T.y2
        }, T), l.drawTicks && S({
          x: T.tx1,
          y: T.ty1
        }, {
          x: T.tx2,
          y: T.ty2
        }, {
          color: T.tickColor,
          width: T.tickWidth,
          borderDash: T.tickBorderDash,
          borderDashOffset: T.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: i, ctx: l, options: { border: u, grid: h } } = this, g = u.setContext(this.getContext()), _ = u.display ? g.width : 0;
    if (!_)
      return;
    const S = h.setContext(this.getContext(0)).lineWidth, T = this._borderValue;
    let E, D, C, z;
    this.isHorizontal() ? (E = rd(i, this.left, _) - _ / 2, D = rd(i, this.right, S) + S / 2, C = z = T) : (C = rd(i, this.top, _) - _ / 2, z = rd(i, this.bottom, S) + S / 2, E = D = T), l.save(), l.lineWidth = g.width, l.strokeStyle = g.color, l.beginPath(), l.moveTo(E, C), l.lineTo(D, z), l.stroke(), l.restore();
  }
  drawLabels(i) {
    if (!this.options.ticks.display)
      return;
    const u = this.ctx, h = this._computeLabelArea();
    h && M1(u, h);
    const g = this.getLabelItems(i);
    for (const _ of g) {
      const S = _.options, T = _.font, E = _.label, D = _.textOffset;
      gx(u, E, 0, D, T, S);
    }
    h && E1(u);
  }
  drawTitle() {
    const { ctx: i, options: { position: l, title: u, reverse: h } } = this;
    if (!u.display)
      return;
    const g = uu(u.font), _ = Of(u.padding), S = u.align;
    let T = g.lineHeight / 2;
    l === "bottom" || l === "center" || Ve(l) ? (T += _.bottom, Fi(u.text) && (T += g.lineHeight * (u.text.length - 1))) : T += _.top;
    const { titleX: E, titleY: D, maxWidth: C, rotation: z } = WD(this, T, l, S);
    gx(i, u.text, 0, 0, g, {
      color: u.color,
      maxWidth: C,
      rotation: z,
      textAlign: KD(S, l, h),
      textBaseline: "middle",
      translation: [
        E,
        D
      ]
    });
  }
  draw(i) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(i), this.drawBorder(), this.drawTitle(), this.drawLabels(i));
  }
  _layers() {
    const i = this.options, l = i.ticks && i.ticks.z || 0, u = gn(i.grid && i.grid.z, -1), h = gn(i.border && i.border.z, 0);
    return !this._isVisible() || this.draw !== xv.prototype.draw ? [
      {
        z: l,
        draw: (g) => {
          this.draw(g);
        }
      }
    ] : [
      {
        z: u,
        draw: (g) => {
          this.drawBackground(), this.drawGrid(g), this.drawTitle();
        }
      },
      {
        z: h,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: l,
        draw: (g) => {
          this.drawLabels(g);
        }
      }
    ];
  }
  getMatchingVisibleMetas(i) {
    const l = this.chart.getSortedVisibleDatasetMetas(), u = this.axis + "AxisID", h = [];
    let g, _;
    for (g = 0, _ = l.length; g < _; ++g) {
      const S = l[g];
      S[u] === this.id && (!i || S.type === i) && h.push(S);
    }
    return h;
  }
  _resolveTickFontOptions(i) {
    const l = this.options.ticks.setContext(this.getContext(i));
    return uu(l.font);
  }
  _maxDigits() {
    const i = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / i;
  }
}
class f0 {
  constructor(i, l, u) {
    this.type = i, this.scope = l, this.override = u, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(i) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, i.prototype);
  }
  register(i) {
    const l = Object.getPrototypeOf(i);
    let u;
    JD(l) && (u = this.register(l));
    const h = this.items, g = i.id, _ = this.scope + "." + g;
    if (!g)
      throw new Error("class does not have id: " + i);
    return g in h || (h[g] = i, ID(i, _, u), this.override && Mi.override(i.id, i.overrides)), _;
  }
  get(i) {
    return this.items[i];
  }
  unregister(i) {
    const l = this.items, u = i.id, h = this.scope;
    u in l && delete l[u], h && u in Mi[h] && (delete Mi[h][u], this.override && delete gd[u]);
  }
}
function ID(s, i, l) {
  const u = yv(/* @__PURE__ */ Object.create(null), [
    l ? Mi.get(l) : {},
    Mi.get(i),
    s.defaults
  ]);
  Mi.set(i, u), s.defaultRoutes && $D(i, s.defaultRoutes), s.descriptors && Mi.describe(i, s.descriptors);
}
function $D(s, i) {
  Object.keys(i).forEach((l) => {
    const u = l.split("."), h = u.pop(), g = [
      s
    ].concat(u).join("."), _ = i[l].split("."), S = _.pop(), T = _.join(".");
    Mi.route(g, h, T, S);
  });
}
function JD(s) {
  return "id" in s && "defaults" in s;
}
class FD {
  constructor() {
    this.controllers = new f0(Qw, "datasets", !0), this.elements = new f0(Tv, "elements"), this.plugins = new f0(Object, "plugins"), this.scales = new f0(xv, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...i) {
    this._each("register", i);
  }
  remove(...i) {
    this._each("unregister", i);
  }
  addControllers(...i) {
    this._each("register", i, this.controllers);
  }
  addElements(...i) {
    this._each("register", i, this.elements);
  }
  addPlugins(...i) {
    this._each("register", i, this.plugins);
  }
  addScales(...i) {
    this._each("register", i, this.scales);
  }
  getController(i) {
    return this._get(i, this.controllers, "controller");
  }
  getElement(i) {
    return this._get(i, this.elements, "element");
  }
  getPlugin(i) {
    return this._get(i, this.plugins, "plugin");
  }
  getScale(i) {
    return this._get(i, this.scales, "scale");
  }
  removeControllers(...i) {
    this._each("unregister", i, this.controllers);
  }
  removeElements(...i) {
    this._each("unregister", i, this.elements);
  }
  removePlugins(...i) {
    this._each("unregister", i, this.plugins);
  }
  removeScales(...i) {
    this._each("unregister", i, this.scales);
  }
  _each(i, l, u) {
    [
      ...l
    ].forEach((h) => {
      const g = u || this._getRegistryForType(h);
      u || g.isForType(h) || g === this.plugins && h.id ? this._exec(i, g, h) : un(h, (_) => {
        const S = u || this._getRegistryForType(_);
        this._exec(i, S, _);
      });
    });
  }
  _exec(i, l, u) {
    const h = T1(i);
    ri(u["before" + h], [], u), l[i](u), ri(u["after" + h], [], u);
  }
  _getRegistryForType(i) {
    for (let l = 0; l < this._typedRegistries.length; l++) {
      const u = this._typedRegistries[l];
      if (u.isForType(i))
        return u;
    }
    return this.plugins;
  }
  _get(i, l, u) {
    const h = l.get(i);
    if (h === void 0)
      throw new Error('"' + i + '" is not a registered ' + u + ".");
    return h;
  }
}
var ou = /* @__PURE__ */ new FD();
class tA {
  constructor() {
    this._init = [];
  }
  notify(i, l, u, h) {
    l === "beforeInit" && (this._init = this._createDescriptors(i, !0), this._notify(this._init, i, "install"));
    const g = h ? this._descriptors(i).filter(h) : this._descriptors(i), _ = this._notify(g, i, l, u);
    return l === "afterDestroy" && (this._notify(g, i, "stop"), this._notify(this._init, i, "uninstall")), _;
  }
  _notify(i, l, u, h) {
    h = h || {};
    for (const g of i) {
      const _ = g.plugin, S = _[u], T = [
        l,
        h,
        g.options
      ];
      if (ri(S, T, _) === !1 && h.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    Mn(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(i) {
    if (this._cache)
      return this._cache;
    const l = this._cache = this._createDescriptors(i);
    return this._notifyStateChanges(i), l;
  }
  _createDescriptors(i, l) {
    const u = i && i.config, h = gn(u.options && u.options.plugins, {}), g = eA(u);
    return h === !1 && !l ? [] : iA(i, g, h, l);
  }
  _notifyStateChanges(i) {
    const l = this._oldCache || [], u = this._cache, h = (g, _) => g.filter((S) => !_.some((T) => S.plugin.id === T.plugin.id));
    this._notify(h(l, u), i, "stop"), this._notify(h(u, l), i, "start");
  }
}
function eA(s) {
  const i = {}, l = [], u = Object.keys(ou.plugins.items);
  for (let g = 0; g < u.length; g++)
    l.push(ou.getPlugin(u[g]));
  const h = s.plugins || [];
  for (let g = 0; g < h.length; g++) {
    const _ = h[g];
    l.indexOf(_) === -1 && (l.push(_), i[_.id] = !0);
  }
  return {
    plugins: l,
    localIds: i
  };
}
function nA(s, i) {
  return !i && s === !1 ? null : s === !0 ? {} : s;
}
function iA(s, { plugins: i, localIds: l }, u, h) {
  const g = [], _ = s.getContext();
  for (const S of i) {
    const T = S.id, E = nA(u[T], h);
    E !== null && g.push({
      plugin: S,
      options: aA(s.config, {
        plugin: S,
        local: l[T]
      }, E, _)
    });
  }
  return g;
}
function aA(s, { plugin: i, local: l }, u, h) {
  const g = s.pluginScopeKeys(i), _ = s.getOptionScopes(u, g);
  return l && i.defaults && _.push(i.defaults), s.createResolver(_, h, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function f1(s, i) {
  const l = Mi.datasets[s] || {};
  return ((i.datasets || {})[s] || {}).indexAxis || i.indexAxis || l.indexAxis || "x";
}
function oA(s, i) {
  let l = s;
  return s === "_index_" ? l = i : s === "_value_" && (l = i === "x" ? "y" : "x"), l;
}
function lA(s, i) {
  return s === i ? "_index_" : "_value_";
}
function qx(s) {
  if (s === "x" || s === "y" || s === "r")
    return s;
}
function sA(s) {
  if (s === "top" || s === "bottom")
    return "x";
  if (s === "left" || s === "right")
    return "y";
}
function h1(s, ...i) {
  if (qx(s))
    return s;
  for (const l of i) {
    const u = l.axis || sA(l.position) || s.length > 1 && qx(s[0].toLowerCase());
    if (u)
      return u;
  }
  throw new Error(`Cannot determine type of '${s}' axis. Please provide 'axis' or 'position' option.`);
}
function Zx(s, i, l) {
  if (l[i + "AxisID"] === s)
    return {
      axis: i
    };
}
function rA(s, i) {
  if (i.data && i.data.datasets) {
    const l = i.data.datasets.filter((u) => u.xAxisID === s || u.yAxisID === s);
    if (l.length)
      return Zx(s, "x", l[0]) || Zx(s, "y", l[0]);
  }
  return {};
}
function uA(s, i) {
  const l = gd[s.type] || {
    scales: {}
  }, u = i.scales || {}, h = f1(s.type, i), g = /* @__PURE__ */ Object.create(null);
  return Object.keys(u).forEach((_) => {
    const S = u[_];
    if (!Ve(S))
      return console.error(`Invalid scale configuration for scale: ${_}`);
    if (S._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${_}`);
    const T = h1(_, S, rA(_, s), Mi.scales[S.type]), E = lA(T, h), D = l.scales || {};
    g[_] = cv(/* @__PURE__ */ Object.create(null), [
      {
        axis: T
      },
      S,
      D[T],
      D[E]
    ]);
  }), s.data.datasets.forEach((_) => {
    const S = _.type || s.type, T = _.indexAxis || f1(S, i), D = (gd[S] || {}).scales || {};
    Object.keys(D).forEach((C) => {
      const z = oA(C, T), j = _[z + "AxisID"] || z;
      g[j] = g[j] || /* @__PURE__ */ Object.create(null), cv(g[j], [
        {
          axis: z
        },
        u[j],
        D[C]
      ]);
    });
  }), Object.keys(g).forEach((_) => {
    const S = g[_];
    cv(S, [
      Mi.scales[S.type],
      Mi.scale
    ]);
  }), g;
}
function tM(s) {
  const i = s.options || (s.options = {});
  i.plugins = gn(i.plugins, {}), i.scales = uA(s, i);
}
function eM(s) {
  return s = s || {}, s.datasets = s.datasets || [], s.labels = s.labels || [], s;
}
function cA(s) {
  return s = s || {}, s.data = eM(s.data), tM(s), s;
}
const Px = /* @__PURE__ */ new Map(), nM = /* @__PURE__ */ new Set();
function h0(s, i) {
  let l = Px.get(s);
  return l || (l = i(), Px.set(s, l), nM.add(l)), l;
}
const ev = (s, i, l) => {
  const u = S0(i, l);
  u !== void 0 && s.add(u);
};
class fA {
  constructor(i) {
    this._config = cA(i), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(i) {
    this._config.type = i;
  }
  get data() {
    return this._config.data;
  }
  set data(i) {
    this._config.data = eM(i);
  }
  get options() {
    return this._config.options;
  }
  set options(i) {
    this._config.options = i;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const i = this._config;
    this.clearCache(), tM(i);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(i) {
    return h0(i, () => [
      [
        `datasets.${i}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(i, l) {
    return h0(`${i}.transition.${l}`, () => [
      [
        `datasets.${i}.transitions.${l}`,
        `transitions.${l}`
      ],
      [
        `datasets.${i}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(i, l) {
    return h0(`${i}-${l}`, () => [
      [
        `datasets.${i}.elements.${l}`,
        `datasets.${i}`,
        `elements.${l}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(i) {
    const l = i.id, u = this.type;
    return h0(`${u}-plugin-${l}`, () => [
      [
        `plugins.${l}`,
        ...i.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(i, l) {
    const u = this._scopeCache;
    let h = u.get(i);
    return (!h || l) && (h = /* @__PURE__ */ new Map(), u.set(i, h)), h;
  }
  getOptionScopes(i, l, u) {
    const { options: h, type: g } = this, _ = this._cachedScopes(i, u), S = _.get(l);
    if (S)
      return S;
    const T = /* @__PURE__ */ new Set();
    l.forEach((D) => {
      i && (T.add(i), D.forEach((C) => ev(T, i, C))), D.forEach((C) => ev(T, h, C)), D.forEach((C) => ev(T, gd[g] || {}, C)), D.forEach((C) => ev(T, Mi, C)), D.forEach((C) => ev(T, u1, C));
    });
    const E = Array.from(T);
    return E.length === 0 && E.push(/* @__PURE__ */ Object.create(null)), nM.has(l) && _.set(l, E), E;
  }
  chartOptionScopes() {
    const { options: i, type: l } = this;
    return [
      i,
      gd[l] || {},
      Mi.datasets[l] || {},
      {
        type: l
      },
      Mi,
      u1
    ];
  }
  resolveNamedOptions(i, l, u, h = [
    ""
  ]) {
    const g = {
      $shared: !0
    }, { resolver: _, subPrefixes: S } = Vx(this._resolverCache, i, h);
    let T = _;
    if (dA(_, l)) {
      g.$shared = !1, u = Ef(u) ? u() : u;
      const E = this.createResolver(i, u, S);
      T = Lp(_, u, E);
    }
    for (const E of l)
      g[E] = T[E];
    return g;
  }
  createResolver(i, l, u = [
    ""
  ], h) {
    const { resolver: g } = Vx(this._resolverCache, i, u);
    return Ve(l) ? Lp(g, l, void 0, h) : g;
  }
}
function Vx(s, i, l) {
  let u = s.get(i);
  u || (u = /* @__PURE__ */ new Map(), s.set(i, u));
  const h = l.join();
  let g = u.get(h);
  return g || (g = {
    resolver: O1(i, l),
    subPrefixes: l.filter((S) => !S.toLowerCase().includes("hover"))
  }, u.set(h, g)), g;
}
const hA = (s) => Ve(s) && Object.getOwnPropertyNames(s).some((i) => Ef(s[i]));
function dA(s, i) {
  const { isScriptable: l, isIndexable: u } = Nw(s);
  for (const h of i) {
    const g = l(h), _ = u(h), S = (_ || g) && s[h];
    if (g && (Ef(S) || hA(S)) || _ && Fi(S))
      return !0;
  }
  return !1;
}
var mA = "4.5.0";
const pA = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function Gx(s, i) {
  return s === "top" || s === "bottom" || pA.indexOf(s) === -1 && i === "x";
}
function Xx(s, i) {
  return function(l, u) {
    return l[s] === u[s] ? l[i] - u[i] : l[s] - u[s];
  };
}
function Qx(s) {
  const i = s.chart, l = i.options.animation;
  i.notifyPlugins("afterRender"), ri(l && l.onComplete, [
    s
  ], i);
}
function gA(s) {
  const i = s.chart, l = i.options.animation;
  ri(l && l.onProgress, [
    s
  ], i);
}
function iM(s) {
  return R1() && typeof s == "string" ? s = document.getElementById(s) : s && s.length && (s = s[0]), s && s.canvas && (s = s.canvas), s;
}
const v0 = {}, Kx = (s) => {
  const i = iM(s);
  return Object.values(v0).filter((l) => l.canvas === i).pop();
};
function yA(s, i, l) {
  const u = Object.keys(s);
  for (const h of u) {
    const g = +h;
    if (g >= i) {
      const _ = s[h];
      delete s[h], (l > 0 || g > i) && (s[g + l] = _);
    }
  }
}
function vA(s, i, l, u) {
  return !l || s.type === "mouseout" ? null : u ? i : s;
}
class L1 {
  static defaults = Mi;
  static instances = v0;
  static overrides = gd;
  static registry = ou;
  static version = mA;
  static getChart = Kx;
  static register(...i) {
    ou.add(...i), Wx();
  }
  static unregister(...i) {
    ou.remove(...i), Wx();
  }
  constructor(i, l) {
    const u = this.config = new fA(l), h = iM(i), g = Kx(h);
    if (g)
      throw new Error("Canvas is already in use. Chart with ID '" + g.id + "' must be destroyed before the canvas with ID '" + g.canvas.id + "' can be reused.");
    const _ = u.createResolver(u.chartOptionScopes(), this.getContext());
    this.platform = new (u.platform || ND(h))(), this.platform.updateConfig(u);
    const S = this.platform.acquireContext(h, _.aspectRatio), T = S && S.canvas, E = T && T.height, D = T && T.width;
    if (this.id = S2(), this.ctx = S, this.canvas = T, this.width = D, this.height = E, this._options = _, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new tA(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Z2((C) => this.update(C), _.resizeDelay || 0), this._dataChanges = [], v0[this.id] = this, !S || !T) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    cc.listen(this, "complete", Qx), cc.listen(this, "progress", gA), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: i, maintainAspectRatio: l }, width: u, height: h, _aspectRatio: g } = this;
    return Mn(i) ? l && g ? g : h ? u / h : null : i;
  }
  get data() {
    return this.config.data;
  }
  set data(i) {
    this.config.data = i;
  }
  get options() {
    return this._options;
  }
  set options(i) {
    this.config.options = i;
  }
  get registry() {
    return ou;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : bx(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return px(this.canvas, this.ctx), this;
  }
  stop() {
    return cc.stop(this), this;
  }
  resize(i, l) {
    cc.running(this) ? this._resizeBeforeDraw = {
      width: i,
      height: l
    } : this._resize(i, l);
  }
  _resize(i, l) {
    const u = this.options, h = this.canvas, g = u.maintainAspectRatio && this.aspectRatio, _ = this.platform.getMaximumSize(h, i, l, g), S = u.devicePixelRatio || this.platform.getDevicePixelRatio(), T = this.width ? "resize" : "attach";
    this.width = _.width, this.height = _.height, this._aspectRatio = this.aspectRatio, bx(this, S, !0) && (this.notifyPlugins("resize", {
      size: _
    }), ri(u.onResize, [
      this,
      _
    ], this), this.attached && this._doResize(T) && this.render());
  }
  ensureScalesHaveIDs() {
    const l = this.options.scales || {};
    un(l, (u, h) => {
      u.id = h;
    });
  }
  buildOrUpdateScales() {
    const i = this.options, l = i.scales, u = this.scales, h = Object.keys(u).reduce((_, S) => (_[S] = !1, _), {});
    let g = [];
    l && (g = g.concat(Object.keys(l).map((_) => {
      const S = l[_], T = h1(_, S), E = T === "r", D = T === "x";
      return {
        options: S,
        dposition: E ? "chartArea" : D ? "bottom" : "left",
        dtype: E ? "radialLinear" : D ? "category" : "linear"
      };
    }))), un(g, (_) => {
      const S = _.options, T = S.id, E = h1(T, S), D = gn(S.type, _.dtype);
      (S.position === void 0 || Gx(S.position, E) !== Gx(_.dposition)) && (S.position = _.dposition), h[T] = !0;
      let C = null;
      if (T in u && u[T].type === D)
        C = u[T];
      else {
        const z = ou.getScale(D);
        C = new z({
          id: T,
          type: D,
          ctx: this.ctx,
          chart: this
        }), u[C.id] = C;
      }
      C.init(S, i);
    }), un(h, (_, S) => {
      _ || delete u[S];
    }), un(u, (_) => {
      u0.configure(this, _, _.options), u0.addBox(this, _);
    });
  }
  _updateMetasets() {
    const i = this._metasets, l = this.data.datasets.length, u = i.length;
    if (i.sort((h, g) => h.index - g.index), u > l) {
      for (let h = l; h < u; ++h)
        this._destroyDatasetMeta(h);
      i.splice(l, u - l);
    }
    this._sortedMetasets = i.slice(0).sort(Xx("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: i, data: { datasets: l } } = this;
    i.length > l.length && delete this._stacks, i.forEach((u, h) => {
      l.filter((g) => g === u._dataset).length === 0 && this._destroyDatasetMeta(h);
    });
  }
  buildOrUpdateControllers() {
    const i = [], l = this.data.datasets;
    let u, h;
    for (this._removeUnreferencedMetasets(), u = 0, h = l.length; u < h; u++) {
      const g = l[u];
      let _ = this.getDatasetMeta(u);
      const S = g.type || this.config.type;
      if (_.type && _.type !== S && (this._destroyDatasetMeta(u), _ = this.getDatasetMeta(u)), _.type = S, _.indexAxis = g.indexAxis || f1(S, this.options), _.order = g.order || 0, _.index = u, _.label = "" + g.label, _.visible = this.isDatasetVisible(u), _.controller)
        _.controller.updateIndex(u), _.controller.linkScales();
      else {
        const T = ou.getController(S), { datasetElementType: E, dataElementType: D } = Mi.datasets[S];
        Object.assign(T, {
          dataElementType: ou.getElement(D),
          datasetElementType: E && ou.getElement(E)
        }), _.controller = new T(this, u), i.push(_.controller);
      }
    }
    return this._updateMetasets(), i;
  }
  _resetElements() {
    un(this.data.datasets, (i, l) => {
      this.getDatasetMeta(l).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(i) {
    const l = this.config;
    l.update();
    const u = this._options = l.createResolver(l.chartOptionScopes(), this.getContext()), h = this._animationsDisabled = !u.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: i,
      cancelable: !0
    }) === !1)
      return;
    const g = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let _ = 0;
    for (let E = 0, D = this.data.datasets.length; E < D; E++) {
      const { controller: C } = this.getDatasetMeta(E), z = !h && g.indexOf(C) === -1;
      C.buildOrUpdateElements(z), _ = Math.max(+C.getMaxOverflow(), _);
    }
    _ = this._minPadding = u.layout.autoPadding ? _ : 0, this._updateLayout(_), h || un(g, (E) => {
      E.reset();
    }), this._updateDatasets(i), this.notifyPlugins("afterUpdate", {
      mode: i
    }), this._layers.sort(Xx("z", "_idx"));
    const { _active: S, _lastEvent: T } = this;
    T ? this._eventHandler(T, !0) : S.length && this._updateHoverStyles(S, S, !0), this.render();
  }
  _updateScales() {
    un(this.scales, (i) => {
      u0.removeBox(this, i);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const i = this.options, l = new Set(Object.keys(this._listeners)), u = new Set(i.events);
    (!ax(l, u) || !!this._responsiveListeners !== i.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: i } = this, l = this._getUniformDataChanges() || [];
    for (const { method: u, start: h, count: g } of l) {
      const _ = u === "_removeElements" ? -g : g;
      yA(i, h, _);
    }
  }
  _getUniformDataChanges() {
    const i = this._dataChanges;
    if (!i || !i.length)
      return;
    this._dataChanges = [];
    const l = this.data.datasets.length, u = (g) => new Set(i.filter((_) => _[0] === g).map((_, S) => S + "," + _.splice(1).join(","))), h = u(0);
    for (let g = 1; g < l; g++)
      if (!ax(h, u(g)))
        return;
    return Array.from(h).map((g) => g.split(",")).map((g) => ({
      method: g[1],
      start: +g[2],
      count: +g[3]
    }));
  }
  _updateLayout(i) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    u0.update(this, this.width, this.height, i);
    const l = this.chartArea, u = l.width <= 0 || l.height <= 0;
    this._layers = [], un(this.boxes, (h) => {
      u && h.position === "chartArea" || (h.configure && h.configure(), this._layers.push(...h._layers()));
    }, this), this._layers.forEach((h, g) => {
      h._idx = g;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(i) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: i,
      cancelable: !0
    }) !== !1) {
      for (let l = 0, u = this.data.datasets.length; l < u; ++l)
        this.getDatasetMeta(l).controller.configure();
      for (let l = 0, u = this.data.datasets.length; l < u; ++l)
        this._updateDataset(l, Ef(i) ? i({
          datasetIndex: l
        }) : i);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: i
      });
    }
  }
  _updateDataset(i, l) {
    const u = this.getDatasetMeta(i), h = {
      meta: u,
      index: i,
      mode: l,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", h) !== !1 && (u.controller._update(l), h.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", h));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (cc.has(this) ? this.attached && !cc.running(this) && cc.start(this) : (this.draw(), Qx({
      chart: this
    })));
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width: u, height: h } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(u, h);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const l = this._layers;
    for (i = 0; i < l.length && l[i].z <= 0; ++i)
      l[i].draw(this.chartArea);
    for (this._drawDatasets(); i < l.length; ++i)
      l[i].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(i) {
    const l = this._sortedMetasets, u = [];
    let h, g;
    for (h = 0, g = l.length; h < g; ++h) {
      const _ = l[h];
      (!i || _.visible) && u.push(_);
    }
    return u;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const i = this.getSortedVisibleDatasetMetas();
    for (let l = i.length - 1; l >= 0; --l)
      this._drawDataset(i[l]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(i) {
    const l = this.ctx, u = {
      meta: i,
      index: i.index,
      cancelable: !0
    }, h = Vw(this, i);
    this.notifyPlugins("beforeDatasetDraw", u) !== !1 && (h && M1(l, h), i.controller.draw(), h && E1(l), u.cancelable = !1, this.notifyPlugins("afterDatasetDraw", u));
  }
  isPointInArea(i) {
    return _v(i, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(i, l, u, h) {
    const g = pD.modes[l];
    return typeof g == "function" ? g(this, i, u, h) : [];
  }
  getDatasetMeta(i) {
    const l = this.data.datasets[i], u = this._metasets;
    let h = u.filter((g) => g && g._dataset === l).pop();
    return h || (h = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: l && l.order || 0,
      index: i,
      _dataset: l,
      _parsed: [],
      _sorted: !1
    }, u.push(h)), h;
  }
  getContext() {
    return this.$context || (this.$context = yd(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(i) {
    const l = this.data.datasets[i];
    if (!l)
      return !1;
    const u = this.getDatasetMeta(i);
    return typeof u.hidden == "boolean" ? !u.hidden : !l.hidden;
  }
  setDatasetVisibility(i, l) {
    const u = this.getDatasetMeta(i);
    u.hidden = !l;
  }
  toggleDataVisibility(i) {
    this._hiddenIndices[i] = !this._hiddenIndices[i];
  }
  getDataVisibility(i) {
    return !this._hiddenIndices[i];
  }
  _updateVisibility(i, l, u) {
    const h = u ? "show" : "hide", g = this.getDatasetMeta(i), _ = g.controller._resolveAnimations(void 0, h);
    T0(l) ? (g.data[l].hidden = !u, this.update()) : (this.setDatasetVisibility(i, u), _.update(g, {
      visible: u
    }), this.update((S) => S.datasetIndex === i ? h : void 0));
  }
  hide(i, l) {
    this._updateVisibility(i, l, !1);
  }
  show(i, l) {
    this._updateVisibility(i, l, !0);
  }
  _destroyDatasetMeta(i) {
    const l = this._metasets[i];
    l && l.controller && l.controller._destroy(), delete this._metasets[i];
  }
  _stop() {
    let i, l;
    for (this.stop(), cc.remove(this), i = 0, l = this.data.datasets.length; i < l; ++i)
      this._destroyDatasetMeta(i);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: i, ctx: l } = this;
    this._stop(), this.config.clearCache(), i && (this.unbindEvents(), px(i, l), this.platform.releaseContext(l), this.canvas = null, this.ctx = null), delete v0[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...i) {
    return this.canvas.toDataURL(...i);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const i = this._listeners, l = this.platform, u = (g, _) => {
      l.addEventListener(this, g, _), i[g] = _;
    }, h = (g, _, S) => {
      g.offsetX = _, g.offsetY = S, this._eventHandler(g);
    };
    un(this.options.events, (g) => u(g, h));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const i = this._responsiveListeners, l = this.platform, u = (T, E) => {
      l.addEventListener(this, T, E), i[T] = E;
    }, h = (T, E) => {
      i[T] && (l.removeEventListener(this, T, E), delete i[T]);
    }, g = (T, E) => {
      this.canvas && this.resize(T, E);
    };
    let _;
    const S = () => {
      h("attach", S), this.attached = !0, this.resize(), u("resize", g), u("detach", _);
    };
    _ = () => {
      this.attached = !1, h("resize", g), this._stop(), this._resize(0, 0), u("attach", S);
    }, l.isAttached(this.canvas) ? S() : _();
  }
  unbindEvents() {
    un(this._listeners, (i, l) => {
      this.platform.removeEventListener(this, l, i);
    }), this._listeners = {}, un(this._responsiveListeners, (i, l) => {
      this.platform.removeEventListener(this, l, i);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(i, l, u) {
    const h = u ? "set" : "remove";
    let g, _, S, T;
    for (l === "dataset" && (g = this.getDatasetMeta(i[0].datasetIndex), g.controller["_" + h + "DatasetHoverStyle"]()), S = 0, T = i.length; S < T; ++S) {
      _ = i[S];
      const E = _ && this.getDatasetMeta(_.datasetIndex).controller;
      E && E[h + "HoverStyle"](_.element, _.datasetIndex, _.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(i) {
    const l = this._active || [], u = i.map(({ datasetIndex: g, index: _ }) => {
      const S = this.getDatasetMeta(g);
      if (!S)
        throw new Error("No dataset found at index " + g);
      return {
        datasetIndex: g,
        element: S.data[_],
        index: _
      };
    });
    !_0(u, l) && (this._active = u, this._lastEvent = null, this._updateHoverStyles(u, l));
  }
  notifyPlugins(i, l, u) {
    return this._plugins.notify(this, i, l, u);
  }
  isPluginEnabled(i) {
    return this._plugins._cache.filter((l) => l.plugin.id === i).length === 1;
  }
  _updateHoverStyles(i, l, u) {
    const h = this.options.hover, g = (T, E) => T.filter((D) => !E.some((C) => D.datasetIndex === C.datasetIndex && D.index === C.index)), _ = g(l, i), S = u ? i : g(i, l);
    _.length && this.updateHoverStyle(_, h.mode, !1), S.length && h.mode && this.updateHoverStyle(S, h.mode, !0);
  }
  _eventHandler(i, l) {
    const u = {
      event: i,
      replay: l,
      cancelable: !0,
      inChartArea: this.isPointInArea(i)
    }, h = (_) => (_.options.events || this.options.events).includes(i.native.type);
    if (this.notifyPlugins("beforeEvent", u, h) === !1)
      return;
    const g = this._handleEvent(i, l, u.inChartArea);
    return u.cancelable = !1, this.notifyPlugins("afterEvent", u, h), (g || u.changed) && this.render(), this;
  }
  _handleEvent(i, l, u) {
    const { _active: h = [], options: g } = this, _ = l, S = this._getActiveElements(i, h, u, _), T = O2(i), E = vA(i, this._lastEvent, u, T);
    u && (this._lastEvent = null, ri(g.onHover, [
      i,
      S,
      this
    ], this), T && ri(g.onClick, [
      i,
      S,
      this
    ], this));
    const D = !_0(S, h);
    return (D || l) && (this._active = S, this._updateHoverStyles(S, h, l)), this._lastEvent = E, D;
  }
  _getActiveElements(i, l, u, h) {
    if (i.type === "mouseout")
      return [];
    if (!u)
      return l;
    const g = this.options.hover;
    return this.getElementsAtEventForMode(i, g.mode, g, h);
  }
}
function Wx() {
  return un(L1.instances, (s) => s._plugins.invalidate());
}
function aM(s, i, l = i) {
  s.lineCap = gn(l.borderCapStyle, i.borderCapStyle), s.setLineDash(gn(l.borderDash, i.borderDash)), s.lineDashOffset = gn(l.borderDashOffset, i.borderDashOffset), s.lineJoin = gn(l.borderJoinStyle, i.borderJoinStyle), s.lineWidth = gn(l.borderWidth, i.borderWidth), s.strokeStyle = gn(l.borderColor, i.borderColor);
}
function _A(s, i, l) {
  s.lineTo(l.x, l.y);
}
function bA(s) {
  return s.stepped ? iO : s.tension || s.cubicInterpolationMode === "monotone" ? aO : _A;
}
function oM(s, i, l = {}) {
  const u = s.length, { start: h = 0, end: g = u - 1 } = l, { start: _, end: S } = i, T = Math.max(h, _), E = Math.min(g, S), D = h < _ && g < _ || h > S && g > S;
  return {
    count: u,
    start: T,
    loop: i.loop,
    ilen: E < T && !D ? u + E - T : E - T
  };
}
function SA(s, i, l, u) {
  const { points: h, options: g } = i, { count: _, start: S, loop: T, ilen: E } = oM(h, l, u), D = bA(g);
  let { move: C = !0, reverse: z } = u || {}, j, I, Q;
  for (j = 0; j <= E; ++j)
    I = h[(S + (z ? E - j : j)) % _], !I.skip && (C ? (s.moveTo(I.x, I.y), C = !1) : D(s, Q, I, z, g.stepped), Q = I);
  return T && (I = h[(S + (z ? E : 0)) % _], D(s, Q, I, z, g.stepped)), !!T;
}
function TA(s, i, l, u) {
  const h = i.points, { count: g, start: _, ilen: S } = oM(h, l, u), { move: T = !0, reverse: E } = u || {};
  let D = 0, C = 0, z, j, I, Q, X, nt;
  const Dt = (zt) => (_ + (E ? S - zt : zt)) % g, Et = () => {
    Q !== X && (s.lineTo(D, X), s.lineTo(D, Q), s.lineTo(D, nt));
  };
  for (T && (j = h[Dt(0)], s.moveTo(j.x, j.y)), z = 0; z <= S; ++z) {
    if (j = h[Dt(z)], j.skip)
      continue;
    const zt = j.x, dt = j.y, Lt = zt | 0;
    Lt === I ? (dt < Q ? Q = dt : dt > X && (X = dt), D = (C * D + zt) / ++C) : (Et(), s.lineTo(zt, dt), I = Lt, C = 0, Q = X = dt), nt = dt;
  }
  Et();
}
function d1(s) {
  const i = s.options, l = i.borderDash && i.borderDash.length;
  return !s._decimated && !s._loop && !i.tension && i.cubicInterpolationMode !== "monotone" && !i.stepped && !l ? TA : SA;
}
function xA(s) {
  return s.stepped ? UO : s.tension || s.cubicInterpolationMode === "monotone" ? BO : fd;
}
function wA(s, i, l, u) {
  let h = i._path;
  h || (h = i._path = new Path2D(), i.path(h, l, u) && h.closePath()), aM(s, i.options), s.stroke(h);
}
function MA(s, i, l, u) {
  const { segments: h, options: g } = i, _ = d1(i);
  for (const S of h)
    aM(s, g, S.style), s.beginPath(), _(s, i, S, {
      start: l,
      end: l + u - 1
    }) && s.closePath(), s.stroke();
}
const EA = typeof Path2D == "function";
function OA(s, i, l, u) {
  EA && !i.options.segment ? wA(s, i, l, u) : MA(s, i, l, u);
}
class R0 extends Tv {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (i) => i !== "borderDash" && i !== "fill"
  };
  constructor(i) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, i && Object.assign(this, i);
  }
  updateControlPoints(i, l) {
    const u = this.options;
    if ((u.tension || u.cubicInterpolationMode === "monotone") && !u.stepped && !this._pointsUpdated) {
      const h = u.spanGaps ? this._loop : this._fullLoop;
      AO(this._points, u, i, h, l), this._pointsUpdated = !0;
    }
  }
  set points(i) {
    this._points = i, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = XO(this, this.options.segment));
  }
  first() {
    const i = this.segments, l = this.points;
    return i.length && l[i[0].start];
  }
  last() {
    const i = this.segments, l = this.points, u = i.length;
    return u && l[i[u - 1].end];
  }
  interpolate(i, l) {
    const u = this.options, h = i[l], g = this.points, _ = Pw(this, {
      property: l,
      start: h,
      end: h
    });
    if (!_.length)
      return;
    const S = [], T = xA(u);
    let E, D;
    for (E = 0, D = _.length; E < D; ++E) {
      const { start: C, end: z } = _[E], j = g[C], I = g[z];
      if (j === I) {
        S.push(j);
        continue;
      }
      const Q = Math.abs((h - j[l]) / (I[l] - j[l])), X = T(j, I, Q, u.stepped);
      X[l] = i[l], S.push(X);
    }
    return S.length === 1 ? S[0] : S;
  }
  pathSegment(i, l, u) {
    return d1(this)(i, this, l, u);
  }
  path(i, l, u) {
    const h = this.segments, g = d1(this);
    let _ = this._loop;
    l = l || 0, u = u || this.points.length - l;
    for (const S of h)
      _ &= g(i, this, S, {
        start: l,
        end: l + u - 1
      });
    return !!_;
  }
  draw(i, l, u, h) {
    const g = this.options || {};
    (this.points || []).length && g.borderWidth && (i.save(), OA(i, this, u, h), i.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
function Ix(s, i, l, u) {
  const h = s.options, { [l]: g } = s.getProps([
    l
  ], u);
  return Math.abs(i - g) < h.radius + h.hitRadius;
}
class DA extends Tv {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(i) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, i && Object.assign(this, i);
  }
  inRange(i, l, u) {
    const h = this.options, { x: g, y: _ } = this.getProps([
      "x",
      "y"
    ], u);
    return Math.pow(i - g, 2) + Math.pow(l - _, 2) < Math.pow(h.hitRadius + h.radius, 2);
  }
  inXRange(i, l) {
    return Ix(this, i, "x", l);
  }
  inYRange(i, l) {
    return Ix(this, i, "y", l);
  }
  getCenterPoint(i) {
    const { x: l, y: u } = this.getProps([
      "x",
      "y"
    ], i);
    return {
      x: l,
      y: u
    };
  }
  size(i) {
    i = i || this.options || {};
    let l = i.radius || 0;
    l = Math.max(l, l && i.hoverRadius || 0);
    const u = l && i.borderWidth || 0;
    return (l + u) * 2;
  }
  draw(i, l) {
    const u = this.options;
    this.skip || u.radius < 0.1 || !_v(this, l, this.size(u) / 2) || (i.strokeStyle = u.borderColor, i.lineWidth = u.borderWidth, i.fillStyle = u.backgroundColor, c1(i, u, this.x, this.y));
  }
  getRange() {
    const i = this.options || {};
    return i.radius + i.hitRadius;
  }
}
function AA(s, i, l) {
  const u = s.segments, h = s.points, g = i.points, _ = [];
  for (const S of u) {
    let { start: T, end: E } = S;
    E = C0(T, E, h);
    const D = m1(l, h[T], h[E], S.loop);
    if (!i.segments) {
      _.push({
        source: S,
        target: D,
        start: h[T],
        end: h[E]
      });
      continue;
    }
    const C = Pw(i, D);
    for (const z of C) {
      const j = m1(l, g[z.start], g[z.end], z.loop), I = Zw(S, h, j);
      for (const Q of I)
        _.push({
          source: Q,
          target: z,
          start: {
            [l]: $x(D, j, "start", Math.max)
          },
          end: {
            [l]: $x(D, j, "end", Math.min)
          }
        });
    }
  }
  return _;
}
function m1(s, i, l, u) {
  if (u)
    return;
  let h = i[s], g = l[s];
  return s === "angle" && (h = lu(h), g = lu(g)), {
    property: s,
    start: h,
    end: g
  };
}
function RA(s, i) {
  const { x: l = null, y: u = null } = s || {}, h = i.points, g = [];
  return i.segments.forEach(({ start: _, end: S }) => {
    S = C0(_, S, h);
    const T = h[_], E = h[S];
    u !== null ? (g.push({
      x: T.x,
      y: u
    }), g.push({
      x: E.x,
      y: u
    })) : l !== null && (g.push({
      x: l,
      y: T.y
    }), g.push({
      x: l,
      y: E.y
    }));
  }), g;
}
function C0(s, i, l) {
  for (; i > s; i--) {
    const u = l[i];
    if (!isNaN(u.x) && !isNaN(u.y))
      break;
  }
  return i;
}
function $x(s, i, l, u) {
  return s && i ? u(s[l], i[l]) : s ? s[l] : i ? i[l] : 0;
}
function lM(s, i) {
  let l = [], u = !1;
  return Fi(s) ? (u = !0, l = s) : l = RA(s, i), l.length ? new R0({
    points: l,
    options: {
      tension: 0
    },
    _loop: u,
    _fullLoop: u
  }) : null;
}
function Jx(s) {
  return s && s.fill !== !1;
}
function CA(s, i, l) {
  let h = s[i].fill;
  const g = [
    i
  ];
  let _;
  if (!l)
    return h;
  for (; h !== !1 && g.indexOf(h) === -1; ) {
    if (!qa(h))
      return h;
    if (_ = s[h], !_)
      return !1;
    if (_.visible)
      return h;
    g.push(h), h = _.fill;
  }
  return !1;
}
function zA(s, i, l) {
  const u = NA(s);
  if (Ve(u))
    return isNaN(u.value) ? !1 : u;
  let h = parseFloat(u);
  return qa(h) && Math.floor(h) === h ? LA(u[0], i, h, l) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(u) >= 0 && u;
}
function LA(s, i, l, u) {
  return (s === "-" || s === "+") && (l = i + l), l === i || l < 0 || l >= u ? !1 : l;
}
function HA(s, i) {
  let l = null;
  return s === "start" ? l = i.bottom : s === "end" ? l = i.top : Ve(s) ? l = i.getPixelForValue(s.value) : i.getBasePixel && (l = i.getBasePixel()), l;
}
function kA(s, i, l) {
  let u;
  return s === "start" ? u = l : s === "end" ? u = i.options.reverse ? i.min : i.max : Ve(s) ? u = s.value : u = i.getBaseValue(), u;
}
function NA(s) {
  const i = s.options, l = i.fill;
  let u = gn(l && l.target, l);
  return u === void 0 && (u = !!i.backgroundColor), u === !1 || u === null ? !1 : u === !0 ? "origin" : u;
}
function UA(s) {
  const { scale: i, index: l, line: u } = s, h = [], g = u.segments, _ = u.points, S = BA(i, l);
  S.push(lM({
    x: null,
    y: i.bottom
  }, u));
  for (let T = 0; T < g.length; T++) {
    const E = g[T];
    for (let D = E.start; D <= E.end; D++)
      YA(h, _[D], S);
  }
  return new R0({
    points: h,
    options: {}
  });
}
function BA(s, i) {
  const l = [], u = s.getMatchingVisibleMetas("line");
  for (let h = 0; h < u.length; h++) {
    const g = u[h];
    if (g.index === i)
      break;
    g.hidden || l.unshift(g.dataset);
  }
  return l;
}
function YA(s, i, l) {
  const u = [];
  for (let h = 0; h < l.length; h++) {
    const g = l[h], { first: _, last: S, point: T } = jA(g, i, "x");
    if (!(!T || _ && S)) {
      if (_)
        u.unshift(T);
      else if (s.push(T), !S)
        break;
    }
  }
  s.push(...u);
}
function jA(s, i, l) {
  const u = s.interpolate(i, l);
  if (!u)
    return {};
  const h = u[l], g = s.segments, _ = s.points;
  let S = !1, T = !1;
  for (let E = 0; E < g.length; E++) {
    const D = g[E], C = _[D.start][l], z = _[D.end][l];
    if (Aw(h, C, z)) {
      S = h === C, T = h === z;
      break;
    }
  }
  return {
    first: S,
    last: T,
    point: u
  };
}
class sM {
  constructor(i) {
    this.x = i.x, this.y = i.y, this.radius = i.radius;
  }
  pathSegment(i, l, u) {
    const { x: h, y: g, radius: _ } = this;
    return l = l || {
      start: 0,
      end: cu
    }, i.arc(h, g, _, l.end, l.start, !0), !u.bounds;
  }
  interpolate(i) {
    const { x: l, y: u, radius: h } = this, g = i.angle;
    return {
      x: l + Math.cos(g) * h,
      y: u + Math.sin(g) * h,
      angle: g
    };
  }
}
function qA(s) {
  const { chart: i, fill: l, line: u } = s;
  if (qa(l))
    return ZA(i, l);
  if (l === "stack")
    return UA(s);
  if (l === "shape")
    return !0;
  const h = PA(s);
  return h instanceof sM ? h : lM(h, u);
}
function ZA(s, i) {
  const l = s.getDatasetMeta(i);
  return l && s.isDatasetVisible(i) ? l.dataset : null;
}
function PA(s) {
  return (s.scale || {}).getPointPositionForValue ? GA(s) : VA(s);
}
function VA(s) {
  const { scale: i = {}, fill: l } = s, u = HA(l, i);
  if (qa(u)) {
    const h = i.isHorizontal();
    return {
      x: h ? u : null,
      y: h ? null : u
    };
  }
  return null;
}
function GA(s) {
  const { scale: i, fill: l } = s, u = i.options, h = i.getLabels().length, g = u.reverse ? i.max : i.min, _ = kA(l, i, g), S = [];
  if (u.grid.circular) {
    const T = i.getPointPositionForValue(0, g);
    return new sM({
      x: T.x,
      y: T.y,
      radius: i.getDistanceFromCenterForValue(_)
    });
  }
  for (let T = 0; T < h; ++T)
    S.push(i.getPointPositionForValue(T, _));
  return S;
}
function i1(s, i, l) {
  const u = qA(i), { chart: h, index: g, line: _, scale: S, axis: T } = i, E = _.options, D = E.fill, C = E.backgroundColor, { above: z = C, below: j = C } = D || {}, I = h.getDatasetMeta(g), Q = Vw(h, I);
  u && _.points.length && (M1(s, l), XA(s, {
    line: _,
    target: u,
    above: z,
    below: j,
    area: l,
    scale: S,
    axis: T,
    clip: Q
  }), E1(s));
}
function XA(s, i) {
  const { line: l, target: u, above: h, below: g, area: _, scale: S, clip: T } = i, E = l._loop ? "angle" : i.axis;
  s.save();
  let D = g;
  g !== h && (E === "x" ? (Fx(s, u, _.top), a1(s, {
    line: l,
    target: u,
    color: h,
    scale: S,
    property: E,
    clip: T
  }), s.restore(), s.save(), Fx(s, u, _.bottom)) : E === "y" && (tw(s, u, _.left), a1(s, {
    line: l,
    target: u,
    color: g,
    scale: S,
    property: E,
    clip: T
  }), s.restore(), s.save(), tw(s, u, _.right), D = h)), a1(s, {
    line: l,
    target: u,
    color: D,
    scale: S,
    property: E,
    clip: T
  }), s.restore();
}
function Fx(s, i, l) {
  const { segments: u, points: h } = i;
  let g = !0, _ = !1;
  s.beginPath();
  for (const S of u) {
    const { start: T, end: E } = S, D = h[T], C = h[C0(T, E, h)];
    g ? (s.moveTo(D.x, D.y), g = !1) : (s.lineTo(D.x, l), s.lineTo(D.x, D.y)), _ = !!i.pathSegment(s, S, {
      move: _
    }), _ ? s.closePath() : s.lineTo(C.x, l);
  }
  s.lineTo(i.first().x, l), s.closePath(), s.clip();
}
function tw(s, i, l) {
  const { segments: u, points: h } = i;
  let g = !0, _ = !1;
  s.beginPath();
  for (const S of u) {
    const { start: T, end: E } = S, D = h[T], C = h[C0(T, E, h)];
    g ? (s.moveTo(D.x, D.y), g = !1) : (s.lineTo(l, D.y), s.lineTo(D.x, D.y)), _ = !!i.pathSegment(s, S, {
      move: _
    }), _ ? s.closePath() : s.lineTo(l, C.y);
  }
  s.lineTo(l, i.first().y), s.closePath(), s.clip();
}
function a1(s, i) {
  const { line: l, target: u, property: h, color: g, scale: _, clip: S } = i, T = AA(l, u, h);
  for (const { source: E, target: D, start: C, end: z } of T) {
    const { style: { backgroundColor: j = g } = {} } = E, I = u !== !0;
    s.save(), s.fillStyle = j, QA(s, _, S, I && m1(h, C, z)), s.beginPath();
    const Q = !!l.pathSegment(s, E);
    let X;
    if (I) {
      Q ? s.closePath() : ew(s, u, z, h);
      const nt = !!u.pathSegment(s, D, {
        move: Q,
        reverse: !0
      });
      X = Q && nt, X || ew(s, u, C, h);
    }
    s.closePath(), s.fill(X ? "evenodd" : "nonzero"), s.restore();
  }
}
function QA(s, i, l, u) {
  const h = i.chart.chartArea, { property: g, start: _, end: S } = u || {};
  if (g === "x" || g === "y") {
    let T, E, D, C;
    g === "x" ? (T = _, E = h.top, D = S, C = h.bottom) : (T = h.left, E = _, D = h.right, C = S), s.beginPath(), l && (T = Math.max(T, l.left), D = Math.min(D, l.right), E = Math.max(E, l.top), C = Math.min(C, l.bottom)), s.rect(T, E, D - T, C - E), s.clip();
  }
}
function ew(s, i, l, u) {
  const h = i.interpolate(l, u);
  h && s.lineTo(h.x, h.y);
}
var KA = {
  id: "filler",
  afterDatasetsUpdate(s, i, l) {
    const u = (s.data.datasets || []).length, h = [];
    let g, _, S, T;
    for (_ = 0; _ < u; ++_)
      g = s.getDatasetMeta(_), S = g.dataset, T = null, S && S.options && S instanceof R0 && (T = {
        visible: s.isDatasetVisible(_),
        index: _,
        fill: zA(S, _, u),
        chart: s,
        axis: g.controller.options.indexAxis,
        scale: g.vScale,
        line: S
      }), g.$filler = T, h.push(T);
    for (_ = 0; _ < u; ++_)
      T = h[_], !(!T || T.fill === !1) && (T.fill = CA(h, _, l.propagate));
  },
  beforeDraw(s, i, l) {
    const u = l.drawTime === "beforeDraw", h = s.getSortedVisibleDatasetMetas(), g = s.chartArea;
    for (let _ = h.length - 1; _ >= 0; --_) {
      const S = h[_].$filler;
      S && (S.line.updateControlPoints(g, S.axis), u && S.fill && i1(s.ctx, S, g));
    }
  },
  beforeDatasetsDraw(s, i, l) {
    if (l.drawTime !== "beforeDatasetsDraw")
      return;
    const u = s.getSortedVisibleDatasetMetas();
    for (let h = u.length - 1; h >= 0; --h) {
      const g = u[h].$filler;
      Jx(g) && i1(s.ctx, g, s.chartArea);
    }
  },
  beforeDatasetDraw(s, i, l) {
    const u = i.meta.$filler;
    !Jx(u) || l.drawTime !== "beforeDatasetDraw" || i1(s.ctx, u, s.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const rv = {
  average(s) {
    if (!s.length)
      return !1;
    let i, l, u = /* @__PURE__ */ new Set(), h = 0, g = 0;
    for (i = 0, l = s.length; i < l; ++i) {
      const S = s[i].element;
      if (S && S.hasValue()) {
        const T = S.tooltipPosition();
        u.add(T.x), h += T.y, ++g;
      }
    }
    return g === 0 || u.size === 0 ? !1 : {
      x: [
        ...u
      ].reduce((S, T) => S + T) / u.size,
      y: h / g
    };
  },
  nearest(s, i) {
    if (!s.length)
      return !1;
    let l = i.x, u = i.y, h = Number.POSITIVE_INFINITY, g, _, S;
    for (g = 0, _ = s.length; g < _; ++g) {
      const T = s[g].element;
      if (T && T.hasValue()) {
        const E = T.getCenterPoint(), D = r1(i, E);
        D < h && (h = D, S = T);
      }
    }
    if (S) {
      const T = S.tooltipPosition();
      l = T.x, u = T.y;
    }
    return {
      x: l,
      y: u
    };
  }
};
function au(s, i) {
  return i && (Fi(i) ? Array.prototype.push.apply(s, i) : s.push(i)), s;
}
function fc(s) {
  return (typeof s == "string" || s instanceof String) && s.indexOf(`
`) > -1 ? s.split(`
`) : s;
}
function WA(s, i) {
  const { element: l, datasetIndex: u, index: h } = i, g = s.getDatasetMeta(u).controller, { label: _, value: S } = g.getLabelAndValue(h);
  return {
    chart: s,
    label: _,
    parsed: g.getParsed(h),
    raw: s.data.datasets[u].data[h],
    formattedValue: S,
    dataset: g.getDataset(),
    dataIndex: h,
    datasetIndex: u,
    element: l
  };
}
function nw(s, i) {
  const l = s.chart.ctx, { body: u, footer: h, title: g } = s, { boxWidth: _, boxHeight: S } = i, T = uu(i.bodyFont), E = uu(i.titleFont), D = uu(i.footerFont), C = g.length, z = h.length, j = u.length, I = Of(i.padding);
  let Q = I.height, X = 0, nt = u.reduce((zt, dt) => zt + dt.before.length + dt.lines.length + dt.after.length, 0);
  if (nt += s.beforeBody.length + s.afterBody.length, C && (Q += C * E.lineHeight + (C - 1) * i.titleSpacing + i.titleMarginBottom), nt) {
    const zt = i.displayColors ? Math.max(S, T.lineHeight) : T.lineHeight;
    Q += j * zt + (nt - j) * T.lineHeight + (nt - 1) * i.bodySpacing;
  }
  z && (Q += i.footerMarginTop + z * D.lineHeight + (z - 1) * i.footerSpacing);
  let Dt = 0;
  const Et = function(zt) {
    X = Math.max(X, l.measureText(zt).width + Dt);
  };
  return l.save(), l.font = E.string, un(s.title, Et), l.font = T.string, un(s.beforeBody.concat(s.afterBody), Et), Dt = i.displayColors ? _ + 2 + i.boxPadding : 0, un(u, (zt) => {
    un(zt.before, Et), un(zt.lines, Et), un(zt.after, Et);
  }), Dt = 0, l.font = D.string, un(s.footer, Et), l.restore(), X += I.width, {
    width: X,
    height: Q
  };
}
function IA(s, i) {
  const { y: l, height: u } = i;
  return l < u / 2 ? "top" : l > s.height - u / 2 ? "bottom" : "center";
}
function $A(s, i, l, u) {
  const { x: h, width: g } = u, _ = l.caretSize + l.caretPadding;
  if (s === "left" && h + g + _ > i.width || s === "right" && h - g - _ < 0)
    return !0;
}
function JA(s, i, l, u) {
  const { x: h, width: g } = l, { width: _, chartArea: { left: S, right: T } } = s;
  let E = "center";
  return u === "center" ? E = h <= (S + T) / 2 ? "left" : "right" : h <= g / 2 ? E = "left" : h >= _ - g / 2 && (E = "right"), $A(E, s, i, l) && (E = "center"), E;
}
function iw(s, i, l) {
  const u = l.yAlign || i.yAlign || IA(s, l);
  return {
    xAlign: l.xAlign || i.xAlign || JA(s, i, l, u),
    yAlign: u
  };
}
function FA(s, i) {
  let { x: l, width: u } = s;
  return i === "right" ? l -= u : i === "center" && (l -= u / 2), l;
}
function tR(s, i, l) {
  let { y: u, height: h } = s;
  return i === "top" ? u += l : i === "bottom" ? u -= h + l : u -= h / 2, u;
}
function aw(s, i, l, u) {
  const { caretSize: h, caretPadding: g, cornerRadius: _ } = s, { xAlign: S, yAlign: T } = l, E = h + g, { topLeft: D, topRight: C, bottomLeft: z, bottomRight: j } = g0(_);
  let I = FA(i, S);
  const Q = tR(i, T, E);
  return T === "center" ? S === "left" ? I += E : S === "right" && (I -= E) : S === "left" ? I -= Math.max(D, z) + h : S === "right" && (I += Math.max(C, j) + h), {
    x: rr(I, 0, u.width - i.width),
    y: rr(Q, 0, u.height - i.height)
  };
}
function d0(s, i, l) {
  const u = Of(l.padding);
  return i === "center" ? s.x + s.width / 2 : i === "right" ? s.x + s.width - u.right : s.x + u.left;
}
function ow(s) {
  return au([], fc(s));
}
function eR(s, i, l) {
  return yd(s, {
    tooltip: i,
    tooltipItems: l,
    type: "tooltip"
  });
}
function lw(s, i) {
  const l = i && i.dataset && i.dataset.tooltip && i.dataset.tooltip.callbacks;
  return l ? s.override(l) : s;
}
const rM = {
  beforeTitle: uc,
  title(s) {
    if (s.length > 0) {
      const i = s[0], l = i.chart.data.labels, u = l ? l.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return i.dataset.label || "";
      if (i.label)
        return i.label;
      if (u > 0 && i.dataIndex < u)
        return l[i.dataIndex];
    }
    return "";
  },
  afterTitle: uc,
  beforeBody: uc,
  beforeLabel: uc,
  label(s) {
    if (this && this.options && this.options.mode === "dataset")
      return s.label + ": " + s.formattedValue || s.formattedValue;
    let i = s.dataset.label || "";
    i && (i += ": ");
    const l = s.formattedValue;
    return Mn(l) || (i += l), i;
  },
  labelColor(s) {
    const l = s.chart.getDatasetMeta(s.datasetIndex).controller.getStyle(s.dataIndex);
    return {
      borderColor: l.borderColor,
      backgroundColor: l.backgroundColor,
      borderWidth: l.borderWidth,
      borderDash: l.borderDash,
      borderDashOffset: l.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(s) {
    const l = s.chart.getDatasetMeta(s.datasetIndex).controller.getStyle(s.dataIndex);
    return {
      pointStyle: l.pointStyle,
      rotation: l.rotation
    };
  },
  afterLabel: uc,
  afterBody: uc,
  beforeFooter: uc,
  footer: uc,
  afterFooter: uc
};
function Qo(s, i, l, u) {
  const h = s[i].call(l, u);
  return typeof h > "u" ? rM[i].call(l, u) : h;
}
class sw extends Tv {
  static positioners = rv;
  constructor(i) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = i.chart, this.options = i.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(i) {
    this.options = i, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const i = this._cachedAnimations;
    if (i)
      return i;
    const l = this.chart, u = this.options.setContext(this.getContext()), h = u.enabled && l.options.animation && u.animations, g = new Gw(this.chart, h);
    return h._cacheable && (this._cachedAnimations = Object.freeze(g)), g;
  }
  getContext() {
    return this.$context || (this.$context = eR(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(i, l) {
    const { callbacks: u } = l, h = Qo(u, "beforeTitle", this, i), g = Qo(u, "title", this, i), _ = Qo(u, "afterTitle", this, i);
    let S = [];
    return S = au(S, fc(h)), S = au(S, fc(g)), S = au(S, fc(_)), S;
  }
  getBeforeBody(i, l) {
    return ow(Qo(l.callbacks, "beforeBody", this, i));
  }
  getBody(i, l) {
    const { callbacks: u } = l, h = [];
    return un(i, (g) => {
      const _ = {
        before: [],
        lines: [],
        after: []
      }, S = lw(u, g);
      au(_.before, fc(Qo(S, "beforeLabel", this, g))), au(_.lines, Qo(S, "label", this, g)), au(_.after, fc(Qo(S, "afterLabel", this, g))), h.push(_);
    }), h;
  }
  getAfterBody(i, l) {
    return ow(Qo(l.callbacks, "afterBody", this, i));
  }
  getFooter(i, l) {
    const { callbacks: u } = l, h = Qo(u, "beforeFooter", this, i), g = Qo(u, "footer", this, i), _ = Qo(u, "afterFooter", this, i);
    let S = [];
    return S = au(S, fc(h)), S = au(S, fc(g)), S = au(S, fc(_)), S;
  }
  _createItems(i) {
    const l = this._active, u = this.chart.data, h = [], g = [], _ = [];
    let S = [], T, E;
    for (T = 0, E = l.length; T < E; ++T)
      S.push(WA(this.chart, l[T]));
    return i.filter && (S = S.filter((D, C, z) => i.filter(D, C, z, u))), i.itemSort && (S = S.sort((D, C) => i.itemSort(D, C, u))), un(S, (D) => {
      const C = lw(i.callbacks, D);
      h.push(Qo(C, "labelColor", this, D)), g.push(Qo(C, "labelPointStyle", this, D)), _.push(Qo(C, "labelTextColor", this, D));
    }), this.labelColors = h, this.labelPointStyles = g, this.labelTextColors = _, this.dataPoints = S, S;
  }
  update(i, l) {
    const u = this.options.setContext(this.getContext()), h = this._active;
    let g, _ = [];
    if (!h.length)
      this.opacity !== 0 && (g = {
        opacity: 0
      });
    else {
      const S = rv[u.position].call(this, h, this._eventPosition);
      _ = this._createItems(u), this.title = this.getTitle(_, u), this.beforeBody = this.getBeforeBody(_, u), this.body = this.getBody(_, u), this.afterBody = this.getAfterBody(_, u), this.footer = this.getFooter(_, u);
      const T = this._size = nw(this, u), E = Object.assign({}, S, T), D = iw(this.chart, u, E), C = aw(u, E, D, this.chart);
      this.xAlign = D.xAlign, this.yAlign = D.yAlign, g = {
        opacity: 1,
        x: C.x,
        y: C.y,
        width: T.width,
        height: T.height,
        caretX: S.x,
        caretY: S.y
      };
    }
    this._tooltipItems = _, this.$context = void 0, g && this._resolveAnimations().update(this, g), i && u.external && u.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: l
    });
  }
  drawCaret(i, l, u, h) {
    const g = this.getCaretPosition(i, u, h);
    l.lineTo(g.x1, g.y1), l.lineTo(g.x2, g.y2), l.lineTo(g.x3, g.y3);
  }
  getCaretPosition(i, l, u) {
    const { xAlign: h, yAlign: g } = this, { caretSize: _, cornerRadius: S } = u, { topLeft: T, topRight: E, bottomLeft: D, bottomRight: C } = g0(S), { x: z, y: j } = i, { width: I, height: Q } = l;
    let X, nt, Dt, Et, zt, dt;
    return g === "center" ? (zt = j + Q / 2, h === "left" ? (X = z, nt = X - _, Et = zt + _, dt = zt - _) : (X = z + I, nt = X + _, Et = zt - _, dt = zt + _), Dt = X) : (h === "left" ? nt = z + Math.max(T, D) + _ : h === "right" ? nt = z + I - Math.max(E, C) - _ : nt = this.caretX, g === "top" ? (Et = j, zt = Et - _, X = nt - _, Dt = nt + _) : (Et = j + Q, zt = Et + _, X = nt + _, Dt = nt - _), dt = Et), {
      x1: X,
      x2: nt,
      x3: Dt,
      y1: Et,
      y2: zt,
      y3: dt
    };
  }
  drawTitle(i, l, u) {
    const h = this.title, g = h.length;
    let _, S, T;
    if (g) {
      const E = Ib(u.rtl, this.x, this.width);
      for (i.x = d0(this, u.titleAlign, u), l.textAlign = E.textAlign(u.titleAlign), l.textBaseline = "middle", _ = uu(u.titleFont), S = u.titleSpacing, l.fillStyle = u.titleColor, l.font = _.string, T = 0; T < g; ++T)
        l.fillText(h[T], E.x(i.x), i.y + _.lineHeight / 2), i.y += _.lineHeight + S, T + 1 === g && (i.y += u.titleMarginBottom - S);
    }
  }
  _drawColorBox(i, l, u, h, g) {
    const _ = this.labelColors[u], S = this.labelPointStyles[u], { boxHeight: T, boxWidth: E } = g, D = uu(g.bodyFont), C = d0(this, "left", g), z = h.x(C), j = T < D.lineHeight ? (D.lineHeight - T) / 2 : 0, I = l.y + j;
    if (g.usePointStyle) {
      const Q = {
        radius: Math.min(E, T) / 2,
        pointStyle: S.pointStyle,
        rotation: S.rotation,
        borderWidth: 1
      }, X = h.leftForLtr(z, E) + E / 2, nt = I + T / 2;
      i.strokeStyle = g.multiKeyBackground, i.fillStyle = g.multiKeyBackground, c1(i, Q, X, nt), i.strokeStyle = _.borderColor, i.fillStyle = _.backgroundColor, c1(i, Q, X, nt);
    } else {
      i.lineWidth = Ve(_.borderWidth) ? Math.max(...Object.values(_.borderWidth)) : _.borderWidth || 1, i.strokeStyle = _.borderColor, i.setLineDash(_.borderDash || []), i.lineDashOffset = _.borderDashOffset || 0;
      const Q = h.leftForLtr(z, E), X = h.leftForLtr(h.xPlus(z, 1), E - 2), nt = g0(_.borderRadius);
      Object.values(nt).some((Dt) => Dt !== 0) ? (i.beginPath(), i.fillStyle = g.multiKeyBackground, yx(i, {
        x: Q,
        y: I,
        w: E,
        h: T,
        radius: nt
      }), i.fill(), i.stroke(), i.fillStyle = _.backgroundColor, i.beginPath(), yx(i, {
        x: X,
        y: I + 1,
        w: E - 2,
        h: T - 2,
        radius: nt
      }), i.fill()) : (i.fillStyle = g.multiKeyBackground, i.fillRect(Q, I, E, T), i.strokeRect(Q, I, E, T), i.fillStyle = _.backgroundColor, i.fillRect(X, I + 1, E - 2, T - 2));
    }
    i.fillStyle = this.labelTextColors[u];
  }
  drawBody(i, l, u) {
    const { body: h } = this, { bodySpacing: g, bodyAlign: _, displayColors: S, boxHeight: T, boxWidth: E, boxPadding: D } = u, C = uu(u.bodyFont);
    let z = C.lineHeight, j = 0;
    const I = Ib(u.rtl, this.x, this.width), Q = function(Yt) {
      l.fillText(Yt, I.x(i.x + j), i.y + z / 2), i.y += z + g;
    }, X = I.textAlign(_);
    let nt, Dt, Et, zt, dt, Lt, Ct;
    for (l.textAlign = _, l.textBaseline = "middle", l.font = C.string, i.x = d0(this, X, u), l.fillStyle = u.bodyColor, un(this.beforeBody, Q), j = S && X !== "right" ? _ === "center" ? E / 2 + D : E + 2 + D : 0, zt = 0, Lt = h.length; zt < Lt; ++zt) {
      for (nt = h[zt], Dt = this.labelTextColors[zt], l.fillStyle = Dt, un(nt.before, Q), Et = nt.lines, S && Et.length && (this._drawColorBox(l, i, zt, I, u), z = Math.max(C.lineHeight, T)), dt = 0, Ct = Et.length; dt < Ct; ++dt)
        Q(Et[dt]), z = C.lineHeight;
      un(nt.after, Q);
    }
    j = 0, z = C.lineHeight, un(this.afterBody, Q), i.y -= g;
  }
  drawFooter(i, l, u) {
    const h = this.footer, g = h.length;
    let _, S;
    if (g) {
      const T = Ib(u.rtl, this.x, this.width);
      for (i.x = d0(this, u.footerAlign, u), i.y += u.footerMarginTop, l.textAlign = T.textAlign(u.footerAlign), l.textBaseline = "middle", _ = uu(u.footerFont), l.fillStyle = u.footerColor, l.font = _.string, S = 0; S < g; ++S)
        l.fillText(h[S], T.x(i.x), i.y + _.lineHeight / 2), i.y += _.lineHeight + u.footerSpacing;
    }
  }
  drawBackground(i, l, u, h) {
    const { xAlign: g, yAlign: _ } = this, { x: S, y: T } = i, { width: E, height: D } = u, { topLeft: C, topRight: z, bottomLeft: j, bottomRight: I } = g0(h.cornerRadius);
    l.fillStyle = h.backgroundColor, l.strokeStyle = h.borderColor, l.lineWidth = h.borderWidth, l.beginPath(), l.moveTo(S + C, T), _ === "top" && this.drawCaret(i, l, u, h), l.lineTo(S + E - z, T), l.quadraticCurveTo(S + E, T, S + E, T + z), _ === "center" && g === "right" && this.drawCaret(i, l, u, h), l.lineTo(S + E, T + D - I), l.quadraticCurveTo(S + E, T + D, S + E - I, T + D), _ === "bottom" && this.drawCaret(i, l, u, h), l.lineTo(S + j, T + D), l.quadraticCurveTo(S, T + D, S, T + D - j), _ === "center" && g === "left" && this.drawCaret(i, l, u, h), l.lineTo(S, T + C), l.quadraticCurveTo(S, T, S + C, T), l.closePath(), l.fill(), h.borderWidth > 0 && l.stroke();
  }
  _updateAnimationTarget(i) {
    const l = this.chart, u = this.$animations, h = u && u.x, g = u && u.y;
    if (h || g) {
      const _ = rv[i.position].call(this, this._active, this._eventPosition);
      if (!_)
        return;
      const S = this._size = nw(this, i), T = Object.assign({}, _, this._size), E = iw(l, i, T), D = aw(i, T, E, l);
      (h._to !== D.x || g._to !== D.y) && (this.xAlign = E.xAlign, this.yAlign = E.yAlign, this.width = S.width, this.height = S.height, this.caretX = _.x, this.caretY = _.y, this._resolveAnimations().update(this, D));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(i) {
    const l = this.options.setContext(this.getContext());
    let u = this.opacity;
    if (!u)
      return;
    this._updateAnimationTarget(l);
    const h = {
      width: this.width,
      height: this.height
    }, g = {
      x: this.x,
      y: this.y
    };
    u = Math.abs(u) < 1e-3 ? 0 : u;
    const _ = Of(l.padding), S = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    l.enabled && S && (i.save(), i.globalAlpha = u, this.drawBackground(g, i, h, l), qO(i, l.textDirection), g.y += _.top, this.drawTitle(g, i, l), this.drawBody(g, i, l), this.drawFooter(g, i, l), ZO(i, l.textDirection), i.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(i, l) {
    const u = this._active, h = i.map(({ datasetIndex: S, index: T }) => {
      const E = this.chart.getDatasetMeta(S);
      if (!E)
        throw new Error("Cannot find a dataset at index " + S);
      return {
        datasetIndex: S,
        element: E.data[T],
        index: T
      };
    }), g = !_0(u, h), _ = this._positionChanged(h, l);
    (g || _) && (this._active = h, this._eventPosition = l, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(i, l, u = !0) {
    if (l && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const h = this.options, g = this._active || [], _ = this._getActiveElements(i, g, l, u), S = this._positionChanged(_, i), T = l || !_0(_, g) || S;
    return T && (this._active = _, (h.enabled || h.external) && (this._eventPosition = {
      x: i.x,
      y: i.y
    }, this.update(!0, l))), T;
  }
  _getActiveElements(i, l, u, h) {
    const g = this.options;
    if (i.type === "mouseout")
      return [];
    if (!h)
      return l.filter((S) => this.chart.data.datasets[S.datasetIndex] && this.chart.getDatasetMeta(S.datasetIndex).controller.getParsed(S.index) !== void 0);
    const _ = this.chart.getElementsAtEventForMode(i, g.mode, g, u);
    return g.reverse && _.reverse(), _;
  }
  _positionChanged(i, l) {
    const { caretX: u, caretY: h, options: g } = this, _ = rv[g.position].call(this, i, l);
    return _ !== !1 && (u !== _.x || h !== _.y);
  }
}
var nR = {
  id: "tooltip",
  _element: sw,
  positioners: rv,
  afterInit(s, i, l) {
    l && (s.tooltip = new sw({
      chart: s,
      options: l
    }));
  },
  beforeUpdate(s, i, l) {
    s.tooltip && s.tooltip.initialize(l);
  },
  reset(s, i, l) {
    s.tooltip && s.tooltip.initialize(l);
  },
  afterDraw(s) {
    const i = s.tooltip;
    if (i && i._willRender()) {
      const l = {
        tooltip: i
      };
      if (s.notifyPlugins("beforeTooltipDraw", {
        ...l,
        cancelable: !0
      }) === !1)
        return;
      i.draw(s.ctx), s.notifyPlugins("afterTooltipDraw", l);
    }
  },
  afterEvent(s, i) {
    if (s.tooltip) {
      const l = i.replay;
      s.tooltip.handleEvent(i.event, l, i.inChartArea) && (i.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (s, i) => i.bodyFont.size,
    boxWidth: (s, i) => i.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: rM
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (s) => s !== "filter" && s !== "itemSort" && s !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
function iR(s, i) {
  const l = [], { bounds: h, step: g, min: _, max: S, precision: T, count: E, maxTicks: D, maxDigits: C, includeBounds: z } = s, j = g || 1, I = D - 1, { min: Q, max: X } = i, nt = !Mn(_), Dt = !Mn(S), Et = !Mn(E), zt = (X - Q) / (C + 1);
  let dt = lx((X - Q) / I / j) * j, Lt, Ct, Yt, wt;
  if (dt < 1e-14 && !nt && !Dt)
    return [
      {
        value: Q
      },
      {
        value: X
      }
    ];
  wt = Math.ceil(X / dt) - Math.floor(Q / dt), wt > I && (dt = lx(wt * dt / I / j) * j), Mn(T) || (Lt = Math.pow(10, T), dt = Math.ceil(dt * Lt) / Lt), h === "ticks" ? (Ct = Math.floor(Q / dt) * dt, Yt = Math.ceil(X / dt) * dt) : (Ct = Q, Yt = X), nt && Dt && g && z2((S - _) / g, dt / 1e3) ? (wt = Math.round(Math.min((S - _) / dt, D)), dt = (S - _) / wt, Ct = _, Yt = S) : Et ? (Ct = nt ? _ : Ct, Yt = Dt ? S : Yt, wt = E - 1, dt = (Yt - Ct) / wt) : (wt = (Yt - Ct) / dt, fv(wt, Math.round(wt), dt / 1e3) ? wt = Math.round(wt) : wt = Math.ceil(wt));
  const ne = Math.max(sx(dt), sx(Ct));
  Lt = Math.pow(10, Mn(T) ? ne : T), Ct = Math.round(Ct * Lt) / Lt, Yt = Math.round(Yt * Lt) / Lt;
  let Rt = 0;
  for (nt && (z && Ct !== _ ? (l.push({
    value: _
  }), Ct < _ && Rt++, fv(Math.round((Ct + Rt * dt) * Lt) / Lt, _, rw(_, zt, s)) && Rt++) : Ct < _ && Rt++); Rt < wt; ++Rt) {
    const Nt = Math.round((Ct + Rt * dt) * Lt) / Lt;
    if (Dt && Nt > S)
      break;
    l.push({
      value: Nt
    });
  }
  return Dt && z && Yt !== S ? l.length && fv(l[l.length - 1].value, S, rw(S, zt, s)) ? l[l.length - 1].value = S : l.push({
    value: S
  }) : (!Dt || Yt === S) && l.push({
    value: Yt
  }), l;
}
function rw(s, i, { horizontal: l, minRotation: u }) {
  const h = dd(u), g = (l ? Math.sin(h) : Math.cos(h)) || 1e-3, _ = 0.75 * i * ("" + s).length;
  return Math.min(i / g, _);
}
class aR extends xv {
  constructor(i) {
    super(i), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(i, l) {
    return Mn(i) || (typeof i == "number" || i instanceof Number) && !isFinite(+i) ? null : +i;
  }
  handleTickRangeOptions() {
    const { beginAtZero: i } = this.options, { minDefined: l, maxDefined: u } = this.getUserBounds();
    let { min: h, max: g } = this;
    const _ = (T) => h = l ? h : T, S = (T) => g = u ? g : T;
    if (i) {
      const T = zp(h), E = zp(g);
      T < 0 && E < 0 ? S(0) : T > 0 && E > 0 && _(0);
    }
    if (h === g) {
      let T = g === 0 ? 1 : Math.abs(g * 0.05);
      S(g + T), i || _(h - T);
    }
    this.min = h, this.max = g;
  }
  getTickLimit() {
    const i = this.options.ticks;
    let { maxTicksLimit: l, stepSize: u } = i, h;
    return u ? (h = Math.ceil(this.max / u) - Math.floor(this.min / u) + 1, h > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${u} would result generating up to ${h} ticks. Limiting to 1000.`), h = 1e3)) : (h = this.computeTickLimit(), l = l || 11), l && (h = Math.min(l, h)), h;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const i = this.options, l = i.ticks;
    let u = this.getTickLimit();
    u = Math.max(2, u);
    const h = {
      maxTicks: u,
      bounds: i.bounds,
      min: i.min,
      max: i.max,
      precision: l.precision,
      step: l.stepSize,
      count: l.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: l.minRotation || 0,
      includeBounds: l.includeBounds !== !1
    }, g = this._range || this, _ = iR(h, g);
    return i.bounds === "ticks" && L2(_, this, "value"), i.reverse ? (_.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), _;
  }
  configure() {
    const i = this.ticks;
    let l = this.min, u = this.max;
    if (super.configure(), this.options.offset && i.length) {
      const h = (u - l) / Math.max(i.length - 1, 1) / 2;
      l -= h, u += h;
    }
    this._startValue = l, this._endValue = u, this._valueRange = u - l;
  }
  getLabelForValue(i) {
    return Lw(i, this.chart.options.locale, this.options.ticks.format);
  }
}
class oR extends aR {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: Hw.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min: i, max: l } = this.getMinMax(!0);
    this.min = qa(i) ? i : 0, this.max = qa(l) ? l : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const i = this.isHorizontal(), l = i ? this.width : this.height, u = dd(this.options.ticks.minRotation), h = (i ? Math.sin(u) : Math.cos(u)) || 1e-3, g = this._resolveTickFontOptions(0);
    return Math.ceil(l / Math.min(40, g.lineHeight / h));
  }
  getPixelForValue(i) {
    return i === null ? NaN : this.getPixelForDecimal((i - this._startValue) / this._valueRange);
  }
  getValueForPixel(i) {
    return this._startValue + this.getDecimalForPixel(i) * this._valueRange;
  }
}
const z0 = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, Ko = /* @__PURE__ */ Object.keys(z0);
function uw(s, i) {
  return s - i;
}
function cw(s, i) {
  if (Mn(i))
    return null;
  const l = s._adapter, { parser: u, round: h, isoWeekday: g } = s._parseOpts;
  let _ = i;
  return typeof u == "function" && (_ = u(_)), qa(_) || (_ = typeof u == "string" ? l.parse(_, u) : l.parse(_)), _ === null ? null : (h && (_ = h === "week" && (vv(g) || g === !0) ? l.startOf(_, "isoWeek", g) : l.startOf(_, h)), +_);
}
function fw(s, i, l, u) {
  const h = Ko.length;
  for (let g = Ko.indexOf(s); g < h - 1; ++g) {
    const _ = z0[Ko[g]], S = _.steps ? _.steps : Number.MAX_SAFE_INTEGER;
    if (_.common && Math.ceil((l - i) / (S * _.size)) <= u)
      return Ko[g];
  }
  return Ko[h - 1];
}
function lR(s, i, l, u, h) {
  for (let g = Ko.length - 1; g >= Ko.indexOf(l); g--) {
    const _ = Ko[g];
    if (z0[_].common && s._adapter.diff(h, u, _) >= i - 1)
      return _;
  }
  return Ko[l ? Ko.indexOf(l) : 0];
}
function sR(s) {
  for (let i = Ko.indexOf(s) + 1, l = Ko.length; i < l; ++i)
    if (z0[Ko[i]].common)
      return Ko[i];
}
function hw(s, i, l) {
  if (!l)
    s[i] = !0;
  else if (l.length) {
    const { lo: u, hi: h } = x1(l, i), g = l[u] >= i ? l[u] : l[h];
    s[g] = !0;
  }
}
function rR(s, i, l, u) {
  const h = s._adapter, g = +h.startOf(i[0].value, u), _ = i[i.length - 1].value;
  let S, T;
  for (S = g; S <= _; S = +h.add(S, 1, u))
    T = l[S], T >= 0 && (i[T].major = !0);
  return i;
}
function dw(s, i, l) {
  const u = [], h = {}, g = i.length;
  let _, S;
  for (_ = 0; _ < g; ++_)
    S = i[_], h[S] = _, u.push({
      value: S,
      major: !1
    });
  return g === 0 || !l ? u : rR(s, u, h, l);
}
class p1 extends xv {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  };
  constructor(i) {
    super(i), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(i, l = {}) {
    const u = i.time || (i.time = {}), h = this._adapter = new Kw._date(i.adapters.date);
    h.init(l), cv(u.displayFormats, h.formats()), this._parseOpts = {
      parser: u.parser,
      round: u.round,
      isoWeekday: u.isoWeekday
    }, super.init(i), this._normalized = l.normalized;
  }
  parse(i, l) {
    return i === void 0 ? null : cw(this, i);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const i = this.options, l = this._adapter, u = i.time.unit || "day";
    let { min: h, max: g, minDefined: _, maxDefined: S } = this.getUserBounds();
    function T(E) {
      !_ && !isNaN(E.min) && (h = Math.min(h, E.min)), !S && !isNaN(E.max) && (g = Math.max(g, E.max));
    }
    (!_ || !S) && (T(this._getLabelBounds()), (i.bounds !== "ticks" || i.ticks.source !== "labels") && T(this.getMinMax(!1))), h = qa(h) && !isNaN(h) ? h : +l.startOf(Date.now(), u), g = qa(g) && !isNaN(g) ? g : +l.endOf(Date.now(), u) + 1, this.min = Math.min(h, g - 1), this.max = Math.max(h + 1, g);
  }
  _getLabelBounds() {
    const i = this.getLabelTimestamps();
    let l = Number.POSITIVE_INFINITY, u = Number.NEGATIVE_INFINITY;
    return i.length && (l = i[0], u = i[i.length - 1]), {
      min: l,
      max: u
    };
  }
  buildTicks() {
    const i = this.options, l = i.time, u = i.ticks, h = u.source === "labels" ? this.getLabelTimestamps() : this._generate();
    i.bounds === "ticks" && h.length && (this.min = this._userMin || h[0], this.max = this._userMax || h[h.length - 1]);
    const g = this.min, _ = this.max, S = Y2(h, g, _);
    return this._unit = l.unit || (u.autoSkip ? fw(l.minUnit, this.min, this.max, this._getLabelCapacity(g)) : lR(this, S.length, l.minUnit, this.min, this.max)), this._majorUnit = !u.major.enabled || this._unit === "year" ? void 0 : sR(this._unit), this.initOffsets(h), i.reverse && S.reverse(), dw(this, S, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((i) => +i.value));
  }
  initOffsets(i = []) {
    let l = 0, u = 0, h, g;
    this.options.offset && i.length && (h = this.getDecimalForValue(i[0]), i.length === 1 ? l = 1 - h : l = (this.getDecimalForValue(i[1]) - h) / 2, g = this.getDecimalForValue(i[i.length - 1]), i.length === 1 ? u = g : u = (g - this.getDecimalForValue(i[i.length - 2])) / 2);
    const _ = i.length < 3 ? 0.5 : 0.25;
    l = rr(l, 0, _), u = rr(u, 0, _), this._offsets = {
      start: l,
      end: u,
      factor: 1 / (l + 1 + u)
    };
  }
  _generate() {
    const i = this._adapter, l = this.min, u = this.max, h = this.options, g = h.time, _ = g.unit || fw(g.minUnit, l, u, this._getLabelCapacity(l)), S = gn(h.ticks.stepSize, 1), T = _ === "week" ? g.isoWeekday : !1, E = vv(T) || T === !0, D = {};
    let C = l, z, j;
    if (E && (C = +i.startOf(C, "isoWeek", T)), C = +i.startOf(C, E ? "day" : _), i.diff(u, l, _) > 1e5 * S)
      throw new Error(l + " and " + u + " are too far apart with stepSize of " + S + " " + _);
    const I = h.ticks.source === "data" && this.getDataTimestamps();
    for (z = C, j = 0; z < u; z = +i.add(z, S, _), j++)
      hw(D, z, I);
    return (z === u || h.bounds === "ticks" || j === 1) && hw(D, z, I), Object.keys(D).sort(uw).map((Q) => +Q);
  }
  getLabelForValue(i) {
    const l = this._adapter, u = this.options.time;
    return u.tooltipFormat ? l.format(i, u.tooltipFormat) : l.format(i, u.displayFormats.datetime);
  }
  format(i, l) {
    const h = this.options.time.displayFormats, g = this._unit, _ = l || h[g];
    return this._adapter.format(i, _);
  }
  _tickFormatFunction(i, l, u, h) {
    const g = this.options, _ = g.ticks.callback;
    if (_)
      return ri(_, [
        i,
        l,
        u
      ], this);
    const S = g.time.displayFormats, T = this._unit, E = this._majorUnit, D = T && S[T], C = E && S[E], z = u[l], j = E && C && z && z.major;
    return this._adapter.format(i, h || (j ? C : D));
  }
  generateTickLabels(i) {
    let l, u, h;
    for (l = 0, u = i.length; l < u; ++l)
      h = i[l], h.label = this._tickFormatFunction(h.value, l, i);
  }
  getDecimalForValue(i) {
    return i === null ? NaN : (i - this.min) / (this.max - this.min);
  }
  getPixelForValue(i) {
    const l = this._offsets, u = this.getDecimalForValue(i);
    return this.getPixelForDecimal((l.start + u) * l.factor);
  }
  getValueForPixel(i) {
    const l = this._offsets, u = this.getDecimalForPixel(i) / l.factor - l.end;
    return this.min + u * (this.max - this.min);
  }
  _getLabelSize(i) {
    const l = this.options.ticks, u = this.ctx.measureText(i).width, h = dd(this.isHorizontal() ? l.maxRotation : l.minRotation), g = Math.cos(h), _ = Math.sin(h), S = this._resolveTickFontOptions(0).size;
    return {
      w: u * g + S * _,
      h: u * _ + S * g
    };
  }
  _getLabelCapacity(i) {
    const l = this.options.time, u = l.displayFormats, h = u[l.unit] || u.millisecond, g = this._tickFormatFunction(i, 0, dw(this, [
      i
    ], this._majorUnit), h), _ = this._getLabelSize(g), S = Math.floor(this.isHorizontal() ? this.width / _.w : this.height / _.h) - 1;
    return S > 0 ? S : 1;
  }
  getDataTimestamps() {
    let i = this._cache.data || [], l, u;
    if (i.length)
      return i;
    const h = this.getMatchingVisibleMetas();
    if (this._normalized && h.length)
      return this._cache.data = h[0].controller.getAllParsedValues(this);
    for (l = 0, u = h.length; l < u; ++l)
      i = i.concat(h[l].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(i);
  }
  getLabelTimestamps() {
    const i = this._cache.labels || [];
    let l, u;
    if (i.length)
      return i;
    const h = this.getLabels();
    for (l = 0, u = h.length; l < u; ++l)
      i.push(cw(this, h[l]));
    return this._cache.labels = this._normalized ? i : this.normalize(i);
  }
  normalize(i) {
    return q2(i.sort(uw));
  }
}
function m0(s, i, l) {
  let u = 0, h = s.length - 1, g, _, S, T;
  l ? (i >= s[u].pos && i <= s[h].pos && ({ lo: u, hi: h } = md(s, "pos", i)), { pos: g, time: S } = s[u], { pos: _, time: T } = s[h]) : (i >= s[u].time && i <= s[h].time && ({ lo: u, hi: h } = md(s, "time", i)), { time: g, pos: S } = s[u], { time: _, pos: T } = s[h]);
  const E = _ - g;
  return E ? S + (T - S) * (i - g) / E : S;
}
class tL extends p1 {
  static id = "timeseries";
  static defaults = p1.defaults;
  constructor(i) {
    super(i), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const i = this._getTimestampsForTable(), l = this._table = this.buildLookupTable(i);
    this._minPos = m0(l, this.min), this._tableRange = m0(l, this.max) - this._minPos, super.initOffsets(i);
  }
  buildLookupTable(i) {
    const { min: l, max: u } = this, h = [], g = [];
    let _, S, T, E, D;
    for (_ = 0, S = i.length; _ < S; ++_)
      E = i[_], E >= l && E <= u && h.push(E);
    if (h.length < 2)
      return [
        {
          time: l,
          pos: 0
        },
        {
          time: u,
          pos: 1
        }
      ];
    for (_ = 0, S = h.length; _ < S; ++_)
      D = h[_ + 1], T = h[_ - 1], E = h[_], Math.round((D + T) / 2) !== E && g.push({
        time: E,
        pos: _ / (S - 1)
      });
    return g;
  }
  _generate() {
    const i = this.min, l = this.max;
    let u = super.getDataTimestamps();
    return (!u.includes(i) || !u.length) && u.splice(0, 0, i), (!u.includes(l) || u.length === 1) && u.push(l), u.sort((h, g) => h - g);
  }
  _getTimestampsForTable() {
    let i = this._cache.all || [];
    if (i.length)
      return i;
    const l = this.getDataTimestamps(), u = this.getLabelTimestamps();
    return l.length && u.length ? i = this.normalize(l.concat(u)) : i = l.length ? l : u, i = this._cache.all = i, i;
  }
  getDecimalForValue(i) {
    return (m0(this._table, i) - this._minPos) / this._tableRange;
  }
  getValueForPixel(i) {
    const l = this._offsets, u = this.getDecimalForPixel(i) / l.factor - l.end;
    return m0(this._table, u * this._tableRange + this._minPos, !0);
  }
}
const uM = 6048e5, uR = 864e5, wv = 6e4, Mv = 36e5, cR = 1e3, mw = Symbol.for("constructDateFrom");
function Wn(s, i) {
  return typeof s == "function" ? s(i) : s && typeof s == "object" && mw in s ? s[mw](i) : s instanceof Date ? new s.constructor(i) : new Date(i);
}
function Te(s, i) {
  return Wn(i || s, s);
}
function L0(s, i, l) {
  const u = Te(s, l?.in);
  return isNaN(i) ? Wn(l?.in || s, NaN) : (i && u.setDate(u.getDate() + i), u);
}
function H1(s, i, l) {
  const u = Te(s, l?.in);
  if (isNaN(i)) return Wn(s, NaN);
  if (!i)
    return u;
  const h = u.getDate(), g = Wn(s, u.getTime());
  g.setMonth(u.getMonth() + i + 1, 0);
  const _ = g.getDate();
  return h >= _ ? g : (u.setFullYear(
    g.getFullYear(),
    g.getMonth(),
    h
  ), u);
}
function k1(s, i, l) {
  return Wn(s, +Te(s) + i);
}
function fR(s, i, l) {
  return k1(s, i * Mv);
}
let hR = {};
function vd() {
  return hR;
}
function fu(s, i) {
  const l = vd(), u = i?.weekStartsOn ?? i?.locale?.options?.weekStartsOn ?? l.weekStartsOn ?? l.locale?.options?.weekStartsOn ?? 0, h = Te(s, i?.in), g = h.getDay(), _ = (g < u ? 7 : 0) + g - u;
  return h.setDate(h.getDate() - _), h.setHours(0, 0, 0, 0), h;
}
function kp(s, i) {
  return fu(s, { ...i, weekStartsOn: 1 });
}
function cM(s, i) {
  const l = Te(s, i?.in), u = l.getFullYear(), h = Wn(l, 0);
  h.setFullYear(u + 1, 0, 4), h.setHours(0, 0, 0, 0);
  const g = kp(h), _ = Wn(l, 0);
  _.setFullYear(u, 0, 4), _.setHours(0, 0, 0, 0);
  const S = kp(_);
  return l.getTime() >= g.getTime() ? u + 1 : l.getTime() >= S.getTime() ? u : u - 1;
}
function E0(s) {
  const i = Te(s), l = new Date(
    Date.UTC(
      i.getFullYear(),
      i.getMonth(),
      i.getDate(),
      i.getHours(),
      i.getMinutes(),
      i.getSeconds(),
      i.getMilliseconds()
    )
  );
  return l.setUTCFullYear(i.getFullYear()), +s - +l;
}
function _d(s, ...i) {
  const l = Wn.bind(
    null,
    i.find((u) => typeof u == "object")
  );
  return i.map(l);
}
function g1(s, i) {
  const l = Te(s, i?.in);
  return l.setHours(0, 0, 0, 0), l;
}
function fM(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = g1(u), _ = g1(h), S = +g - E0(g), T = +_ - E0(_);
  return Math.round((S - T) / uR);
}
function dR(s, i) {
  const l = cM(s, i), u = Wn(s, 0);
  return u.setFullYear(l, 0, 4), u.setHours(0, 0, 0, 0), kp(u);
}
function mR(s, i, l) {
  const u = Te(s, l?.in);
  return u.setTime(u.getTime() + i * wv), u;
}
function pR(s, i, l) {
  return H1(s, i * 3, l);
}
function gR(s, i, l) {
  return k1(s, i * 1e3);
}
function yR(s, i, l) {
  return L0(s, i * 7, l);
}
function vR(s, i, l) {
  return H1(s, i * 12, l);
}
function mv(s, i) {
  const l = +Te(s) - +Te(i);
  return l < 0 ? -1 : l > 0 ? 1 : l;
}
function _R(s) {
  return s instanceof Date || typeof s == "object" && Object.prototype.toString.call(s) === "[object Date]";
}
function hM(s) {
  return !(!_R(s) && typeof s != "number" || isNaN(+Te(s)));
}
function bR(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = u.getFullYear() - h.getFullYear(), _ = u.getMonth() - h.getMonth();
  return g * 12 + _;
}
function SR(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  );
  return u.getFullYear() - h.getFullYear();
}
function dM(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = pw(u, h), _ = Math.abs(
    fM(u, h)
  );
  u.setDate(u.getDate() - g * _);
  const S = +(pw(u, h) === -g), T = g * (_ - S);
  return T === 0 ? 0 : T;
}
function pw(s, i) {
  const l = s.getFullYear() - i.getFullYear() || s.getMonth() - i.getMonth() || s.getDate() - i.getDate() || s.getHours() - i.getHours() || s.getMinutes() - i.getMinutes() || s.getSeconds() - i.getSeconds() || s.getMilliseconds() - i.getMilliseconds();
  return l < 0 ? -1 : l > 0 ? 1 : l;
}
function Ev(s) {
  return (i) => {
    const u = (s ? Math[s] : Math.trunc)(i);
    return u === 0 ? 0 : u;
  };
}
function TR(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = (+u - +h) / Mv;
  return Ev(l?.roundingMethod)(g);
}
function N1(s, i) {
  return +Te(s) - +Te(i);
}
function xR(s, i, l) {
  const u = N1(s, i) / wv;
  return Ev(l?.roundingMethod)(u);
}
function mM(s, i) {
  const l = Te(s, i?.in);
  return l.setHours(23, 59, 59, 999), l;
}
function pM(s, i) {
  const l = Te(s, i?.in), u = l.getMonth();
  return l.setFullYear(l.getFullYear(), u + 1, 0), l.setHours(23, 59, 59, 999), l;
}
function wR(s, i) {
  const l = Te(s, i?.in);
  return +mM(l, i) == +pM(l, i);
}
function gM(s, i, l) {
  const [u, h, g] = _d(
    l?.in,
    s,
    s,
    i
  ), _ = mv(h, g), S = Math.abs(
    bR(h, g)
  );
  if (S < 1) return 0;
  h.getMonth() === 1 && h.getDate() > 27 && h.setDate(30), h.setMonth(h.getMonth() - _ * S);
  let T = mv(h, g) === -_;
  wR(u) && S === 1 && mv(u, g) === 1 && (T = !1);
  const E = _ * (S - +T);
  return E === 0 ? 0 : E;
}
function MR(s, i, l) {
  const u = gM(s, i, l) / 3;
  return Ev(l?.roundingMethod)(u);
}
function ER(s, i, l) {
  const u = N1(s, i) / 1e3;
  return Ev(l?.roundingMethod)(u);
}
function OR(s, i, l) {
  const u = dM(s, i, l) / 7;
  return Ev(l?.roundingMethod)(u);
}
function DR(s, i, l) {
  const [u, h] = _d(
    l?.in,
    s,
    i
  ), g = mv(u, h), _ = Math.abs(SR(u, h));
  u.setFullYear(1584), h.setFullYear(1584);
  const S = mv(u, h) === -g, T = g * (_ - +S);
  return T === 0 ? 0 : T;
}
function AR(s, i) {
  const l = Te(s, i?.in), u = l.getMonth(), h = u - u % 3;
  return l.setMonth(h, 1), l.setHours(0, 0, 0, 0), l;
}
function RR(s, i) {
  const l = Te(s, i?.in);
  return l.setDate(1), l.setHours(0, 0, 0, 0), l;
}
function CR(s, i) {
  const l = Te(s, i?.in), u = l.getFullYear();
  return l.setFullYear(u + 1, 0, 0), l.setHours(23, 59, 59, 999), l;
}
function yM(s, i) {
  const l = Te(s, i?.in);
  return l.setFullYear(l.getFullYear(), 0, 1), l.setHours(0, 0, 0, 0), l;
}
function zR(s, i) {
  const l = Te(s, i?.in);
  return l.setMinutes(59, 59, 999), l;
}
function LR(s, i) {
  const l = vd(), u = l.weekStartsOn ?? l.locale?.options?.weekStartsOn ?? 0, h = Te(s, i?.in), g = h.getDay(), _ = (g < u ? -7 : 0) + 6 - (g - u);
  return h.setDate(h.getDate() + _), h.setHours(23, 59, 59, 999), h;
}
function HR(s, i) {
  const l = Te(s, i?.in);
  return l.setSeconds(59, 999), l;
}
function kR(s, i) {
  const l = Te(s, i?.in), u = l.getMonth(), h = u - u % 3 + 3;
  return l.setMonth(h, 0), l.setHours(23, 59, 59, 999), l;
}
function NR(s, i) {
  const l = Te(s, i?.in);
  return l.setMilliseconds(999), l;
}
const UR = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, BR = (s, i, l) => {
  let u;
  const h = UR[s];
  return typeof h == "string" ? u = h : i === 1 ? u = h.one : u = h.other.replace("{{count}}", i.toString()), l?.addSuffix ? l.comparison && l.comparison > 0 ? "in " + u : u + " ago" : u;
};
function o1(s) {
  return (i = {}) => {
    const l = i.width ? String(i.width) : s.defaultWidth;
    return s.formats[l] || s.formats[s.defaultWidth];
  };
}
const YR = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, jR = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, qR = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, ZR = {
  date: o1({
    formats: YR,
    defaultWidth: "full"
  }),
  time: o1({
    formats: jR,
    defaultWidth: "full"
  }),
  dateTime: o1({
    formats: qR,
    defaultWidth: "full"
  })
}, PR = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, VR = (s, i, l, u) => PR[s];
function nv(s) {
  return (i, l) => {
    const u = l?.context ? String(l.context) : "standalone";
    let h;
    if (u === "formatting" && s.formattingValues) {
      const _ = s.defaultFormattingWidth || s.defaultWidth, S = l?.width ? String(l.width) : _;
      h = s.formattingValues[S] || s.formattingValues[_];
    } else {
      const _ = s.defaultWidth, S = l?.width ? String(l.width) : s.defaultWidth;
      h = s.values[S] || s.values[_];
    }
    const g = s.argumentCallback ? s.argumentCallback(i) : i;
    return h[g];
  };
}
const GR = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, XR = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, QR = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, KR = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, WR = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, IR = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, $R = (s, i) => {
  const l = Number(s), u = l % 100;
  if (u > 20 || u < 10)
    switch (u % 10) {
      case 1:
        return l + "st";
      case 2:
        return l + "nd";
      case 3:
        return l + "rd";
    }
  return l + "th";
}, JR = {
  ordinalNumber: $R,
  era: nv({
    values: GR,
    defaultWidth: "wide"
  }),
  quarter: nv({
    values: XR,
    defaultWidth: "wide",
    argumentCallback: (s) => s - 1
  }),
  month: nv({
    values: QR,
    defaultWidth: "wide"
  }),
  day: nv({
    values: KR,
    defaultWidth: "wide"
  }),
  dayPeriod: nv({
    values: WR,
    defaultWidth: "wide",
    formattingValues: IR,
    defaultFormattingWidth: "wide"
  })
};
function iv(s) {
  return (i, l = {}) => {
    const u = l.width, h = u && s.matchPatterns[u] || s.matchPatterns[s.defaultMatchWidth], g = i.match(h);
    if (!g)
      return null;
    const _ = g[0], S = u && s.parsePatterns[u] || s.parsePatterns[s.defaultParseWidth], T = Array.isArray(S) ? tC(S, (C) => C.test(_)) : (
      // [TODO] -- I challenge you to fix the type
      FR(S, (C) => C.test(_))
    );
    let E;
    E = s.valueCallback ? s.valueCallback(T) : T, E = l.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      l.valueCallback(E)
    ) : E;
    const D = i.slice(_.length);
    return { value: E, rest: D };
  };
}
function FR(s, i) {
  for (const l in s)
    if (Object.prototype.hasOwnProperty.call(s, l) && i(s[l]))
      return l;
}
function tC(s, i) {
  for (let l = 0; l < s.length; l++)
    if (i(s[l]))
      return l;
}
function eC(s) {
  return (i, l = {}) => {
    const u = i.match(s.matchPattern);
    if (!u) return null;
    const h = u[0], g = i.match(s.parsePattern);
    if (!g) return null;
    let _ = s.valueCallback ? s.valueCallback(g[0]) : g[0];
    _ = l.valueCallback ? l.valueCallback(_) : _;
    const S = i.slice(h.length);
    return { value: _, rest: S };
  };
}
const nC = /^(\d+)(th|st|nd|rd)?/i, iC = /\d+/i, aC = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, oC = {
  any: [/^b/i, /^(a|c)/i]
}, lC = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, sC = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, rC = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, uC = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, cC = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, fC = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, hC = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, dC = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, mC = {
  ordinalNumber: eC({
    matchPattern: nC,
    parsePattern: iC,
    valueCallback: (s) => parseInt(s, 10)
  }),
  era: iv({
    matchPatterns: aC,
    defaultMatchWidth: "wide",
    parsePatterns: oC,
    defaultParseWidth: "any"
  }),
  quarter: iv({
    matchPatterns: lC,
    defaultMatchWidth: "wide",
    parsePatterns: sC,
    defaultParseWidth: "any",
    valueCallback: (s) => s + 1
  }),
  month: iv({
    matchPatterns: rC,
    defaultMatchWidth: "wide",
    parsePatterns: uC,
    defaultParseWidth: "any"
  }),
  day: iv({
    matchPatterns: cC,
    defaultMatchWidth: "wide",
    parsePatterns: fC,
    defaultParseWidth: "any"
  }),
  dayPeriod: iv({
    matchPatterns: hC,
    defaultMatchWidth: "any",
    parsePatterns: dC,
    defaultParseWidth: "any"
  })
}, vM = {
  code: "en-US",
  formatDistance: BR,
  formatLong: ZR,
  formatRelative: VR,
  localize: JR,
  match: mC,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function pC(s, i) {
  const l = Te(s, i?.in);
  return fM(l, yM(l)) + 1;
}
function _M(s, i) {
  const l = Te(s, i?.in), u = +kp(l) - +dR(l);
  return Math.round(u / uM) + 1;
}
function U1(s, i) {
  const l = Te(s, i?.in), u = l.getFullYear(), h = vd(), g = i?.firstWeekContainsDate ?? i?.locale?.options?.firstWeekContainsDate ?? h.firstWeekContainsDate ?? h.locale?.options?.firstWeekContainsDate ?? 1, _ = Wn(i?.in || s, 0);
  _.setFullYear(u + 1, 0, g), _.setHours(0, 0, 0, 0);
  const S = fu(_, i), T = Wn(i?.in || s, 0);
  T.setFullYear(u, 0, g), T.setHours(0, 0, 0, 0);
  const E = fu(T, i);
  return +l >= +S ? u + 1 : +l >= +E ? u : u - 1;
}
function gC(s, i) {
  const l = vd(), u = i?.firstWeekContainsDate ?? i?.locale?.options?.firstWeekContainsDate ?? l.firstWeekContainsDate ?? l.locale?.options?.firstWeekContainsDate ?? 1, h = U1(s, i), g = Wn(i?.in || s, 0);
  return g.setFullYear(h, 0, u), g.setHours(0, 0, 0, 0), fu(g, i);
}
function bM(s, i) {
  const l = Te(s, i?.in), u = +fu(l, i) - +gC(l, i);
  return Math.round(u / uM) + 1;
}
function rn(s, i) {
  const l = s < 0 ? "-" : "", u = Math.abs(s).toString().padStart(i, "0");
  return l + u;
}
const xf = {
  // Year
  y(s, i) {
    const l = s.getFullYear(), u = l > 0 ? l : 1 - l;
    return rn(i === "yy" ? u % 100 : u, i.length);
  },
  // Month
  M(s, i) {
    const l = s.getMonth();
    return i === "M" ? String(l + 1) : rn(l + 1, 2);
  },
  // Day of the month
  d(s, i) {
    return rn(s.getDate(), i.length);
  },
  // AM or PM
  a(s, i) {
    const l = s.getHours() / 12 >= 1 ? "pm" : "am";
    switch (i) {
      case "a":
      case "aa":
        return l.toUpperCase();
      case "aaa":
        return l;
      case "aaaaa":
        return l[0];
      case "aaaa":
      default:
        return l === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(s, i) {
    return rn(s.getHours() % 12 || 12, i.length);
  },
  // Hour [0-23]
  H(s, i) {
    return rn(s.getHours(), i.length);
  },
  // Minute
  m(s, i) {
    return rn(s.getMinutes(), i.length);
  },
  // Second
  s(s, i) {
    return rn(s.getSeconds(), i.length);
  },
  // Fraction of second
  S(s, i) {
    const l = i.length, u = s.getMilliseconds(), h = Math.trunc(
      u * Math.pow(10, l - 3)
    );
    return rn(h, i.length);
  }
}, Cp = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, gw = {
  // Era
  G: function(s, i, l) {
    const u = s.getFullYear() > 0 ? 1 : 0;
    switch (i) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return l.era(u, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return l.era(u, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return l.era(u, { width: "wide" });
    }
  },
  // Year
  y: function(s, i, l) {
    if (i === "yo") {
      const u = s.getFullYear(), h = u > 0 ? u : 1 - u;
      return l.ordinalNumber(h, { unit: "year" });
    }
    return xf.y(s, i);
  },
  // Local week-numbering year
  Y: function(s, i, l, u) {
    const h = U1(s, u), g = h > 0 ? h : 1 - h;
    if (i === "YY") {
      const _ = g % 100;
      return rn(_, 2);
    }
    return i === "Yo" ? l.ordinalNumber(g, { unit: "year" }) : rn(g, i.length);
  },
  // ISO week-numbering year
  R: function(s, i) {
    const l = cM(s);
    return rn(l, i.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(s, i) {
    const l = s.getFullYear();
    return rn(l, i.length);
  },
  // Quarter
  Q: function(s, i, l) {
    const u = Math.ceil((s.getMonth() + 1) / 3);
    switch (i) {
      // 1, 2, 3, 4
      case "Q":
        return String(u);
      // 01, 02, 03, 04
      case "QQ":
        return rn(u, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return l.ordinalNumber(u, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return l.quarter(u, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return l.quarter(u, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return l.quarter(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(s, i, l) {
    const u = Math.ceil((s.getMonth() + 1) / 3);
    switch (i) {
      // 1, 2, 3, 4
      case "q":
        return String(u);
      // 01, 02, 03, 04
      case "qq":
        return rn(u, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return l.ordinalNumber(u, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return l.quarter(u, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return l.quarter(u, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return l.quarter(u, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(s, i, l) {
    const u = s.getMonth();
    switch (i) {
      case "M":
      case "MM":
        return xf.M(s, i);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return l.ordinalNumber(u + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return l.month(u, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return l.month(u, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return l.month(u, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(s, i, l) {
    const u = s.getMonth();
    switch (i) {
      // 1, 2, ..., 12
      case "L":
        return String(u + 1);
      // 01, 02, ..., 12
      case "LL":
        return rn(u + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return l.ordinalNumber(u + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return l.month(u, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return l.month(u, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return l.month(u, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(s, i, l, u) {
    const h = bM(s, u);
    return i === "wo" ? l.ordinalNumber(h, { unit: "week" }) : rn(h, i.length);
  },
  // ISO week of year
  I: function(s, i, l) {
    const u = _M(s);
    return i === "Io" ? l.ordinalNumber(u, { unit: "week" }) : rn(u, i.length);
  },
  // Day of the month
  d: function(s, i, l) {
    return i === "do" ? l.ordinalNumber(s.getDate(), { unit: "date" }) : xf.d(s, i);
  },
  // Day of year
  D: function(s, i, l) {
    const u = pC(s);
    return i === "Do" ? l.ordinalNumber(u, { unit: "dayOfYear" }) : rn(u, i.length);
  },
  // Day of week
  E: function(s, i, l) {
    const u = s.getDay();
    switch (i) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return l.day(u, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return l.day(u, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return l.day(u, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return l.day(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(s, i, l, u) {
    const h = s.getDay(), g = (h - u.weekStartsOn + 8) % 7 || 7;
    switch (i) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(g);
      // Padded numerical value
      case "ee":
        return rn(g, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return l.ordinalNumber(g, { unit: "day" });
      case "eee":
        return l.day(h, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return l.day(h, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return l.day(h, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return l.day(h, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(s, i, l, u) {
    const h = s.getDay(), g = (h - u.weekStartsOn + 8) % 7 || 7;
    switch (i) {
      // Numerical value (same as in `e`)
      case "c":
        return String(g);
      // Padded numerical value
      case "cc":
        return rn(g, i.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return l.ordinalNumber(g, { unit: "day" });
      case "ccc":
        return l.day(h, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return l.day(h, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return l.day(h, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return l.day(h, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(s, i, l) {
    const u = s.getDay(), h = u === 0 ? 7 : u;
    switch (i) {
      // 2
      case "i":
        return String(h);
      // 02
      case "ii":
        return rn(h, i.length);
      // 2nd
      case "io":
        return l.ordinalNumber(h, { unit: "day" });
      // Tue
      case "iii":
        return l.day(u, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return l.day(u, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return l.day(u, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return l.day(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(s, i, l) {
    const h = s.getHours() / 12 >= 1 ? "pm" : "am";
    switch (i) {
      case "a":
      case "aa":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return l.dayPeriod(h, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return l.dayPeriod(h, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(s, i, l) {
    const u = s.getHours();
    let h;
    switch (u === 12 ? h = Cp.noon : u === 0 ? h = Cp.midnight : h = u / 12 >= 1 ? "pm" : "am", i) {
      case "b":
      case "bb":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return l.dayPeriod(h, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return l.dayPeriod(h, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(s, i, l) {
    const u = s.getHours();
    let h;
    switch (u >= 17 ? h = Cp.evening : u >= 12 ? h = Cp.afternoon : u >= 4 ? h = Cp.morning : h = Cp.night, i) {
      case "B":
      case "BB":
      case "BBB":
        return l.dayPeriod(h, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return l.dayPeriod(h, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return l.dayPeriod(h, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(s, i, l) {
    if (i === "ho") {
      let u = s.getHours() % 12;
      return u === 0 && (u = 12), l.ordinalNumber(u, { unit: "hour" });
    }
    return xf.h(s, i);
  },
  // Hour [0-23]
  H: function(s, i, l) {
    return i === "Ho" ? l.ordinalNumber(s.getHours(), { unit: "hour" }) : xf.H(s, i);
  },
  // Hour [0-11]
  K: function(s, i, l) {
    const u = s.getHours() % 12;
    return i === "Ko" ? l.ordinalNumber(u, { unit: "hour" }) : rn(u, i.length);
  },
  // Hour [1-24]
  k: function(s, i, l) {
    let u = s.getHours();
    return u === 0 && (u = 24), i === "ko" ? l.ordinalNumber(u, { unit: "hour" }) : rn(u, i.length);
  },
  // Minute
  m: function(s, i, l) {
    return i === "mo" ? l.ordinalNumber(s.getMinutes(), { unit: "minute" }) : xf.m(s, i);
  },
  // Second
  s: function(s, i, l) {
    return i === "so" ? l.ordinalNumber(s.getSeconds(), { unit: "second" }) : xf.s(s, i);
  },
  // Fraction of second
  S: function(s, i) {
    return xf.S(s, i);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(s, i, l) {
    const u = s.getTimezoneOffset();
    if (u === 0)
      return "Z";
    switch (i) {
      // Hours and optional minutes
      case "X":
        return vw(u);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return hd(u);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return hd(u, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(s, i, l) {
    const u = s.getTimezoneOffset();
    switch (i) {
      // Hours and optional minutes
      case "x":
        return vw(u);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return hd(u);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return hd(u, ":");
    }
  },
  // Timezone (GMT)
  O: function(s, i, l) {
    const u = s.getTimezoneOffset();
    switch (i) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + yw(u, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + hd(u, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(s, i, l) {
    const u = s.getTimezoneOffset();
    switch (i) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + yw(u, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + hd(u, ":");
    }
  },
  // Seconds timestamp
  t: function(s, i, l) {
    const u = Math.trunc(+s / 1e3);
    return rn(u, i.length);
  },
  // Milliseconds timestamp
  T: function(s, i, l) {
    return rn(+s, i.length);
  }
};
function yw(s, i = "") {
  const l = s > 0 ? "-" : "+", u = Math.abs(s), h = Math.trunc(u / 60), g = u % 60;
  return g === 0 ? l + String(h) : l + String(h) + i + rn(g, 2);
}
function vw(s, i) {
  return s % 60 === 0 ? (s > 0 ? "-" : "+") + rn(Math.abs(s) / 60, 2) : hd(s, i);
}
function hd(s, i = "") {
  const l = s > 0 ? "-" : "+", u = Math.abs(s), h = rn(Math.trunc(u / 60), 2), g = rn(u % 60, 2);
  return l + h + i + g;
}
const _w = (s, i) => {
  switch (s) {
    case "P":
      return i.date({ width: "short" });
    case "PP":
      return i.date({ width: "medium" });
    case "PPP":
      return i.date({ width: "long" });
    case "PPPP":
    default:
      return i.date({ width: "full" });
  }
}, SM = (s, i) => {
  switch (s) {
    case "p":
      return i.time({ width: "short" });
    case "pp":
      return i.time({ width: "medium" });
    case "ppp":
      return i.time({ width: "long" });
    case "pppp":
    default:
      return i.time({ width: "full" });
  }
}, yC = (s, i) => {
  const l = s.match(/(P+)(p+)?/) || [], u = l[1], h = l[2];
  if (!h)
    return _w(s, i);
  let g;
  switch (u) {
    case "P":
      g = i.dateTime({ width: "short" });
      break;
    case "PP":
      g = i.dateTime({ width: "medium" });
      break;
    case "PPP":
      g = i.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      g = i.dateTime({ width: "full" });
      break;
  }
  return g.replace("{{date}}", _w(u, i)).replace("{{time}}", SM(h, i));
}, y1 = {
  p: SM,
  P: yC
}, vC = /^D+$/, _C = /^Y+$/, bC = ["D", "DD", "YY", "YYYY"];
function TM(s) {
  return vC.test(s);
}
function xM(s) {
  return _C.test(s);
}
function v1(s, i, l) {
  const u = SC(s, i, l);
  if (console.warn(u), bC.includes(s)) throw new RangeError(u);
}
function SC(s, i, l) {
  const u = s[0] === "Y" ? "years" : "days of the month";
  return `Use \`${s.toLowerCase()}\` instead of \`${s}\` (in \`${i}\`) for formatting ${u} to the input \`${l}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const TC = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, xC = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, wC = /^'([^]*?)'?$/, MC = /''/g, EC = /[a-zA-Z]/;
function OC(s, i, l) {
  const u = vd(), h = l?.locale ?? u.locale ?? vM, g = l?.firstWeekContainsDate ?? l?.locale?.options?.firstWeekContainsDate ?? u.firstWeekContainsDate ?? u.locale?.options?.firstWeekContainsDate ?? 1, _ = l?.weekStartsOn ?? l?.locale?.options?.weekStartsOn ?? u.weekStartsOn ?? u.locale?.options?.weekStartsOn ?? 0, S = Te(s, l?.in);
  if (!hM(S))
    throw new RangeError("Invalid time value");
  let T = i.match(xC).map((D) => {
    const C = D[0];
    if (C === "p" || C === "P") {
      const z = y1[C];
      return z(D, h.formatLong);
    }
    return D;
  }).join("").match(TC).map((D) => {
    if (D === "''")
      return { isToken: !1, value: "'" };
    const C = D[0];
    if (C === "'")
      return { isToken: !1, value: DC(D) };
    if (gw[C])
      return { isToken: !0, value: D };
    if (C.match(EC))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + C + "`"
      );
    return { isToken: !1, value: D };
  });
  h.localize.preprocessor && (T = h.localize.preprocessor(S, T));
  const E = {
    firstWeekContainsDate: g,
    weekStartsOn: _,
    locale: h
  };
  return T.map((D) => {
    if (!D.isToken) return D.value;
    const C = D.value;
    (!l?.useAdditionalWeekYearTokens && xM(C) || !l?.useAdditionalDayOfYearTokens && TM(C)) && v1(C, i, String(s));
    const z = gw[C[0]];
    return z(S, C, h.localize, E);
  }).join("");
}
function DC(s) {
  const i = s.match(wC);
  return i ? i[1].replace(MC, "'") : s;
}
function AC() {
  return Object.assign({}, vd());
}
function RC(s, i) {
  const l = Te(s, i?.in).getDay();
  return l === 0 ? 7 : l;
}
function CC(s, i) {
  const l = zC(i) ? new i(0) : Wn(i, 0);
  return l.setFullYear(s.getFullYear(), s.getMonth(), s.getDate()), l.setHours(
    s.getHours(),
    s.getMinutes(),
    s.getSeconds(),
    s.getMilliseconds()
  ), l;
}
function zC(s) {
  return typeof s == "function" && s.prototype?.constructor === s;
}
const LC = 10;
class wM {
  subPriority = 0;
  validate(i, l) {
    return !0;
  }
}
class HC extends wM {
  constructor(i, l, u, h, g) {
    super(), this.value = i, this.validateValue = l, this.setValue = u, this.priority = h, g && (this.subPriority = g);
  }
  validate(i, l) {
    return this.validateValue(i, this.value, l);
  }
  set(i, l, u) {
    return this.setValue(i, l, this.value, u);
  }
}
class kC extends wM {
  priority = LC;
  subPriority = -1;
  constructor(i, l) {
    super(), this.context = i || ((u) => Wn(l, u));
  }
  set(i, l) {
    return l.timestampIsSet ? i : Wn(i, CC(i, this.context));
  }
}
class Je {
  run(i, l, u, h) {
    const g = this.parse(i, l, u, h);
    return g ? {
      setter: new HC(
        g.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: g.rest
    } : null;
  }
  validate(i, l, u) {
    return !0;
  }
}
class NC extends Je {
  priority = 140;
  parse(i, l, u) {
    switch (l) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return u.era(i, { width: "abbreviated" }) || u.era(i, { width: "narrow" });
      // A, B
      case "GGGGG":
        return u.era(i, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return u.era(i, { width: "wide" }) || u.era(i, { width: "abbreviated" }) || u.era(i, { width: "narrow" });
    }
  }
  set(i, l, u) {
    return l.era = u, i.setFullYear(u, 0, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = ["R", "u", "t", "T"];
}
const ui = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, su = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function ci(s, i) {
  return s && {
    value: i(s.value),
    rest: s.rest
  };
}
function qn(s, i) {
  const l = i.match(s);
  return l ? {
    value: parseInt(l[0], 10),
    rest: i.slice(l[0].length)
  } : null;
}
function ru(s, i) {
  const l = i.match(s);
  if (!l)
    return null;
  if (l[0] === "Z")
    return {
      value: 0,
      rest: i.slice(1)
    };
  const u = l[1] === "+" ? 1 : -1, h = l[2] ? parseInt(l[2], 10) : 0, g = l[3] ? parseInt(l[3], 10) : 0, _ = l[5] ? parseInt(l[5], 10) : 0;
  return {
    value: u * (h * Mv + g * wv + _ * cR),
    rest: i.slice(l[0].length)
  };
}
function MM(s) {
  return qn(ui.anyDigitsSigned, s);
}
function In(s, i) {
  switch (s) {
    case 1:
      return qn(ui.singleDigit, i);
    case 2:
      return qn(ui.twoDigits, i);
    case 3:
      return qn(ui.threeDigits, i);
    case 4:
      return qn(ui.fourDigits, i);
    default:
      return qn(new RegExp("^\\d{1," + s + "}"), i);
  }
}
function O0(s, i) {
  switch (s) {
    case 1:
      return qn(ui.singleDigitSigned, i);
    case 2:
      return qn(ui.twoDigitsSigned, i);
    case 3:
      return qn(ui.threeDigitsSigned, i);
    case 4:
      return qn(ui.fourDigitsSigned, i);
    default:
      return qn(new RegExp("^-?\\d{1," + s + "}"), i);
  }
}
function B1(s) {
  switch (s) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function EM(s, i) {
  const l = i > 0, u = l ? i : 1 - i;
  let h;
  if (u <= 50)
    h = s || 100;
  else {
    const g = u + 50, _ = Math.trunc(g / 100) * 100, S = s >= g % 100;
    h = s + _ - (S ? 100 : 0);
  }
  return l ? h : 1 - h;
}
function OM(s) {
  return s % 400 === 0 || s % 4 === 0 && s % 100 !== 0;
}
class UC extends Je {
  priority = 130;
  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];
  parse(i, l, u) {
    const h = (g) => ({
      year: g,
      isTwoDigitYear: l === "yy"
    });
    switch (l) {
      case "y":
        return ci(In(4, i), h);
      case "yo":
        return ci(
          u.ordinalNumber(i, {
            unit: "year"
          }),
          h
        );
      default:
        return ci(In(l.length, i), h);
    }
  }
  validate(i, l) {
    return l.isTwoDigitYear || l.year > 0;
  }
  set(i, l, u) {
    const h = i.getFullYear();
    if (u.isTwoDigitYear) {
      const _ = EM(
        u.year,
        h
      );
      return i.setFullYear(_, 0, 1), i.setHours(0, 0, 0, 0), i;
    }
    const g = !("era" in l) || l.era === 1 ? u.year : 1 - u.year;
    return i.setFullYear(g, 0, 1), i.setHours(0, 0, 0, 0), i;
  }
}
class BC extends Je {
  priority = 130;
  parse(i, l, u) {
    const h = (g) => ({
      year: g,
      isTwoDigitYear: l === "YY"
    });
    switch (l) {
      case "Y":
        return ci(In(4, i), h);
      case "Yo":
        return ci(
          u.ordinalNumber(i, {
            unit: "year"
          }),
          h
        );
      default:
        return ci(In(l.length, i), h);
    }
  }
  validate(i, l) {
    return l.isTwoDigitYear || l.year > 0;
  }
  set(i, l, u, h) {
    const g = U1(i, h);
    if (u.isTwoDigitYear) {
      const S = EM(
        u.year,
        g
      );
      return i.setFullYear(
        S,
        0,
        h.firstWeekContainsDate
      ), i.setHours(0, 0, 0, 0), fu(i, h);
    }
    const _ = !("era" in l) || l.era === 1 ? u.year : 1 - u.year;
    return i.setFullYear(_, 0, h.firstWeekContainsDate), i.setHours(0, 0, 0, 0), fu(i, h);
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T"
  ];
}
class YC extends Je {
  priority = 130;
  parse(i, l) {
    return O0(l === "R" ? 4 : l.length, i);
  }
  set(i, l, u) {
    const h = Wn(i, 0);
    return h.setFullYear(u, 0, 4), h.setHours(0, 0, 0, 0), kp(h);
  }
  incompatibleTokens = [
    "G",
    "y",
    "Y",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T"
  ];
}
class jC extends Je {
  priority = 130;
  parse(i, l) {
    return O0(l === "u" ? 4 : l.length, i);
  }
  set(i, l, u) {
    return i.setFullYear(u, 0, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
}
class qC extends Je {
  priority = 120;
  parse(i, l, u) {
    switch (l) {
      // 1, 2, 3, 4
      case "Q":
      case "QQ":
        return In(l.length, i);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return u.ordinalNumber(i, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return u.quarter(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.quarter(i, {
          width: "narrow",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return u.quarter(i, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return u.quarter(i, {
          width: "wide",
          context: "formatting"
        }) || u.quarter(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.quarter(i, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 4;
  }
  set(i, l, u) {
    return i.setMonth((u - 1) * 3, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
class ZC extends Je {
  priority = 120;
  parse(i, l, u) {
    switch (l) {
      // 1, 2, 3, 4
      case "q":
      case "qq":
        return In(l.length, i);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return u.ordinalNumber(i, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return u.quarter(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.quarter(i, {
          width: "narrow",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return u.quarter(i, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return u.quarter(i, {
          width: "wide",
          context: "standalone"
        }) || u.quarter(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.quarter(i, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 4;
  }
  set(i, l, u) {
    return i.setMonth((u - 1) * 3, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
class PC extends Je {
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "L",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
  priority = 110;
  parse(i, l, u) {
    const h = (g) => g - 1;
    switch (l) {
      // 1, 2, ..., 12
      case "M":
        return ci(
          qn(ui.month, i),
          h
        );
      // 01, 02, ..., 12
      case "MM":
        return ci(In(2, i), h);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return ci(
          u.ordinalNumber(i, {
            unit: "month"
          }),
          h
        );
      // Jan, Feb, ..., Dec
      case "MMM":
        return u.month(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.month(i, { width: "narrow", context: "formatting" });
      // J, F, ..., D
      case "MMMMM":
        return u.month(i, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return u.month(i, { width: "wide", context: "formatting" }) || u.month(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.month(i, { width: "narrow", context: "formatting" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 11;
  }
  set(i, l, u) {
    return i.setMonth(u, 1), i.setHours(0, 0, 0, 0), i;
  }
}
class VC extends Je {
  priority = 110;
  parse(i, l, u) {
    const h = (g) => g - 1;
    switch (l) {
      // 1, 2, ..., 12
      case "L":
        return ci(
          qn(ui.month, i),
          h
        );
      // 01, 02, ..., 12
      case "LL":
        return ci(In(2, i), h);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return ci(
          u.ordinalNumber(i, {
            unit: "month"
          }),
          h
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return u.month(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.month(i, { width: "narrow", context: "standalone" });
      // J, F, ..., D
      case "LLLLL":
        return u.month(i, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return u.month(i, { width: "wide", context: "standalone" }) || u.month(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.month(i, { width: "narrow", context: "standalone" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 11;
  }
  set(i, l, u) {
    return i.setMonth(u, 1), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
function GC(s, i, l) {
  const u = Te(s, l?.in), h = bM(u, l) - i;
  return u.setDate(u.getDate() - h * 7), Te(u, l?.in);
}
class XC extends Je {
  priority = 100;
  parse(i, l, u) {
    switch (l) {
      case "w":
        return qn(ui.week, i);
      case "wo":
        return u.ordinalNumber(i, { unit: "week" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 53;
  }
  set(i, l, u, h) {
    return fu(GC(i, u, h), h);
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T"
  ];
}
function QC(s, i, l) {
  const u = Te(s, l?.in), h = _M(u, l) - i;
  return u.setDate(u.getDate() - h * 7), u;
}
class KC extends Je {
  priority = 100;
  parse(i, l, u) {
    switch (l) {
      case "I":
        return qn(ui.week, i);
      case "Io":
        return u.ordinalNumber(i, { unit: "week" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 53;
  }
  set(i, l, u) {
    return kp(QC(i, u));
  }
  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T"
  ];
}
const WC = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], IC = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class $C extends Je {
  priority = 90;
  subPriority = 1;
  parse(i, l, u) {
    switch (l) {
      case "d":
        return qn(ui.date, i);
      case "do":
        return u.ordinalNumber(i, { unit: "date" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    const u = i.getFullYear(), h = OM(u), g = i.getMonth();
    return h ? l >= 1 && l <= IC[g] : l >= 1 && l <= WC[g];
  }
  set(i, l, u) {
    return i.setDate(u), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
class JC extends Je {
  priority = 90;
  subpriority = 1;
  parse(i, l, u) {
    switch (l) {
      case "D":
      case "DD":
        return qn(ui.dayOfYear, i);
      case "Do":
        return u.ordinalNumber(i, { unit: "date" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    const u = i.getFullYear();
    return OM(u) ? l >= 1 && l <= 366 : l >= 1 && l <= 365;
  }
  set(i, l, u) {
    return i.setMonth(0, u), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "E",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
function Y1(s, i, l) {
  const u = vd(), h = l?.weekStartsOn ?? l?.locale?.options?.weekStartsOn ?? u.weekStartsOn ?? u.locale?.options?.weekStartsOn ?? 0, g = Te(s, l?.in), _ = g.getDay(), T = (i % 7 + 7) % 7, E = 7 - h, D = i < 0 || i > 6 ? i - (_ + E) % 7 : (T + E) % 7 - (_ + E) % 7;
  return L0(g, D, l);
}
class FC extends Je {
  priority = 90;
  parse(i, l, u) {
    switch (l) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return u.day(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
      // T
      case "EEEEE":
        return u.day(i, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
      // Tuesday
      case "EEEE":
      default:
        return u.day(i, { width: "wide", context: "formatting" }) || u.day(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 6;
  }
  set(i, l, u, h) {
    return i = Y1(i, u, h), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
}
class tz extends Je {
  priority = 90;
  parse(i, l, u, h) {
    const g = (_) => {
      const S = Math.floor((_ - 1) / 7) * 7;
      return (_ + h.weekStartsOn + 6) % 7 + S;
    };
    switch (l) {
      // 3
      case "e":
      case "ee":
        return ci(In(l.length, i), g);
      // 3rd
      case "eo":
        return ci(
          u.ordinalNumber(i, {
            unit: "day"
          }),
          g
        );
      // Tue
      case "eee":
        return u.day(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
      // T
      case "eeeee":
        return u.day(i, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
      // Tuesday
      case "eeee":
      default:
        return u.day(i, { width: "wide", context: "formatting" }) || u.day(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.day(i, { width: "short", context: "formatting" }) || u.day(i, { width: "narrow", context: "formatting" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 6;
  }
  set(i, l, u, h) {
    return i = Y1(i, u, h), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "c",
    "t",
    "T"
  ];
}
class ez extends Je {
  priority = 90;
  parse(i, l, u, h) {
    const g = (_) => {
      const S = Math.floor((_ - 1) / 7) * 7;
      return (_ + h.weekStartsOn + 6) % 7 + S;
    };
    switch (l) {
      // 3
      case "c":
      case "cc":
        return ci(In(l.length, i), g);
      // 3rd
      case "co":
        return ci(
          u.ordinalNumber(i, {
            unit: "day"
          }),
          g
        );
      // Tue
      case "ccc":
        return u.day(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.day(i, { width: "short", context: "standalone" }) || u.day(i, { width: "narrow", context: "standalone" });
      // T
      case "ccccc":
        return u.day(i, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return u.day(i, { width: "short", context: "standalone" }) || u.day(i, { width: "narrow", context: "standalone" });
      // Tuesday
      case "cccc":
      default:
        return u.day(i, { width: "wide", context: "standalone" }) || u.day(i, {
          width: "abbreviated",
          context: "standalone"
        }) || u.day(i, { width: "short", context: "standalone" }) || u.day(i, { width: "narrow", context: "standalone" });
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 6;
  }
  set(i, l, u, h) {
    return i = Y1(i, u, h), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "e",
    "t",
    "T"
  ];
}
function nz(s, i, l) {
  const u = Te(s, l?.in), h = RC(u, l), g = i - h;
  return L0(u, g, l);
}
class iz extends Je {
  priority = 90;
  parse(i, l, u) {
    const h = (g) => g === 0 ? 7 : g;
    switch (l) {
      // 2
      case "i":
      case "ii":
        return In(l.length, i);
      // 2nd
      case "io":
        return u.ordinalNumber(i, { unit: "day" });
      // Tue
      case "iii":
        return ci(
          u.day(i, {
            width: "abbreviated",
            context: "formatting"
          }) || u.day(i, {
            width: "short",
            context: "formatting"
          }) || u.day(i, {
            width: "narrow",
            context: "formatting"
          }),
          h
        );
      // T
      case "iiiii":
        return ci(
          u.day(i, {
            width: "narrow",
            context: "formatting"
          }),
          h
        );
      // Tu
      case "iiiiii":
        return ci(
          u.day(i, {
            width: "short",
            context: "formatting"
          }) || u.day(i, {
            width: "narrow",
            context: "formatting"
          }),
          h
        );
      // Tuesday
      case "iiii":
      default:
        return ci(
          u.day(i, {
            width: "wide",
            context: "formatting"
          }) || u.day(i, {
            width: "abbreviated",
            context: "formatting"
          }) || u.day(i, {
            width: "short",
            context: "formatting"
          }) || u.day(i, {
            width: "narrow",
            context: "formatting"
          }),
          h
        );
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 7;
  }
  set(i, l, u) {
    return i = nz(i, u), i.setHours(0, 0, 0, 0), i;
  }
  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "E",
    "e",
    "c",
    "t",
    "T"
  ];
}
class az extends Je {
  priority = 80;
  parse(i, l, u) {
    switch (l) {
      case "a":
      case "aa":
      case "aaa":
        return u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return u.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(i, l, u) {
    return i.setHours(B1(u), 0, 0, 0), i;
  }
  incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
}
class oz extends Je {
  priority = 80;
  parse(i, l, u) {
    switch (l) {
      case "b":
      case "bb":
      case "bbb":
        return u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return u.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(i, l, u) {
    return i.setHours(B1(u), 0, 0, 0), i;
  }
  incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
}
class lz extends Je {
  priority = 80;
  parse(i, l, u) {
    switch (l) {
      case "B":
      case "BB":
      case "BBB":
        return u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return u.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }) || u.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(i, l, u) {
    return i.setHours(B1(u), 0, 0, 0), i;
  }
  incompatibleTokens = ["a", "b", "t", "T"];
}
class sz extends Je {
  priority = 70;
  parse(i, l, u) {
    switch (l) {
      case "h":
        return qn(ui.hour12h, i);
      case "ho":
        return u.ordinalNumber(i, { unit: "hour" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 12;
  }
  set(i, l, u) {
    const h = i.getHours() >= 12;
    return h && u < 12 ? i.setHours(u + 12, 0, 0, 0) : !h && u === 12 ? i.setHours(0, 0, 0, 0) : i.setHours(u, 0, 0, 0), i;
  }
  incompatibleTokens = ["H", "K", "k", "t", "T"];
}
class rz extends Je {
  priority = 70;
  parse(i, l, u) {
    switch (l) {
      case "H":
        return qn(ui.hour23h, i);
      case "Ho":
        return u.ordinalNumber(i, { unit: "hour" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 23;
  }
  set(i, l, u) {
    return i.setHours(u, 0, 0, 0), i;
  }
  incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
}
class uz extends Je {
  priority = 70;
  parse(i, l, u) {
    switch (l) {
      case "K":
        return qn(ui.hour11h, i);
      case "Ko":
        return u.ordinalNumber(i, { unit: "hour" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 11;
  }
  set(i, l, u) {
    return i.getHours() >= 12 && u < 12 ? i.setHours(u + 12, 0, 0, 0) : i.setHours(u, 0, 0, 0), i;
  }
  incompatibleTokens = ["h", "H", "k", "t", "T"];
}
class cz extends Je {
  priority = 70;
  parse(i, l, u) {
    switch (l) {
      case "k":
        return qn(ui.hour24h, i);
      case "ko":
        return u.ordinalNumber(i, { unit: "hour" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 1 && l <= 24;
  }
  set(i, l, u) {
    const h = u <= 24 ? u % 24 : u;
    return i.setHours(h, 0, 0, 0), i;
  }
  incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
}
class fz extends Je {
  priority = 60;
  parse(i, l, u) {
    switch (l) {
      case "m":
        return qn(ui.minute, i);
      case "mo":
        return u.ordinalNumber(i, { unit: "minute" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 59;
  }
  set(i, l, u) {
    return i.setMinutes(u, 0, 0), i;
  }
  incompatibleTokens = ["t", "T"];
}
class hz extends Je {
  priority = 50;
  parse(i, l, u) {
    switch (l) {
      case "s":
        return qn(ui.second, i);
      case "so":
        return u.ordinalNumber(i, { unit: "second" });
      default:
        return In(l.length, i);
    }
  }
  validate(i, l) {
    return l >= 0 && l <= 59;
  }
  set(i, l, u) {
    return i.setSeconds(u, 0), i;
  }
  incompatibleTokens = ["t", "T"];
}
class dz extends Je {
  priority = 30;
  parse(i, l) {
    const u = (h) => Math.trunc(h * Math.pow(10, -l.length + 3));
    return ci(In(l.length, i), u);
  }
  set(i, l, u) {
    return i.setMilliseconds(u), i;
  }
  incompatibleTokens = ["t", "T"];
}
class mz extends Je {
  priority = 10;
  parse(i, l) {
    switch (l) {
      case "X":
        return ru(
          su.basicOptionalMinutes,
          i
        );
      case "XX":
        return ru(su.basic, i);
      case "XXXX":
        return ru(
          su.basicOptionalSeconds,
          i
        );
      case "XXXXX":
        return ru(
          su.extendedOptionalSeconds,
          i
        );
      case "XXX":
      default:
        return ru(su.extended, i);
    }
  }
  set(i, l, u) {
    return l.timestampIsSet ? i : Wn(
      i,
      i.getTime() - E0(i) - u
    );
  }
  incompatibleTokens = ["t", "T", "x"];
}
class pz extends Je {
  priority = 10;
  parse(i, l) {
    switch (l) {
      case "x":
        return ru(
          su.basicOptionalMinutes,
          i
        );
      case "xx":
        return ru(su.basic, i);
      case "xxxx":
        return ru(
          su.basicOptionalSeconds,
          i
        );
      case "xxxxx":
        return ru(
          su.extendedOptionalSeconds,
          i
        );
      case "xxx":
      default:
        return ru(su.extended, i);
    }
  }
  set(i, l, u) {
    return l.timestampIsSet ? i : Wn(
      i,
      i.getTime() - E0(i) - u
    );
  }
  incompatibleTokens = ["t", "T", "X"];
}
class gz extends Je {
  priority = 40;
  parse(i) {
    return MM(i);
  }
  set(i, l, u) {
    return [Wn(i, u * 1e3), { timestampIsSet: !0 }];
  }
  incompatibleTokens = "*";
}
class yz extends Je {
  priority = 20;
  parse(i) {
    return MM(i);
  }
  set(i, l, u) {
    return [Wn(i, u), { timestampIsSet: !0 }];
  }
  incompatibleTokens = "*";
}
const vz = {
  G: new NC(),
  y: new UC(),
  Y: new BC(),
  R: new YC(),
  u: new jC(),
  Q: new qC(),
  q: new ZC(),
  M: new PC(),
  L: new VC(),
  w: new XC(),
  I: new KC(),
  d: new $C(),
  D: new JC(),
  E: new FC(),
  e: new tz(),
  c: new ez(),
  i: new iz(),
  a: new az(),
  b: new oz(),
  B: new lz(),
  h: new sz(),
  H: new rz(),
  K: new uz(),
  k: new cz(),
  m: new fz(),
  s: new hz(),
  S: new dz(),
  X: new mz(),
  x: new pz(),
  t: new gz(),
  T: new yz()
}, _z = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, bz = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Sz = /^'([^]*?)'?$/, Tz = /''/g, xz = /\S/, wz = /[a-zA-Z]/;
function Mz(s, i, l, u) {
  const h = () => Wn(u?.in || l, NaN), g = AC(), _ = u?.locale ?? g.locale ?? vM, S = u?.firstWeekContainsDate ?? u?.locale?.options?.firstWeekContainsDate ?? g.firstWeekContainsDate ?? g.locale?.options?.firstWeekContainsDate ?? 1, T = u?.weekStartsOn ?? u?.locale?.options?.weekStartsOn ?? g.weekStartsOn ?? g.locale?.options?.weekStartsOn ?? 0;
  if (!i)
    return s ? h() : Te(l, u?.in);
  const E = {
    firstWeekContainsDate: S,
    weekStartsOn: T,
    locale: _
  }, D = [new kC(u?.in, l)], C = i.match(bz).map((X) => {
    const nt = X[0];
    if (nt in y1) {
      const Dt = y1[nt];
      return Dt(X, _.formatLong);
    }
    return X;
  }).join("").match(_z), z = [];
  for (let X of C) {
    !u?.useAdditionalWeekYearTokens && xM(X) && v1(X, i, s), !u?.useAdditionalDayOfYearTokens && TM(X) && v1(X, i, s);
    const nt = X[0], Dt = vz[nt];
    if (Dt) {
      const { incompatibleTokens: Et } = Dt;
      if (Array.isArray(Et)) {
        const dt = z.find(
          (Lt) => Et.includes(Lt.token) || Lt.token === nt
        );
        if (dt)
          throw new RangeError(
            `The format string mustn't contain \`${dt.fullToken}\` and \`${X}\` at the same time`
          );
      } else if (Dt.incompatibleTokens === "*" && z.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${X}\` and any other token at the same time`
        );
      z.push({ token: nt, fullToken: X });
      const zt = Dt.run(
        s,
        X,
        _.match,
        E
      );
      if (!zt)
        return h();
      D.push(zt.setter), s = zt.rest;
    } else {
      if (nt.match(wz))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + nt + "`"
        );
      if (X === "''" ? X = "'" : nt === "'" && (X = Ez(X)), s.indexOf(X) === 0)
        s = s.slice(X.length);
      else
        return h();
    }
  }
  if (s.length > 0 && xz.test(s))
    return h();
  const j = D.map((X) => X.priority).sort((X, nt) => nt - X).filter((X, nt, Dt) => Dt.indexOf(X) === nt).map(
    (X) => D.filter((nt) => nt.priority === X).sort((nt, Dt) => Dt.subPriority - nt.subPriority)
  ).map((X) => X[0]);
  let I = Te(l, u?.in);
  if (isNaN(+I)) return h();
  const Q = {};
  for (const X of j) {
    if (!X.validate(I, E))
      return h();
    const nt = X.set(I, Q, E);
    Array.isArray(nt) ? (I = nt[0], Object.assign(Q, nt[1])) : I = nt;
  }
  return I;
}
function Ez(s) {
  return s.match(Sz)[1].replace(Tz, "'");
}
function Oz(s, i) {
  const l = Te(s, i?.in);
  return l.setMinutes(0, 0, 0), l;
}
function Dz(s, i) {
  const l = Te(s, i?.in);
  return l.setSeconds(0, 0), l;
}
function Az(s, i) {
  const l = Te(s, i?.in);
  return l.setMilliseconds(0), l;
}
function Rz(s, i) {
  const l = () => Wn(i?.in, NaN), u = i?.additionalDigits ?? 2, h = Hz(s);
  let g;
  if (h.date) {
    const E = kz(h.date, u);
    g = Nz(E.restDateString, E.year);
  }
  if (!g || isNaN(+g)) return l();
  const _ = +g;
  let S = 0, T;
  if (h.time && (S = Uz(h.time), isNaN(S)))
    return l();
  if (h.timezone) {
    if (T = Bz(h.timezone), isNaN(T)) return l();
  } else {
    const E = new Date(_ + S), D = Te(0, i?.in);
    return D.setFullYear(
      E.getUTCFullYear(),
      E.getUTCMonth(),
      E.getUTCDate()
    ), D.setHours(
      E.getUTCHours(),
      E.getUTCMinutes(),
      E.getUTCSeconds(),
      E.getUTCMilliseconds()
    ), D;
  }
  return Te(_ + S + T, i?.in);
}
const p0 = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, Cz = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, zz = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, Lz = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function Hz(s) {
  const i = {}, l = s.split(p0.dateTimeDelimiter);
  let u;
  if (l.length > 2)
    return i;
  if (/:/.test(l[0]) ? u = l[0] : (i.date = l[0], u = l[1], p0.timeZoneDelimiter.test(i.date) && (i.date = s.split(p0.timeZoneDelimiter)[0], u = s.substr(
    i.date.length,
    s.length
  ))), u) {
    const h = p0.timezone.exec(u);
    h ? (i.time = u.replace(h[1], ""), i.timezone = h[1]) : i.time = u;
  }
  return i;
}
function kz(s, i) {
  const l = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + i) + "})|(\\d{2}|[+-]\\d{" + (2 + i) + "})$)"
  ), u = s.match(l);
  if (!u) return { year: NaN, restDateString: "" };
  const h = u[1] ? parseInt(u[1]) : null, g = u[2] ? parseInt(u[2]) : null;
  return {
    year: g === null ? h : g * 100,
    restDateString: s.slice((u[1] || u[2]).length)
  };
}
function Nz(s, i) {
  if (i === null) return /* @__PURE__ */ new Date(NaN);
  const l = s.match(Cz);
  if (!l) return /* @__PURE__ */ new Date(NaN);
  const u = !!l[4], h = av(l[1]), g = av(l[2]) - 1, _ = av(l[3]), S = av(l[4]), T = av(l[5]) - 1;
  if (u)
    return Pz(i, S, T) ? Yz(i, S, T) : /* @__PURE__ */ new Date(NaN);
  {
    const E = /* @__PURE__ */ new Date(0);
    return !qz(i, g, _) || !Zz(i, h) ? /* @__PURE__ */ new Date(NaN) : (E.setUTCFullYear(i, g, Math.max(h, _)), E);
  }
}
function av(s) {
  return s ? parseInt(s) : 1;
}
function Uz(s) {
  const i = s.match(zz);
  if (!i) return NaN;
  const l = l1(i[1]), u = l1(i[2]), h = l1(i[3]);
  return Vz(l, u, h) ? l * Mv + u * wv + h * 1e3 : NaN;
}
function l1(s) {
  return s && parseFloat(s.replace(",", ".")) || 0;
}
function Bz(s) {
  if (s === "Z") return 0;
  const i = s.match(Lz);
  if (!i) return 0;
  const l = i[1] === "+" ? -1 : 1, u = parseInt(i[2]), h = i[3] && parseInt(i[3]) || 0;
  return Gz(u, h) ? l * (u * Mv + h * wv) : NaN;
}
function Yz(s, i, l) {
  const u = /* @__PURE__ */ new Date(0);
  u.setUTCFullYear(s, 0, 4);
  const h = u.getUTCDay() || 7, g = (i - 1) * 7 + l + 1 - h;
  return u.setUTCDate(u.getUTCDate() + g), u;
}
const jz = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function DM(s) {
  return s % 400 === 0 || s % 4 === 0 && s % 100 !== 0;
}
function qz(s, i, l) {
  return i >= 0 && i <= 11 && l >= 1 && l <= (jz[i] || (DM(s) ? 29 : 28));
}
function Zz(s, i) {
  return i >= 1 && i <= (DM(s) ? 366 : 365);
}
function Pz(s, i, l) {
  return i >= 1 && i <= 53 && l >= 0 && l <= 6;
}
function Vz(s, i, l) {
  return s === 24 ? i === 0 && l === 0 : l >= 0 && l < 60 && i >= 0 && i < 60 && s >= 0 && s < 25;
}
function Gz(s, i) {
  return i >= 0 && i <= 59;
}
/*!
 * chartjs-adapter-date-fns v3.0.0
 * https://www.chartjs.org
 * (c) 2022 chartjs-adapter-date-fns Contributors
 * Released under the MIT license
 */
const Xz = {
  datetime: "MMM d, yyyy, h:mm:ss aaaa",
  millisecond: "h:mm:ss.SSS aaaa",
  second: "h:mm:ss aaaa",
  minute: "h:mm aaaa",
  hour: "ha",
  day: "MMM d",
  week: "PP",
  month: "MMM yyyy",
  quarter: "qqq - yyyy",
  year: "yyyy"
};
Kw._date.override({
  _id: "date-fns",
  // DEBUG
  formats: function() {
    return Xz;
  },
  parse: function(s, i) {
    if (s === null || typeof s > "u")
      return null;
    const l = typeof s;
    return l === "number" || s instanceof Date ? s = Te(s) : l === "string" && (typeof i == "string" ? s = Mz(s, i, /* @__PURE__ */ new Date(), this.options) : s = Rz(s, this.options)), hM(s) ? s.getTime() : null;
  },
  format: function(s, i) {
    return OC(s, i, this.options);
  },
  add: function(s, i, l) {
    switch (l) {
      case "millisecond":
        return k1(s, i);
      case "second":
        return gR(s, i);
      case "minute":
        return mR(s, i);
      case "hour":
        return fR(s, i);
      case "day":
        return L0(s, i);
      case "week":
        return yR(s, i);
      case "month":
        return H1(s, i);
      case "quarter":
        return pR(s, i);
      case "year":
        return vR(s, i);
      default:
        return s;
    }
  },
  diff: function(s, i, l) {
    switch (l) {
      case "millisecond":
        return N1(s, i);
      case "second":
        return ER(s, i);
      case "minute":
        return xR(s, i);
      case "hour":
        return TR(s, i);
      case "day":
        return dM(s, i);
      case "week":
        return OR(s, i);
      case "month":
        return gM(s, i);
      case "quarter":
        return MR(s, i);
      case "year":
        return DR(s, i);
      default:
        return 0;
    }
  },
  startOf: function(s, i, l) {
    switch (i) {
      case "second":
        return Az(s);
      case "minute":
        return Dz(s);
      case "hour":
        return Oz(s);
      case "day":
        return g1(s);
      case "week":
        return fu(s);
      case "isoWeek":
        return fu(s, { weekStartsOn: +l });
      case "month":
        return RR(s);
      case "quarter":
        return AR(s);
      case "year":
        return yM(s);
      default:
        return s;
    }
  },
  endOf: function(s, i) {
    switch (i) {
      case "second":
        return NR(s);
      case "minute":
        return HR(s);
      case "hour":
        return zR(s);
      case "day":
        return mM(s);
      case "week":
        return LR(s);
      case "month":
        return pM(s);
      case "quarter":
        return kR(s);
      case "year":
        return CR(s);
      default:
        return s;
    }
  }
});
L1.register(cD, R0, DA, oR, p1, nR, KA);
function Qz({ data: s }) {
  const i = si.useRef(null);
  return si.useEffect(() => {
    const l = i.current?.getContext("2d");
    if (!l) return;
    const u = s.map((g) => parseFloat(g.price)), h = new L1(l, {
      type: "line",
      data: {
        labels: s.map((g) => g.fetched_at),
        datasets: [
          {
            label: "Cena",
            data: u,
            borderColor: "#0d6efd",
            fill: !1
          }
        ]
      },
      options: {
        scales: {
          x: { type: "time" }
        }
      }
    });
    return () => h.destroy();
  }, [s]), /* @__PURE__ */ Qt.jsx("canvas", { ref: i, height: 300 });
}
var uv = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
var Kz = uv.exports, bw;
function Wz() {
  return bw || (bw = 1, function(s, i) {
    (function(l, u) {
      u(i);
    })(Kz, function(l) {
      var u = "1.9.4";
      function h(r) {
        var d, v, w, O;
        for (v = 1, w = arguments.length; v < w; v++) {
          O = arguments[v];
          for (d in O)
            r[d] = O[d];
        }
        return r;
      }
      var g = Object.create || /* @__PURE__ */ function() {
        function r() {
        }
        return function(d) {
          return r.prototype = d, new r();
        };
      }();
      function _(r, d) {
        var v = Array.prototype.slice;
        if (r.bind)
          return r.bind.apply(r, v.call(arguments, 1));
        var w = v.call(arguments, 2);
        return function() {
          return r.apply(d, w.length ? w.concat(v.call(arguments)) : arguments);
        };
      }
      var S = 0;
      function T(r) {
        return "_leaflet_id" in r || (r._leaflet_id = ++S), r._leaflet_id;
      }
      function E(r, d, v) {
        var w, O, H, q;
        return q = function() {
          w = !1, O && (H.apply(v, O), O = !1);
        }, H = function() {
          w ? O = arguments : (r.apply(v, arguments), setTimeout(q, d), w = !0);
        }, H;
      }
      function D(r, d, v) {
        var w = d[1], O = d[0], H = w - O;
        return r === w && v ? r : ((r - O) % H + H) % H + O;
      }
      function C() {
        return !1;
      }
      function z(r, d) {
        if (d === !1)
          return r;
        var v = Math.pow(10, d === void 0 ? 6 : d);
        return Math.round(r * v) / v;
      }
      function j(r) {
        return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, "");
      }
      function I(r) {
        return j(r).split(/\s+/);
      }
      function Q(r, d) {
        Object.prototype.hasOwnProperty.call(r, "options") || (r.options = r.options ? g(r.options) : {});
        for (var v in d)
          r.options[v] = d[v];
        return r.options;
      }
      function X(r, d, v) {
        var w = [];
        for (var O in r)
          w.push(encodeURIComponent(v ? O.toUpperCase() : O) + "=" + encodeURIComponent(r[O]));
        return (!d || d.indexOf("?") === -1 ? "?" : "&") + w.join("&");
      }
      var nt = /\{ *([\w_ -]+) *\}/g;
      function Dt(r, d) {
        return r.replace(nt, function(v, w) {
          var O = d[w];
          if (O === void 0)
            throw new Error("No value provided for variable " + v);
          return typeof O == "function" && (O = O(d)), O;
        });
      }
      var Et = Array.isArray || function(r) {
        return Object.prototype.toString.call(r) === "[object Array]";
      };
      function zt(r, d) {
        for (var v = 0; v < r.length; v++)
          if (r[v] === d)
            return v;
        return -1;
      }
      var dt = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function Lt(r) {
        return window["webkit" + r] || window["moz" + r] || window["ms" + r];
      }
      var Ct = 0;
      function Yt(r) {
        var d = +/* @__PURE__ */ new Date(), v = Math.max(0, 16 - (d - Ct));
        return Ct = d + v, window.setTimeout(r, v);
      }
      var wt = window.requestAnimationFrame || Lt("RequestAnimationFrame") || Yt, ne = window.cancelAnimationFrame || Lt("CancelAnimationFrame") || Lt("CancelRequestAnimationFrame") || function(r) {
        window.clearTimeout(r);
      };
      function Rt(r, d, v) {
        if (v && wt === Yt)
          r.call(d);
        else
          return wt.call(window, _(r, d));
      }
      function Nt(r) {
        r && ne.call(window, r);
      }
      var Ee = {
        __proto__: null,
        extend: h,
        create: g,
        bind: _,
        get lastId() {
          return S;
        },
        stamp: T,
        throttle: E,
        wrapNum: D,
        falseFn: C,
        formatNum: z,
        trim: j,
        splitWords: I,
        setOptions: Q,
        getParamString: X,
        template: Dt,
        isArray: Et,
        indexOf: zt,
        emptyImageUrl: dt,
        requestFn: wt,
        cancelFn: ne,
        requestAnimFrame: Rt,
        cancelAnimFrame: Nt
      };
      function ge() {
      }
      ge.extend = function(r) {
        var d = function() {
          Q(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
        }, v = d.__super__ = this.prototype, w = g(v);
        w.constructor = d, d.prototype = w;
        for (var O in this)
          Object.prototype.hasOwnProperty.call(this, O) && O !== "prototype" && O !== "__super__" && (d[O] = this[O]);
        return r.statics && h(d, r.statics), r.includes && (Jt(r.includes), h.apply(null, [w].concat(r.includes))), h(w, r), delete w.statics, delete w.includes, w.options && (w.options = v.options ? g(v.options) : {}, h(w.options, r.options)), w._initHooks = [], w.callInitHooks = function() {
          if (!this._initHooksCalled) {
            v.callInitHooks && v.callInitHooks.call(this), this._initHooksCalled = !0;
            for (var H = 0, q = w._initHooks.length; H < q; H++)
              w._initHooks[H].call(this);
          }
        }, d;
      }, ge.include = function(r) {
        var d = this.prototype.options;
        return h(this.prototype, r), r.options && (this.prototype.options = d, this.mergeOptions(r.options)), this;
      }, ge.mergeOptions = function(r) {
        return h(this.prototype.options, r), this;
      }, ge.addInitHook = function(r) {
        var d = Array.prototype.slice.call(arguments, 1), v = typeof r == "function" ? r : function() {
          this[r].apply(this, d);
        };
        return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(v), this;
      };
      function Jt(r) {
        if (!(typeof L > "u" || !L || !L.Mixin)) {
          r = Et(r) ? r : [r];
          for (var d = 0; d < r.length; d++)
            r[d] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
        }
      }
      var V = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(r, d, v) {
          if (typeof r == "object")
            for (var w in r)
              this._on(w, r[w], d);
          else {
            r = I(r);
            for (var O = 0, H = r.length; O < H; O++)
              this._on(r[O], d, v);
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(r, d, v) {
          if (!arguments.length)
            delete this._events;
          else if (typeof r == "object")
            for (var w in r)
              this._off(w, r[w], d);
          else {
            r = I(r);
            for (var O = arguments.length === 1, H = 0, q = r.length; H < q; H++)
              O ? this._off(r[H]) : this._off(r[H], d, v);
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(r, d, v, w) {
          if (typeof d != "function") {
            console.warn("wrong listener type: " + typeof d);
            return;
          }
          if (this._listens(r, d, v) === !1) {
            v === this && (v = void 0);
            var O = { fn: d, ctx: v };
            w && (O.once = !0), this._events = this._events || {}, this._events[r] = this._events[r] || [], this._events[r].push(O);
          }
        },
        _off: function(r, d, v) {
          var w, O, H;
          if (this._events && (w = this._events[r], !!w)) {
            if (arguments.length === 1) {
              if (this._firingCount)
                for (O = 0, H = w.length; O < H; O++)
                  w[O].fn = C;
              delete this._events[r];
              return;
            }
            if (typeof d != "function") {
              console.warn("wrong listener type: " + typeof d);
              return;
            }
            var q = this._listens(r, d, v);
            if (q !== !1) {
              var $ = w[q];
              this._firingCount && ($.fn = C, this._events[r] = w = w.slice()), w.splice(q, 1);
            }
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object — the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(r, d, v) {
          if (!this.listens(r, v))
            return this;
          var w = h({}, d, {
            type: r,
            target: this,
            sourceTarget: d && d.sourceTarget || this
          });
          if (this._events) {
            var O = this._events[r];
            if (O) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var H = 0, q = O.length; H < q; H++) {
                var $ = O[H], rt = $.fn;
                $.once && this.off(r, rt, $.ctx), rt.call($.ctx || this, w);
              }
              this._firingCount--;
            }
          }
          return v && this._propagateEvent(w), this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(r, d, v, w) {
          typeof r != "string" && console.warn('"string" type argument expected');
          var O = d;
          typeof d != "function" && (w = !!d, O = void 0, v = void 0);
          var H = this._events && this._events[r];
          if (H && H.length && this._listens(r, O, v) !== !1)
            return !0;
          if (w) {
            for (var q in this._eventParents)
              if (this._eventParents[q].listens(r, d, v, w))
                return !0;
          }
          return !1;
        },
        // returns the index (number) or false
        _listens: function(r, d, v) {
          if (!this._events)
            return !1;
          var w = this._events[r] || [];
          if (!d)
            return !!w.length;
          v === this && (v = void 0);
          for (var O = 0, H = w.length; O < H; O++)
            if (w[O].fn === d && w[O].ctx === v)
              return O;
          return !1;
        },
        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        once: function(r, d, v) {
          if (typeof r == "object")
            for (var w in r)
              this._on(w, r[w], d, !0);
          else {
            r = I(r);
            for (var O = 0, H = r.length; O < H; O++)
              this._on(r[O], d, v, !0);
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(r) {
          return this._eventParents = this._eventParents || {}, this._eventParents[T(r)] = r, this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(r) {
          return this._eventParents && delete this._eventParents[T(r)], this;
        },
        _propagateEvent: function(r) {
          for (var d in this._eventParents)
            this._eventParents[d].fire(r.type, h({
              layer: r.target,
              propagatedFrom: r.target
            }, r), !0);
        }
      };
      V.addEventListener = V.on, V.removeEventListener = V.clearAllEventListeners = V.off, V.addOneTimeEventListener = V.once, V.fireEvent = V.fire, V.hasEventListeners = V.listens;
      var mt = ge.extend(V);
      function ut(r, d, v) {
        this.x = v ? Math.round(r) : r, this.y = v ? Math.round(d) : d;
      }
      var Gt = Math.trunc || function(r) {
        return r > 0 ? Math.floor(r) : Math.ceil(r);
      };
      ut.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new ut(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(r) {
          return this.clone()._add(k(r));
        },
        _add: function(r) {
          return this.x += r.x, this.y += r.y, this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(r) {
          return this.clone()._subtract(k(r));
        },
        _subtract: function(r) {
          return this.x -= r.x, this.y -= r.y, this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(r) {
          return this.clone()._divideBy(r);
        },
        _divideBy: function(r) {
          return this.x /= r, this.y /= r, this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(r) {
          return this.clone()._multiplyBy(r);
        },
        _multiplyBy: function(r) {
          return this.x *= r, this.y *= r, this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(r) {
          return new ut(this.x * r.x, this.y * r.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(r) {
          return new ut(this.x / r.x, this.y / r.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          return this.x = Gt(this.x), this.y = Gt(this.y), this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(r) {
          r = k(r);
          var d = r.x - this.x, v = r.y - this.y;
          return Math.sqrt(d * d + v * v);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(r) {
          return r = k(r), r.x === this.x && r.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(r) {
          return r = k(r), Math.abs(r.x) <= Math.abs(this.x) && Math.abs(r.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + z(this.x) + ", " + z(this.y) + ")";
        }
      };
      function k(r, d, v) {
        return r instanceof ut ? r : Et(r) ? new ut(r[0], r[1]) : r == null ? r : typeof r == "object" && "x" in r && "y" in r ? new ut(r.x, r.y) : new ut(r, d, v);
      }
      function F(r, d) {
        if (r)
          for (var v = d ? [r, d] : r, w = 0, O = v.length; w < O; w++)
            this.extend(v[w]);
      }
      F.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(r) {
          var d, v;
          if (!r)
            return this;
          if (r instanceof ut || typeof r[0] == "number" || "x" in r)
            d = v = k(r);
          else if (r = ct(r), d = r.min, v = r.max, !d || !v)
            return this;
          return !this.min && !this.max ? (this.min = d.clone(), this.max = v.clone()) : (this.min.x = Math.min(d.x, this.min.x), this.max.x = Math.max(v.x, this.max.x), this.min.y = Math.min(d.y, this.min.y), this.max.y = Math.max(v.y, this.max.y)), this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(r) {
          return k(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            r
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return k(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return k(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(r) {
          var d, v;
          return typeof r[0] == "number" || r instanceof ut ? r = k(r) : r = ct(r), r instanceof F ? (d = r.min, v = r.max) : d = v = r, d.x >= this.min.x && v.x <= this.max.x && d.y >= this.min.y && v.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(r) {
          r = ct(r);
          var d = this.min, v = this.max, w = r.min, O = r.max, H = O.x >= d.x && w.x <= v.x, q = O.y >= d.y && w.y <= v.y;
          return H && q;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(r) {
          r = ct(r);
          var d = this.min, v = this.max, w = r.min, O = r.max, H = O.x > d.x && w.x < v.x, q = O.y > d.y && w.y < v.y;
          return H && q;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(r) {
          var d = this.min, v = this.max, w = Math.abs(d.x - v.x) * r, O = Math.abs(d.y - v.y) * r;
          return ct(
            k(d.x - w, d.y - O),
            k(v.x + w, v.y + O)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(r) {
          return r ? (r = ct(r), this.min.equals(r.getTopLeft()) && this.max.equals(r.getBottomRight())) : !1;
        }
      };
      function ct(r, d) {
        return !r || r instanceof F ? r : new F(r, d);
      }
      function bt(r, d) {
        if (r)
          for (var v = d ? [r, d] : r, w = 0, O = v.length; w < O; w++)
            this.extend(v[w]);
      }
      bt.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(r) {
          var d = this._southWest, v = this._northEast, w, O;
          if (r instanceof Ht)
            w = r, O = r;
          else if (r instanceof bt) {
            if (w = r._southWest, O = r._northEast, !w || !O)
              return this;
          } else
            return r ? this.extend(Tt(r) || Mt(r)) : this;
          return !d && !v ? (this._southWest = new Ht(w.lat, w.lng), this._northEast = new Ht(O.lat, O.lng)) : (d.lat = Math.min(w.lat, d.lat), d.lng = Math.min(w.lng, d.lng), v.lat = Math.max(O.lat, v.lat), v.lng = Math.max(O.lng, v.lng)), this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(r) {
          var d = this._southWest, v = this._northEast, w = Math.abs(d.lat - v.lat) * r, O = Math.abs(d.lng - v.lng) * r;
          return new bt(
            new Ht(d.lat - w, d.lng - O),
            new Ht(v.lat + w, v.lng + O)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new Ht(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new Ht(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new Ht(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(r) {
          typeof r[0] == "number" || r instanceof Ht || "lat" in r ? r = Tt(r) : r = Mt(r);
          var d = this._southWest, v = this._northEast, w, O;
          return r instanceof bt ? (w = r.getSouthWest(), O = r.getNorthEast()) : w = O = r, w.lat >= d.lat && O.lat <= v.lat && w.lng >= d.lng && O.lng <= v.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(r) {
          r = Mt(r);
          var d = this._southWest, v = this._northEast, w = r.getSouthWest(), O = r.getNorthEast(), H = O.lat >= d.lat && w.lat <= v.lat, q = O.lng >= d.lng && w.lng <= v.lng;
          return H && q;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(r) {
          r = Mt(r);
          var d = this._southWest, v = this._northEast, w = r.getSouthWest(), O = r.getNorthEast(), H = O.lat > d.lat && w.lat < v.lat, q = O.lng > d.lng && w.lng < v.lng;
          return H && q;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(r, d) {
          return r ? (r = Mt(r), this._southWest.equals(r.getSouthWest(), d) && this._northEast.equals(r.getNorthEast(), d)) : !1;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function Mt(r, d) {
        return r instanceof bt ? r : new bt(r, d);
      }
      function Ht(r, d, v) {
        if (isNaN(r) || isNaN(d))
          throw new Error("Invalid LatLng object: (" + r + ", " + d + ")");
        this.lat = +r, this.lng = +d, v !== void 0 && (this.alt = +v);
      }
      Ht.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(r, d) {
          if (!r)
            return !1;
          r = Tt(r);
          var v = Math.max(
            Math.abs(this.lat - r.lat),
            Math.abs(this.lng - r.lng)
          );
          return v <= (d === void 0 ? 1e-9 : d);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(r) {
          return "LatLng(" + z(this.lat, r) + ", " + z(this.lng, r) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(r) {
          return Ft.distance(this, Tt(r));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return Ft.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(r) {
          var d = 180 * r / 40075017, v = d / Math.cos(Math.PI / 180 * this.lat);
          return Mt(
            [this.lat - d, this.lng - v],
            [this.lat + d, this.lng + v]
          );
        },
        clone: function() {
          return new Ht(this.lat, this.lng, this.alt);
        }
      };
      function Tt(r, d, v) {
        return r instanceof Ht ? r : Et(r) && typeof r[0] != "object" ? r.length === 3 ? new Ht(r[0], r[1], r[2]) : r.length === 2 ? new Ht(r[0], r[1]) : null : r == null ? r : typeof r == "object" && "lat" in r ? new Ht(r.lat, "lng" in r ? r.lng : r.lon, r.alt) : d === void 0 ? null : new Ht(r, d, v);
      }
      var We = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(r, d) {
          var v = this.projection.project(r), w = this.scale(d);
          return this.transformation._transform(v, w);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(r, d) {
          var v = this.scale(d), w = this.transformation.untransform(r, v);
          return this.projection.unproject(w);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(r) {
          return this.projection.project(r);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(r) {
          return this.projection.unproject(r);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(r) {
          return 256 * Math.pow(2, r);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(r) {
          return Math.log(r / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(r) {
          if (this.infinite)
            return null;
          var d = this.projection.bounds, v = this.scale(r), w = this.transformation.transform(d.min, v), O = this.transformation.transform(d.max, v);
          return new F(w, O);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: !1,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(r) {
          var d = this.wrapLng ? D(r.lng, this.wrapLng, !0) : r.lng, v = this.wrapLat ? D(r.lat, this.wrapLat, !0) : r.lat, w = r.alt;
          return new Ht(v, d, w);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(r) {
          var d = r.getCenter(), v = this.wrapLatLng(d), w = d.lat - v.lat, O = d.lng - v.lng;
          if (w === 0 && O === 0)
            return r;
          var H = r.getSouthWest(), q = r.getNorthEast(), $ = new Ht(H.lat - w, H.lng - O), rt = new Ht(q.lat - w, q.lng - O);
          return new bt($, rt);
        }
      }, Ft = h({}, We, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(r, d) {
          var v = Math.PI / 180, w = r.lat * v, O = d.lat * v, H = Math.sin((d.lat - r.lat) * v / 2), q = Math.sin((d.lng - r.lng) * v / 2), $ = H * H + Math.cos(w) * Math.cos(O) * q * q, rt = 2 * Math.atan2(Math.sqrt($), Math.sqrt(1 - $));
          return this.R * rt;
        }
      }), on = 6378137, fi = {
        R: on,
        MAX_LATITUDE: 85.0511287798,
        project: function(r) {
          var d = Math.PI / 180, v = this.MAX_LATITUDE, w = Math.max(Math.min(v, r.lat), -v), O = Math.sin(w * d);
          return new ut(
            this.R * r.lng * d,
            this.R * Math.log((1 + O) / (1 - O)) / 2
          );
        },
        unproject: function(r) {
          var d = 180 / Math.PI;
          return new Ht(
            (2 * Math.atan(Math.exp(r.y / this.R)) - Math.PI / 2) * d,
            r.x * d / this.R
          );
        },
        bounds: function() {
          var r = on * Math.PI;
          return new F([-r, -r], [r, r]);
        }()
      };
      function da(r, d, v, w) {
        if (Et(r)) {
          this._a = r[0], this._b = r[1], this._c = r[2], this._d = r[3];
          return;
        }
        this._a = r, this._b = d, this._c = v, this._d = w;
      }
      da.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(r, d) {
          return this._transform(r.clone(), d);
        },
        // destructive transform (faster)
        _transform: function(r, d) {
          return d = d || 1, r.x = d * (this._a * r.x + this._b), r.y = d * (this._c * r.y + this._d), r;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(r, d) {
          return d = d || 1, new ut(
            (r.x / d - this._b) / this._a,
            (r.y / d - this._d) / this._c
          );
        }
      };
      function Za(r, d, v, w) {
        return new da(r, d, v, w);
      }
      var ma = h({}, Ft, {
        code: "EPSG:3857",
        projection: fi,
        transformation: function() {
          var r = 0.5 / (Math.PI * fi.R);
          return Za(r, 0.5, -r, 0.5);
        }()
      }), ur = h({}, ma, {
        code: "EPSG:900913"
      });
      function cr(r) {
        return document.createElementNS("http://www.w3.org/2000/svg", r);
      }
      function Tn(r, d) {
        var v = "", w, O, H, q, $, rt;
        for (w = 0, H = r.length; w < H; w++) {
          for ($ = r[w], O = 0, q = $.length; O < q; O++)
            rt = $[O], v += (O ? "L" : "M") + rt.x + " " + rt.y;
          v += d ? It.svg ? "z" : "x" : "";
        }
        return v || "M0 0";
      }
      var En = document.documentElement.style, Pa = "ActiveXObject" in window, dc = Pa && !document.addEventListener, pe = "msLaunchUri" in navigator && !("documentMode" in document), pa = ea("webkit"), vs = ea("android"), po = ea("android 2") || ea("android 3"), mc = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), hu = vs && ea("Google") && mc < 537 && !("AudioNode" in window), go = !!window.opera, Zn = !pe && ea("chrome"), ta = ea("gecko") && !pa && !go && !Pa, $n = !Zn && ea("safari"), _s = ea("phantom"), fr = "OTransition" in En, hr = navigator.platform.indexOf("Win") === 0, ga = Pa && "transition" in En, hi = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !po, Pn = "MozPerspective" in En, Va = !window.L_DISABLE_3D && (ga || hi || Pn) && !fr && !_s, N = typeof orientation < "u" || ea("mobile"), J = N && pa, At = N && hi, kt = !window.PointerEvent && window.MSPointerEvent, Xt = !!(window.PointerEvent || kt), se = "ontouchstart" in window || !!window.TouchEvent, he = !window.L_NO_TOUCH && (se || Xt), ze = N && go, fe = N && ta, On = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, Ga = function() {
        var r = !1;
        try {
          var d = Object.defineProperty({}, "passive", {
            get: function() {
              r = !0;
            }
          });
          window.addEventListener("testPassiveEventSupport", C, d), window.removeEventListener("testPassiveEventSupport", C, d);
        } catch {
        }
        return r;
      }(), pc = function() {
        return !!document.createElement("canvas").getContext;
      }(), du = !!(document.createElementNS && cr("svg").createSVGRect), Nn = !!du && function() {
        var r = document.createElement("div");
        return r.innerHTML = "<svg/>", (r.firstChild && r.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }(), Vn = !du && function() {
        try {
          var r = document.createElement("div");
          r.innerHTML = '<v:shape adj="1"/>';
          var d = r.firstChild;
          return d.style.behavior = "url(#default#VML)", d && typeof d.adj == "object";
        } catch {
          return !1;
        }
      }(), Ei = navigator.platform.indexOf("Mac") === 0, dr = navigator.platform.indexOf("Linux") === 0;
      function ea(r) {
        return navigator.userAgent.toLowerCase().indexOf(r) >= 0;
      }
      var It = {
        ie: Pa,
        ielt9: dc,
        edge: pe,
        webkit: pa,
        android: vs,
        android23: po,
        androidStock: hu,
        opera: go,
        chrome: Zn,
        gecko: ta,
        safari: $n,
        phantom: _s,
        opera12: fr,
        win: hr,
        ie3d: ga,
        webkit3d: hi,
        gecko3d: Pn,
        any3d: Va,
        mobile: N,
        mobileWebkit: J,
        mobileWebkit3d: At,
        msPointer: kt,
        pointer: Xt,
        touch: he,
        touchNative: se,
        mobileOpera: ze,
        mobileGecko: fe,
        retina: On,
        passiveEvents: Ga,
        canvas: pc,
        svg: du,
        vml: Vn,
        inlineSvg: Nn,
        mac: Ei,
        linux: dr
      }, mu = It.msPointer ? "MSPointerDown" : "pointerdown", Df = It.msPointer ? "MSPointerMove" : "pointermove", Pt = It.msPointer ? "MSPointerUp" : "pointerup", mr = It.msPointer ? "MSPointerCancel" : "pointercancel", Un = {
        touchstart: mu,
        touchmove: Df,
        touchend: Pt,
        touchcancel: mr
      }, bl = {
        touchstart: Af,
        touchmove: bs,
        touchend: bs,
        touchcancel: bs
      }, yo = {}, vo = !1;
      function Bn(r, d, v) {
        return d === "touchstart" && bd(), bl[d] ? (v = bl[d].bind(this, v), r.addEventListener(Un[d], v, !1), v) : (console.warn("wrong event specified:", d), C);
      }
      function pu(r, d, v) {
        if (!Un[d]) {
          console.warn("wrong event specified:", d);
          return;
        }
        r.removeEventListener(Un[d], v, !1);
      }
      function na(r) {
        yo[r.pointerId] = r;
      }
      function Sl(r) {
        yo[r.pointerId] && (yo[r.pointerId] = r);
      }
      function Wo(r) {
        delete yo[r.pointerId];
      }
      function bd() {
        vo || (document.addEventListener(mu, na, !0), document.addEventListener(Df, Sl, !0), document.addEventListener(Pt, Wo, !0), document.addEventListener(mr, Wo, !0), vo = !0);
      }
      function bs(r, d) {
        if (d.pointerType !== (d.MSPOINTER_TYPE_MOUSE || "mouse")) {
          d.touches = [];
          for (var v in yo)
            d.touches.push(yo[v]);
          d.changedTouches = [d], r(d);
        }
      }
      function Af(r, d) {
        d.MSPOINTER_TYPE_TOUCH && d.pointerType === d.MSPOINTER_TYPE_TOUCH && Ue(d), bs(r, d);
      }
      function Sd(r) {
        var d = {}, v, w;
        for (w in r)
          v = r[w], d[w] = v && v.bind ? v.bind(r) : v;
        return r = d, d.type = "dblclick", d.detail = 2, d.isTrusted = !1, d._simulated = !0, d;
      }
      var Io = 200;
      function gu(r, d) {
        r.addEventListener("dblclick", d);
        var v = 0, w;
        function O(H) {
          if (H.detail !== 1) {
            w = H.detail;
            return;
          }
          if (!(H.pointerType === "mouse" || H.sourceCapabilities && !H.sourceCapabilities.firesTouchEvents)) {
            var q = vu(H);
            if (!(q.some(function(rt) {
              return rt instanceof HTMLLabelElement && rt.attributes.for;
            }) && !q.some(function(rt) {
              return rt instanceof HTMLInputElement || rt instanceof HTMLSelectElement;
            }))) {
              var $ = Date.now();
              $ - v <= Io ? (w++, w === 2 && d(Sd(H))) : w = 1, v = $;
            }
          }
        }
        return r.addEventListener("click", O), {
          dblclick: d,
          simDblclick: O
        };
      }
      function _o(r, d) {
        r.removeEventListener("dblclick", d.dblclick), r.removeEventListener("click", d.simDblclick);
      }
      var pr = wl(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      ), Ss = wl(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      ), Tl = Ss === "webkitTransition" || Ss === "OTransition" ? Ss + "End" : "transitionend";
      function di(r) {
        return typeof r == "string" ? document.getElementById(r) : r;
      }
      function ya(r, d) {
        var v = r.style[d] || r.currentStyle && r.currentStyle[d];
        if ((!v || v === "auto") && document.defaultView) {
          var w = document.defaultView.getComputedStyle(r, null);
          v = w ? w[d] : null;
        }
        return v === "auto" ? null : v;
      }
      function we(r, d, v) {
        var w = document.createElement(r);
        return w.className = d || "", v && v.appendChild(w), w;
      }
      function ln(r) {
        var d = r.parentNode;
        d && d.removeChild(r);
      }
      function Yn(r) {
        for (; r.firstChild; )
          r.removeChild(r.firstChild);
      }
      function bo(r) {
        var d = r.parentNode;
        d && d.lastChild !== r && d.appendChild(r);
      }
      function xl(r) {
        var d = r.parentNode;
        d && d.firstChild !== r && d.insertBefore(r, d.firstChild);
      }
      function So(r, d) {
        if (r.classList !== void 0)
          return r.classList.contains(d);
        var v = Oi(r);
        return v.length > 0 && new RegExp("(^|\\s)" + d + "(\\s|$)").test(v);
      }
      function le(r, d) {
        if (r.classList !== void 0)
          for (var v = I(d), w = 0, O = v.length; w < O; w++)
            r.classList.add(v[w]);
        else if (!So(r, d)) {
          var H = Oi(r);
          Rf(r, (H ? H + " " : "") + d);
        }
      }
      function Fe(r, d) {
        r.classList !== void 0 ? r.classList.remove(d) : Rf(r, j((" " + Oi(r) + " ").replace(" " + d + " ", " ")));
      }
      function Rf(r, d) {
        r.className.baseVal === void 0 ? r.className = d : r.className.baseVal = d;
      }
      function Oi(r) {
        return r.correspondingElement && (r = r.correspondingElement), r.className.baseVal === void 0 ? r.className : r.className.baseVal;
      }
      function Di(r, d) {
        "opacity" in r.style ? r.style.opacity = d : "filter" in r.style && gc(r, d);
      }
      function gc(r, d) {
        var v = !1, w = "DXImageTransform.Microsoft.Alpha";
        try {
          v = r.filters.item(w);
        } catch {
          if (d === 1)
            return;
        }
        d = Math.round(d * 100), v ? (v.Enabled = d !== 100, v.Opacity = d) : r.style.filter += " progid:" + w + "(opacity=" + d + ")";
      }
      function wl(r) {
        for (var d = document.documentElement.style, v = 0; v < r.length; v++)
          if (r[v] in d)
            return r[v];
        return !1;
      }
      function ia(r, d, v) {
        var w = d || new ut(0, 0);
        r.style[pr] = (It.ie3d ? "translate(" + w.x + "px," + w.y + "px)" : "translate3d(" + w.x + "px," + w.y + "px,0)") + (v ? " scale(" + v + ")" : "");
      }
      function yn(r, d) {
        r._leaflet_pos = d, It.any3d ? ia(r, d) : (r.style.left = d.x + "px", r.style.top = d.y + "px");
      }
      function $o(r) {
        return r._leaflet_pos || new ut(0, 0);
      }
      var To, gr, yr;
      if ("onselectstart" in document)
        To = function() {
          ce(window, "selectstart", Ue);
        }, gr = function() {
          Ye(window, "selectstart", Ue);
        };
      else {
        var Jo = wl(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        To = function() {
          if (Jo) {
            var r = document.documentElement.style;
            yr = r[Jo], r[Jo] = "none";
          }
        }, gr = function() {
          Jo && (document.documentElement.style[Jo] = yr, yr = void 0);
        };
      }
      function Fo() {
        ce(window, "dragstart", Ue);
      }
      function Cf() {
        Ye(window, "dragstart", Ue);
      }
      var yu, Ts;
      function tl(r) {
        for (; r.tabIndex === -1; )
          r = r.parentNode;
        r.style && (xs(), yu = r, Ts = r.style.outlineStyle, r.style.outlineStyle = "none", ce(window, "keydown", xs));
      }
      function xs() {
        yu && (yu.style.outlineStyle = Ts, yu = void 0, Ts = void 0, Ye(window, "keydown", xs));
      }
      function ws(r) {
        do
          r = r.parentNode;
        while ((!r.offsetWidth || !r.offsetHeight) && r !== document.body);
        return r;
      }
      function Ml(r) {
        var d = r.getBoundingClientRect();
        return {
          x: d.width / r.offsetWidth || 1,
          y: d.height / r.offsetHeight || 1,
          boundingClientRect: d
        };
      }
      var Td = {
        __proto__: null,
        TRANSFORM: pr,
        TRANSITION: Ss,
        TRANSITION_END: Tl,
        get: di,
        getStyle: ya,
        create: we,
        remove: ln,
        empty: Yn,
        toFront: bo,
        toBack: xl,
        hasClass: So,
        addClass: le,
        removeClass: Fe,
        setClass: Rf,
        getClass: Oi,
        setOpacity: Di,
        testProp: wl,
        setTransform: ia,
        setPosition: yn,
        getPosition: $o,
        get disableTextSelection() {
          return To;
        },
        get enableTextSelection() {
          return gr;
        },
        disableImageDrag: Fo,
        enableImageDrag: Cf,
        preventOutline: tl,
        restoreOutline: xs,
        getSizedParentNode: ws,
        getScale: Ml
      };
      function ce(r, d, v, w) {
        if (d && typeof d == "object")
          for (var O in d)
            Qa(r, O, d[O], v);
        else {
          d = I(d);
          for (var H = 0, q = d.length; H < q; H++)
            Qa(r, d[H], v, w);
        }
        return this;
      }
      var Ai = "_leaflet_events";
      function Ye(r, d, v, w) {
        if (arguments.length === 1)
          Xa(r), delete r[Ai];
        else if (d && typeof d == "object")
          for (var O in d)
            Ka(r, O, d[O], v);
        else if (d = I(d), arguments.length === 2)
          Xa(r, function($) {
            return zt(d, $) !== -1;
          });
        else
          for (var H = 0, q = d.length; H < q; H++)
            Ka(r, d[H], v, w);
        return this;
      }
      function Xa(r, d) {
        for (var v in r[Ai]) {
          var w = v.split(/\d/)[0];
          (!d || d(w)) && Ka(r, w, null, null, v);
        }
      }
      var vr = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function Qa(r, d, v, w) {
        var O = d + T(v) + (w ? "_" + T(w) : "");
        if (r[Ai] && r[Ai][O])
          return this;
        var H = function($) {
          return v.call(w || r, $ || window.event);
        }, q = H;
        !It.touchNative && It.pointer && d.indexOf("touch") === 0 ? H = Bn(r, d, H) : It.touch && d === "dblclick" ? H = gu(r, H) : "addEventListener" in r ? d === "touchstart" || d === "touchmove" || d === "wheel" || d === "mousewheel" ? r.addEventListener(vr[d] || d, H, It.passiveEvents ? { passive: !1 } : !1) : d === "mouseenter" || d === "mouseleave" ? (H = function($) {
          $ = $ || window.event, Es(r, $) && q($);
        }, r.addEventListener(vr[d], H, !1)) : r.addEventListener(d, q, !1) : r.attachEvent("on" + d, H), r[Ai] = r[Ai] || {}, r[Ai][O] = H;
      }
      function Ka(r, d, v, w, O) {
        O = O || d + T(v) + (w ? "_" + T(w) : "");
        var H = r[Ai] && r[Ai][O];
        if (!H)
          return this;
        !It.touchNative && It.pointer && d.indexOf("touch") === 0 ? pu(r, d, H) : It.touch && d === "dblclick" ? _o(r, H) : "removeEventListener" in r ? r.removeEventListener(vr[d] || d, H, !1) : r.detachEvent("on" + d, H), r[Ai][O] = null;
      }
      function va(r) {
        return r.stopPropagation ? r.stopPropagation() : r.originalEvent ? r.originalEvent._stopped = !0 : r.cancelBubble = !0, this;
      }
      function el(r) {
        return Qa(r, "wheel", va), this;
      }
      function Ms(r) {
        return ce(r, "mousedown touchstart dblclick contextmenu", va), r._leaflet_disable_click = !0, this;
      }
      function Ue(r) {
        return r.preventDefault ? r.preventDefault() : r.returnValue = !1, this;
      }
      function xo(r) {
        return Ue(r), va(r), this;
      }
      function vu(r) {
        if (r.composedPath)
          return r.composedPath();
        for (var d = [], v = r.target; v; )
          d.push(v), v = v.parentNode;
        return d;
      }
      function mi(r, d) {
        if (!d)
          return new ut(r.clientX, r.clientY);
        var v = Ml(d), w = v.boundingClientRect;
        return new ut(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (r.clientX - w.left) / v.x - d.clientLeft,
          (r.clientY - w.top) / v.y - d.clientTop
        );
      }
      var El = It.linux && It.chrome ? window.devicePixelRatio : It.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function _u(r) {
        return It.edge ? r.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          r.deltaY && r.deltaMode === 0 ? -r.deltaY / El : (
            // Pixels
            r.deltaY && r.deltaMode === 1 ? -r.deltaY * 20 : (
              // Lines
              r.deltaY && r.deltaMode === 2 ? -r.deltaY * 60 : (
                // Pages
                r.deltaX || r.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  r.wheelDelta ? (r.wheelDeltaY || r.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    r.detail && Math.abs(r.detail) < 32765 ? -r.detail * 20 : (
                      // Legacy Moz lines
                      r.detail ? r.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function Es(r, d) {
        var v = d.relatedTarget;
        if (!v)
          return !0;
        try {
          for (; v && v !== r; )
            v = v.parentNode;
        } catch {
          return !1;
        }
        return v !== r;
      }
      var xd = {
        __proto__: null,
        on: ce,
        off: Ye,
        stopPropagation: va,
        disableScrollPropagation: el,
        disableClickPropagation: Ms,
        preventDefault: Ue,
        stop: xo,
        getPropagationPath: vu,
        getMousePosition: mi,
        getWheelDelta: _u,
        isExternalTarget: Es,
        addListener: ce,
        removeListener: Ye
      }, yc = mt.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(r, d, v, w) {
          this.stop(), this._el = r, this._inProgress = !0, this._duration = v || 0.25, this._easeOutPower = 1 / Math.max(w || 0.5, 0.2), this._startPos = $o(r), this._offset = d.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          this._inProgress && (this._step(!0), this._complete());
        },
        _animate: function() {
          this._animId = Rt(this._animate, this), this._step();
        },
        _step: function(r) {
          var d = +/* @__PURE__ */ new Date() - this._startTime, v = this._duration * 1e3;
          d < v ? this._runFrame(this._easeOut(d / v), r) : (this._runFrame(1), this._complete());
        },
        _runFrame: function(r, d) {
          var v = this._startPos.add(this._offset.multiplyBy(r));
          d && v._round(), yn(this._el, v), this.fire("step");
        },
        _complete: function() {
          Nt(this._animId), this._inProgress = !1, this.fire("end");
        },
        _easeOut: function(r) {
          return 1 - Math.pow(1 - r, this._easeOutPower);
        }
      }), Oe = mt.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: ma,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: !0,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: !0,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: !0,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: !0
        },
        initialize: function(r, d) {
          d = Q(this, d), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(r), this._initLayout(), this._onResize = _(this._onResize, this), this._initEvents(), d.maxBounds && this.setMaxBounds(d.maxBounds), d.zoom !== void 0 && (this._zoom = this._limitZoom(d.zoom)), d.center && d.zoom !== void 0 && this.setView(Tt(d.center), d.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = Ss && It.any3d && !It.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), ce(this._proxy, Tl, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(r, d, v) {
          if (d = d === void 0 ? this._zoom : this._limitZoom(d), r = this._limitCenter(Tt(r), d, this.options.maxBounds), v = v || {}, this._stop(), this._loaded && !v.reset && v !== !0) {
            v.animate !== void 0 && (v.zoom = h({ animate: v.animate }, v.zoom), v.pan = h({ animate: v.animate, duration: v.duration }, v.pan));
            var w = this._zoom !== d ? this._tryAnimatedZoom && this._tryAnimatedZoom(r, d, v.zoom) : this._tryAnimatedPan(r, v.pan);
            if (w)
              return clearTimeout(this._sizeTimer), this;
          }
          return this._resetView(r, d, v.pan && v.pan.noMoveStart), this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(r, d) {
          return this._loaded ? this.setView(this.getCenter(), r, { zoom: d }) : (this._zoom = r, this);
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(r, d) {
          return r = r || (It.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + r, d);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(r, d) {
          return r = r || (It.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - r, d);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(r, d, v) {
          var w = this.getZoomScale(d), O = this.getSize().divideBy(2), H = r instanceof ut ? r : this.latLngToContainerPoint(r), q = H.subtract(O).multiplyBy(1 - 1 / w), $ = this.containerPointToLatLng(O.add(q));
          return this.setView($, d, { zoom: v });
        },
        _getBoundsCenterZoom: function(r, d) {
          d = d || {}, r = r.getBounds ? r.getBounds() : Mt(r);
          var v = k(d.paddingTopLeft || d.padding || [0, 0]), w = k(d.paddingBottomRight || d.padding || [0, 0]), O = this.getBoundsZoom(r, !1, v.add(w));
          if (O = typeof d.maxZoom == "number" ? Math.min(d.maxZoom, O) : O, O === 1 / 0)
            return {
              center: r.getCenter(),
              zoom: O
            };
          var H = w.subtract(v).divideBy(2), q = this.project(r.getSouthWest(), O), $ = this.project(r.getNorthEast(), O), rt = this.unproject(q.add($).divideBy(2).add(H), O);
          return {
            center: rt,
            zoom: O
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(r, d) {
          if (r = Mt(r), !r.isValid())
            throw new Error("Bounds are not valid.");
          var v = this._getBoundsCenterZoom(r, d);
          return this.setView(v.center, v.zoom, d);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(r) {
          return this.fitBounds([[-90, -180], [90, 180]], r);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(r, d) {
          return this.setView(r, this._zoom, { pan: d });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(r, d) {
          if (r = k(r).round(), d = d || {}, !r.x && !r.y)
            return this.fire("moveend");
          if (d.animate !== !0 && !this.getSize().contains(r))
            return this._resetView(this.unproject(this.project(this.getCenter()).add(r)), this.getZoom()), this;
          if (this._panAnim || (this._panAnim = new yc(), this._panAnim.on({
            step: this._onPanTransitionStep,
            end: this._onPanTransitionEnd
          }, this)), d.noMoveStart || this.fire("movestart"), d.animate !== !1) {
            le(this._mapPane, "leaflet-pan-anim");
            var v = this._getMapPanePos().subtract(r).round();
            this._panAnim.run(this._mapPane, v, d.duration || 0.25, d.easeLinearity);
          } else
            this._rawPanBy(r), this.fire("move").fire("moveend");
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(r, d, v) {
          if (v = v || {}, v.animate === !1 || !It.any3d)
            return this.setView(r, d, v);
          this._stop();
          var w = this.project(this.getCenter()), O = this.project(r), H = this.getSize(), q = this._zoom;
          r = Tt(r), d = d === void 0 ? q : d;
          var $ = Math.max(H.x, H.y), rt = $ * this.getZoomScale(q, d), xt = O.distanceTo(w) || 1, Ut = 1.42, qt = Ut * Ut;
          function Zt(fn) {
            var Ea = fn ? -1 : 1, eo = fn ? rt : $, cl = rt * rt - $ * $ + Ea * qt * qt * xt * xt, Ho = 2 * eo * qt * xt, Or = cl / Ho, Mc = Math.sqrt(Or * Or + 1) - Or, Dr = Mc < 1e-9 ? -18 : Math.log(Mc);
            return Dr;
          }
          function oe(fn) {
            return (Math.exp(fn) - Math.exp(-fn)) / 2;
          }
          function Ge(fn) {
            return (Math.exp(fn) + Math.exp(-fn)) / 2;
          }
          function dn(fn) {
            return oe(fn) / Ge(fn);
          }
          var Dn = Zt(0);
          function Gi(fn) {
            return $ * (Ge(Dn) / Ge(Dn + Ut * fn));
          }
          function xu(fn) {
            return $ * (Ge(Dn) * dn(Dn + Ut * fn) - oe(Dn)) / qt;
          }
          function Vf(fn) {
            return 1 - Math.pow(1 - fn, 1.5);
          }
          var Er = Date.now(), Bs = (Zt(1) - Dn) / Ut, Gf = v.duration ? 1e3 * v.duration : 1e3 * Bs * 0.8;
          function Ys() {
            var fn = (Date.now() - Er) / Gf, Ea = Vf(fn) * Bs;
            fn <= 1 ? (this._flyToFrame = Rt(Ys, this), this._move(
              this.unproject(w.add(O.subtract(w).multiplyBy(xu(Ea) / xt)), q),
              this.getScaleZoom($ / Gi(Ea), q),
              { flyTo: !0 }
            )) : this._move(r, d)._moveEnd(!0);
          }
          return this._moveStart(!0, v.noMoveStart), Ys.call(this), this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(r, d) {
          var v = this._getBoundsCenterZoom(r, d);
          return this.flyTo(v.center, v.zoom, d);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(r) {
          return r = Mt(r), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), r.isValid() ? (this.options.maxBounds = r, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(r) {
          var d = this.options.minZoom;
          return this.options.minZoom = r, this._loaded && d !== r && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(r) : this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(r) {
          var d = this.options.maxZoom;
          return this.options.maxZoom = r, this._loaded && d !== r && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(r) : this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(r, d) {
          this._enforcingBounds = !0;
          var v = this.getCenter(), w = this._limitCenter(v, this._zoom, Mt(r));
          return v.equals(w) || this.panTo(w, d), this._enforcingBounds = !1, this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(r, d) {
          d = d || {};
          var v = k(d.paddingTopLeft || d.padding || [0, 0]), w = k(d.paddingBottomRight || d.padding || [0, 0]), O = this.project(this.getCenter()), H = this.project(r), q = this.getPixelBounds(), $ = ct([q.min.add(v), q.max.subtract(w)]), rt = $.getSize();
          if (!$.contains(H)) {
            this._enforcingBounds = !0;
            var xt = H.subtract($.getCenter()), Ut = $.extend(H).getSize().subtract(rt);
            O.x += xt.x < 0 ? -Ut.x : Ut.x, O.y += xt.y < 0 ? -Ut.y : Ut.y, this.panTo(this.unproject(O), d), this._enforcingBounds = !1;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(r) {
          if (!this._loaded)
            return this;
          r = h({
            animate: !1,
            pan: !0
          }, r === !0 ? { animate: !0 } : r);
          var d = this.getSize();
          this._sizeChanged = !0, this._lastCenter = null;
          var v = this.getSize(), w = d.divideBy(2).round(), O = v.divideBy(2).round(), H = w.subtract(O);
          return !H.x && !H.y ? this : (r.animate && r.pan ? this.panBy(H) : (r.pan && this._rawPanBy(H), this.fire("move"), r.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(_(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
            oldSize: d,
            newSize: v
          }));
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(r) {
          if (r = this._locateOptions = h({
            timeout: 1e4,
            watch: !1
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, r), !("geolocation" in navigator))
            return this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            }), this;
          var d = _(this._handleGeolocationResponse, this), v = _(this._handleGeolocationError, this);
          return r.watch ? this._locationWatchId = navigator.geolocation.watchPosition(d, v, r) : navigator.geolocation.getCurrentPosition(d, v, r), this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;
        },
        _handleGeolocationError: function(r) {
          if (this._container._leaflet_id) {
            var d = r.code, v = r.message || (d === 1 ? "permission denied" : d === 2 ? "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
              code: d,
              message: "Geolocation error: " + v + "."
            });
          }
        },
        _handleGeolocationResponse: function(r) {
          if (this._container._leaflet_id) {
            var d = r.coords.latitude, v = r.coords.longitude, w = new Ht(d, v), O = w.toBounds(r.coords.accuracy * 2), H = this._locateOptions;
            if (H.setView) {
              var q = this.getBoundsZoom(O);
              this.setView(w, H.maxZoom ? Math.min(q, H.maxZoom) : q);
            }
            var $ = {
              latlng: w,
              bounds: O,
              timestamp: r.timestamp
            };
            for (var rt in r.coords)
              typeof r.coords[rt] == "number" && ($[rt] = r.coords[rt]);
            this.fire("locationfound", $);
          }
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(r, d) {
          if (!d)
            return this;
          var v = this[r] = new d(this);
          return this._handlers.push(v), this.options[r] && v.enable(), this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id)
            throw new Error("Map container is being reused by another instance");
          try {
            delete this._container._leaflet_id, delete this._containerId;
          } catch {
            this._container._leaflet_id = void 0, this._containerId = void 0;
          }
          this._locationWatchId !== void 0 && this.stopLocate(), this._stop(), ln(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (Nt(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload");
          var r;
          for (r in this._layers)
            this._layers[r].remove();
          for (r in this._panes)
            ln(this._panes[r]);
          return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(r, d) {
          var v = "leaflet-pane" + (r ? " leaflet-" + r.replace("Pane", "") + "-pane" : ""), w = we("div", v, d || this._mapPane);
          return r && (this._panes[r] = w), w;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var r = this.getPixelBounds(), d = this.unproject(r.getBottomLeft()), v = this.unproject(r.getTopRight());
          return new bt(d, v);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(r, d, v) {
          r = Mt(r), v = k(v || [0, 0]);
          var w = this.getZoom() || 0, O = this.getMinZoom(), H = this.getMaxZoom(), q = r.getNorthWest(), $ = r.getSouthEast(), rt = this.getSize().subtract(v), xt = ct(this.project($, w), this.project(q, w)).getSize(), Ut = It.any3d ? this.options.zoomSnap : 1, qt = rt.x / xt.x, Zt = rt.y / xt.y, oe = d ? Math.max(qt, Zt) : Math.min(qt, Zt);
          return w = this.getScaleZoom(oe, w), Ut && (w = Math.round(w / (Ut / 100)) * (Ut / 100), w = d ? Math.ceil(w / Ut) * Ut : Math.floor(w / Ut) * Ut), Math.max(O, Math.min(H, w));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          return (!this._size || this._sizeChanged) && (this._size = new ut(
            this._container.clientWidth || 0,
            this._container.clientHeight || 0
          ), this._sizeChanged = !1), this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(r, d) {
          var v = this._getTopLeftPoint(r, d);
          return new F(v, v.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          return this._checkIfLoaded(), this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(r) {
          return this.options.crs.getProjectedBounds(r === void 0 ? this.getZoom() : r);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(r) {
          return typeof r == "string" ? this._panes[r] : r;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(r, d) {
          var v = this.options.crs;
          return d = d === void 0 ? this._zoom : d, v.scale(r) / v.scale(d);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(r, d) {
          var v = this.options.crs;
          d = d === void 0 ? this._zoom : d;
          var w = v.zoom(r * v.scale(d));
          return isNaN(w) ? 1 / 0 : w;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(r, d) {
          return d = d === void 0 ? this._zoom : d, this.options.crs.latLngToPoint(Tt(r), d);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(r, d) {
          return d = d === void 0 ? this._zoom : d, this.options.crs.pointToLatLng(k(r), d);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(r) {
          var d = k(r).add(this.getPixelOrigin());
          return this.unproject(d);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(r) {
          var d = this.project(Tt(r))._round();
          return d._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(r) {
          return this.options.crs.wrapLatLng(Tt(r));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(r) {
          return this.options.crs.wrapLatLngBounds(Mt(r));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(r, d) {
          return this.options.crs.distance(Tt(r), Tt(d));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(r) {
          return k(r).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(r) {
          return k(r).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(r) {
          var d = this.containerPointToLayerPoint(k(r));
          return this.layerPointToLatLng(d);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(r) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(Tt(r)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(r) {
          return mi(r, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(r) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(r));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(r) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(r));
        },
        // map initialization methods
        _initContainer: function(r) {
          var d = this._container = di(r);
          if (d) {
            if (d._leaflet_id)
              throw new Error("Map container is already initialized.");
          } else throw new Error("Map container not found.");
          ce(d, "scroll", this._onScroll, this), this._containerId = T(d);
        },
        _initLayout: function() {
          var r = this._container;
          this._fadeAnimated = this.options.fadeAnimation && It.any3d, le(r, "leaflet-container" + (It.touch ? " leaflet-touch" : "") + (It.retina ? " leaflet-retina" : "") + (It.ielt9 ? " leaflet-oldie" : "") + (It.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var d = ya(r, "position");
          d !== "absolute" && d !== "relative" && d !== "fixed" && d !== "sticky" && (r.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
        },
        _initPanes: function() {
          var r = this._panes = {};
          this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), yn(this._mapPane, new ut(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (le(r.markerPane, "leaflet-zoom-hide"), le(r.shadowPane, "leaflet-zoom-hide"));
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(r, d, v) {
          yn(this._mapPane, new ut(0, 0));
          var w = !this._loaded;
          this._loaded = !0, d = this._limitZoom(d), this.fire("viewprereset");
          var O = this._zoom !== d;
          this._moveStart(O, v)._move(r, d)._moveEnd(O), this.fire("viewreset"), w && this.fire("load");
        },
        _moveStart: function(r, d) {
          return r && this.fire("zoomstart"), d || this.fire("movestart"), this;
        },
        _move: function(r, d, v, w) {
          d === void 0 && (d = this._zoom);
          var O = this._zoom !== d;
          return this._zoom = d, this._lastCenter = r, this._pixelOrigin = this._getNewPixelOrigin(r), w ? v && v.pinch && this.fire("zoom", v) : ((O || v && v.pinch) && this.fire("zoom", v), this.fire("move", v)), this;
        },
        _moveEnd: function(r) {
          return r && this.fire("zoomend"), this.fire("moveend");
        },
        _stop: function() {
          return Nt(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
        },
        _rawPanBy: function(r) {
          yn(this._mapPane, this._getMapPanePos().subtract(r));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
        },
        _checkIfLoaded: function() {
          if (!this._loaded)
            throw new Error("Set map center and zoom first.");
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(r) {
          this._targets = {}, this._targets[T(this._container)] = this;
          var d = r ? Ye : ce;
          d(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && d(window, "resize", this._onResize, this), It.any3d && this.options.transform3DLimit && (r ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
        },
        _onResize: function() {
          Nt(this._resizeRequest), this._resizeRequest = Rt(
            function() {
              this.invalidateSize({ debounceMoveend: !0 });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0, this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var r = this._getMapPanePos();
          Math.max(Math.abs(r.x), Math.abs(r.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
        },
        _findEventTargets: function(r, d) {
          for (var v = [], w, O = d === "mouseout" || d === "mouseover", H = r.target || r.srcElement, q = !1; H; ) {
            if (w = this._targets[T(H)], w && (d === "click" || d === "preclick") && this._draggableMoved(w)) {
              q = !0;
              break;
            }
            if (w && w.listens(d, !0) && (O && !Es(H, r) || (v.push(w), O)) || H === this._container)
              break;
            H = H.parentNode;
          }
          return !v.length && !q && !O && this.listens(d, !0) && (v = [this]), v;
        },
        _isClickDisabled: function(r) {
          for (; r && r !== this._container; ) {
            if (r._leaflet_disable_click)
              return !0;
            r = r.parentNode;
          }
        },
        _handleDOMEvent: function(r) {
          var d = r.target || r.srcElement;
          if (!(!this._loaded || d._leaflet_disable_events || r.type === "click" && this._isClickDisabled(d))) {
            var v = r.type;
            v === "mousedown" && tl(d), this._fireDOMEvent(r, v);
          }
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(r, d, v) {
          if (r.type === "click") {
            var w = h({}, r);
            w.type = "preclick", this._fireDOMEvent(w, w.type, v);
          }
          var O = this._findEventTargets(r, d);
          if (v) {
            for (var H = [], q = 0; q < v.length; q++)
              v[q].listens(d, !0) && H.push(v[q]);
            O = H.concat(O);
          }
          if (O.length) {
            d === "contextmenu" && Ue(r);
            var $ = O[0], rt = {
              originalEvent: r
            };
            if (r.type !== "keypress" && r.type !== "keydown" && r.type !== "keyup") {
              var xt = $.getLatLng && (!$._radius || $._radius <= 10);
              rt.containerPoint = xt ? this.latLngToContainerPoint($.getLatLng()) : this.mouseEventToContainerPoint(r), rt.layerPoint = this.containerPointToLayerPoint(rt.containerPoint), rt.latlng = xt ? $.getLatLng() : this.layerPointToLatLng(rt.layerPoint);
            }
            for (q = 0; q < O.length; q++)
              if (O[q].fire(d, rt, !0), rt.originalEvent._stopped || O[q].options.bubblingMouseEvents === !1 && zt(this._mouseEvents, d) !== -1)
                return;
          }
        },
        _draggableMoved: function(r) {
          return r = r.dragging && r.dragging.enabled() ? r : this, r.dragging && r.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var r = 0, d = this._handlers.length; r < d; r++)
            this._handlers[r].disable();
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(r, d) {
          return this._loaded ? r.call(d || this, { target: this }) : this.on("load", r, d), this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return $o(this._mapPane) || new ut(0, 0);
        },
        _moved: function() {
          var r = this._getMapPanePos();
          return r && !r.equals([0, 0]);
        },
        _getTopLeftPoint: function(r, d) {
          var v = r && d !== void 0 ? this._getNewPixelOrigin(r, d) : this.getPixelOrigin();
          return v.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(r, d) {
          var v = this.getSize()._divideBy(2);
          return this.project(r, d)._subtract(v)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(r, d, v) {
          var w = this._getNewPixelOrigin(v, d);
          return this.project(r, d)._subtract(w);
        },
        _latLngBoundsToNewLayerBounds: function(r, d, v) {
          var w = this._getNewPixelOrigin(v, d);
          return ct([
            this.project(r.getSouthWest(), d)._subtract(w),
            this.project(r.getNorthWest(), d)._subtract(w),
            this.project(r.getSouthEast(), d)._subtract(w),
            this.project(r.getNorthEast(), d)._subtract(w)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(r) {
          return this.latLngToLayerPoint(r).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(r, d, v) {
          if (!v)
            return r;
          var w = this.project(r, d), O = this.getSize().divideBy(2), H = new F(w.subtract(O), w.add(O)), q = this._getBoundsOffset(H, v, d);
          return Math.abs(q.x) <= 1 && Math.abs(q.y) <= 1 ? r : this.unproject(w.add(q), d);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(r, d) {
          if (!d)
            return r;
          var v = this.getPixelBounds(), w = new F(v.min.add(r), v.max.add(r));
          return r.add(this._getBoundsOffset(w, d));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(r, d, v) {
          var w = ct(
            this.project(d.getNorthEast(), v),
            this.project(d.getSouthWest(), v)
          ), O = w.min.subtract(r.min), H = w.max.subtract(r.max), q = this._rebound(O.x, -H.x), $ = this._rebound(O.y, -H.y);
          return new ut(q, $);
        },
        _rebound: function(r, d) {
          return r + d > 0 ? Math.round(r - d) / 2 : Math.max(0, Math.ceil(r)) - Math.max(0, Math.floor(d));
        },
        _limitZoom: function(r) {
          var d = this.getMinZoom(), v = this.getMaxZoom(), w = It.any3d ? this.options.zoomSnap : 1;
          return w && (r = Math.round(r / w) * w), Math.max(d, Math.min(v, r));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          Fe(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
        },
        _tryAnimatedPan: function(r, d) {
          var v = this._getCenterOffset(r)._trunc();
          return (d && d.animate) !== !0 && !this.getSize().contains(v) ? !1 : (this.panBy(v, d), !0);
        },
        _createAnimProxy: function() {
          var r = this._proxy = we("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(r), this.on("zoomanim", function(d) {
            var v = pr, w = this._proxy.style[v];
            ia(this._proxy, this.project(d.center, d.zoom), this.getZoomScale(d.zoom, 1)), w === this._proxy.style[v] && this._animatingZoom && this._onZoomTransitionEnd();
          }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          ln(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
        },
        _animMoveEnd: function() {
          var r = this.getCenter(), d = this.getZoom();
          ia(this._proxy, this.project(r, d), this.getZoomScale(d, 1));
        },
        _catchTransitionEnd: function(r) {
          this._animatingZoom && r.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(r, d, v) {
          if (this._animatingZoom)
            return !0;
          if (v = v || {}, !this._zoomAnimated || v.animate === !1 || this._nothingToAnimate() || Math.abs(d - this._zoom) > this.options.zoomAnimationThreshold)
            return !1;
          var w = this.getZoomScale(d), O = this._getCenterOffset(r)._divideBy(1 - 1 / w);
          return v.animate !== !0 && !this.getSize().contains(O) ? !1 : (Rt(function() {
            this._moveStart(!0, v.noMoveStart || !1)._animateZoom(r, d, !0);
          }, this), !0);
        },
        _animateZoom: function(r, d, v, w) {
          this._mapPane && (v && (this._animatingZoom = !0, this._animateToCenter = r, this._animateToZoom = d, le(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
            center: r,
            zoom: d,
            noUpdate: w
          }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(_(this._onZoomTransitionEnd, this), 250));
        },
        _onZoomTransitionEnd: function() {
          this._animatingZoom && (this._mapPane && Fe(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0));
        }
      });
      function bu(r, d) {
        return new Oe(r, d);
      }
      var Jn = ge.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(r) {
          Q(this, r);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(r) {
          var d = this._map;
          return d && d.removeControl(this), this.options.position = r, d && d.addControl(this), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(r) {
          this.remove(), this._map = r;
          var d = this._container = this.onAdd(r), v = this.getPosition(), w = r._controlCorners[v];
          return le(d, "leaflet-control"), v.indexOf("bottom") !== -1 ? w.insertBefore(d, w.firstChild) : w.appendChild(d), this._map.on("unload", this.remove, this), this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          return this._map ? (ln(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null, this) : this;
        },
        _refocusOnMap: function(r) {
          this._map && r && r.screenX > 0 && r.screenY > 0 && this._map.getContainer().focus();
        }
      }), Os = function(r) {
        return new Jn(r);
      };
      Oe.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(r) {
          return r.addTo(this), this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(r) {
          return r.remove(), this;
        },
        _initControlPos: function() {
          var r = this._controlCorners = {}, d = "leaflet-", v = this._controlContainer = we("div", d + "control-container", this._container);
          function w(O, H) {
            var q = d + O + " " + d + H;
            r[O + H] = we("div", q, v);
          }
          w("top", "left"), w("top", "right"), w("bottom", "left"), w("bottom", "right");
        },
        _clearControlPos: function() {
          for (var r in this._controlCorners)
            ln(this._controlCorners[r]);
          ln(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
        }
      });
      var zf = Jn.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: !0,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: !0,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: !1,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: !1,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(r, d, v, w) {
            return v < w ? -1 : w < v ? 1 : 0;
          }
        },
        initialize: function(r, d, v) {
          Q(this, v), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1;
          for (var w in r)
            this._addLayer(r[w], w);
          for (w in d)
            this._addLayer(d[w], w, !0);
        },
        onAdd: function(r) {
          this._initLayout(), this._update(), this._map = r, r.on("zoomend", this._checkDisabledLayers, this);
          for (var d = 0; d < this._layers.length; d++)
            this._layers[d].layer.on("add remove", this._onLayerChange, this);
          return this._container;
        },
        addTo: function(r) {
          return Jn.prototype.addTo.call(this, r), this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var r = 0; r < this._layers.length; r++)
            this._layers[r].layer.off("add remove", this._onLayerChange, this);
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(r, d) {
          return this._addLayer(r, d), this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(r, d) {
          return this._addLayer(r, d, !0), this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(r) {
          r.off("add remove", this._onLayerChange, this);
          var d = this._getLayer(T(r));
          return d && this._layers.splice(this._layers.indexOf(d), 1), this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          le(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
          var r = this._map.getSize().y - (this._container.offsetTop + 50);
          return r < this._section.clientHeight ? (le(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = r + "px") : Fe(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          return Fe(this._container, "leaflet-control-layers-expanded"), this;
        },
        _initLayout: function() {
          var r = "leaflet-control-layers", d = this._container = we("div", r), v = this.options.collapsed;
          d.setAttribute("aria-haspopup", !0), Ms(d), el(d);
          var w = this._section = we("section", r + "-list");
          v && (this._map.on("click", this.collapse, this), ce(d, {
            mouseenter: this._expandSafely,
            mouseleave: this.collapse
          }, this));
          var O = this._layersLink = we("a", r + "-toggle", d);
          O.href = "#", O.title = "Layers", O.setAttribute("role", "button"), ce(O, {
            keydown: function(H) {
              H.keyCode === 13 && this._expandSafely();
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(H) {
              Ue(H), this._expandSafely();
            }
          }, this), v || this.expand(), this._baseLayersList = we("div", r + "-base", w), this._separator = we("div", r + "-separator", w), this._overlaysList = we("div", r + "-overlays", w), d.appendChild(w);
        },
        _getLayer: function(r) {
          for (var d = 0; d < this._layers.length; d++)
            if (this._layers[d] && T(this._layers[d].layer) === r)
              return this._layers[d];
        },
        _addLayer: function(r, d, v) {
          this._map && r.on("add remove", this._onLayerChange, this), this._layers.push({
            layer: r,
            name: d,
            overlay: v
          }), this.options.sortLayers && this._layers.sort(_(function(w, O) {
            return this.options.sortFunction(w.layer, O.layer, w.name, O.name);
          }, this)), this.options.autoZIndex && r.setZIndex && (this._lastZIndex++, r.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container)
            return this;
          Yn(this._baseLayersList), Yn(this._overlaysList), this._layerControlInputs = [];
          var r, d, v, w, O = 0;
          for (v = 0; v < this._layers.length; v++)
            w = this._layers[v], this._addItem(w), d = d || w.overlay, r = r || !w.overlay, O += w.overlay ? 0 : 1;
          return this.options.hideSingleBase && (r = r && O > 1, this._baseLayersList.style.display = r ? "" : "none"), this._separator.style.display = d && r ? "" : "none", this;
        },
        _onLayerChange: function(r) {
          this._handlingClick || this._update();
          var d = this._getLayer(T(r.target)), v = d.overlay ? r.type === "add" ? "overlayadd" : "overlayremove" : r.type === "add" ? "baselayerchange" : null;
          v && this._map.fire(v, d);
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(r, d) {
          var v = '<input type="radio" class="leaflet-control-layers-selector" name="' + r + '"' + (d ? ' checked="checked"' : "") + "/>", w = document.createElement("div");
          return w.innerHTML = v, w.firstChild;
        },
        _addItem: function(r) {
          var d = document.createElement("label"), v = this._map.hasLayer(r.layer), w;
          r.overlay ? (w = document.createElement("input"), w.type = "checkbox", w.className = "leaflet-control-layers-selector", w.defaultChecked = v) : w = this._createRadioElement("leaflet-base-layers_" + T(this), v), this._layerControlInputs.push(w), w.layerId = T(r.layer), ce(w, "click", this._onInputClick, this);
          var O = document.createElement("span");
          O.innerHTML = " " + r.name;
          var H = document.createElement("span");
          d.appendChild(H), H.appendChild(w), H.appendChild(O);
          var q = r.overlay ? this._overlaysList : this._baseLayersList;
          return q.appendChild(d), this._checkDisabledLayers(), d;
        },
        _onInputClick: function() {
          if (!this._preventClick) {
            var r = this._layerControlInputs, d, v, w = [], O = [];
            this._handlingClick = !0;
            for (var H = r.length - 1; H >= 0; H--)
              d = r[H], v = this._getLayer(d.layerId).layer, d.checked ? w.push(v) : d.checked || O.push(v);
            for (H = 0; H < O.length; H++)
              this._map.hasLayer(O[H]) && this._map.removeLayer(O[H]);
            for (H = 0; H < w.length; H++)
              this._map.hasLayer(w[H]) || this._map.addLayer(w[H]);
            this._handlingClick = !1, this._refocusOnMap();
          }
        },
        _checkDisabledLayers: function() {
          for (var r = this._layerControlInputs, d, v, w = this._map.getZoom(), O = r.length - 1; O >= 0; O--)
            d = r[O], v = this._getLayer(d.layerId).layer, d.disabled = v.options.minZoom !== void 0 && w < v.options.minZoom || v.options.maxZoom !== void 0 && w > v.options.maxZoom;
        },
        _expandIfNotCollapsed: function() {
          return this._map && !this.options.collapsed && this.expand(), this;
        },
        _expandSafely: function() {
          var r = this._section;
          this._preventClick = !0, ce(r, "click", Ue), this.expand();
          var d = this;
          setTimeout(function() {
            Ye(r, "click", Ue), d._preventClick = !1;
          });
        }
      }), wd = function(r, d, v) {
        return new zf(r, d, v);
      }, Lf = Jn.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(r) {
          var d = "leaflet-control-zoom", v = we("div", d + " leaflet-bar"), w = this.options;
          return this._zoomInButton = this._createButton(
            w.zoomInText,
            w.zoomInTitle,
            d + "-in",
            v,
            this._zoomIn
          ), this._zoomOutButton = this._createButton(
            w.zoomOutText,
            w.zoomOutTitle,
            d + "-out",
            v,
            this._zoomOut
          ), this._updateDisabled(), r.on("zoomend zoomlevelschange", this._updateDisabled, this), v;
        },
        onRemove: function(r) {
          r.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          return this._disabled = !0, this._updateDisabled(), this;
        },
        enable: function() {
          return this._disabled = !1, this._updateDisabled(), this;
        },
        _zoomIn: function(r) {
          !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (r.shiftKey ? 3 : 1));
        },
        _zoomOut: function(r) {
          !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (r.shiftKey ? 3 : 1));
        },
        _createButton: function(r, d, v, w, O) {
          var H = we("a", v, w);
          return H.innerHTML = r, H.href = "#", H.title = d, H.setAttribute("role", "button"), H.setAttribute("aria-label", d), Ms(H), ce(H, "click", xo), ce(H, "click", O, this), ce(H, "click", this._refocusOnMap, this), H;
        },
        _updateDisabled: function() {
          var r = this._map, d = "leaflet-disabled";
          Fe(this._zoomInButton, d), Fe(this._zoomOutButton, d), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), (this._disabled || r._zoom === r.getMinZoom()) && (le(this._zoomOutButton, d), this._zoomOutButton.setAttribute("aria-disabled", "true")), (this._disabled || r._zoom === r.getMaxZoom()) && (le(this._zoomInButton, d), this._zoomInButton.setAttribute("aria-disabled", "true"));
        }
      });
      Oe.mergeOptions({
        zoomControl: !0
      }), Oe.addInitHook(function() {
        this.options.zoomControl && (this.zoomControl = new Lf(), this.addControl(this.zoomControl));
      });
      var Hf = function(r) {
        return new Lf(r);
      }, Md = Jn.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: !0,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: !0
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(r) {
          var d = "leaflet-control-scale", v = we("div", d), w = this.options;
          return this._addScales(w, d + "-line", v), r.on(w.updateWhenIdle ? "moveend" : "move", this._update, this), r.whenReady(this._update, this), v;
        },
        onRemove: function(r) {
          r.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(r, d, v) {
          r.metric && (this._mScale = we("div", d, v)), r.imperial && (this._iScale = we("div", d, v));
        },
        _update: function() {
          var r = this._map, d = r.getSize().y / 2, v = r.distance(
            r.containerPointToLatLng([0, d]),
            r.containerPointToLatLng([this.options.maxWidth, d])
          );
          this._updateScales(v);
        },
        _updateScales: function(r) {
          this.options.metric && r && this._updateMetric(r), this.options.imperial && r && this._updateImperial(r);
        },
        _updateMetric: function(r) {
          var d = this._getRoundNum(r), v = d < 1e3 ? d + " m" : d / 1e3 + " km";
          this._updateScale(this._mScale, v, d / r);
        },
        _updateImperial: function(r) {
          var d = r * 3.2808399, v, w, O;
          d > 5280 ? (v = d / 5280, w = this._getRoundNum(v), this._updateScale(this._iScale, w + " mi", w / v)) : (O = this._getRoundNum(d), this._updateScale(this._iScale, O + " ft", O / d));
        },
        _updateScale: function(r, d, v) {
          r.style.width = Math.round(this.options.maxWidth * v) + "px", r.innerHTML = d;
        },
        _getRoundNum: function(r) {
          var d = Math.pow(10, (Math.floor(r) + "").length - 1), v = r / d;
          return v = v >= 10 ? 10 : v >= 5 ? 5 : v >= 3 ? 3 : v >= 2 ? 2 : 1, d * v;
        }
      }), Up = function(r) {
        return new Md(r);
      }, Bp = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>', Ds = Jn.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (It.inlineSvg ? Bp + " " : "") + "Leaflet</a>"
        },
        initialize: function(r) {
          Q(this, r), this._attributions = {};
        },
        onAdd: function(r) {
          r.attributionControl = this, this._container = we("div", "leaflet-control-attribution"), Ms(this._container);
          for (var d in r._layers)
            r._layers[d].getAttribution && this.addAttribution(r._layers[d].getAttribution());
          return this._update(), r.on("layeradd", this._addAttribution, this), this._container;
        },
        onRemove: function(r) {
          r.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(r) {
          r.layer.getAttribution && (this.addAttribution(r.layer.getAttribution()), r.layer.once("remove", function() {
            this.removeAttribution(r.layer.getAttribution());
          }, this));
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(r) {
          return this.options.prefix = r, this._update(), this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(r) {
          return r ? (this._attributions[r] || (this._attributions[r] = 0), this._attributions[r]++, this._update(), this) : this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(r) {
          return r ? (this._attributions[r] && (this._attributions[r]--, this._update()), this) : this;
        },
        _update: function() {
          if (this._map) {
            var r = [];
            for (var d in this._attributions)
              this._attributions[d] && r.push(d);
            var v = [];
            this.options.prefix && v.push(this.options.prefix), r.length && v.push(r.join(", ")), this._container.innerHTML = v.join(' <span aria-hidden="true">|</span> ');
          }
        }
      });
      Oe.mergeOptions({
        attributionControl: !0
      }), Oe.addInitHook(function() {
        this.options.attributionControl && new Ds().addTo(this);
      });
      var Ed = function(r) {
        return new Ds(r);
      };
      Jn.Layers = zf, Jn.Zoom = Lf, Jn.Scale = Md, Jn.Attribution = Ds, Os.layers = wd, Os.zoom = Hf, Os.scale = Up, Os.attribution = Ed;
      var _a = ge.extend({
        initialize: function(r) {
          this._map = r;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      _a.addTo = function(r, d) {
        return r.addHandler(d, this), this;
      };
      var Od = { Events: V }, kf = It.touch ? "touchstart mousedown" : "mousedown", wo = mt.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(r, d, v, w) {
          Q(this, w), this._element = r, this._dragStartTarget = d || r, this._preventOutline = v;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          this._enabled || (ce(this._dragStartTarget, kf, this._onDown, this), this._enabled = !0);
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          this._enabled && (wo._dragging === this && this.finishDrag(!0), Ye(this._dragStartTarget, kf, this._onDown, this), this._enabled = !1, this._moved = !1);
        },
        _onDown: function(r) {
          if (this._enabled && (this._moved = !1, !So(this._element, "leaflet-zoom-anim"))) {
            if (r.touches && r.touches.length !== 1) {
              wo._dragging === this && this.finishDrag();
              return;
            }
            if (!(wo._dragging || r.shiftKey || r.which !== 1 && r.button !== 1 && !r.touches) && (wo._dragging = this, this._preventOutline && tl(this._element), Fo(), To(), !this._moving)) {
              this.fire("down");
              var d = r.touches ? r.touches[0] : r, v = ws(this._element);
              this._startPoint = new ut(d.clientX, d.clientY), this._startPos = $o(this._element), this._parentScale = Ml(v);
              var w = r.type === "mousedown";
              ce(document, w ? "mousemove" : "touchmove", this._onMove, this), ce(document, w ? "mouseup" : "touchend touchcancel", this._onUp, this);
            }
          }
        },
        _onMove: function(r) {
          if (this._enabled) {
            if (r.touches && r.touches.length > 1) {
              this._moved = !0;
              return;
            }
            var d = r.touches && r.touches.length === 1 ? r.touches[0] : r, v = new ut(d.clientX, d.clientY)._subtract(this._startPoint);
            !v.x && !v.y || Math.abs(v.x) + Math.abs(v.y) < this.options.clickTolerance || (v.x /= this._parentScale.x, v.y /= this._parentScale.y, Ue(r), this._moved || (this.fire("dragstart"), this._moved = !0, le(document.body, "leaflet-dragging"), this._lastTarget = r.target || r.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), le(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(v), this._moving = !0, this._lastEvent = r, this._updatePosition());
          }
        },
        _updatePosition: function() {
          var r = { originalEvent: this._lastEvent };
          this.fire("predrag", r), yn(this._element, this._newPos), this.fire("drag", r);
        },
        _onUp: function() {
          this._enabled && this.finishDrag();
        },
        finishDrag: function(r) {
          Fe(document.body, "leaflet-dragging"), this._lastTarget && (Fe(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), Ye(document, "mousemove touchmove", this._onMove, this), Ye(document, "mouseup touchend touchcancel", this._onUp, this), Cf(), gr();
          var d = this._moved && this._moving;
          this._moving = !1, wo._dragging = !1, d && this.fire("dragend", {
            noInertia: r,
            distance: this._newPos.distanceTo(this._startPos)
          });
        }
      });
      function Nf(r, d, v) {
        var w, O = [1, 4, 2, 8], H, q, $, rt, xt, Ut, qt, Zt;
        for (H = 0, Ut = r.length; H < Ut; H++)
          r[H]._code = Dl(r[H], d);
        for ($ = 0; $ < 4; $++) {
          for (qt = O[$], w = [], H = 0, Ut = r.length, q = Ut - 1; H < Ut; q = H++)
            rt = r[H], xt = r[q], rt._code & qt ? xt._code & qt || (Zt = br(xt, rt, qt, d, v), Zt._code = Dl(Zt, d), w.push(Zt)) : (xt._code & qt && (Zt = br(xt, rt, qt, d, v), Zt._code = Dl(Zt, d), w.push(Zt)), w.push(rt));
          r = w;
        }
        return r;
      }
      function Mo(r, d) {
        var v, w, O, H, q, $, rt, xt, Ut;
        if (!r || r.length === 0)
          throw new Error("latlngs not passed");
        gi(r) || (console.warn("latlngs are not flat! Only the first ring will be used"), r = r[0]);
        var qt = Tt([0, 0]), Zt = Mt(r), oe = Zt.getNorthWest().distanceTo(Zt.getSouthWest()) * Zt.getNorthEast().distanceTo(Zt.getNorthWest());
        oe < 1700 && (qt = nl(r));
        var Ge = r.length, dn = [];
        for (v = 0; v < Ge; v++) {
          var Dn = Tt(r[v]);
          dn.push(d.project(Tt([Dn.lat - qt.lat, Dn.lng - qt.lng])));
        }
        for ($ = rt = xt = 0, v = 0, w = Ge - 1; v < Ge; w = v++)
          O = dn[v], H = dn[w], q = O.y * H.x - H.y * O.x, rt += (O.x + H.x) * q, xt += (O.y + H.y) * q, $ += q * 3;
        $ === 0 ? Ut = dn[0] : Ut = [rt / $, xt / $];
        var Gi = d.unproject(k(Ut));
        return Tt([Gi.lat + qt.lat, Gi.lng + qt.lng]);
      }
      function nl(r) {
        for (var d = 0, v = 0, w = 0, O = 0; O < r.length; O++) {
          var H = Tt(r[O]);
          d += H.lat, v += H.lng, w++;
        }
        return Tt([d / w, v / w]);
      }
      var Wa = {
        __proto__: null,
        clipPolygon: Nf,
        polygonCenter: Mo,
        centroid: nl
      };
      function qi(r, d) {
        if (!d || !r.length)
          return r.slice();
        var v = d * d;
        return r = Dd(r, v), r = Uf(r, v), r;
      }
      function _r(r, d, v) {
        return Math.sqrt(il(r, d, v, !0));
      }
      function vc(r, d, v) {
        return il(r, d, v);
      }
      function Uf(r, d) {
        var v = r.length, w = typeof Uint8Array < "u" ? Uint8Array : Array, O = new w(v);
        O[0] = O[v - 1] = 1, pi(r, O, d, 0, v - 1);
        var H, q = [];
        for (H = 0; H < v; H++)
          O[H] && q.push(r[H]);
        return q;
      }
      function pi(r, d, v, w, O) {
        var H = 0, q, $, rt;
        for ($ = w + 1; $ <= O - 1; $++)
          rt = il(r[$], r[w], r[O], !0), rt > H && (q = $, H = rt);
        H > v && (d[q] = 1, pi(r, d, v, w, q), pi(r, d, v, q, O));
      }
      function Dd(r, d) {
        for (var v = [r[0]], w = 1, O = 0, H = r.length; w < H; w++)
          Ad(r[w], r[O]) > d && (v.push(r[w]), O = w);
        return O < H - 1 && v.push(r[H - 1]), v;
      }
      var Su;
      function Ol(r, d, v, w, O) {
        var H = w ? Su : Dl(r, v), q = Dl(d, v), $, rt, xt;
        for (Su = q; ; ) {
          if (!(H | q))
            return [r, d];
          if (H & q)
            return !1;
          $ = H || q, rt = br(r, d, $, v, O), xt = Dl(rt, v), $ === H ? (r = rt, H = xt) : (d = rt, q = xt);
        }
      }
      function br(r, d, v, w, O) {
        var H = d.x - r.x, q = d.y - r.y, $ = w.min, rt = w.max, xt, Ut;
        return v & 8 ? (xt = r.x + H * (rt.y - r.y) / q, Ut = rt.y) : v & 4 ? (xt = r.x + H * ($.y - r.y) / q, Ut = $.y) : v & 2 ? (xt = rt.x, Ut = r.y + q * (rt.x - r.x) / H) : v & 1 && (xt = $.x, Ut = r.y + q * ($.x - r.x) / H), new ut(xt, Ut, O);
      }
      function Dl(r, d) {
        var v = 0;
        return r.x < d.min.x ? v |= 1 : r.x > d.max.x && (v |= 2), r.y < d.min.y ? v |= 4 : r.y > d.max.y && (v |= 8), v;
      }
      function Ad(r, d) {
        var v = d.x - r.x, w = d.y - r.y;
        return v * v + w * w;
      }
      function il(r, d, v, w) {
        var O = d.x, H = d.y, q = v.x - O, $ = v.y - H, rt = q * q + $ * $, xt;
        return rt > 0 && (xt = ((r.x - O) * q + (r.y - H) * $) / rt, xt > 1 ? (O = v.x, H = v.y) : xt > 0 && (O += q * xt, H += $ * xt)), q = r.x - O, $ = r.y - H, w ? q * q + $ * $ : new ut(O, H);
      }
      function gi(r) {
        return !Et(r[0]) || typeof r[0][0] != "object" && typeof r[0][0] < "u";
      }
      function _c(r) {
        return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), gi(r);
      }
      function Ia(r, d) {
        var v, w, O, H, q, $, rt, xt;
        if (!r || r.length === 0)
          throw new Error("latlngs not passed");
        gi(r) || (console.warn("latlngs are not flat! Only the first ring will be used"), r = r[0]);
        var Ut = Tt([0, 0]), qt = Mt(r), Zt = qt.getNorthWest().distanceTo(qt.getSouthWest()) * qt.getNorthEast().distanceTo(qt.getNorthWest());
        Zt < 1700 && (Ut = nl(r));
        var oe = r.length, Ge = [];
        for (v = 0; v < oe; v++) {
          var dn = Tt(r[v]);
          Ge.push(d.project(Tt([dn.lat - Ut.lat, dn.lng - Ut.lng])));
        }
        for (v = 0, w = 0; v < oe - 1; v++)
          w += Ge[v].distanceTo(Ge[v + 1]) / 2;
        if (w === 0)
          xt = Ge[0];
        else
          for (v = 0, H = 0; v < oe - 1; v++)
            if (q = Ge[v], $ = Ge[v + 1], O = q.distanceTo($), H += O, H > w) {
              rt = (H - w) / O, xt = [
                $.x - rt * ($.x - q.x),
                $.y - rt * ($.y - q.y)
              ];
              break;
            }
        var Dn = d.unproject(k(xt));
        return Tt([Dn.lat + Ut.lat, Dn.lng + Ut.lng]);
      }
      var Bf = {
        __proto__: null,
        simplify: qi,
        pointToSegmentDistance: _r,
        closestPointOnSegment: vc,
        clipSegment: Ol,
        _getEdgeIntersection: br,
        _getBitCode: Dl,
        _sqClosestPointOnSegment: il,
        isFlat: gi,
        _flat: _c,
        polylineCenter: Ia
      }, Sr = {
        project: function(r) {
          return new ut(r.lng, r.lat);
        },
        unproject: function(r) {
          return new Ht(r.y, r.x);
        },
        bounds: new F([-180, -90], [180, 90])
      }, As = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new F([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(r) {
          var d = Math.PI / 180, v = this.R, w = r.lat * d, O = this.R_MINOR / v, H = Math.sqrt(1 - O * O), q = H * Math.sin(w), $ = Math.tan(Math.PI / 4 - w / 2) / Math.pow((1 - q) / (1 + q), H / 2);
          return w = -v * Math.log(Math.max($, 1e-10)), new ut(r.lng * d * v, w);
        },
        unproject: function(r) {
          for (var d = 180 / Math.PI, v = this.R, w = this.R_MINOR / v, O = Math.sqrt(1 - w * w), H = Math.exp(-r.y / v), q = Math.PI / 2 - 2 * Math.atan(H), $ = 0, rt = 0.1, xt; $ < 15 && Math.abs(rt) > 1e-7; $++)
            xt = O * Math.sin(q), xt = Math.pow((1 - xt) / (1 + xt), O / 2), rt = Math.PI / 2 - 2 * Math.atan(H * xt) - q, q += rt;
          return new Ht(q * d, r.x * d / v);
        }
      }, Al = {
        __proto__: null,
        LonLat: Sr,
        Mercator: As,
        SphericalMercator: fi
      }, Rl = h({}, Ft, {
        code: "EPSG:3395",
        projection: As,
        transformation: function() {
          var r = 0.5 / (Math.PI * As.R);
          return Za(r, 0.5, -r, 0.5);
        }()
      }), bc = h({}, Ft, {
        code: "EPSG:4326",
        projection: Sr,
        transformation: Za(1 / 180, 1, -1 / 180, 0.5)
      }), Rs = h({}, We, {
        projection: Sr,
        transformation: Za(1, 0, -1, 0),
        scale: function(r) {
          return Math.pow(2, r);
        },
        zoom: function(r) {
          return Math.log(r) / Math.LN2;
        },
        distance: function(r, d) {
          var v = d.lng - r.lng, w = d.lat - r.lat;
          return Math.sqrt(v * v + w * w);
        },
        infinite: !0
      });
      We.Earth = Ft, We.EPSG3395 = Rl, We.EPSG3857 = ma, We.EPSG900913 = ur, We.EPSG4326 = bc, We.Simple = Rs;
      var ba = mt.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: !0
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(r) {
          return r.addLayer(this), this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(r) {
          return r && r.removeLayer(this), this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(r) {
          return this._map.getPane(r ? this.options[r] || r : this.options.pane);
        },
        addInteractiveTarget: function(r) {
          return this._map._targets[T(r)] = this, this;
        },
        removeInteractiveTarget: function(r) {
          return delete this._map._targets[T(r)], this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(r) {
          var d = r.target;
          if (d.hasLayer(this)) {
            if (this._map = d, this._zoomAnimated = d._zoomAnimated, this.getEvents) {
              var v = this.getEvents();
              d.on(v, this), this.once("remove", function() {
                d.off(v, this);
              }, this);
            }
            this.onAdd(d), this.fire("add"), d.fire("layeradd", { layer: this });
          }
        }
      });
      Oe.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(r) {
          if (!r._layerAdd)
            throw new Error("The provided object is not a Layer.");
          var d = T(r);
          return this._layers[d] ? this : (this._layers[d] = r, r._mapToAdd = this, r.beforeAdd && r.beforeAdd(this), this.whenReady(r._layerAdd, r), this);
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(r) {
          var d = T(r);
          return this._layers[d] ? (this._loaded && r.onRemove(this), delete this._layers[d], this._loaded && (this.fire("layerremove", { layer: r }), r.fire("remove")), r._map = r._mapToAdd = null, this) : this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(r) {
          return T(r) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(r, d) {
          for (var v in this._layers)
            r.call(d, this._layers[v]);
          return this;
        },
        _addLayers: function(r) {
          r = r ? Et(r) ? r : [r] : [];
          for (var d = 0, v = r.length; d < v; d++)
            this.addLayer(r[d]);
        },
        _addZoomLimit: function(r) {
          (!isNaN(r.options.maxZoom) || !isNaN(r.options.minZoom)) && (this._zoomBoundLayers[T(r)] = r, this._updateZoomLevels());
        },
        _removeZoomLimit: function(r) {
          var d = T(r);
          this._zoomBoundLayers[d] && (delete this._zoomBoundLayers[d], this._updateZoomLevels());
        },
        _updateZoomLevels: function() {
          var r = 1 / 0, d = -1 / 0, v = this._getZoomSpan();
          for (var w in this._zoomBoundLayers) {
            var O = this._zoomBoundLayers[w].options;
            r = O.minZoom === void 0 ? r : Math.min(r, O.minZoom), d = O.maxZoom === void 0 ? d : Math.max(d, O.maxZoom);
          }
          this._layersMaxZoom = d === -1 / 0 ? void 0 : d, this._layersMinZoom = r === 1 / 0 ? void 0 : r, v !== this._getZoomSpan() && this.fire("zoomlevelschange"), this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
        }
      });
      var al = ba.extend({
        initialize: function(r, d) {
          Q(this, d), this._layers = {};
          var v, w;
          if (r)
            for (v = 0, w = r.length; v < w; v++)
              this.addLayer(r[v]);
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(r) {
          var d = this.getLayerId(r);
          return this._layers[d] = r, this._map && this._map.addLayer(r), this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(r) {
          var d = r in this._layers ? r : this.getLayerId(r);
          return this._map && this._layers[d] && this._map.removeLayer(this._layers[d]), delete this._layers[d], this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(r) {
          var d = typeof r == "number" ? r : this.getLayerId(r);
          return d in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, …): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(r) {
          var d = Array.prototype.slice.call(arguments, 1), v, w;
          for (v in this._layers)
            w = this._layers[v], w[r] && w[r].apply(w, d);
          return this;
        },
        onAdd: function(r) {
          this.eachLayer(r.addLayer, r);
        },
        onRemove: function(r) {
          this.eachLayer(r.removeLayer, r);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(r, d) {
          for (var v in this._layers)
            r.call(d, this._layers[v]);
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(r) {
          return this._layers[r];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var r = [];
          return this.eachLayer(r.push, r), r;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(r) {
          return this.invoke("setZIndex", r);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(r) {
          return T(r);
        }
      }), Sc = function(r, d) {
        return new al(r, d);
      }, jn = al.extend({
        addLayer: function(r) {
          return this.hasLayer(r) ? this : (r.addEventParent(this), al.prototype.addLayer.call(this, r), this.fire("layeradd", { layer: r }));
        },
        removeLayer: function(r) {
          return this.hasLayer(r) ? (r in this._layers && (r = this._layers[r]), r.removeEventParent(this), al.prototype.removeLayer.call(this, r), this.fire("layerremove", { layer: r })) : this;
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(r) {
          return this.invoke("setStyle", r);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var r = new bt();
          for (var d in this._layers) {
            var v = this._layers[d];
            r.extend(v.getBounds ? v.getBounds() : v.getLatLng());
          }
          return r;
        }
      }), $a = function(r, d) {
        return new jn(r, d);
      }, Cl = ge.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1
        },
        initialize: function(r) {
          Q(this, r);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(r) {
          return this._createIcon("icon", r);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(r) {
          return this._createIcon("shadow", r);
        },
        _createIcon: function(r, d) {
          var v = this._getIconUrl(r);
          if (!v) {
            if (r === "icon")
              throw new Error("iconUrl not set in Icon options (see the docs).");
            return null;
          }
          var w = this._createImg(v, d && d.tagName === "IMG" ? d : null);
          return this._setIconStyles(w, r), (this.options.crossOrigin || this.options.crossOrigin === "") && (w.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), w;
        },
        _setIconStyles: function(r, d) {
          var v = this.options, w = v[d + "Size"];
          typeof w == "number" && (w = [w, w]);
          var O = k(w), H = k(d === "shadow" && v.shadowAnchor || v.iconAnchor || O && O.divideBy(2, !0));
          r.className = "leaflet-marker-" + d + " " + (v.className || ""), H && (r.style.marginLeft = -H.x + "px", r.style.marginTop = -H.y + "px"), O && (r.style.width = O.x + "px", r.style.height = O.y + "px");
        },
        _createImg: function(r, d) {
          return d = d || document.createElement("img"), d.src = r, d;
        },
        _getIconUrl: function(r) {
          return It.retina && this.options[r + "RetinaUrl"] || this.options[r + "Url"];
        }
      });
      function Eo(r) {
        return new Cl(r);
      }
      var Cs = Cl.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(r) {
          return typeof Cs.imagePath != "string" && (Cs.imagePath = this._detectIconPath()), (this.options.imagePath || Cs.imagePath) + Cl.prototype._getIconUrl.call(this, r);
        },
        _stripUrl: function(r) {
          var d = function(v, w, O) {
            var H = w.exec(v);
            return H && H[O];
          };
          return r = d(r, /^url\((['"])?(.+)\1\)$/, 2), r && d(r, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var r = we("div", "leaflet-default-icon-path", document.body), d = ya(r, "background-image") || ya(r, "backgroundImage");
          if (document.body.removeChild(r), d = this._stripUrl(d), d)
            return d;
          var v = document.querySelector('link[href$="leaflet.css"]');
          return v ? v.href.substring(0, v.href.length - 11 - 1) : "";
        }
      }), Tc = _a.extend({
        initialize: function(r) {
          this._marker = r;
        },
        addHooks: function() {
          var r = this._marker._icon;
          this._draggable || (this._draggable = new wo(r, r, !0)), this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable(), le(r, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable(), this._marker._icon && Fe(this._marker._icon, "leaflet-marker-draggable");
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(r) {
          var d = this._marker, v = d._map, w = this._marker.options.autoPanSpeed, O = this._marker.options.autoPanPadding, H = $o(d._icon), q = v.getPixelBounds(), $ = v.getPixelOrigin(), rt = ct(
            q.min._subtract($).add(O),
            q.max._subtract($).subtract(O)
          );
          if (!rt.contains(H)) {
            var xt = k(
              (Math.max(rt.max.x, H.x) - rt.max.x) / (q.max.x - rt.max.x) - (Math.min(rt.min.x, H.x) - rt.min.x) / (q.min.x - rt.min.x),
              (Math.max(rt.max.y, H.y) - rt.max.y) / (q.max.y - rt.max.y) - (Math.min(rt.min.y, H.y) - rt.min.y) / (q.min.y - rt.min.y)
            ).multiplyBy(w);
            v.panBy(xt, { animate: !1 }), this._draggable._newPos._add(xt), this._draggable._startPos._add(xt), yn(d._icon, this._draggable._newPos), this._onDrag(r), this._panRequest = Rt(this._adjustPan.bind(this, r));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(r) {
          this._marker.options.autoPan && (Nt(this._panRequest), this._panRequest = Rt(this._adjustPan.bind(this, r)));
        },
        _onDrag: function(r) {
          var d = this._marker, v = d._shadow, w = $o(d._icon), O = d._map.layerPointToLatLng(w);
          v && yn(v, w), d._latlng = O, r.latlng = O, r.oldLatLng = this._oldLatLng, d.fire("move", r).fire("drag", r);
        },
        _onDragEnd: function(r) {
          Nt(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", r);
        }
      }), Oo = ba.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new Cs(),
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: !0,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: !1,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !1,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: !0,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: !1,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: !1,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(r, d) {
          Q(this, d), this._latlng = Tt(r);
        },
        onAdd: function(r) {
          this._zoomAnimated = this._zoomAnimated && r.options.markerZoomAnimation, this._zoomAnimated && r.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
        },
        onRemove: function(r) {
          this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && r.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(r) {
          var d = this._latlng;
          return this._latlng = Tt(r), this.update(), this.fire("move", { oldLatLng: d, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(r) {
          return this.options.zIndexOffset = r, this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(r) {
          return this.options.icon = r, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var r = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(r);
          }
          return this;
        },
        _initIcon: function() {
          var r = this.options, d = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), v = r.icon.createIcon(this._icon), w = !1;
          v !== this._icon && (this._icon && this._removeIcon(), w = !0, r.title && (v.title = r.title), v.tagName === "IMG" && (v.alt = r.alt || "")), le(v, d), r.keyboard && (v.tabIndex = "0", v.setAttribute("role", "button")), this._icon = v, r.riseOnHover && this.on({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && ce(v, "focus", this._panOnFocus, this);
          var O = r.icon.createShadow(this._shadow), H = !1;
          O !== this._shadow && (this._removeShadow(), H = !0), O && (le(O, d), O.alt = ""), this._shadow = O, r.opacity < 1 && this._updateOpacity(), w && this.getPane().appendChild(this._icon), this._initInteraction(), O && H && this.getPane(r.shadowPane).appendChild(this._shadow);
        },
        _removeIcon: function() {
          this.options.riseOnHover && this.off({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && Ye(this._icon, "focus", this._panOnFocus, this), ln(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
        },
        _removeShadow: function() {
          this._shadow && ln(this._shadow), this._shadow = null;
        },
        _setPos: function(r) {
          this._icon && yn(this._icon, r), this._shadow && yn(this._shadow, r), this._zIndex = r.y + this.options.zIndexOffset, this._resetZIndex();
        },
        _updateZIndex: function(r) {
          this._icon && (this._icon.style.zIndex = this._zIndex + r);
        },
        _animateZoom: function(r) {
          var d = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center).round();
          this._setPos(d);
        },
        _initInteraction: function() {
          if (this.options.interactive && (le(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), Tc)) {
            var r = this.options.draggable;
            this.dragging && (r = this.dragging.enabled(), this.dragging.disable()), this.dragging = new Tc(this), r && this.dragging.enable();
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(r) {
          return this.options.opacity = r, this._map && this._updateOpacity(), this;
        },
        _updateOpacity: function() {
          var r = this.options.opacity;
          this._icon && Di(this._icon, r), this._shadow && Di(this._shadow, r);
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var r = this._map;
          if (r) {
            var d = this.options.icon.options, v = d.iconSize ? k(d.iconSize) : k(0, 0), w = d.iconAnchor ? k(d.iconAnchor) : k(0, 0);
            r.panInside(this._latlng, {
              paddingTopLeft: w,
              paddingBottomRight: v.subtract(w)
            });
          }
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function zs(r, d) {
        return new Oo(r, d);
      }
      var Do = ba.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: !0,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: !1,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !0
        },
        beforeAdd: function(r) {
          this._renderer = r.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          return this._map && this._renderer._updatePath(this), this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(r) {
          return Q(this, r), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && r && Object.prototype.hasOwnProperty.call(r, "weight") && this._updateBounds()), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          return this._renderer && this._renderer._bringToFront(this), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          return this._renderer && this._renderer._bringToBack(this), this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project(), this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      }), ol = Do.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: !0,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(r, d) {
          Q(this, d), this._latlng = Tt(r), this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(r) {
          var d = this._latlng;
          return this._latlng = Tt(r), this.redraw(), this.fire("move", { oldLatLng: d, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(r) {
          return this.options.radius = this._radius = r, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(r) {
          var d = r && r.radius || this._radius;
          return Do.prototype.setStyle.call(this, r), this.setRadius(d), this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
        },
        _updateBounds: function() {
          var r = this._radius, d = this._radiusY || r, v = this._clickTolerance(), w = [r + v, d + v];
          this._pxBounds = new F(this._point.subtract(w), this._point.add(w));
        },
        _update: function() {
          this._map && this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(r) {
          return r.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function Yf(r, d) {
        return new ol(r, d);
      }
      var Tr = ol.extend({
        initialize: function(r, d, v) {
          if (typeof d == "number" && (d = h({}, v, { radius: d })), Q(this, d), this._latlng = Tt(r), isNaN(this.options.radius))
            throw new Error("Circle radius cannot be NaN");
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(r) {
          return this._mRadius = r, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var r = [this._radius, this._radiusY || this._radius];
          return new bt(
            this._map.layerPointToLatLng(this._point.subtract(r)),
            this._map.layerPointToLatLng(this._point.add(r))
          );
        },
        setStyle: Do.prototype.setStyle,
        _project: function() {
          var r = this._latlng.lng, d = this._latlng.lat, v = this._map, w = v.options.crs;
          if (w.distance === Ft.distance) {
            var O = Math.PI / 180, H = this._mRadius / Ft.R / O, q = v.project([d + H, r]), $ = v.project([d - H, r]), rt = q.add($).divideBy(2), xt = v.unproject(rt).lat, Ut = Math.acos((Math.cos(H * O) - Math.sin(d * O) * Math.sin(xt * O)) / (Math.cos(d * O) * Math.cos(xt * O))) / O;
            (isNaN(Ut) || Ut === 0) && (Ut = H / Math.cos(Math.PI / 180 * d)), this._point = rt.subtract(v.getPixelOrigin()), this._radius = isNaN(Ut) ? 0 : rt.x - v.project([xt, r - Ut]).x, this._radiusY = rt.y - q.y;
          } else {
            var qt = w.unproject(w.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = v.latLngToLayerPoint(this._latlng), this._radius = this._point.x - v.latLngToLayerPoint(qt).x;
          }
          this._updateBounds();
        }
      });
      function zl(r, d, v) {
        return new Tr(r, d, v);
      }
      var Fn = Do.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: !1
        },
        initialize: function(r, d) {
          Q(this, d), this._setLatLngs(r);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(r) {
          return this._setLatLngs(r), this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(r) {
          for (var d = 1 / 0, v = null, w = il, O, H, q = 0, $ = this._parts.length; q < $; q++)
            for (var rt = this._parts[q], xt = 1, Ut = rt.length; xt < Ut; xt++) {
              O = rt[xt - 1], H = rt[xt];
              var qt = w(r, O, H, !0);
              qt < d && (d = qt, v = w(r, O, H));
            }
          return v && (v.distance = Math.sqrt(d)), v;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          return Ia(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(r, d) {
          return d = d || this._defaultShape(), r = Tt(r), d.push(r), this._bounds.extend(r), this.redraw();
        },
        _setLatLngs: function(r) {
          this._bounds = new bt(), this._latlngs = this._convertLatLngs(r);
        },
        _defaultShape: function() {
          return gi(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(r) {
          for (var d = [], v = gi(r), w = 0, O = r.length; w < O; w++)
            v ? (d[w] = Tt(r[w]), this._bounds.extend(d[w])) : d[w] = this._convertLatLngs(r[w]);
          return d;
        },
        _project: function() {
          var r = new F();
          this._rings = [], this._projectLatlngs(this._latlngs, this._rings, r), this._bounds.isValid() && r.isValid() && (this._rawPxBounds = r, this._updateBounds());
        },
        _updateBounds: function() {
          var r = this._clickTolerance(), d = new ut(r, r);
          this._rawPxBounds && (this._pxBounds = new F([
            this._rawPxBounds.min.subtract(d),
            this._rawPxBounds.max.add(d)
          ]));
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(r, d, v) {
          var w = r[0] instanceof Ht, O = r.length, H, q;
          if (w) {
            for (q = [], H = 0; H < O; H++)
              q[H] = this._map.latLngToLayerPoint(r[H]), v.extend(q[H]);
            d.push(q);
          } else
            for (H = 0; H < O; H++)
              this._projectLatlngs(r[H], d, v);
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var r = this._renderer._bounds;
          if (this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(r))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var d = this._parts, v, w, O, H, q, $, rt;
            for (v = 0, O = 0, H = this._rings.length; v < H; v++)
              for (rt = this._rings[v], w = 0, q = rt.length; w < q - 1; w++)
                $ = Ol(rt[w], rt[w + 1], r, w, !0), $ && (d[O] = d[O] || [], d[O].push($[0]), ($[1] !== rt[w + 1] || w === q - 2) && (d[O].push($[1]), O++));
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          for (var r = this._parts, d = this.options.smoothFactor, v = 0, w = r.length; v < w; v++)
            r[v] = qi(r[v], d);
        },
        _update: function() {
          this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(r, d) {
          var v, w, O, H, q, $, rt = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(r))
            return !1;
          for (v = 0, H = this._parts.length; v < H; v++)
            for ($ = this._parts[v], w = 0, q = $.length, O = q - 1; w < q; O = w++)
              if (!(!d && w === 0) && _r(r, $[O], $[w]) <= rt)
                return !0;
          return !1;
        }
      });
      function jf(r, d) {
        return new Fn(r, d);
      }
      Fn._flat = _c;
      var Ll = Fn.extend({
        options: {
          fill: !0
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          return Mo(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(r) {
          var d = Fn.prototype._convertLatLngs.call(this, r), v = d.length;
          return v >= 2 && d[0] instanceof Ht && d[0].equals(d[v - 1]) && d.pop(), d;
        },
        _setLatLngs: function(r) {
          Fn.prototype._setLatLngs.call(this, r), gi(this._latlngs) && (this._latlngs = [this._latlngs]);
        },
        _defaultShape: function() {
          return gi(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var r = this._renderer._bounds, d = this.options.weight, v = new ut(d, d);
          if (r = new F(r.min.subtract(v), r.max.add(v)), this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(r))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var w = 0, O = this._rings.length, H; w < O; w++)
              H = Nf(this._rings[w], r, !0), H.length && this._parts.push(H);
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, !0);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(r) {
          var d = !1, v, w, O, H, q, $, rt, xt;
          if (!this._pxBounds || !this._pxBounds.contains(r))
            return !1;
          for (H = 0, rt = this._parts.length; H < rt; H++)
            for (v = this._parts[H], q = 0, xt = v.length, $ = xt - 1; q < xt; $ = q++)
              w = v[q], O = v[$], w.y > r.y != O.y > r.y && r.x < (O.x - w.x) * (r.y - w.y) / (O.y - w.y) + w.x && (d = !d);
          return d || Fn.prototype._containsPoint.call(this, r, !0);
        }
      });
      function ti(r, d) {
        return new Ll(r, d);
      }
      var yi = jn.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(r, d) {
          Q(this, d), this._layers = {}, r && this.addData(r);
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(r) {
          var d = Et(r) ? r : r.features, v, w, O;
          if (d) {
            for (v = 0, w = d.length; v < w; v++)
              O = d[v], (O.geometries || O.geometry || O.features || O.coordinates) && this.addData(O);
            return this;
          }
          var H = this.options;
          if (H.filter && !H.filter(r))
            return this;
          var q = Ja(r, H);
          return q ? (q.feature = Zi(r), q.defaultOptions = q.options, this.resetStyle(q), H.onEachFeature && H.onEachFeature(r, q), this.addLayer(q)) : this;
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(r) {
          return r === void 0 ? this.eachLayer(this.resetStyle, this) : (r.options = h({}, r.defaultOptions), this._setLayerStyle(r, this.options.style), this);
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(r) {
          return this.eachLayer(function(d) {
            this._setLayerStyle(d, r);
          }, this);
        },
        _setLayerStyle: function(r, d) {
          r.setStyle && (typeof d == "function" && (d = d(r.feature)), r.setStyle(d));
        }
      });
      function Ja(r, d) {
        var v = r.type === "Feature" ? r.geometry : r, w = v ? v.coordinates : null, O = [], H = d && d.pointToLayer, q = d && d.coordsToLatLng || Ls, $, rt, xt, Ut;
        if (!w && !v)
          return null;
        switch (v.type) {
          case "Point":
            return $ = q(w), tn(H, r, $, d);
          case "MultiPoint":
            for (xt = 0, Ut = w.length; xt < Ut; xt++)
              $ = q(w[xt]), O.push(tn(H, r, $, d));
            return new jn(O);
          case "LineString":
          case "MultiLineString":
            return rt = xr(w, v.type === "LineString" ? 0 : 1, q), new Fn(rt, d);
          case "Polygon":
          case "MultiPolygon":
            return rt = xr(w, v.type === "Polygon" ? 1 : 2, q), new Ll(rt, d);
          case "GeometryCollection":
            for (xt = 0, Ut = v.geometries.length; xt < Ut; xt++) {
              var qt = Ja({
                geometry: v.geometries[xt],
                type: "Feature",
                properties: r.properties
              }, d);
              qt && O.push(qt);
            }
            return new jn(O);
          case "FeatureCollection":
            for (xt = 0, Ut = v.features.length; xt < Ut; xt++) {
              var Zt = Ja(v.features[xt], d);
              Zt && O.push(Zt);
            }
            return new jn(O);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function tn(r, d, v, w) {
        return r ? r(d, v) : new Oo(v, w && w.markersInheritOptions && w);
      }
      function Ls(r) {
        return new Ht(r[1], r[0], r[2]);
      }
      function xr(r, d, v) {
        for (var w = [], O = 0, H = r.length, q; O < H; O++)
          q = d ? xr(r[O], d - 1, v) : (v || Ls)(r[O]), w.push(q);
        return w;
      }
      function Hs(r, d) {
        return r = Tt(r), r.alt !== void 0 ? [z(r.lng, d), z(r.lat, d), z(r.alt, d)] : [z(r.lng, d), z(r.lat, d)];
      }
      function Ao(r, d, v, w) {
        for (var O = [], H = 0, q = r.length; H < q; H++)
          O.push(d ? Ao(r[H], gi(r[H]) ? 0 : d - 1, v, w) : Hs(r[H], w));
        return !d && v && O.length > 0 && O.push(O[0].slice()), O;
      }
      function Ri(r, d) {
        return r.feature ? h({}, r.feature, { geometry: d }) : Zi(d);
      }
      function Zi(r) {
        return r.type === "Feature" || r.type === "FeatureCollection" ? r : {
          type: "Feature",
          properties: {},
          geometry: r
        };
      }
      var Ro = {
        toGeoJSON: function(r) {
          return Ri(this, {
            type: "Point",
            coordinates: Hs(this.getLatLng(), r)
          });
        }
      };
      Oo.include(Ro), Tr.include(Ro), ol.include(Ro), Fn.include({
        toGeoJSON: function(r) {
          var d = !gi(this._latlngs), v = Ao(this._latlngs, d ? 1 : 0, !1, r);
          return Ri(this, {
            type: (d ? "Multi" : "") + "LineString",
            coordinates: v
          });
        }
      }), Ll.include({
        toGeoJSON: function(r) {
          var d = !gi(this._latlngs), v = d && !gi(this._latlngs[0]), w = Ao(this._latlngs, v ? 2 : d ? 1 : 0, !0, r);
          return d || (w = [w]), Ri(this, {
            type: (v ? "Multi" : "") + "Polygon",
            coordinates: w
          });
        }
      }), al.include({
        toMultiPoint: function(r) {
          var d = [];
          return this.eachLayer(function(v) {
            d.push(v.toGeoJSON(r).geometry.coordinates);
          }), Ri(this, {
            type: "MultiPoint",
            coordinates: d
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(r) {
          var d = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (d === "MultiPoint")
            return this.toMultiPoint(r);
          var v = d === "GeometryCollection", w = [];
          return this.eachLayer(function(O) {
            if (O.toGeoJSON) {
              var H = O.toGeoJSON(r);
              if (v)
                w.push(H.geometry);
              else {
                var q = Zi(H);
                q.type === "FeatureCollection" ? w.push.apply(w, q.features) : w.push(q);
              }
            }
          }), v ? Ri(this, {
            geometries: w,
            type: "GeometryCollection"
          }) : {
            type: "FeatureCollection",
            features: w
          };
        }
      });
      function Hl(r, d) {
        return new yi(r, d);
      }
      var xc = Hl, Sa = ba.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(r, d, v) {
          this._url = r, this._bounds = Mt(d), Q(this, v);
        },
        onAdd: function() {
          this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (le(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
        },
        onRemove: function() {
          ln(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(r) {
          return this.options.opacity = r, this._image && this._updateOpacity(), this;
        },
        setStyle: function(r) {
          return r.opacity && this.setOpacity(r.opacity), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          return this._map && bo(this._image), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          return this._map && xl(this._image), this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(r) {
          return this._url = r, this._image && (this._image.src = r), this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(r) {
          return this._bounds = Mt(r), this._map && this._reset(), this;
        },
        getEvents: function() {
          var r = {
            zoom: this._reset,
            viewreset: this._reset
          };
          return this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(r) {
          return this.options.zIndex = r, this._updateZIndex(), this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var r = this._url.tagName === "IMG", d = this._image = r ? this._url : we("img");
          if (le(d, "leaflet-image-layer"), this._zoomAnimated && le(d, "leaflet-zoom-animated"), this.options.className && le(d, this.options.className), d.onselectstart = C, d.onmousemove = C, d.onload = _(this.fire, this, "load"), d.onerror = _(this._overlayOnError, this, "error"), (this.options.crossOrigin || this.options.crossOrigin === "") && (d.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), r) {
            this._url = d.src;
            return;
          }
          d.src = this._url, d.alt = this.options.alt;
        },
        _animateZoom: function(r) {
          var d = this._map.getZoomScale(r.zoom), v = this._map._latLngBoundsToNewLayerBounds(this._bounds, r.zoom, r.center).min;
          ia(this._image, v, d);
        },
        _reset: function() {
          var r = this._image, d = new F(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), v = d.getSize();
          yn(r, d.min), r.style.width = v.x + "px", r.style.height = v.y + "px";
        },
        _updateOpacity: function() {
          Di(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex);
        },
        _overlayOnError: function() {
          this.fire("error");
          var r = this.options.errorOverlayUrl;
          r && this._url !== r && (this._url = r, this._image.src = r);
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      }), ks = function(r, d, v) {
        return new Sa(r, d, v);
      }, aa = Sa.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: !0,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: !0,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: !0,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: !1,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: !0
        },
        _initImage: function() {
          var r = this._url.tagName === "VIDEO", d = this._image = r ? this._url : we("video");
          if (le(d, "leaflet-image-layer"), this._zoomAnimated && le(d, "leaflet-zoom-animated"), this.options.className && le(d, this.options.className), d.onselectstart = C, d.onmousemove = C, d.onloadeddata = _(this.fire, this, "load"), r) {
            for (var v = d.getElementsByTagName("source"), w = [], O = 0; O < v.length; O++)
              w.push(v[O].src);
            this._url = v.length > 0 ? w : [d.src];
            return;
          }
          Et(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(d.style, "objectFit") && (d.style.objectFit = "fill"), d.autoplay = !!this.options.autoplay, d.loop = !!this.options.loop, d.muted = !!this.options.muted, d.playsInline = !!this.options.playsInline;
          for (var H = 0; H < this._url.length; H++) {
            var q = we("source");
            q.src = this._url[H], d.appendChild(q);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function Fa(r, d, v) {
        return new aa(r, d, v);
      }
      var to = Sa.extend({
        _initImage: function() {
          var r = this._image = this._url;
          le(r, "leaflet-image-layer"), this._zoomAnimated && le(r, "leaflet-zoom-animated"), this.options.className && le(r, this.options.className), r.onselectstart = C, r.onmousemove = C;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function Rd(r, d, v) {
        return new to(r, d, v);
      }
      var Ta = ba.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: !1,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(r, d) {
          r && (r instanceof Ht || Et(r)) ? (this._latlng = Tt(r), Q(this, d)) : (Q(this, r), this._source = d), this.options.content && (this._content = this.options.content);
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(r) {
          return r = arguments.length ? r : this._source._map, r.hasLayer(this) || r.addLayer(this), this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          return this._map && this._map.removeLayer(this), this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(r) {
          return this._map ? this.close() : (arguments.length ? this._source = r : r = this._source, this._prepareOpen(), this.openOn(r._map)), this;
        },
        onAdd: function(r) {
          this._zoomAnimated = r._zoomAnimated, this._container || this._initLayout(), r._fadeAnimated && Di(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), r._fadeAnimated && Di(this._container, 1), this.bringToFront(), this.options.interactive && (le(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
        },
        onRemove: function(r) {
          r._fadeAnimated ? (Di(this._container, 0), this._removeTimeout = setTimeout(_(ln, void 0, this._container), 200)) : ln(this._container), this.options.interactive && (Fe(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(r) {
          return this._latlng = Tt(r), this._map && (this._updatePosition(), this._adjustPan()), this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(r) {
          return this._content = r, this.update(), this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
        },
        getEvents: function() {
          var r = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          return this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          return this._map && bo(this._container), this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          return this._map && xl(this._container), this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(r) {
          var d = this._source;
          if (!d._map)
            return !1;
          if (d instanceof jn) {
            d = null;
            var v = this._source._layers;
            for (var w in v)
              if (v[w]._map) {
                d = v[w];
                break;
              }
            if (!d)
              return !1;
            this._source = d;
          }
          if (!r)
            if (d.getCenter)
              r = d.getCenter();
            else if (d.getLatLng)
              r = d.getLatLng();
            else if (d.getBounds)
              r = d.getBounds().getCenter();
            else
              throw new Error("Unable to get source layer LatLng.");
          return this.setLatLng(r), this._map && this.update(), !0;
        },
        _updateContent: function() {
          if (this._content) {
            var r = this._contentNode, d = typeof this._content == "function" ? this._content(this._source || this) : this._content;
            if (typeof d == "string")
              r.innerHTML = d;
            else {
              for (; r.hasChildNodes(); )
                r.removeChild(r.firstChild);
              r.appendChild(d);
            }
            this.fire("contentupdate");
          }
        },
        _updatePosition: function() {
          if (this._map) {
            var r = this._map.latLngToLayerPoint(this._latlng), d = k(this.options.offset), v = this._getAnchor();
            this._zoomAnimated ? yn(this._container, r.add(v)) : d = d.add(r).add(v);
            var w = this._containerBottom = -d.y, O = this._containerLeft = -Math.round(this._containerWidth / 2) + d.x;
            this._container.style.bottom = w + "px", this._container.style.left = O + "px";
          }
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      Oe.include({
        _initOverlay: function(r, d, v, w) {
          var O = d;
          return O instanceof r || (O = new r(w).setContent(d)), v && O.setLatLng(v), O;
        }
      }), ba.include({
        _initOverlay: function(r, d, v, w) {
          var O = v;
          return O instanceof r ? (Q(O, w), O._source = this) : (O = d && !w ? d : new r(w, this), O.setContent(v)), O;
        }
      });
      var Tu = Ta.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: !0,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: !1,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: !0,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: !0,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: !0,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(r) {
          return r = arguments.length ? r : this._source._map, !r.hasLayer(this) && r._popup && r._popup.options.autoClose && r.removeLayer(r._popup), r._popup = this, Ta.prototype.openOn.call(this, r);
        },
        onAdd: function(r) {
          Ta.prototype.onAdd.call(this, r), r.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof Do || this._source.on("preclick", va));
        },
        onRemove: function(r) {
          Ta.prototype.onRemove.call(this, r), r.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof Do || this._source.off("preclick", va));
        },
        getEvents: function() {
          var r = Ta.prototype.getEvents.call(this);
          return (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (r.preclick = this.close), this.options.keepInView && (r.moveend = this._adjustPan), r;
        },
        _initLayout: function() {
          var r = "leaflet-popup", d = this._container = we(
            "div",
            r + " " + (this.options.className || "") + " leaflet-zoom-animated"
          ), v = this._wrapper = we("div", r + "-content-wrapper", d);
          if (this._contentNode = we("div", r + "-content", v), Ms(d), el(this._contentNode), ce(d, "contextmenu", va), this._tipContainer = we("div", r + "-tip-container", d), this._tip = we("div", r + "-tip", this._tipContainer), this.options.closeButton) {
            var w = this._closeButton = we("a", r + "-close-button", d);
            w.setAttribute("role", "button"), w.setAttribute("aria-label", "Close popup"), w.href = "#close", w.innerHTML = '<span aria-hidden="true">&#215;</span>', ce(w, "click", function(O) {
              Ue(O), this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var r = this._contentNode, d = r.style;
          d.width = "", d.whiteSpace = "nowrap";
          var v = r.offsetWidth;
          v = Math.min(v, this.options.maxWidth), v = Math.max(v, this.options.minWidth), d.width = v + 1 + "px", d.whiteSpace = "", d.height = "";
          var w = r.offsetHeight, O = this.options.maxHeight, H = "leaflet-popup-scrolled";
          O && w > O ? (d.height = O + "px", le(r, H)) : Fe(r, H), this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(r) {
          var d = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center), v = this._getAnchor();
          yn(this._container, d.add(v));
        },
        _adjustPan: function() {
          if (this.options.autoPan) {
            if (this._map._panAnim && this._map._panAnim.stop(), this._autopanning) {
              this._autopanning = !1;
              return;
            }
            var r = this._map, d = parseInt(ya(this._container, "marginBottom"), 10) || 0, v = this._container.offsetHeight + d, w = this._containerWidth, O = new ut(this._containerLeft, -v - this._containerBottom);
            O._add($o(this._container));
            var H = r.layerPointToContainerPoint(O), q = k(this.options.autoPanPadding), $ = k(this.options.autoPanPaddingTopLeft || q), rt = k(this.options.autoPanPaddingBottomRight || q), xt = r.getSize(), Ut = 0, qt = 0;
            H.x + w + rt.x > xt.x && (Ut = H.x + w - xt.x + rt.x), H.x - Ut - $.x < 0 && (Ut = H.x - $.x), H.y + v + rt.y > xt.y && (qt = H.y + v - xt.y + rt.y), H.y - qt - $.y < 0 && (qt = H.y - $.y), (Ut || qt) && (this.options.keepInView && (this._autopanning = !0), r.fire("autopanstart").panBy([Ut, qt]));
          }
        },
        _getAnchor: function() {
          return k(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      }), qf = function(r, d) {
        return new Tu(r, d);
      };
      Oe.mergeOptions({
        closePopupOnClick: !0
      }), Oe.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(r, d, v) {
          return this._initOverlay(Tu, r, d, v).openOn(this), this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(r) {
          return r = arguments.length ? r : this._popup, r && r.close(), this;
        }
      }), ba.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(r, d) {
          return this._popup = this._initOverlay(Tu, this._popup, r, d), this._popupHandlersAdded || (this.on({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !0), this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          return this._popup && (this.off({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !1, this._popup = null), this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(r) {
          return this._popup && (this instanceof jn || (this._popup._source = this), this._popup._prepareOpen(r || this._latlng) && this._popup.openOn(this._map)), this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          return this._popup && this._popup.close(), this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          return this._popup && this._popup.toggle(this), this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : !1;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(r) {
          return this._popup && this._popup.setContent(r), this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(r) {
          if (!(!this._popup || !this._map)) {
            xo(r);
            var d = r.layer || r.target;
            if (this._popup._source === d && !(d instanceof Do)) {
              this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(r.latlng);
              return;
            }
            this._popup._source = d, this.openPopup(r.latlng);
          }
        },
        _movePopup: function(r) {
          this._popup.setLatLng(r.latlng);
        },
        _onKeyPress: function(r) {
          r.originalEvent.keyCode === 13 && this._openPopup(r);
        }
      });
      var Ns = Ta.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: !1,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: !1,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(r) {
          Ta.prototype.onAdd.call(this, r), this.setOpacity(this.options.opacity), r.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0));
        },
        onRemove: function(r) {
          Ta.prototype.onRemove.call(this, r), r.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0));
        },
        getEvents: function() {
          var r = Ta.prototype.getEvents.call(this);
          return this.options.permanent || (r.preclick = this.close), r;
        },
        _initLayout: function() {
          var r = "leaflet-tooltip", d = r + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = we("div", d), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + T(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(r) {
          var d, v, w = this._map, O = this._container, H = w.latLngToContainerPoint(w.getCenter()), q = w.layerPointToContainerPoint(r), $ = this.options.direction, rt = O.offsetWidth, xt = O.offsetHeight, Ut = k(this.options.offset), qt = this._getAnchor();
          $ === "top" ? (d = rt / 2, v = xt) : $ === "bottom" ? (d = rt / 2, v = 0) : $ === "center" ? (d = rt / 2, v = xt / 2) : $ === "right" ? (d = 0, v = xt / 2) : $ === "left" ? (d = rt, v = xt / 2) : q.x < H.x ? ($ = "right", d = 0, v = xt / 2) : ($ = "left", d = rt + (Ut.x + qt.x) * 2, v = xt / 2), r = r.subtract(k(d, v, !0)).add(Ut).add(qt), Fe(O, "leaflet-tooltip-right"), Fe(O, "leaflet-tooltip-left"), Fe(O, "leaflet-tooltip-top"), Fe(O, "leaflet-tooltip-bottom"), le(O, "leaflet-tooltip-" + $), yn(O, r);
        },
        _updatePosition: function() {
          var r = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(r);
        },
        setOpacity: function(r) {
          this.options.opacity = r, this._container && Di(this._container, r);
        },
        _animateZoom: function(r) {
          var d = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center);
          this._setPosition(d);
        },
        _getAnchor: function() {
          return k(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      }), Cd = function(r, d) {
        return new Ns(r, d);
      };
      Oe.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(r, d, v) {
          return this._initOverlay(Ns, r, d, v).openOn(this), this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(r) {
          return r.close(), this;
        }
      }), ba.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(r, d) {
          return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Ns, this._tooltip, r, d), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this;
        },
        _initTooltipInteractions: function(r) {
          if (!(!r && this._tooltipHandlersAdded)) {
            var d = r ? "off" : "on", v = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            this._tooltip.options.permanent ? v.add = this._openTooltip : (v.mouseover = this._openTooltip, v.mouseout = this.closeTooltip, v.click = this._openTooltip, this._map ? this._addFocusListeners() : v.add = this._addFocusListeners), this._tooltip.options.sticky && (v.mousemove = this._moveTooltip), this[d](v), this._tooltipHandlersAdded = !r;
          }
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(r) {
          return this._tooltip && (this instanceof jn || (this._tooltip._source = this), this._tooltip._prepareOpen(r) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip)
            return this._tooltip.close();
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          return this._tooltip && this._tooltip.toggle(this), this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(r) {
          return this._tooltip && this._tooltip.setContent(r), this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
        },
        _addFocusListenersOnLayer: function(r) {
          var d = typeof r.getElement == "function" && r.getElement();
          d && (ce(d, "focus", function() {
            this._tooltip._source = r, this.openTooltip();
          }, this), ce(d, "blur", this.closeTooltip, this));
        },
        _setAriaDescribedByOnLayer: function(r) {
          var d = typeof r.getElement == "function" && r.getElement();
          d && d.setAttribute("aria-describedby", this._tooltip._container.id);
        },
        _openTooltip: function(r) {
          if (!(!this._tooltip || !this._map)) {
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
              this._openOnceFlag = !0;
              var d = this;
              this._map.once("moveend", function() {
                d._openOnceFlag = !1, d._openTooltip(r);
              });
              return;
            }
            this._tooltip._source = r.layer || r.target, this.openTooltip(this._tooltip.options.sticky ? r.latlng : void 0);
          }
        },
        _moveTooltip: function(r) {
          var d = r.latlng, v, w;
          this._tooltip.options.sticky && r.originalEvent && (v = this._map.mouseEventToContainerPoint(r.originalEvent), w = this._map.containerPointToLayerPoint(v), d = this._map.layerPointToLatLng(w)), this._tooltip.setLatLng(d);
        }
      });
      var wc = Cl.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: !1,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(r) {
          var d = r && r.tagName === "DIV" ? r : document.createElement("div"), v = this.options;
          if (v.html instanceof Element ? (Yn(d), d.appendChild(v.html)) : d.innerHTML = v.html !== !1 ? v.html : "", v.bgPos) {
            var w = k(v.bgPos);
            d.style.backgroundPosition = -w.x + "px " + -w.y + "px";
          }
          return this._setIconStyles(d, "icon"), d;
        },
        createShadow: function() {
          return null;
        }
      });
      function Zf(r) {
        return new wc(r);
      }
      Cl.Default = Cs;
      var Co = ba.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: It.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: !0,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: !1,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(r) {
          Q(this, r);
        },
        onAdd: function() {
          this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
        },
        beforeAdd: function(r) {
          r._addZoomLimit(this);
        },
        onRemove: function(r) {
          this._removeAllTiles(), ln(this._container), r._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          return this._map && (bo(this._container), this._setAutoZIndex(Math.max)), this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          return this._map && (xl(this._container), this._setAutoZIndex(Math.min)), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(r) {
          return this.options.opacity = r, this._updateOpacity(), this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(r) {
          return this.options.zIndex = r, this._updateZIndex(), this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var r = this._clampZoom(this._map.getZoom());
            r !== this._tileZoom && (this._tileZoom = r, this._updateLevels()), this._update();
          }
          return this;
        },
        getEvents: function() {
          var r = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          return this.options.updateWhenIdle || (this._onMove || (this._onMove = E(this._onMoveEnd, this.options.updateInterval, this)), r.move = this._onMove), this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var r = this.options.tileSize;
          return r instanceof ut ? r : new ut(r, r);
        },
        _updateZIndex: function() {
          this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex);
        },
        _setAutoZIndex: function(r) {
          for (var d = this.getPane().children, v = -r(-1 / 0, 1 / 0), w = 0, O = d.length, H; w < O; w++)
            H = d[w].style.zIndex, d[w] !== this._container && H && (v = r(v, +H));
          isFinite(v) && (this.options.zIndex = v + r(-1, 1), this._updateZIndex());
        },
        _updateOpacity: function() {
          if (this._map && !It.ielt9) {
            Di(this._container, this.options.opacity);
            var r = +/* @__PURE__ */ new Date(), d = !1, v = !1;
            for (var w in this._tiles) {
              var O = this._tiles[w];
              if (!(!O.current || !O.loaded)) {
                var H = Math.min(1, (r - O.loaded) / 200);
                Di(O.el, H), H < 1 ? d = !0 : (O.active ? v = !0 : this._onOpaqueTile(O), O.active = !0);
              }
            }
            v && !this._noPrune && this._pruneTiles(), d && (Nt(this._fadeFrame), this._fadeFrame = Rt(this._updateOpacity, this));
          }
        },
        _onOpaqueTile: C,
        _initContainer: function() {
          this._container || (this._container = we("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
        },
        _updateLevels: function() {
          var r = this._tileZoom, d = this.options.maxZoom;
          if (r !== void 0) {
            for (var v in this._levels)
              v = Number(v), this._levels[v].el.children.length || v === r ? (this._levels[v].el.style.zIndex = d - Math.abs(r - v), this._onUpdateLevel(v)) : (ln(this._levels[v].el), this._removeTilesAtZoom(v), this._onRemoveLevel(v), delete this._levels[v]);
            var w = this._levels[r], O = this._map;
            return w || (w = this._levels[r] = {}, w.el = we("div", "leaflet-tile-container leaflet-zoom-animated", this._container), w.el.style.zIndex = d, w.origin = O.project(O.unproject(O.getPixelOrigin()), r).round(), w.zoom = r, this._setZoomTransform(w, O.getCenter(), O.getZoom()), C(w.el.offsetWidth), this._onCreateLevel(w)), this._level = w, w;
          }
        },
        _onUpdateLevel: C,
        _onRemoveLevel: C,
        _onCreateLevel: C,
        _pruneTiles: function() {
          if (this._map) {
            var r, d, v = this._map.getZoom();
            if (v > this.options.maxZoom || v < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (r in this._tiles)
              d = this._tiles[r], d.retain = d.current;
            for (r in this._tiles)
              if (d = this._tiles[r], d.current && !d.active) {
                var w = d.coords;
                this._retainParent(w.x, w.y, w.z, w.z - 5) || this._retainChildren(w.x, w.y, w.z, w.z + 2);
              }
            for (r in this._tiles)
              this._tiles[r].retain || this._removeTile(r);
          }
        },
        _removeTilesAtZoom: function(r) {
          for (var d in this._tiles)
            this._tiles[d].coords.z === r && this._removeTile(d);
        },
        _removeAllTiles: function() {
          for (var r in this._tiles)
            this._removeTile(r);
        },
        _invalidateAll: function() {
          for (var r in this._levels)
            ln(this._levels[r].el), this._onRemoveLevel(Number(r)), delete this._levels[r];
          this._removeAllTiles(), this._tileZoom = void 0;
        },
        _retainParent: function(r, d, v, w) {
          var O = Math.floor(r / 2), H = Math.floor(d / 2), q = v - 1, $ = new ut(+O, +H);
          $.z = +q;
          var rt = this._tileCoordsToKey($), xt = this._tiles[rt];
          return xt && xt.active ? (xt.retain = !0, !0) : (xt && xt.loaded && (xt.retain = !0), q > w ? this._retainParent(O, H, q, w) : !1);
        },
        _retainChildren: function(r, d, v, w) {
          for (var O = 2 * r; O < 2 * r + 2; O++)
            for (var H = 2 * d; H < 2 * d + 2; H++) {
              var q = new ut(O, H);
              q.z = v + 1;
              var $ = this._tileCoordsToKey(q), rt = this._tiles[$];
              if (rt && rt.active) {
                rt.retain = !0;
                continue;
              } else rt && rt.loaded && (rt.retain = !0);
              v + 1 < w && this._retainChildren(O, H, v + 1, w);
            }
        },
        _resetView: function(r) {
          var d = r && (r.pinch || r.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), d, d);
        },
        _animateZoom: function(r) {
          this._setView(r.center, r.zoom, !0, r.noUpdate);
        },
        _clampZoom: function(r) {
          var d = this.options;
          return d.minNativeZoom !== void 0 && r < d.minNativeZoom ? d.minNativeZoom : d.maxNativeZoom !== void 0 && d.maxNativeZoom < r ? d.maxNativeZoom : r;
        },
        _setView: function(r, d, v, w) {
          var O = Math.round(d);
          this.options.maxZoom !== void 0 && O > this.options.maxZoom || this.options.minZoom !== void 0 && O < this.options.minZoom ? O = void 0 : O = this._clampZoom(O);
          var H = this.options.updateWhenZooming && O !== this._tileZoom;
          (!w || H) && (this._tileZoom = O, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), O !== void 0 && this._update(r), v || this._pruneTiles(), this._noPrune = !!v), this._setZoomTransforms(r, d);
        },
        _setZoomTransforms: function(r, d) {
          for (var v in this._levels)
            this._setZoomTransform(this._levels[v], r, d);
        },
        _setZoomTransform: function(r, d, v) {
          var w = this._map.getZoomScale(v, r.zoom), O = r.origin.multiplyBy(w).subtract(this._map._getNewPixelOrigin(d, v)).round();
          It.any3d ? ia(r.el, O, w) : yn(r.el, O);
        },
        _resetGrid: function() {
          var r = this._map, d = r.options.crs, v = this._tileSize = this.getTileSize(), w = this._tileZoom, O = this._map.getPixelWorldBounds(this._tileZoom);
          O && (this._globalTileRange = this._pxBoundsToTileRange(O)), this._wrapX = d.wrapLng && !this.options.noWrap && [
            Math.floor(r.project([0, d.wrapLng[0]], w).x / v.x),
            Math.ceil(r.project([0, d.wrapLng[1]], w).x / v.y)
          ], this._wrapY = d.wrapLat && !this.options.noWrap && [
            Math.floor(r.project([d.wrapLat[0], 0], w).y / v.x),
            Math.ceil(r.project([d.wrapLat[1], 0], w).y / v.y)
          ];
        },
        _onMoveEnd: function() {
          !this._map || this._map._animatingZoom || this._update();
        },
        _getTiledPixelBounds: function(r) {
          var d = this._map, v = d._animatingZoom ? Math.max(d._animateToZoom, d.getZoom()) : d.getZoom(), w = d.getZoomScale(v, this._tileZoom), O = d.project(r, this._tileZoom).floor(), H = d.getSize().divideBy(w * 2);
          return new F(O.subtract(H), O.add(H));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(r) {
          var d = this._map;
          if (d) {
            var v = this._clampZoom(d.getZoom());
            if (r === void 0 && (r = d.getCenter()), this._tileZoom !== void 0) {
              var w = this._getTiledPixelBounds(r), O = this._pxBoundsToTileRange(w), H = O.getCenter(), q = [], $ = this.options.keepBuffer, rt = new F(
                O.getBottomLeft().subtract([$, -$]),
                O.getTopRight().add([$, -$])
              );
              if (!(isFinite(O.min.x) && isFinite(O.min.y) && isFinite(O.max.x) && isFinite(O.max.y)))
                throw new Error("Attempted to load an infinite number of tiles");
              for (var xt in this._tiles) {
                var Ut = this._tiles[xt].coords;
                (Ut.z !== this._tileZoom || !rt.contains(new ut(Ut.x, Ut.y))) && (this._tiles[xt].current = !1);
              }
              if (Math.abs(v - this._tileZoom) > 1) {
                this._setView(r, v);
                return;
              }
              for (var qt = O.min.y; qt <= O.max.y; qt++)
                for (var Zt = O.min.x; Zt <= O.max.x; Zt++) {
                  var oe = new ut(Zt, qt);
                  if (oe.z = this._tileZoom, !!this._isValidTile(oe)) {
                    var Ge = this._tiles[this._tileCoordsToKey(oe)];
                    Ge ? Ge.current = !0 : q.push(oe);
                  }
                }
              if (q.sort(function(Dn, Gi) {
                return Dn.distanceTo(H) - Gi.distanceTo(H);
              }), q.length !== 0) {
                this._loading || (this._loading = !0, this.fire("loading"));
                var dn = document.createDocumentFragment();
                for (Zt = 0; Zt < q.length; Zt++)
                  this._addTile(q[Zt], dn);
                this._level.el.appendChild(dn);
              }
            }
          }
        },
        _isValidTile: function(r) {
          var d = this._map.options.crs;
          if (!d.infinite) {
            var v = this._globalTileRange;
            if (!d.wrapLng && (r.x < v.min.x || r.x > v.max.x) || !d.wrapLat && (r.y < v.min.y || r.y > v.max.y))
              return !1;
          }
          if (!this.options.bounds)
            return !0;
          var w = this._tileCoordsToBounds(r);
          return Mt(this.options.bounds).overlaps(w);
        },
        _keyToBounds: function(r) {
          return this._tileCoordsToBounds(this._keyToTileCoords(r));
        },
        _tileCoordsToNwSe: function(r) {
          var d = this._map, v = this.getTileSize(), w = r.scaleBy(v), O = w.add(v), H = d.unproject(w, r.z), q = d.unproject(O, r.z);
          return [H, q];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(r) {
          var d = this._tileCoordsToNwSe(r), v = new bt(d[0], d[1]);
          return this.options.noWrap || (v = this._map.wrapLatLngBounds(v)), v;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(r) {
          return r.x + ":" + r.y + ":" + r.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(r) {
          var d = r.split(":"), v = new ut(+d[0], +d[1]);
          return v.z = +d[2], v;
        },
        _removeTile: function(r) {
          var d = this._tiles[r];
          d && (ln(d.el), delete this._tiles[r], this.fire("tileunload", {
            tile: d.el,
            coords: this._keyToTileCoords(r)
          }));
        },
        _initTile: function(r) {
          le(r, "leaflet-tile");
          var d = this.getTileSize();
          r.style.width = d.x + "px", r.style.height = d.y + "px", r.onselectstart = C, r.onmousemove = C, It.ielt9 && this.options.opacity < 1 && Di(r, this.options.opacity);
        },
        _addTile: function(r, d) {
          var v = this._getTilePos(r), w = this._tileCoordsToKey(r), O = this.createTile(this._wrapCoords(r), _(this._tileReady, this, r));
          this._initTile(O), this.createTile.length < 2 && Rt(_(this._tileReady, this, r, null, O)), yn(O, v), this._tiles[w] = {
            el: O,
            coords: r,
            current: !0
          }, d.appendChild(O), this.fire("tileloadstart", {
            tile: O,
            coords: r
          });
        },
        _tileReady: function(r, d, v) {
          d && this.fire("tileerror", {
            error: d,
            tile: v,
            coords: r
          });
          var w = this._tileCoordsToKey(r);
          v = this._tiles[w], v && (v.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (Di(v.el, 0), Nt(this._fadeFrame), this._fadeFrame = Rt(this._updateOpacity, this)) : (v.active = !0, this._pruneTiles()), d || (le(v.el, "leaflet-tile-loaded"), this.fire("tileload", {
            tile: v.el,
            coords: r
          })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), It.ielt9 || !this._map._fadeAnimated ? Rt(this._pruneTiles, this) : setTimeout(_(this._pruneTiles, this), 250)));
        },
        _getTilePos: function(r) {
          return r.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(r) {
          var d = new ut(
            this._wrapX ? D(r.x, this._wrapX) : r.x,
            this._wrapY ? D(r.y, this._wrapY) : r.y
          );
          return d.z = r.z, d;
        },
        _pxBoundsToTileRange: function(r) {
          var d = this.getTileSize();
          return new F(
            r.min.unscaleBy(d).floor(),
            r.max.unscaleBy(d).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var r in this._tiles)
            if (!this._tiles[r].loaded)
              return !1;
          return !0;
        }
      });
      function xa(r) {
        return new Co(r);
      }
      var kl = Co.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: !1,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: !1,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: !1
        },
        initialize: function(r, d) {
          this._url = r, d = Q(this, d), d.detectRetina && It.retina && d.maxZoom > 0 ? (d.tileSize = Math.floor(d.tileSize / 2), d.zoomReverse ? (d.zoomOffset--, d.minZoom = Math.min(d.maxZoom, d.minZoom + 1)) : (d.zoomOffset++, d.maxZoom = Math.max(d.minZoom, d.maxZoom - 1)), d.minZoom = Math.max(0, d.minZoom)) : d.zoomReverse ? d.minZoom = Math.min(d.maxZoom, d.minZoom) : d.maxZoom = Math.max(d.minZoom, d.maxZoom), typeof d.subdomains == "string" && (d.subdomains = d.subdomains.split("")), this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(r, d) {
          return this._url === r && d === void 0 && (d = !0), this._url = r, d || this.redraw(), this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(r, d) {
          var v = document.createElement("img");
          return ce(v, "load", _(this._tileOnLoad, this, d, v)), ce(v, "error", _(this._tileOnError, this, d, v)), (this.options.crossOrigin || this.options.crossOrigin === "") && (v.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), typeof this.options.referrerPolicy == "string" && (v.referrerPolicy = this.options.referrerPolicy), v.alt = "", v.src = this.getTileUrl(r), v;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(r) {
          var d = {
            r: It.retina ? "@2x" : "",
            s: this._getSubdomain(r),
            x: r.x,
            y: r.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var v = this._globalTileRange.max.y - r.y;
            this.options.tms && (d.y = v), d["-y"] = v;
          }
          return Dt(this._url, h(d, this.options));
        },
        _tileOnLoad: function(r, d) {
          It.ielt9 ? setTimeout(_(r, this, null, d), 0) : r(null, d);
        },
        _tileOnError: function(r, d, v) {
          var w = this.options.errorTileUrl;
          w && d.getAttribute("src") !== w && (d.src = w), r(v, d);
        },
        _onTileRemove: function(r) {
          r.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var r = this._tileZoom, d = this.options.maxZoom, v = this.options.zoomReverse, w = this.options.zoomOffset;
          return v && (r = d - r), r + w;
        },
        _getSubdomain: function(r) {
          var d = Math.abs(r.x + r.y) % this.options.subdomains.length;
          return this.options.subdomains[d];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var r, d;
          for (r in this._tiles)
            if (this._tiles[r].coords.z !== this._tileZoom && (d = this._tiles[r].el, d.onload = C, d.onerror = C, !d.complete)) {
              d.src = dt;
              var v = this._tiles[r].coords;
              ln(d), delete this._tiles[r], this.fire("tileabort", {
                tile: d,
                coords: v
              });
            }
        },
        _removeTile: function(r) {
          var d = this._tiles[r];
          if (d)
            return d.el.setAttribute("src", dt), Co.prototype._removeTile.call(this, r);
        },
        _tileReady: function(r, d, v) {
          if (!(!this._map || v && v.getAttribute("src") === dt))
            return Co.prototype._tileReady.call(this, r, d, v);
        }
      });
      function Pi(r, d) {
        return new kl(r, d);
      }
      var Ci = kl.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: !1,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: !1
        },
        initialize: function(r, d) {
          this._url = r;
          var v = h({}, this.defaultWmsParams);
          for (var w in d)
            w in this.options || (v[w] = d[w]);
          d = Q(this, d);
          var O = d.detectRetina && It.retina ? 2 : 1, H = this.getTileSize();
          v.width = H.x * O, v.height = H.y * O, this.wmsParams = v;
        },
        onAdd: function(r) {
          this._crs = this.options.crs || r.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
          var d = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[d] = this._crs.code, kl.prototype.onAdd.call(this, r);
        },
        getTileUrl: function(r) {
          var d = this._tileCoordsToNwSe(r), v = this._crs, w = ct(v.project(d[0]), v.project(d[1])), O = w.min, H = w.max, q = (this._wmsVersion >= 1.3 && this._crs === bc ? [O.y, O.x, H.y, H.x] : [O.x, O.y, H.x, H.y]).join(","), $ = kl.prototype.getTileUrl.call(this, r);
          return $ + X(this.wmsParams, $, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + q;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(r, d) {
          return h(this.wmsParams, r), d || this.redraw(), this;
        }
      });
      function Nl(r, d) {
        return new Ci(r, d);
      }
      kl.WMS = Ci, Pi.wms = Nl;
      var Gn = ba.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(r) {
          Q(this, r), T(this), this._layers = this._layers || {};
        },
        onAdd: function() {
          this._container || (this._initContainer(), le(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this), this._destroyContainer();
        },
        getEvents: function() {
          var r = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          return this._zoomAnimated && (r.zoomanim = this._onAnimZoom), r;
        },
        _onAnimZoom: function(r) {
          this._updateTransform(r.center, r.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(r, d) {
          var v = this._map.getZoomScale(d, this._zoom), w = this._map.getSize().multiplyBy(0.5 + this.options.padding), O = this._map.project(this._center, d), H = w.multiplyBy(-v).add(O).subtract(this._map._getNewPixelOrigin(r, d));
          It.any3d ? ia(this._container, H, v) : yn(this._container, H);
        },
        _reset: function() {
          this._update(), this._updateTransform(this._center, this._zoom);
          for (var r in this._layers)
            this._layers[r]._reset();
        },
        _onZoomEnd: function() {
          for (var r in this._layers)
            this._layers[r]._project();
        },
        _updatePaths: function() {
          for (var r in this._layers)
            this._layers[r]._update();
        },
        _update: function() {
          var r = this.options.padding, d = this._map.getSize(), v = this._map.containerPointToLayerPoint(d.multiplyBy(-r)).round();
          this._bounds = new F(v, v.add(d.multiplyBy(1 + r * 2)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
        }
      }), wa = Gn.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var r = Gn.prototype.getEvents.call(this);
          return r.viewprereset = this._onViewPreReset, r;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = !0;
        },
        onAdd: function() {
          Gn.prototype.onAdd.call(this), this._draw();
        },
        _initContainer: function() {
          var r = this._container = document.createElement("canvas");
          ce(r, "mousemove", this._onMouseMove, this), ce(r, "click dblclick mousedown mouseup contextmenu", this._onClick, this), ce(r, "mouseout", this._handleMouseOut, this), r._leaflet_disable_events = !0, this._ctx = r.getContext("2d");
        },
        _destroyContainer: function() {
          Nt(this._redrawRequest), delete this._ctx, ln(this._container), Ye(this._container), delete this._container;
        },
        _updatePaths: function() {
          if (!this._postponeUpdatePaths) {
            var r;
            this._redrawBounds = null;
            for (var d in this._layers)
              r = this._layers[d], r._update();
            this._redraw();
          }
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            Gn.prototype._update.call(this);
            var r = this._bounds, d = this._container, v = r.getSize(), w = It.retina ? 2 : 1;
            yn(d, r.min), d.width = w * v.x, d.height = w * v.y, d.style.width = v.x + "px", d.style.height = v.y + "px", It.retina && this._ctx.scale(2, 2), this._ctx.translate(-r.min.x, -r.min.y), this.fire("update");
          }
        },
        _reset: function() {
          Gn.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());
        },
        _initPath: function(r) {
          this._updateDashArray(r), this._layers[T(r)] = r;
          var d = r._order = {
            layer: r,
            prev: this._drawLast,
            next: null
          };
          this._drawLast && (this._drawLast.next = d), this._drawLast = d, this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(r) {
          this._requestRedraw(r);
        },
        _removePath: function(r) {
          var d = r._order, v = d.next, w = d.prev;
          v ? v.prev = w : this._drawLast = w, w ? w.next = v : this._drawFirst = v, delete r._order, delete this._layers[T(r)], this._requestRedraw(r);
        },
        _updatePath: function(r) {
          this._extendRedrawBounds(r), r._project(), r._update(), this._requestRedraw(r);
        },
        _updateStyle: function(r) {
          this._updateDashArray(r), this._requestRedraw(r);
        },
        _updateDashArray: function(r) {
          if (typeof r.options.dashArray == "string") {
            var d = r.options.dashArray.split(/[, ]+/), v = [], w, O;
            for (O = 0; O < d.length; O++) {
              if (w = Number(d[O]), isNaN(w))
                return;
              v.push(w);
            }
            r.options._dashArray = v;
          } else
            r.options._dashArray = r.options.dashArray;
        },
        _requestRedraw: function(r) {
          this._map && (this._extendRedrawBounds(r), this._redrawRequest = this._redrawRequest || Rt(this._redraw, this));
        },
        _extendRedrawBounds: function(r) {
          if (r._pxBounds) {
            var d = (r.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new F(), this._redrawBounds.extend(r._pxBounds.min.subtract([d, d])), this._redrawBounds.extend(r._pxBounds.max.add([d, d]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
        },
        _clear: function() {
          var r = this._redrawBounds;
          if (r) {
            var d = r.getSize();
            this._ctx.clearRect(r.min.x, r.min.y, d.x, d.y);
          } else
            this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore();
        },
        _draw: function() {
          var r, d = this._redrawBounds;
          if (this._ctx.save(), d) {
            var v = d.getSize();
            this._ctx.beginPath(), this._ctx.rect(d.min.x, d.min.y, v.x, v.y), this._ctx.clip();
          }
          this._drawing = !0;
          for (var w = this._drawFirst; w; w = w.next)
            r = w.layer, (!d || r._pxBounds && r._pxBounds.intersects(d)) && r._updatePath();
          this._drawing = !1, this._ctx.restore();
        },
        _updatePoly: function(r, d) {
          if (this._drawing) {
            var v, w, O, H, q = r._parts, $ = q.length, rt = this._ctx;
            if ($) {
              for (rt.beginPath(), v = 0; v < $; v++) {
                for (w = 0, O = q[v].length; w < O; w++)
                  H = q[v][w], rt[w ? "lineTo" : "moveTo"](H.x, H.y);
                d && rt.closePath();
              }
              this._fillStroke(rt, r);
            }
          }
        },
        _updateCircle: function(r) {
          if (!(!this._drawing || r._empty())) {
            var d = r._point, v = this._ctx, w = Math.max(Math.round(r._radius), 1), O = (Math.max(Math.round(r._radiusY), 1) || w) / w;
            O !== 1 && (v.save(), v.scale(1, O)), v.beginPath(), v.arc(d.x, d.y / O, w, 0, Math.PI * 2, !1), O !== 1 && v.restore(), this._fillStroke(v, r);
          }
        },
        _fillStroke: function(r, d) {
          var v = d.options;
          v.fill && (r.globalAlpha = v.fillOpacity, r.fillStyle = v.fillColor || v.color, r.fill(v.fillRule || "evenodd")), v.stroke && v.weight !== 0 && (r.setLineDash && r.setLineDash(d.options && d.options._dashArray || []), r.globalAlpha = v.opacity, r.lineWidth = v.weight, r.strokeStyle = v.color, r.lineCap = v.lineCap, r.lineJoin = v.lineJoin, r.stroke());
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(r) {
          for (var d = this._map.mouseEventToLayerPoint(r), v, w, O = this._drawFirst; O; O = O.next)
            v = O.layer, v.options.interactive && v._containsPoint(d) && (!(r.type === "click" || r.type === "preclick") || !this._map._draggableMoved(v)) && (w = v);
          this._fireEvent(w ? [w] : !1, r);
        },
        _onMouseMove: function(r) {
          if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
            var d = this._map.mouseEventToLayerPoint(r);
            this._handleMouseHover(r, d);
          }
        },
        _handleMouseOut: function(r) {
          var d = this._hoveredLayer;
          d && (Fe(this._container, "leaflet-interactive"), this._fireEvent([d], r, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1);
        },
        _handleMouseHover: function(r, d) {
          if (!this._mouseHoverThrottled) {
            for (var v, w, O = this._drawFirst; O; O = O.next)
              v = O.layer, v.options.interactive && v._containsPoint(d) && (w = v);
            w !== this._hoveredLayer && (this._handleMouseOut(r), w && (le(this._container, "leaflet-interactive"), this._fireEvent([w], r, "mouseover"), this._hoveredLayer = w)), this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, r), this._mouseHoverThrottled = !0, setTimeout(_(function() {
              this._mouseHoverThrottled = !1;
            }, this), 32);
          }
        },
        _fireEvent: function(r, d, v) {
          this._map._fireDOMEvent(d, v || d.type, r);
        },
        _bringToFront: function(r) {
          var d = r._order;
          if (d) {
            var v = d.next, w = d.prev;
            if (v)
              v.prev = w;
            else
              return;
            w ? w.next = v : v && (this._drawFirst = v), d.prev = this._drawLast, this._drawLast.next = d, d.next = null, this._drawLast = d, this._requestRedraw(r);
          }
        },
        _bringToBack: function(r) {
          var d = r._order;
          if (d) {
            var v = d.next, w = d.prev;
            if (w)
              w.next = v;
            else
              return;
            v ? v.prev = w : w && (this._drawLast = w), d.prev = null, d.next = this._drawFirst, this._drawFirst.prev = d, this._drawFirst = d, this._requestRedraw(r);
          }
        }
      });
      function ll(r) {
        return It.canvas ? new wa(r) : null;
      }
      var zo = function() {
        try {
          return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(r) {
            return document.createElement("<lvml:" + r + ' class="lvml">');
          };
        } catch {
        }
        return function(r) {
          return document.createElement("<" + r + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }(), Lo = {
        _initContainer: function() {
          this._container = we("div", "leaflet-vml-container");
        },
        _update: function() {
          this._map._animatingZoom || (Gn.prototype._update.call(this), this.fire("update"));
        },
        _initPath: function(r) {
          var d = r._container = zo("shape");
          le(d, "leaflet-vml-shape " + (this.options.className || "")), d.coordsize = "1 1", r._path = zo("path"), d.appendChild(r._path), this._updateStyle(r), this._layers[T(r)] = r;
        },
        _addPath: function(r) {
          var d = r._container;
          this._container.appendChild(d), r.options.interactive && r.addInteractiveTarget(d);
        },
        _removePath: function(r) {
          var d = r._container;
          ln(d), r.removeInteractiveTarget(d), delete this._layers[T(r)];
        },
        _updateStyle: function(r) {
          var d = r._stroke, v = r._fill, w = r.options, O = r._container;
          O.stroked = !!w.stroke, O.filled = !!w.fill, w.stroke ? (d || (d = r._stroke = zo("stroke")), O.appendChild(d), d.weight = w.weight + "px", d.color = w.color, d.opacity = w.opacity, w.dashArray ? d.dashStyle = Et(w.dashArray) ? w.dashArray.join(" ") : w.dashArray.replace(/( *, *)/g, " ") : d.dashStyle = "", d.endcap = w.lineCap.replace("butt", "flat"), d.joinstyle = w.lineJoin) : d && (O.removeChild(d), r._stroke = null), w.fill ? (v || (v = r._fill = zo("fill")), O.appendChild(v), v.color = w.fillColor || w.color, v.opacity = w.fillOpacity) : v && (O.removeChild(v), r._fill = null);
        },
        _updateCircle: function(r) {
          var d = r._point.round(), v = Math.round(r._radius), w = Math.round(r._radiusY || v);
          this._setPath(r, r._empty() ? "M0 0" : "AL " + d.x + "," + d.y + " " + v + "," + w + " 0," + 65535 * 360);
        },
        _setPath: function(r, d) {
          r._path.v = d;
        },
        _bringToFront: function(r) {
          bo(r._container);
        },
        _bringToBack: function(r) {
          xl(r._container);
        }
      }, sl = It.vml ? zo : cr, rl = Gn.extend({
        _initContainer: function() {
          this._container = sl("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = sl("g"), this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          ln(this._container), Ye(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            Gn.prototype._update.call(this);
            var r = this._bounds, d = r.getSize(), v = this._container;
            (!this._svgSize || !this._svgSize.equals(d)) && (this._svgSize = d, v.setAttribute("width", d.x), v.setAttribute("height", d.y)), yn(v, r.min), v.setAttribute("viewBox", [r.min.x, r.min.y, d.x, d.y].join(" ")), this.fire("update");
          }
        },
        // methods below are called by vector layers implementations
        _initPath: function(r) {
          var d = r._path = sl("path");
          r.options.className && le(d, r.options.className), r.options.interactive && le(d, "leaflet-interactive"), this._updateStyle(r), this._layers[T(r)] = r;
        },
        _addPath: function(r) {
          this._rootGroup || this._initContainer(), this._rootGroup.appendChild(r._path), r.addInteractiveTarget(r._path);
        },
        _removePath: function(r) {
          ln(r._path), r.removeInteractiveTarget(r._path), delete this._layers[T(r)];
        },
        _updatePath: function(r) {
          r._project(), r._update();
        },
        _updateStyle: function(r) {
          var d = r._path, v = r.options;
          d && (v.stroke ? (d.setAttribute("stroke", v.color), d.setAttribute("stroke-opacity", v.opacity), d.setAttribute("stroke-width", v.weight), d.setAttribute("stroke-linecap", v.lineCap), d.setAttribute("stroke-linejoin", v.lineJoin), v.dashArray ? d.setAttribute("stroke-dasharray", v.dashArray) : d.removeAttribute("stroke-dasharray"), v.dashOffset ? d.setAttribute("stroke-dashoffset", v.dashOffset) : d.removeAttribute("stroke-dashoffset")) : d.setAttribute("stroke", "none"), v.fill ? (d.setAttribute("fill", v.fillColor || v.color), d.setAttribute("fill-opacity", v.fillOpacity), d.setAttribute("fill-rule", v.fillRule || "evenodd")) : d.setAttribute("fill", "none"));
        },
        _updatePoly: function(r, d) {
          this._setPath(r, Tn(r._parts, d));
        },
        _updateCircle: function(r) {
          var d = r._point, v = Math.max(Math.round(r._radius), 1), w = Math.max(Math.round(r._radiusY), 1) || v, O = "a" + v + "," + w + " 0 1,0 ", H = r._empty() ? "M0 0" : "M" + (d.x - v) + "," + d.y + O + v * 2 + ",0 " + O + -v * 2 + ",0 ";
          this._setPath(r, H);
        },
        _setPath: function(r, d) {
          r._path.setAttribute("d", d);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(r) {
          bo(r._path);
        },
        _bringToBack: function(r) {
          xl(r._path);
        }
      });
      It.vml && rl.include(Lo);
      function Us(r) {
        return It.svg || It.vml ? new rl(r) : null;
      }
      Oe.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(r) {
          var d = r.options.renderer || this._getPaneRenderer(r.options.pane) || this.options.renderer || this._renderer;
          return d || (d = this._renderer = this._createRenderer()), this.hasLayer(d) || this.addLayer(d), d;
        },
        _getPaneRenderer: function(r) {
          if (r === "overlayPane" || r === void 0)
            return !1;
          var d = this._paneRenderers[r];
          return d === void 0 && (d = this._createRenderer({ pane: r }), this._paneRenderers[r] = d), d;
        },
        _createRenderer: function(r) {
          return this.options.preferCanvas && ll(r) || Us(r);
        }
      });
      var Pf = Ll.extend({
        initialize: function(r, d) {
          Ll.prototype.initialize.call(this, this._boundsToLatLngs(r), d);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(r) {
          return this.setLatLngs(this._boundsToLatLngs(r));
        },
        _boundsToLatLngs: function(r) {
          return r = Mt(r), [
            r.getSouthWest(),
            r.getNorthWest(),
            r.getNorthEast(),
            r.getSouthEast()
          ];
        }
      });
      function Vi(r, d) {
        return new Pf(r, d);
      }
      rl.create = sl, rl.pointsToPath = Tn, yi.geometryToLayer = Ja, yi.coordsToLatLng = Ls, yi.coordsToLatLngs = xr, yi.latLngToCoords = Hs, yi.latLngsToCoords = Ao, yi.getFeature = Ri, yi.asFeature = Zi, Oe.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: !0
      });
      var wr = _a.extend({
        initialize: function(r) {
          this._map = r, this._container = r._container, this._pane = r._panes.overlayPane, this._resetStateTimeout = 0, r.on("unload", this._destroy, this);
        },
        addHooks: function() {
          ce(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          Ye(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          ln(this._pane), delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0, this._moved = !1;
        },
        _clearDeferredResetState: function() {
          this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
        },
        _onMouseDown: function(r) {
          if (!r.shiftKey || r.which !== 1 && r.button !== 1)
            return !1;
          this._clearDeferredResetState(), this._resetState(), To(), Fo(), this._startPoint = this._map.mouseEventToContainerPoint(r), ce(document, {
            contextmenu: xo,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(r) {
          this._moved || (this._moved = !0, this._box = we("div", "leaflet-zoom-box", this._container), le(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(r);
          var d = new F(this._point, this._startPoint), v = d.getSize();
          yn(this._box, d.min), this._box.style.width = v.x + "px", this._box.style.height = v.y + "px";
        },
        _finish: function() {
          this._moved && (ln(this._box), Fe(this._container, "leaflet-crosshair")), gr(), Cf(), Ye(document, {
            contextmenu: xo,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(r) {
          if (!(r.which !== 1 && r.button !== 1) && (this._finish(), !!this._moved)) {
            this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(_(this._resetState, this), 0);
            var d = new bt(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(d).fire("boxzoomend", { boxZoomBounds: d });
          }
        },
        _onKeyDown: function(r) {
          r.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
        }
      });
      Oe.addInitHook("addHandler", "boxZoom", wr), Oe.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: !0
      });
      var Ma = _a.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(r) {
          var d = this._map, v = d.getZoom(), w = d.options.zoomDelta, O = r.originalEvent.shiftKey ? v - w : v + w;
          d.options.doubleClickZoom === "center" ? d.setZoom(O) : d.setZoomAround(r.containerPoint, O);
        }
      });
      Oe.addInitHook("addHandler", "doubleClickZoom", Ma), Oe.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: !0,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: !0,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second².
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: 1 / 0,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: !1,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var ye = _a.extend({
        addHooks: function() {
          if (!this._draggable) {
            var r = this._map;
            this._draggable = new wo(r._mapPane, r._container), this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this), this._draggable.on("predrag", this._onPreDragLimit, this), r.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), r.on("zoomend", this._onZoomEnd, this), r.whenReady(this._onZoomEnd, this));
          }
          le(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
        },
        removeHooks: function() {
          Fe(this._map._container, "leaflet-grab"), Fe(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var r = this._map;
          if (r._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var d = Mt(this._map.options.maxBounds);
            this._offsetLimit = ct(
              this._map.latLngToContainerPoint(d.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(d.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            ), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else
            this._offsetLimit = null;
          r.fire("movestart").fire("dragstart"), r.options.inertia && (this._positions = [], this._times = []);
        },
        _onDrag: function(r) {
          if (this._map.options.inertia) {
            var d = this._lastTime = +/* @__PURE__ */ new Date(), v = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(v), this._times.push(d), this._prunePositions(d);
          }
          this._map.fire("move", r).fire("drag", r);
        },
        _prunePositions: function(r) {
          for (; this._positions.length > 1 && r - this._times[0] > 50; )
            this._positions.shift(), this._times.shift();
        },
        _onZoomEnd: function() {
          var r = this._map.getSize().divideBy(2), d = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = d.subtract(r).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(r, d) {
          return r - (r - d) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!(!this._viscosity || !this._offsetLimit)) {
            var r = this._draggable._newPos.subtract(this._draggable._startPos), d = this._offsetLimit;
            r.x < d.min.x && (r.x = this._viscousLimit(r.x, d.min.x)), r.y < d.min.y && (r.y = this._viscousLimit(r.y, d.min.y)), r.x > d.max.x && (r.x = this._viscousLimit(r.x, d.max.x)), r.y > d.max.y && (r.y = this._viscousLimit(r.y, d.max.y)), this._draggable._newPos = this._draggable._startPos.add(r);
          }
        },
        _onPreDragWrap: function() {
          var r = this._worldWidth, d = Math.round(r / 2), v = this._initialWorldOffset, w = this._draggable._newPos.x, O = (w - d + v) % r + d - v, H = (w + d + v) % r - d - v, q = Math.abs(O + v) < Math.abs(H + v) ? O : H;
          this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = q;
        },
        _onDragEnd: function(r) {
          var d = this._map, v = d.options, w = !v.inertia || r.noInertia || this._times.length < 2;
          if (d.fire("dragend", r), w)
            d.fire("moveend");
          else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var O = this._lastPos.subtract(this._positions[0]), H = (this._lastTime - this._times[0]) / 1e3, q = v.easeLinearity, $ = O.multiplyBy(q / H), rt = $.distanceTo([0, 0]), xt = Math.min(v.inertiaMaxSpeed, rt), Ut = $.multiplyBy(xt / rt), qt = xt / (v.inertiaDeceleration * q), Zt = Ut.multiplyBy(-qt / 2).round();
            !Zt.x && !Zt.y ? d.fire("moveend") : (Zt = d._limitOffset(Zt, d.options.maxBounds), Rt(function() {
              d.panBy(Zt, {
                duration: qt,
                easeLinearity: q,
                noMoveStart: !0,
                animate: !0
              });
            }));
          }
        }
      });
      Oe.addInitHook("addHandler", "dragging", ye), Oe.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: !0,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Ot = _a.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(r) {
          this._map = r, this._setPanDelta(r.options.keyboardPanDelta), this._setZoomDelta(r.options.zoomDelta);
        },
        addHooks: function() {
          var r = this._map._container;
          r.tabIndex <= 0 && (r.tabIndex = "0"), ce(r, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks(), Ye(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (!this._focused) {
            var r = document.body, d = document.documentElement, v = r.scrollTop || d.scrollTop, w = r.scrollLeft || d.scrollLeft;
            this._map._container.focus(), window.scrollTo(w, v);
          }
        },
        _onFocus: function() {
          this._focused = !0, this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = !1, this._map.fire("blur");
        },
        _setPanDelta: function(r) {
          var d = this._panKeys = {}, v = this.keyCodes, w, O;
          for (w = 0, O = v.left.length; w < O; w++)
            d[v.left[w]] = [-1 * r, 0];
          for (w = 0, O = v.right.length; w < O; w++)
            d[v.right[w]] = [r, 0];
          for (w = 0, O = v.down.length; w < O; w++)
            d[v.down[w]] = [0, r];
          for (w = 0, O = v.up.length; w < O; w++)
            d[v.up[w]] = [0, -1 * r];
        },
        _setZoomDelta: function(r) {
          var d = this._zoomKeys = {}, v = this.keyCodes, w, O;
          for (w = 0, O = v.zoomIn.length; w < O; w++)
            d[v.zoomIn[w]] = r;
          for (w = 0, O = v.zoomOut.length; w < O; w++)
            d[v.zoomOut[w]] = -r;
        },
        _addHooks: function() {
          ce(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          Ye(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(r) {
          if (!(r.altKey || r.ctrlKey || r.metaKey)) {
            var d = r.keyCode, v = this._map, w;
            if (d in this._panKeys) {
              if (!v._panAnim || !v._panAnim._inProgress)
                if (w = this._panKeys[d], r.shiftKey && (w = k(w).multiplyBy(3)), v.options.maxBounds && (w = v._limitOffset(k(w), v.options.maxBounds)), v.options.worldCopyJump) {
                  var O = v.wrapLatLng(v.unproject(v.project(v.getCenter()).add(w)));
                  v.panTo(O);
                } else
                  v.panBy(w);
            } else if (d in this._zoomKeys)
              v.setZoom(v.getZoom() + (r.shiftKey ? 3 : 1) * this._zoomKeys[d]);
            else if (d === 27 && v._popup && v._popup.options.closeOnEscapeKey)
              v.closePopup();
            else
              return;
            xo(r);
          }
        }
      });
      Oe.addInitHook("addHandler", "keyboard", Ot), Oe.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: !0,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var oa = _a.extend({
        addHooks: function() {
          ce(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
        },
        removeHooks: function() {
          Ye(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(r) {
          var d = _u(r), v = this._map.options.wheelDebounceTime;
          this._delta += d, this._lastMousePos = this._map.mouseEventToContainerPoint(r), this._startTime || (this._startTime = +/* @__PURE__ */ new Date());
          var w = Math.max(v - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer), this._timer = setTimeout(_(this._performZoom, this), w), xo(r);
        },
        _performZoom: function() {
          var r = this._map, d = r.getZoom(), v = this._map.options.zoomSnap || 0;
          r._stop();
          var w = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), O = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(w)))) / Math.LN2, H = v ? Math.ceil(O / v) * v : O, q = r._limitZoom(d + (this._delta > 0 ? H : -H)) - d;
          this._delta = 0, this._startTime = null, q && (r.options.scrollWheelZoom === "center" ? r.setZoom(d + q) : r.setZoomAround(this._lastMousePos, d + q));
        }
      });
      Oe.addInitHook("addHandler", "scrollWheelZoom", oa);
      var Mr = 600;
      Oe.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: It.touchNative && It.safari && It.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var cn = _a.extend({
        addHooks: function() {
          ce(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          Ye(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(r) {
          if (clearTimeout(this._holdTimeout), r.touches.length === 1) {
            var d = r.touches[0];
            this._startPos = this._newPos = new ut(d.clientX, d.clientY), this._holdTimeout = setTimeout(_(function() {
              this._cancel(), this._isTapValid() && (ce(document, "touchend", Ue), ce(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", d));
            }, this), Mr), ce(document, "touchend touchcancel contextmenu", this._cancel, this), ce(document, "touchmove", this._onMove, this);
          }
        },
        _cancelClickPrevent: function r() {
          Ye(document, "touchend", Ue), Ye(document, "touchend touchcancel", r);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout), Ye(document, "touchend touchcancel contextmenu", this._cancel, this), Ye(document, "touchmove", this._onMove, this);
        },
        _onMove: function(r) {
          var d = r.touches[0];
          this._newPos = new ut(d.clientX, d.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(r, d) {
          var v = new MouseEvent(r, {
            bubbles: !0,
            cancelable: !0,
            view: window,
            // detail: 1,
            screenX: d.screenX,
            screenY: d.screenY,
            clientX: d.clientX,
            clientY: d.clientY
            // button: 2,
            // buttons: 2
          });
          v._simulated = !0, d.target.dispatchEvent(v);
        }
      });
      Oe.addInitHook("addHandler", "tapHold", cn), Oe.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: It.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: !0
      });
      var ul = _a.extend({
        addHooks: function() {
          le(this._map._container, "leaflet-touch-zoom"), ce(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          Fe(this._map._container, "leaflet-touch-zoom"), Ye(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(r) {
          var d = this._map;
          if (!(!r.touches || r.touches.length !== 2 || d._animatingZoom || this._zooming)) {
            var v = d.mouseEventToContainerPoint(r.touches[0]), w = d.mouseEventToContainerPoint(r.touches[1]);
            this._centerPoint = d.getSize()._divideBy(2), this._startLatLng = d.containerPointToLatLng(this._centerPoint), d.options.touchZoom !== "center" && (this._pinchStartLatLng = d.containerPointToLatLng(v.add(w)._divideBy(2))), this._startDist = v.distanceTo(w), this._startZoom = d.getZoom(), this._moved = !1, this._zooming = !0, d._stop(), ce(document, "touchmove", this._onTouchMove, this), ce(document, "touchend touchcancel", this._onTouchEnd, this), Ue(r);
          }
        },
        _onTouchMove: function(r) {
          if (!(!r.touches || r.touches.length !== 2 || !this._zooming)) {
            var d = this._map, v = d.mouseEventToContainerPoint(r.touches[0]), w = d.mouseEventToContainerPoint(r.touches[1]), O = v.distanceTo(w) / this._startDist;
            if (this._zoom = d.getScaleZoom(O, this._startZoom), !d.options.bounceAtZoomLimits && (this._zoom < d.getMinZoom() && O < 1 || this._zoom > d.getMaxZoom() && O > 1) && (this._zoom = d._limitZoom(this._zoom)), d.options.touchZoom === "center") {
              if (this._center = this._startLatLng, O === 1)
                return;
            } else {
              var H = v._add(w)._divideBy(2)._subtract(this._centerPoint);
              if (O === 1 && H.x === 0 && H.y === 0)
                return;
              this._center = d.unproject(d.project(this._pinchStartLatLng, this._zoom).subtract(H), this._zoom);
            }
            this._moved || (d._moveStart(!0, !1), this._moved = !0), Nt(this._animRequest);
            var q = _(d._move, d, this._center, this._zoom, { pinch: !0, round: !1 }, void 0);
            this._animRequest = Rt(q, this, !0), Ue(r);
          }
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = !1;
            return;
          }
          this._zooming = !1, Nt(this._animRequest), Ye(document, "touchmove", this._onTouchMove, this), Ye(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom));
        }
      });
      Oe.addInitHook("addHandler", "touchZoom", ul), Oe.BoxZoom = wr, Oe.DoubleClickZoom = Ma, Oe.Drag = ye, Oe.Keyboard = Ot, Oe.ScrollWheelZoom = oa, Oe.TapHold = cn, Oe.TouchZoom = ul, l.Bounds = F, l.Browser = It, l.CRS = We, l.Canvas = wa, l.Circle = Tr, l.CircleMarker = ol, l.Class = ge, l.Control = Jn, l.DivIcon = wc, l.DivOverlay = Ta, l.DomEvent = xd, l.DomUtil = Td, l.Draggable = wo, l.Evented = mt, l.FeatureGroup = jn, l.GeoJSON = yi, l.GridLayer = Co, l.Handler = _a, l.Icon = Cl, l.ImageOverlay = Sa, l.LatLng = Ht, l.LatLngBounds = bt, l.Layer = ba, l.LayerGroup = al, l.LineUtil = Bf, l.Map = Oe, l.Marker = Oo, l.Mixin = Od, l.Path = Do, l.Point = ut, l.PolyUtil = Wa, l.Polygon = Ll, l.Polyline = Fn, l.Popup = Tu, l.PosAnimation = yc, l.Projection = Al, l.Rectangle = Pf, l.Renderer = Gn, l.SVG = rl, l.SVGOverlay = to, l.TileLayer = kl, l.Tooltip = Ns, l.Transformation = da, l.Util = Ee, l.VideoOverlay = aa, l.bind = _, l.bounds = ct, l.canvas = ll, l.circle = zl, l.circleMarker = Yf, l.control = Os, l.divIcon = Zf, l.extend = h, l.featureGroup = $a, l.geoJSON = Hl, l.geoJson = xc, l.gridLayer = xa, l.icon = Eo, l.imageOverlay = ks, l.latLng = Tt, l.latLngBounds = Mt, l.layerGroup = Sc, l.map = bu, l.marker = zs, l.point = k, l.polygon = ti, l.polyline = jf, l.popup = qf, l.rectangle = Vi, l.setOptions = Q, l.stamp = T, l.svg = Us, l.svgOverlay = Rd, l.tileLayer = Pi, l.tooltip = Cd, l.transformation = Za, l.version = u, l.videoOverlay = Fa;
      var Ul = window.L;
      l.noConflict = function() {
        return window.L = Ul, this;
      }, window.L = l;
    });
  }(uv, uv.exports)), uv.exports;
}
var Iz = Wz();
const pv = /* @__PURE__ */ HE(Iz);
delete pv.Icon.Default.prototype._getIconUrl;
pv.Icon.Default.mergeOptions({
  iconRetinaUrl: "/images/marker-icon-2x.png",
  iconUrl: "/images/marker-icon.png",
  shadowUrl: "/images/marker-shadow.png"
});
function $z({ offers: s, center: i }) {
  const l = si.useRef(null);
  return si.useEffect(() => {
    if (!l.current) return;
    const u = pv.map(l.current).setView(i || [52.2297, 21.0122], i ? 13 : 6);
    return pv.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(u), s.forEach((h) => {
      h.pharmacy_lat && h.pharmacy_lon && pv.marker([h.pharmacy_lat, h.pharmacy_lon]).addTo(u);
    }), () => {
      u.remove();
    };
  }, [s, i]), /* @__PURE__ */ Qt.jsx("div", { id: "map", ref: l, style: { height: "300px" } });
}
function Jz() {
  const [s, i] = si.useState(""), [l, u] = si.useState(""), [h, g] = si.useState([]), [_, S] = si.useState([]), [T, E] = si.useState("price"), [D, C] = si.useState("asc"), [z, j] = si.useState(0), [I, Q] = si.useState(0), [X, nt] = si.useState(!1), [Dt, Et] = si.useState(null), zt = 50;
  return si.useEffect(() => {
    document.body.classList.add(localStorage.getItem("theme") || "dark");
  }, []), si.useEffect(() => {
    if (!s) {
      g([]), S([]), j(0), Et(null);
      return;
    }
    nt(!0), Et(null);
    const dt = new URLSearchParams({
      limit: String(zt),
      offset: String(I),
      sort: T,
      order: D
    });
    l && dt.append("city", l), fetch(`/api/product/${encodeURIComponent(s)}?${dt}`).then((Lt) => {
      if (!Lt.ok) throw new Error(`HTTP ${Lt.status} - ${Lt.statusText}`);
      return Lt.json();
    }).then((Lt) => {
      g(Lt.offers || []), S(Lt.trend || []), j(Lt.total || 0);
    }).catch((Lt) => {
      console.error("product error", Lt), Et(`Błąd podczas ładowania danych: ${Lt.message}`);
    }).finally(() => {
      nt(!1);
    });
  }, [s, l, T, D, I]), /* @__PURE__ */ Qt.jsxs("div", { className: "container py-4", children: [
    /* @__PURE__ */ Qt.jsx("div", { className: "text-end", children: /* @__PURE__ */ Qt.jsx("button", { id: "themeToggle", className: "btn btn-outline-light btn-sm", children: "Zmień motyw" }) }),
    /* @__PURE__ */ Qt.jsx("h1", { className: "text-center mb-4", children: "🌿 Dashboard cen medycznej marihuany" }),
    Dt && /* @__PURE__ */ Qt.jsx("div", { className: "alert alert-danger", role: "alert", children: Dt }),
    /* @__PURE__ */ Qt.jsxs("div", { className: "row mb-3", children: [
      /* @__PURE__ */ Qt.jsxs("div", { className: "col-md-6 mb-2 mb-md-0", children: [
        /* @__PURE__ */ Qt.jsx("label", { className: "form-label", children: "Wybierz produkt:" }),
        /* @__PURE__ */ Qt.jsx(
          KE,
          {
            value: s,
            onChange: (dt) => {
              i(dt), Q(0);
            }
          }
        )
      ] }),
      /* @__PURE__ */ Qt.jsxs("div", { className: "col-md-6", children: [
        /* @__PURE__ */ Qt.jsx("label", { className: "form-label", children: "Miasto:" }),
        /* @__PURE__ */ Qt.jsx(
          WE,
          {
            value: l,
            onChange: (dt) => {
              u(dt), Q(0);
            }
          }
        )
      ] })
    ] }),
    s && /* @__PURE__ */ Qt.jsxs(Qt.Fragment, { children: [
      /* @__PURE__ */ Qt.jsx(
        IE,
        {
          sort: T,
          order: D,
          onSortChange: (dt) => {
            E(dt), Q(0);
          },
          onOrderChange: (dt) => {
            C(dt), Q(0);
          }
        }
      ),
      X && /* @__PURE__ */ Qt.jsx("div", { className: "text-center my-4", children: /* @__PURE__ */ Qt.jsx("div", { className: "spinner-border", role: "status", children: /* @__PURE__ */ Qt.jsx("span", { className: "visually-hidden", children: "Ładowanie..." }) }) }),
      !X && h.length > 0 && /* @__PURE__ */ Qt.jsxs(Qt.Fragment, { children: [
        /* @__PURE__ */ Qt.jsxs("div", { className: "card p-3 mb-4", children: [
          /* @__PURE__ */ Qt.jsx("h2", { className: "card-title", children: "🗺️ Najbliższa apteka" }),
          /* @__PURE__ */ Qt.jsx(
            $z,
            {
              offers: h,
              center: h.length && h[0].pharmacy_lat && h[0].pharmacy_lon ? [h[0].pharmacy_lat, h[0].pharmacy_lon] : void 0
            }
          )
        ] }),
        /* @__PURE__ */ Qt.jsxs("div", { className: "card p-3 mb-4", children: [
          /* @__PURE__ */ Qt.jsx("h2", { className: "card-title", children: "💎 Najtańsze oferty" }),
          /* @__PURE__ */ Qt.jsx($E, { offers: h }),
          /* @__PURE__ */ Qt.jsx(JE, { total: z, limit: zt, offset: I, onChange: Q }),
          /* @__PURE__ */ Qt.jsxs("div", { id: "countInfo", className: "mb-2 text-muted", children: [
            "Wyświetlasz ",
            I + 1,
            "–",
            Math.min(I + zt, z),
            " z ",
            z,
            " ofert"
          ] })
        ] }),
        /* @__PURE__ */ Qt.jsxs("div", { className: "card p-3 mb-4", children: [
          /* @__PURE__ */ Qt.jsx("h2", { className: "card-title", children: "📈 Trend cen wg daty" }),
          /* @__PURE__ */ Qt.jsx(Qz, { data: _ })
        ] })
      ] }),
      !X && h.length === 0 && !Dt && /* @__PURE__ */ Qt.jsxs("div", { className: "alert alert-info", children: [
        "Brak ofert dla wybranego produktu",
        l ? ` w mieście ${l}` : "",
        "."
      ] })
    ] })
  ] });
}
QE.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ Qt.jsx(si.StrictMode, { children: /* @__PURE__ */ Qt.jsx(Jz, {}) })
);
